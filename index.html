<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>coygOdegaard</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="coygOdegaard">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="coygOdegaard">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Odegaard">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="coygOdegaard" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">Odegaard</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 10px;">大数据</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">语言</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-深度学习入门" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/09/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/" class="article-date">
  	<time datetime="2025-09-11T02:01:58.000Z" itemprop="datePublished">2025-09-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/09/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/">
        深度学习入门
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>在神经网络发展的历史上， sigmoid函数很早就开始被使用了，而最近则主要使用ReLU（Rectified Linear Unit）函数。</p>
<p>ReLU函数在输入大于0时，直接输出该值；在输入小于等于0时，输出0。</p>
<p>ReLU函数可以表示为下面的式。</p>
<img src="../source/imgs/${fiilname}/image-20250911110202414.png" alt="image-20250911110202414" style="zoom:50%;" />

<pre><code class="hljs plaintext">def relu(x):
	return np.maximum(0, x)</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250911110300246.png" alt="image-20250911110300246"></p>
<p>输出层的激活函数用σ()表示，不同于隐藏层的激活函数h()（σ读作sigma）。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250911154019871.png" alt="image-20250911154019871"></p>
<p>输出层所用的激活函数，要根据求解问题的性质决定。一般地，回归问题可以使用恒等函数，二元分类问题可以使用 sigmoid函数，多元分类问题可以使用 softmax函数。</p>
<p><strong>恒等函数</strong>会将输入按原样输出，对于输入的信息，不加以任何改动地直接输出。因此，在输出层使用恒等函数时，输入信号会原封不动地被输出。</p>
<p>分类问题中使用的<strong>softmax函数</strong>可以用下面的式表示。<img src="../source/imgs/${fiilname}/image-20250911154756373.png" alt="image-20250911154756373" style="zoom:50%;" /></p>
<pre><code class="hljs plaintext">def softmax(a):
    exp_a = np.exp(a)
    sum_exp_a = np.sum(exp_a)
    y = exp_a / sum_exp_a
    return y</code></pre>

<p>上面的softmax函数的实现虽然正确描述了式，但在计算机的运算上有一定的缺陷。这个缺陷就是溢出问题。 softmax函数的实现中要进行指数函数的运算，但是此时指数函数的值很容易变得非常大。</p>
<p>softmax函数的实现可以像式这样进行改进。</p>
<img src="../source/imgs/${fiilname}/image-20250911155201797.png" alt="image-20250911155201797" style="zoom:50%;" />

<p>首先，在分子和分母上都乘上C这个任意的常数（因为同时对分母和分子乘以相同的常数，所以计算结果不变）。然后，把这个C移动到指数函数（exp）中，记为log C。最后，把log C替换为另一个符号<img src="../source/imgs/${fiilname}/image-20250911195950571.png" alt="image-20250911195950571" style="zoom:50%;" />。说明，在进行softmax的指数函数的运算时，加上（或者减去)某个常数并不会改变运算的结果。这里的<img src="../source/imgs/${fiilname}/image-20250911200008808.png" alt="image-20250911200008808" style="zoom:50%;" />可以使用任何值，但是为了防止溢出，一般会使用输入信号中的最大值。</p>
<pre><code class="hljs plaintext">def softmax(a):
    c = np.max(a)
    exp_a = np.exp(a - c) # 溢出对策
    sum_exp_a = np.sum(exp_a)
    y = exp_a / sum_exp_a
    return y</code></pre>

<p>softmax函数的<strong>输出是0.0到1.0之间的实数</strong>。并且， <strong>softmax函数的输出值的总和是1</strong>。输出总和为1是softmax函数的一个重要性质。正因为有了这个性质，我们才可以把softmax函数的输出解释为“概率”。</p>
<p>比如，上面的例子可以解释成 y[0]的概率是0.018（1.8 %）， y[1]的概率是0.245（24.5 %）， y[2]的概率是0.737（73.7 %）。</p>
<p>即便使用了softmax函数，<strong>各个元素之间的大小关系也不会改变</strong>。这是因为指数函数（y &#x3D; exp(x)）是单调递增函数。实际上，上例中a的各元素的大小关系和y的各元素的大小关系并没有改变。比如， a的最大值是第2个元素， y的最大值也仍是第2个元素。</p>
<p>一般而言，神经网络只把输出值最大的神经元所对应的类别作为识别结果。并且，即便使用softmax函数，输出值最大的神经元的位置也不会变。因此，神经网络在进行分类时，<strong>输出层的softmax函数可以省略</strong>。</p>
<h2 id="手写数字识别"><a href="#手写数字识别" class="headerlink" title="手写数字识别"></a>手写数字识别</h2><p>这里使用的数据集是MNIST手写数字图像集。 MNIST是机器学习领域最有名的数据集之一，被应用于从简单的实验到发表的论文研究等各种场合。实际上，在阅读图像识别或机器学习的论文时， MNIST数据集经常作为实验用的数据出现。MNIST数据集是由0到9的数字图像构成的.</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250911202019486.png" alt="image-20250911202019486"></p>
<p>MNIST的图像数据是28像素 × 28像素的灰度图像（1通道），各个像素的取值在0到255之间。每个图像数据都相应地标有“7”“2”“1”等标签。</p>
<h1 id="神经网络的学习"><a href="#神经网络的学习" class="headerlink" title="神经网络的学习"></a>神经网络的学习</h1><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>这个损失函数可以使用任意函数，但一般用均方误差和交叉熵误差等。</p>
<p>可以用作损失函数的函数有很多，其中最有名的是<strong>均方误差</strong><img src="../source/imgs/${fiilname}/image-20250913095941450.png" alt="image-20250913095941450" style="zoom:50%;" /></p>
<p>这里， yk是表示神经网络的输出， tk表示监督数据， k表示数据的维数。</p>
<p>在3.6节手写数字识别的例子中， yk、 tk是由如下10个元素构成的数据。</p>
<img src="../source/imgs/${fiilname}/image-20250913100104125.png" alt="image-20250913100104125" style="zoom:70%;" />

<p>t是监督数据，将正确解标签设为1，其他均设为0。这里，标签“2”为1，表示正确解是“2”。将正确解标签表示为1，其他标签表示为0的表示方法称为<strong>one-hot</strong>表示。</p>
<p>除了均方误差之外， <strong>交叉熵误差</strong>（cross entropy error）也经常被用作损失函数<img src="../source/imgs/${fiilname}/image-20250913100143104.png" alt="image-20250913100143104" style="zoom:50%;" /></p>
<p>这里， log表示以e为底数的自然对数（log e）。 yk是神经网络的输出， tk是正确解标签。并且， tk中只有正确解标签的索引为1，其他均为0（one-hot表示）。因此，式（4.2）实际上只计算<strong>对应正确解标签的输出的自然对数</strong>。比如，假设正确解标签的索引是“2”，与之对应的神经网络的输出是0.6，则交叉熵误差是-log 0.6 &#x3D; 0.51；若“2”对应的输出是0.1，则交叉熵误差为-log 0.1 &#x3D; 2.30。也就是说，交叉熵误差的值是由正确解标签所对应的输出结果决定的。</p>
<pre><code class="hljs plaintext">def cross_entropy_error(y, t):
    delta = 1e-7
    return -np.sum(t * np.log(y + delta))</code></pre>

<p>这里，参数y和t是NumPy数组。函数内部在计算np.log时，<strong>加上了一个微小值delta</strong>。这是因为，当出现np.log(0)时， np.log(0)会变为负无限大的-inf，这样一来就会导致后续计算无法进行。作为保护性对策，<strong>添加一个微小值可以防止负无限大的发生</strong>。</p>
<p>此外，当监督数据是标签形式（非one-hot表示，而是像“2”“7”这样的标签）时，交叉熵误差可通过如下代码实现。</p>
<pre><code class="hljs plaintext">def cross_entropy_error(y, t):
    if y.ndim == 1:
    t = t.reshape(1, t.size)
    y = y.reshape(1, y.size)
    batch_size = y.shape[0]
    return -np.sum(np.log(y[np.arange(batch_size), t] + 1e-7)) / batch_size</code></pre>

<p>需要求batch_size是因为此时的y不是一个数据。</p>
<p>作为参考，简单介绍一下np.log( y[np.arange(batch_size), t] )。 np.arange (batch_size)会生成一个从0到 batch_size-1的数组。比如当 batch_size为5时， np.arange(batch_size)会生成一个NumPy 数组 [0, 1, 2, 3, 4]。因为t中标签是以 [2, 7, 0, 9, 4]的形式存储的，所以 y[np.arange(batch_size), t]能抽出各个数据的正确解标签对应的神经网络的输出（在这个例子中， y[np.arange(batch_size), t] 会 生 成 NumPy 数 组 [y[0,2], y[1,7], y[2,0], y[3,9], y[4,4]]）。</p>
<p><strong>epoch</strong>是一个单位。一个epoch表示学习中所有训练数据均被使用过一次时的更新次数。比如，对于 10000笔训练数据，用大小为 100笔数据的mini-batch进行学习时，重复随机梯度下降法100次，所有的训练数据就都被“看过”了 A。此时，100次就是一个epoch。</p>
<p>实际上，一般做法是事先将所有训练数据随机打乱，然后按指定的批次大小，按序生成mini-batch。这样每个mini-batch均有一个索引号，比如此例可以是0, 1, 2, . . . , 99，然后用索引号可以遍历所有的mini-batch。遍历一次所有数据，就称为一个epoch。</p>
<h1 id="误差反向传播法"><a href="#误差反向传播法" class="headerlink" title="误差反向传播法"></a>误差反向传播法</h1><h2 id="激活函数层的实现"><a href="#激活函数层的实现" class="headerlink" title="激活函数层的实现"></a>激活函数层的实现</h2><p><strong>ReLU层</strong></p>
<p>激活函数ReLU（Rectified Linear Unit）<img src="../source/imgs/${fiilname}/image-20250913101100478.png" alt="image-20250913101100478" style="zoom:50%;" />，它的导数是<img src="../source/imgs/${fiilname}/image-20250913101122323.png" alt="image-20250913101122323" style="zoom:50%;" /></p>
<pre><code class="hljs plaintext">class Relu:
    def __init__(self):
        self.mask = None
        def forward(self, x):
        self.mask = (x &lt;= 0)
        out = x.copy()
        out[self.mask] = 0
        return out
    def backward(self, dout):
        dout[self.mask] = 0
        dx = dout
        return dx</code></pre>

<p><strong>Sigmoid层</strong></p>
<p>sigmoid函数<img src="../source/imgs/${fiilname}/image-20250913101457738.png" alt="image-20250913101457738" style="zoom:50%;" />，它的导数是<img src="../source/imgs/${fiilname}/image-20250913101724780.png" alt="image-20250913101724780" style="zoom:50%;" /></p>
<pre><code class="hljs plaintext">class Sigmoid:
    def __init__(self):
        self.out = None
        def forward(self, x):
        out = 1 / (1 + np.exp(-x))
        self.out = out
        return out
    def backward(self, dout):
        dx = dout * (1.0 - self.out) * self.out
        return dx</code></pre>

<p>这个实现中，正向传播时将输出保存在了实例变量 out中。然后，反向传播时，使用该变量out进行计算。</p>
<h2 id="Affine-Softmax层的实现"><a href="#Affine-Softmax层的实现" class="headerlink" title="Affine&#x2F;Softmax层的实现"></a>Affine&#x2F;Softmax层的实现</h2><p><strong>Affine层</strong></p>
<p>神经网络的<strong>正向传播</strong>中进行的<strong>矩阵的乘积运算</strong>在几何学领域被称为“仿射变换” 。因此，这里将进行仿射变换的处理实现为“Affine层”。</p>
<p><strong>Softmax-with-Loss 层</strong></p>
<p>最后介绍一下输出层的softmax函数。前面我们提到过， softmax函数会将输入值正规化之后再输出。比如手写数字识别时， Softmax层的输出如：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250913102830344.png" alt="image-20250913102830344"></p>
<p>因为手写数字识别要进行10类分类，所以向Softmax层的输入也有10个。</p>
<p>神经网络中进行的处理有<strong>推理</strong>（inference）和<strong>学习</strong>两个阶段。神经网络的<strong>推理通常不使用Softmax层</strong>。比如，用图5-28的网络进行推理时，会将最后一个 Affine层的输出作为识别结果。神经网络中未被正规化的输出结果（图 5-28中 Softmax层前面的 Affine层的输出）有时被称为“得分”。也就是说，当神经网络的推理只需要给出一个答案的情况下，因为此时只对得分最大值感兴趣，所以不需要Softmax层。不过，神经网络的<strong>学习阶段则需要Softmax层</strong>。</p>
<p>softmax函数记为Softmax层，交叉熵误差记为Cross Entropy Error层。这里假设要进行3类分类，从前面的层接收3个输入（得分）。如图5-30所示， Softmax层将输入（a1, a2, a3）正规化，输出（y1, y2, y3）。 Cross Entropy Error层接收Softmax的输出（y1, y2, y3）和教师标签（t1, t2, t3），从这些数据中输出损失L。</p>
<img src="../source/imgs/${fiilname}/image-20250913103053341.png" alt="image-20250913103053341" style="zoom:50%;" />

<p>Softmax层的反向传播得到了（y1 - t1, y2 - t2, y3 - t3）这样“漂亮”的结果。由于（y1, y2, y3）是Softmax层的输出，（t1, t2, t3）是监督数据，所以（y1 - t1, y2 - t2, y3 - t3）是Softmax层的输出和教师标签的差分。神经网络的反向传播会把这个差分表示的误差传递给前面的层。</p>
<h1 id="与学习相关的技巧"><a href="#与学习相关的技巧" class="headerlink" title="与学习相关的技巧"></a>与学习相关的技巧</h1><h2 id="参数的更新"><a href="#参数的更新" class="headerlink" title="参数的更新"></a>参数的更新</h2><h3 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h3><p><strong>随机梯度下降法</strong>（SGD），在解决某些问题的时候没有效率，因为梯度的方向没有指向最小值。<img src="../source/imgs/${fiilname}/image-20250915200803430.png" alt="image-20250915200803430" style="zoom:40%;" /></p>
<p><img src="../source/imgs/${fiilname}/image-20250915194354567.png" alt="image-20250915194354567" style="zoom:40%;" />，表示的函数是向x轴方向延伸的“碗”状函数。</p>
<img src="../source/imgs/${fiilname}/image-20250915194431174.png" alt="image-20250915194431174" style="zoom:50%;" />

<p>应用SGD，SGD呈“之”字形移动。这是一个相当低效的路径。也就是说， SGD的缺点是，如果函数的形状非均向，比如呈延伸状，搜索的路径就会非常低效。</p>
<img src="../source/imgs/${fiilname}/image-20250915194538985.png" alt="image-20250915194538985" style="zoom:40%;" />

<h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><p>Momentum是“动量”的意思，和物理有关。用数学式表示Momentum方法，<img src="../source/imgs/${fiilname}/image-20250915194751261.png" alt="image-20250915194751261" style="zoom:40%;" />，<img src="../source/imgs/${fiilname}/image-20250915194807290.png" alt="image-20250915194807290" style="zoom:40%;" /></p>
<p>和前面的SGD一样， W表示要更新的权重参数，<img src="../source/imgs/${fiilname}/image-20250915194942860.png" alt="image-20250915194942860" style="zoom:50%;" />表示损失函数关于W的梯度， η表示学习率。这里新出现了一个变量v，对应物理上的速度。第一个式子表示了物体在梯度方向上受力，在这个力的作用下，物体的速度增加这一物理法则。</p>
<pre><code class="hljs plaintext">class Momentum:
    def __init__(self, lr=0.01, momentum=0.9):
        self.lr = lr
        self.momentum = momentum
        self.v = None
    def update(self, params, grads):
        if self.v is None:
        self.v = &#123;&#125;
        for key, val in params.items():
        self.v[key] = np.zeros_like(val)
        for key in params.keys():
        self.v[key] = self.momentum*self.v[key] - self.lr*grads[key]
        params[key] += self.v[key]</code></pre>

<p><code>numpy.zeros_like()</code> ，用于创建一个与给定数组<strong>形状和数据类型相同</strong>的新数组，但所有元素都被初始化为 <strong>0</strong>。</p>
<img src="../source/imgs/${fiilname}/image-20250915203234346.png" alt="image-20250915203234346" style="zoom:50%;" />

<img src="../source/imgs/${fiilname}/image-20250915201507943.png" alt="image-20250915201507943" style="zoom:50%;" />

<p><strong>与SGD的对比及其优势</strong></p>
<ul>
<li><strong>普通SGD（随机梯度下降）</strong>：<br><code>W ← W - η(∂L/∂W)</code><br>在梯度为零的区域（<code>∂L/∂W = 0</code>），更新量直接为零，优化过程会<strong>立刻停止</strong>。这很容易陷入一些平坦的局部最优点或鞍点（这些点的梯度也是零，但不是最优解）。</li>
<li><strong>Momentum方法</strong>：<br>即使在梯度为零的点，由于 <code>αv</code> 项的存在，​<strong>速度不会立刻为零</strong>。之前积累的动量会推动参数 <code>W</code> 继续向前移动一段距离。这带来了两大好处：<ol>
<li><strong>有助于逃离局部最优点和鞍点</strong>：如果小球有足够的动量，它就可以“滚过”一个平坦的局部极小点或鞍点，而不是陷在里面。</li>
<li><strong>抑制震荡，加速收敛</strong>：在沟壑（类似峡谷地形）中，梯度方向在沟壁间剧烈摇摆。普通的SGD会剧烈震荡，收敛缓慢。而Momentum方法中的 <code>αv</code> 项相当于一个迟滞系统，会将速度平均化，使更新方向更加一致地沿着沟壑的中心线（下降的主方向），从而<strong>大大减少震荡并加快收敛速度</strong></li>
</ol>
</li>
</ul>
<p>在优化过程中，“速度” <code>v</code> 是一个矢量，它同时记录了<strong>方向</strong>和<strong>大小</strong>。<code>αv</code> 项代表的是“历史移动趋势”。</p>
<ul>
<li><strong>当上一时刻的速度 <code>v</code> 为负值，且当前梯度 <code>-η(∂L/∂W)</code> 也是负值时</strong>：<ul>
<li>两者方向相同，<code>αv</code> 项（负值）与梯度力（负值）叠加，确实起到了<strong>加速</strong>的作用。这会使得本次更新沿着负方向走得更远、更快。</li>
</ul>
</li>
<li><strong>当上一时刻的速度 <code>v</code> 为负值，但当前梯度 <code>-η(∂L/∂W)</code> 为正值时</strong>：<ul>
<li>这通常发生在参数即将越过最低点（谷底）时。此时，梯度方向改变了（从向右下变为向左下），但历史动量（<code>αv</code>）仍然试图将它往原来的方向（右下）推。</li>
<li>这时，<code>αv</code>（负值）和梯度力（正值）方向相反，会<strong>相互抵消一部分</strong>。这起到了“刹车”或缓冲的作用，防止参数更新在最低点附近发生过于剧烈的震荡和摇摆。</li>
</ul>
</li>
</ul>
<p><strong>结论：</strong> <code>αv</code> 项并不总是起到“减速”作用。它的角色是<strong>保持历史运动趋势</strong>。这个趋势既可能加速（当与梯度同向时），也可能减速（当与梯度反向时）。这种机制使得优化过程在正确的方向上更快，同时能平滑掉一些错误方向的震荡。</p>
<p>但是，如果梯度为0的地方就是最低点，<strong>相比于没有动量的SGD（梯度为0就立刻停止），Momentum方法可能需要更多的迭代步骤来让这种振荡停止下来，最终精确收敛到最低点。</strong></p>
<h3 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h3><p>在关于学习率的有效技巧中，有一种被称为<strong>学习率衰减</strong>的方法，即随着学习的进行，使学习率逐渐减小。实际上，一开始“多”学，然后逐渐“少”学的方法，在神经网络的学习中经常被使用。</p>
<p>逐渐减小学习率的想法，相当于将“全体”参数的学习率值一起降低。而AdaGrad进一步发展了这个想法，针对“<strong>一个一个</strong>”的参数，赋予其“定制”的值。AdaGrad会为参数的<strong>每个元素</strong>适当地调整学习率，与此同时进行学习。</p>
<img src="../source/imgs/${fiilname}/image-20250915202216158.png" alt="image-20250915202216158" style="zoom:50%;" />

<p>和前面的SGD一样， W表示要更新的权重参数， 表示损失函数关于W的梯度， η表示学习率。这里新出现了变量h，如式(6.5)所示，它保存了以前的所有梯度值的<strong>平方和</strong>（式（6.5）中的<img src="../source/imgs/${fiilname}/image-20250915202243610.png" alt="image-20250915202243610" style="zoom:50%;" />表示矩阵中对应元素的乘法）。然后，在更新参数时，通过乘以<img src="../source/imgs/${fiilname}/image-20250915202334230.png" alt="image-20250915202334230" style="zoom:50%;" />，就可以调整学习的尺度。这意味着，参数的<strong>元素中变动较大</strong>（被大幅更新)的元素的<strong>学习率将变小</strong>。也就是说，可以按参数的元素进行学习率衰减，使变动大的参数的学习率逐渐减小。</p>
<p>AdaGrad会记录<strong>过去所有梯度</strong>的平方和。因此，学习<strong>越深入</strong>，更新的<strong>幅度就越小</strong>。实际上，如果无止境地学习，更新量就会变为 0，完全不再更新。为了改善这个问题，可以使用 <strong>RMSProp</strong>方法。RMSProp方法并不是将过去所有的梯度一视同仁地相加，而是逐渐地遗忘过去的梯度，在做加法运算时将新梯度的信息更多地反映出来。这种操作从专业上讲，称为“指数移动平均”，呈指数函数式地减小过去的梯度的尺度。</p>
<pre><code class="hljs plaintext">class AdaGrad:
    def __init__(self, lr=0.01):
        self.lr = lr
        self.h = None
        
    def update(self, params, grads):
        if self.h is None:
            self.h = &#123;&#125;
            for key, val in params.items():
                self.h[key] = np.zeros_like(val)            
        for key in params.keys():
            self.h[key] += grads[key] * grads[key]
            params[key] -= self.lr * grads[key] / (np.sqrt(self.h[key]) + 1e-7)</code></pre>

<img src="../source/imgs/${fiilname}/image-20250915203148184.png" alt="image-20250915203148184" style="zoom:50%;" />

<p>由于y轴方向上的梯度较大，因此刚开始变动较大，但是后面会根据这个较大的变动按比例进行调整，减小更新的步伐。因此， y轴方向上的更新程度被减弱，“之”字形的变动程度有所衰减。</p>
<h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p>Momentum参照小球在碗中滚动的物理规则进行移动， AdaGrad为参数的每个元素适当地调整更新步伐。Adam就是融合了这两个方法。具体的想看去看论文。</p>
<img src="../source/imgs/${fiilname}/image-20250915203909822.png" alt="image-20250915203909822" style="zoom:50%;" />

<p>虽然Momentun也有类似的移动，但是相比之下， Adam的小球左右摇晃的程度有所减轻。这得益于学习的更新程度被适当地调整了。</p>
<img src="../source/imgs/${fiilname}/image-20250915203954895.png" alt="image-20250915203954895" style="zoom:50%;" />

<pre><code class="hljs plaintext">class Adam:

    &quot;&quot;&quot;Adam (http://arxiv.org/abs/1412.6980v8)&quot;&quot;&quot;

    def __init__(self, lr=0.001, beta1=0.9, beta2=0.999):
        self.lr = lr
        self.beta1 = beta1
        self.beta2 = beta2
        self.iter = 0
        self.m = None
        self.v = None
        
    def update(self, params, grads):
        if self.m is None:
            self.m, self.v = &#123;&#125;, &#123;&#125;
            for key, val in params.items():
                self.m[key] = np.zeros_like(val)
                self.v[key] = np.zeros_like(val)
        
        self.iter += 1
        lr_t  = self.lr * np.sqrt(1.0 - self.beta2**self.iter) / (1.0 - self.beta1**self.iter)         
        
        for key in params.keys():
            #self.m[key] = self.beta1*self.m[key] + (1-self.beta1)*grads[key]
            #self.v[key] = self.beta2*self.v[key] + (1-self.beta2)*(grads[key]**2)
            self.m[key] += (1 - self.beta1) * (grads[key] - self.m[key])
            self.v[key] += (1 - self.beta2) * (grads[key]**2 - self.v[key])
            
            params[key] -= lr_t * self.m[key] / (np.sqrt(self.v[key]) + 1e-7)
            
            #unbias_m += (1 - self.beta1) * (grads[key] - self.m[key]) # correct bias
            #unbisa_b += (1 - self.beta2) * (grads[key]*grads[key] - self.v[key]) # correct bias
            #params[key] += self.lr * unbias_m / (np.sqrt(unbisa_b) + 1e-7)</code></pre>

<h2 id="权重的初始值"><a href="#权重的初始值" class="headerlink" title="权重的初始值"></a>权重的初始值</h2><h3 id="隐藏层的激活值分布"><a href="#隐藏层的激活值分布" class="headerlink" title="隐藏层的激活值分布"></a>隐藏层的激活值分布</h3><p>做一个简单的实验，观察权重初始值是如何影响隐藏层的激活值的分布的。这里要做的实验是，向一个5层神经网络（激活函数使用sigmoid函数）传入随机生成的输入数据，用直方图绘制各层激活值的数据分布。</p>
<pre><code class="hljs plaintext">import numpy as np
import matplotlib.pyplot as plt

def sigmoid(x):
    return 1 / (1 + np.exp(-x))
    
x = np.random.randn(1000, 100) # 1000个数据
node_num = 100 # 各隐藏层的节点（神经元）数
hidden_layer_size = 5 # 隐藏层有5层
activations = &#123;&#125; # 激活值的结果保存在这里
for i in range(hidden_layer_size):
    if i != 0:
    	x = activations[i-1]
    w = np.random.randn(node_num, node_num) * 1
    z = np.dot(x, w)
    a = sigmoid(z) # sigmoid函数
    activations[i] = a
for i, a in activations.items():
    plt.subplot(1, len(activations), i+1)
    plt.title(str(i+1) + &quot;-layer&quot;)
    plt.hist(a.flatten(), 30, range=(0,1))
plt.show()</code></pre>

<img src="../source/imgs/${fiilname}/image-20250915213751053.png" alt="image-20250915213751053" style="zoom:50%;" />

<p>各层的激活值呈偏向0和1的分布。这里使用的sigmoid函数是S型函数，随着输出不断地靠近0（或者靠近1），它的导数的值逐渐接近0。因此，偏向0和1的数据分布会造成反向传播中梯度的值不断变小，最后消失。这个问题称为<strong>梯度消失</strong>。层次加深的深度学习中，梯度消失的问题可能会更加严重。</p>
<p>下面，将权重的标准差设为0.01，进行相同的实验。<code>w = np.random.randn(node_num, node_num) * 0.01</code></p>
<img src="../source/imgs/${fiilname}/image-20250915213919994.png" alt="image-20250915213919994" style="zoom:50%;" />

<p>这次呈集中在0.5附近的分布。因为不像刚才的例子那样偏向0和1，所以不会发生梯度消失的问题。但是，激活值的分布有所<strong>偏向</strong>，说明在表现力上会有很大问题。为什么这么说呢？因为如果有多个神经元都输出几乎相同的值，那它们就没有存在的意义了。比如，如果100个神经元都输出几乎相同的值，那么也可以由1个神经元来表达基本相同的事情。因此，激活值在分布上有所偏向会出现“<strong>表现力受限</strong>”的问题。</p>
<p><strong>各层的激活值的分布都要求有适当的广度。为什么呢？因为通过在各层间传递多样性的数据，神经网络可以进行高效的学习。反过来，如果传递的是有所偏向的数据，就会出现梯度消失或者“表现力受限”的问题，导致学习可能无法顺利进行。</strong></p>
<p>接着，我们尝试使用Xavier Glorot等人的论文中推荐的权重初始值（俗称“Xavier初始值”）。现在，在一般的深度学习框架中， Xavier初始值已被作为标准使用。</p>
<p>如果前一层的节点数为n，则初始值使用标准差为<img src="../source/imgs/${fiilname}/image-20250915214127994.png" alt="image-20250915214127994" style="zoom:50%;" />的分布。</p>
<p><strong>Xavier初始值：与前一层有n个节点连接时，初始值使用标准差为<img src="../source/imgs/${fiilname}/image-20250915214229318.png" alt="image-20250915214229318" style="zoom:50%;" />的分布。</strong></p>
<p>使用Xavier初始值后，前一层的节点数<strong>越多</strong>，要设定为目标节点的初始值的权重尺度就<strong>越小</strong>。现在，我们使用Xavier初始值进行实验。</p>
<pre><code class="hljs plaintext">node_num = 100 # 前一层的节点数
w = np.random.randn(node_num, node_num) / np.sqrt(node_num)</code></pre>

<img src="../source/imgs/${fiilname}/image-20250915214401550.png" alt="image-20250915214401550" style="zoom:50%;" />

<p>后面的层的分布呈稍微歪斜的形状。如果用<strong>tanh函数</strong>（双曲线函数）代替 sigmoid函数，这个稍微歪斜的问题就能得到改善。实际上，使用 tanh函数后，会呈漂亮的吊钟型分布。 tanh函数和sigmoid函数同是S型曲线函数，但tanh函数是<strong>关于原点(0, 0)对称</strong>的S型曲线，而 sigmoid函数是关于(x, y)&#x3D;(0, 0.5)对称的S型曲线。众所周知，<strong>用作激活函数的函数最好具有关于原点对称的性质</strong>。</p>
<h3 id="ReLU的权重初始值"><a href="#ReLU的权重初始值" class="headerlink" title="ReLU的权重初始值"></a>ReLU的权重初始值</h3><p>Xavier初始值是以激活函数是<strong>线性函数</strong>为前提而推导出来的。因为sigmoid函数和 tanh函数左右对称，且中央附近可以视作线性函数，所以适合使用Xavier初始值。但当激活函数<strong>使用ReLU</strong>时，一般推荐使用ReLU专用的初始值，也就是Kaiming He等人推荐的初始值，也称为“<strong>He初始值</strong>” 。当前一层的节点数为n时， He初始值使用标准差为<img src="../source/imgs/${fiilname}/image-20250915214753398.png" alt="image-20250915214753398" style="zoom:50%;" />的高斯分布。</p>
<img src="../source/imgs/${fiilname}/image-20250915214852076.png" alt="image-20250915214852076" style="zoom:50%;" />

<p>当“std &#x3D; 0.01”时，各层的激活值非常小 。神经网络上传递的是非常小的值，说明逆向传播时权重的梯度也同样很小。这是很严重的问题，实际上学习基本上没有进展。</p>
<p>接下来是初始值为<strong>Xavier初始值</strong>时的结果。在这种情况下，随着层的<strong>加深</strong>，<strong>偏向</strong>一点点<strong>变大</strong>。实际上，层加深后，激活值的偏向变大，学习时会出现<strong>梯度消失</strong>的问题。而当初始值为<strong>He初始值</strong>时，各层中<strong>分布的广度相同</strong>。由于即便层加深，数据的广度也能保持不变，因此逆向传播时，也会传递合适的值。</p>
<p><strong>当激活函数使用ReLU时，权重初始值使用He初始值，当激活函数为 sigmoid或 tanh等S型曲线函数时，初始值使用Xavier初始值。</strong></p>
<h2 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h2><p>如果设定了合适的权重初始值，则各层的激活值分布会有适当的广度，从而可以顺利地进行学习。那么，为了使各层拥有适当的广度，<strong>“强制性”地调整激活值的分布</strong>会怎样呢？实际上， Batch Normalization方法就是基于这个想法而产生的。</p>
<h3 id="Batch-Normalization-的算法"><a href="#Batch-Normalization-的算法" class="headerlink" title="Batch Normalization 的算法"></a>Batch Normalization 的算法</h3><p>优点：</p>
<p>• 可以使学习快速进行（可以增大学习率）。</p>
<p>• 不那么依赖初始值（对于初始值不用那么神经质）。</p>
<p>• 抑制过拟合（降低Dropout等的必要性）。</p>
<p>Batch Norm的思路是<strong>调整各层的激活值分布</strong>使其拥有适当的广度。为此，要向神经网络中插入对数据分布进行<strong>正规化</strong>的层，即Batch Normalization层（下文简称Batch Norm层），如图6-16所示。</p>
<img src="../source/imgs/${fiilname}/image-20250916094735875.png" alt="image-20250916094735875" style="zoom:50%;" />

<p>Batch Norm，顾名思义，以进行学习时的mini-batch为单位，按minibatch进行正规化。具体而言，就是进行使数据分布的均值为0、方差为1的<strong>正规化</strong>。</p>
<img src="../source/imgs/${fiilname}/image-20250916095036960.png" alt="image-20250916095036960" style="zoom:50%;" />

<p>式（6.7）中的ε是一个微小值（比如， 10e-7等），它是为了防止出现除以0的情况。</p>
<p>通过将这个处理插入到激活函数的前面（或者后面） ，可以减小数据分布的偏向。</p>
<p>接着， Batch Norm层会对正规化后的数据进行缩放和平移的变换，<img src="../source/imgs/${fiilname}/image-20250916095355658.png" alt="image-20250916095355658" style="zoom:50%;" />，γ和β是参数。一开始γ &#x3D; 1， β &#x3D; 0，然后再通过学习调整到合适的值。</p>
<p>Batch Norm的反向传播在Frederik Kratzert 的博客“Understanding the backward pass through Batch Normalization Layer”里有详细说明。</p>
<img src="../source/imgs/${fiilname}/image-20250916095541658.png" alt="image-20250916095541658" style="zoom:50%;" />

<p>几乎所有的情况下都是使用Batch Norm时学习进行得更快。同时也可以发现，实际上，在不使用Batch Norm的情况下，如果不赋予一个尺度好的初始值，学习将完全无法进行。</p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><h3 id="权值衰减"><a href="#权值衰减" class="headerlink" title="权值衰减"></a>权值衰减</h3><p>该方法通过在学习的过程中对大的权重进行惩罚，来抑制过拟合。很多过拟合原本就是因为权重参数取值过大才发生的。</p>
<p>对于所有权重，权值衰减方法都会为损失函数加上<img src="../source/imgs/${fiilname}/image-20250916100018954.png" alt="image-20250916100018954" style="zoom:50%;" />，因此，在求权重梯度的计算中，要为之前的误差反向传播法的结果加上正则化项的导数λW。</p>
<h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p>如果网络的模型变得很复杂，只用权值衰减就难以应对了。在这种情况下，我们经常会使用Dropout方法。</p>
<p>Dropout是一种在学习的过程中<strong>随机删除神经元</strong>的方法。训练时，随机选出隐藏层的神经元，然后将其删除。<strong>被删除的神经元不再进行信号的传递</strong>，如图6-22所示。训练时，<strong>每传递一次</strong>数据，就会随机选择要删除的神经元。然后，测试时，虽然会传递所有的神经元信号，但是对于各个神经元的输出，要乘上训练时的删除比例后再输出。</p>
<img src="../source/imgs/${fiilname}/image-20250916100528410.png" alt="image-20250916100528410" style="zoom:50%;" />

<p>下面的实现重视易理解性。不过，因为训练时如果进行恰当的计算的话，正向传播时单纯地传递数据就可以了（不用乘以删除比例），所以深度学习的框架中进行了这样的实现。  </p>
<pre><code class="hljs plaintext">class Dropout:
    def __init__(self, dropout_ratio=0.5):
        self.dropout_ratio = dropout_ratio
        self.mask = None
    def forward(self, x, train_flg=True):
        if train_flg:
            self.mask = np.random.rand(*x.shape) &gt; self.dropout_ratio
            return x * self.mask
        else:
        	return x * (1.0 - self.dropout_ratio)
    def backward(self, dout):
    	return dout * self.mask</code></pre>

<p>机器学习中经常使用<strong>集成学习</strong>。所谓集成学习，就是让多个模型单独进行学习，推理时再取多个模型的输出的平均值。用神经网络的语境来说，比如，准备5个结构相同（或者类似）的网络，分别进行学习，测试时，以这5个网络的输出的平均值作为答案。实验告诉我们，通过进行集成学习，神经网络的识别精度可以提高好几个百分点。这个集成学习与 Dropout有密切的关系。这是因为可以将 Dropout理解为，通过在学习过程中随机删除神经元，从而每一次都让不同的模型进行学习。并且，推理时，通过对神经元的输出乘以删除比例（比如，0.5等），可以取得模型的平均值。也就是说，可以理解成， <strong>Dropout将集成学习的效果（模拟地）通过一个网络实现了</strong>。</p>
<h2 id="超参数的验证"><a href="#超参数的验证" class="headerlink" title="超参数的验证"></a>超参数的验证</h2><p>超参数是指，比如各层的神经元数量、 batch大小、参数更新时的学习率或权值衰减等。如果这些超参数没有设置合适的值，模型的性能就会很差。虽然超参数的取值非常重要，但是在决定超参数的过程中一般会伴随很多的试错。</p>
<h3 id="验证数据"><a href="#验证数据" class="headerlink" title="验证数据"></a>验证数据</h3><p><strong>不能使用测试数据评估超参数的性能。</strong></p>
<p>为什么不能用测试数据评估超参数的性能呢？这是因为如果使用测试数据调整超参数，超参数的值会对测试数据发生过拟合。换句话说，用测试数据确认超参数的值的“好坏”，就会导致超参数的值被调整为只拟合测试数据。这样的话，可能就会得到不能拟合其他数据、泛化能力低的模型。</p>
<p>因此，调整超参数时，必须使用超参数专用的确认数据。用于调整超参数的数据，一般称为验证数据。我们使用这个验证数据来评估超参数的好坏。</p>
<p>训练数据用于参数（权重和偏置）的学习，验证数据用于超参数的性能评估。为了确认泛化能力，要在最后使用（比较理想的是只用一次）测试数据。</p>
<h3 id="超参数的最优化"><a href="#超参数的最优化" class="headerlink" title="超参数的最优化"></a>超参数的最优化</h3><p>进行超参数的最优化时，逐渐缩小超参数的“好值”的存在范围非常重要。所谓逐渐缩小范围，是指一开始先大致设定一个范围，从这个范围中随机选出一个超参数（采样），用这个采样到的值进行识别精度的评估；然后，多次重复该操作，观察识别精度的结果，根据这个结果缩小超参数的“好值”的范围。通过重复这一操作，就可以逐渐确定超参数的合适范围。</p>
<p>在进行神经网络的超参数的最优化时，与网格搜索等有规律的搜索相比，<strong>随机采样</strong>的搜索方式效果更好。</p>
<p>超参数的范围只要“大致地指定”就可以了。所谓“大致地指定”，是指像0.001（10^-3）到1000（10^3）这样，以“<strong>10的阶乘</strong>”的尺度指定范围（也表述为“用对数尺度（log scale）指定”）。这在Python中可以写成 <code>10 ** np.random. uniform(-3, 3)</code>。</p>
<p>在超参数的最优化中，要注意的是深度学习需要很长时间（比如，几天或几周）。因此，在超参数的搜索中，需要尽早放弃那些不符合逻辑的超参数。于是，在超参数的最优化中，<strong>减少学习的epoch</strong>，缩短一次评估所需的时间是一个不错的办法。  </p>
<p><strong>步骤0</strong></p>
<p>设定超参数的范围。</p>
<p><strong>步骤1</strong></p>
<p>从设定的超参数范围中随机采样。</p>
<p><strong>步骤2</strong></p>
<p>使用步骤1中采样到的超参数的值进行学习，通过验证数据评估识别精度（但是要将epoch设置得很小）。</p>
<p><strong>步骤3</strong></p>
<p>重复步骤1和步骤2（100次等），根据它们的识别精度的结果，缩小超参数的范围。</p>
<p>反复进行上述操作，不断缩小超参数的范围，在缩小到一定程度时，从该范围中选出一个超参数的值。</p>
<p>在超参数的最优化中，如果需要更精炼的方法，可以使用<strong>贝叶斯最优化</strong>。贝叶斯最优化运用以贝叶斯定理为中心的数学理论，能够更加严密、高效地进行最优化。</p>
<h1 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络 CNN"></a>卷积神经网络 CNN</h1><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>CNN中新出现了卷积层（Convolution层）和池化层（Pooling层）。</p>
<p>之前介绍的神经网络中，相邻层的所有神经元之间都有连接，这称为<strong>全连接</strong>（fully-connected）。另外，我们用Affine层实现了全连接层。如果使用这个Affine层，一个5层的全连接的神经网络就可以通过图7-1所示的网络结构来实现。</p>
<p>如图7-1所示，全连接的神经网络中， Affine层后面跟着激活函数ReLU层（或者Sigmoid层）。这里堆叠了4层“Affine-ReLU”组合，然后第5层是Affine层，最后由Softmax层输出最终结果（概率）。</p>
<img src="../source/imgs/${fiilname}/image-20250913105112819.png" alt="image-20250913105112819" style="zoom:50%;" />

<p>CNN的一个例子：<img src="../source/imgs/${fiilname}/image-20250913105141247.png" alt="image-20250913105141247" style="zoom:50%;" /></p>
<p>CNN 中 新 增 了 Convolution 层 和 Pooling 层。 CNN 的层的连接顺序是“Convolution - ReLU -（Pooling）”（Pooling层有时会被省略）。这可以理解为之前的“Affi ne - ReLU”连接被替换成了“Convolution - ReLU -（Pooling）”连接。</p>
<p>还需要注意的是，在图7-2的CNN中，靠近输出的层中使用了之前的“Affine - ReLU”组合。此外，最后的输出层中使用了之前的“Affine - Softmax”组合。这些都是一般的CNN中比较常见的结构。</p>
<h2 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h2><h3 id="全连接层的问题"><a href="#全连接层的问题" class="headerlink" title="全连接层的问题"></a>全连接层的问题</h3><p>之前介绍的全连接的神经网络中使用了全连接层（Affine层）。在全连接层中，相邻层的神经元全部连接在一起，输出的数量可以任意决定。</p>
<p>全连接层存在什么问题呢？那就是<strong>数据的形状被“忽视”</strong>了。比如，输入数据是图像时，图像通常是高、长、通道方向上的3维形状。但是，向全连接层输入时，需要将3维数据拉平为1维数据。实际上，前面提到的使用了MNIST数据集的例子中，输入图像就是1通道、高28像素、长28像素的（1, 28, 28）形状，但却被排成1列，以784个数据的形式输入到最开始的Affine层。</p>
<p>图像是3维形状，这个形状中应该含有重要的空间信息。比如，空间上邻近的像素为相似的值、 RBG的各个通道之间分别有密切的关联性、相距较远的像素之间没有什么关联等， 3维形状中可能隐藏有值得提取的本质模式。但是，因为<strong>全连接层</strong>会忽视形状，将全部的输入数据作为相同的神经元（同一维度的神经元）处理，所以<strong>无法利用与形状相关的信息</strong>。</p>
<p>而<strong>卷积层可以保持形状不变</strong>。当输入数据是图像时，卷积层会以3维数据的形式接收输入数据，并同样以3维数据的形式输出至下一层。因此，在CNN中，<strong>可以（有可能）正确理解图像等具有形状的数据</strong>。</p>
<p>另外， CNN 中，有时将卷积层的输入输出数据称为<strong>特征图</strong>（feature map）。其中，卷积层的输入数据称为<strong>输入特征图</strong>（input feature map），输出数据称为<strong>输出特征图</strong>（output feature map）。</p>
<h3 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h3><p>卷积层进行的处理就是卷积运算。卷积运算相当于图像处理中的“滤波器运算”。</p>
<p>滤波器运算，可以把它理解为给图像“戴上一副特殊的眼镜”或“使用一个修图工具”，来达到某种特定的效果。</p>
<p>在图像处理中，<strong>滤波器（Filter）</strong>，有时也称为<strong>内核（Kernel）</strong>或<strong>掩模（Mask）</strong>，是一个小的数字矩阵。滤波器运算就是<strong>将这个小的矩阵（滤波器）在大的数字矩阵（原始图像）上滑动，并在每个位置进行一系列数学计算，从而生成一幅新图像的过程</strong>。</p>
<p>这个过程在数学上称为<strong>卷积（Convolution）</strong>，因此也常被称为<strong>卷积运算</strong>。</p>
<img src="../source/imgs/${fiilname}/image-20250913110528152.png" alt="image-20250913110528152" style="zoom:50%;" />

<p>有的文献中也会用“核”这个词来表示这里所说的“滤波器”。</p>
<p>如何计算：</p>
<p>对于输入数据，卷积运算以一定间隔滑动滤波器的窗口并应用。这里所说的窗口是指图7-4中灰色的3 × 3的部分。如图7-4所示，将各个位置上滤波器的元素和输入的对应元素相乘，然后再求和（有时将这个计算称为<strong>乘积累加运算</strong>）。然后，将这个结果保存到输出的对应位置。将这个过程在所有位置都进行一遍，就可以得到卷积运算的输出。</p>
<img src="../source/imgs/${fiilname}/image-20250913111620630.png" alt="image-20250913111620630" style="zoom:50%;" />

<p>在全连接的神经网络中，除了权重参数，还存在偏置。 CNN中，滤波器的参数就对应之前的权重。并且， CNN中也存在偏置。图7-3的卷积运算的例子一直展示到了应用滤波器的阶段。包含偏置的卷积运算的处理流如图7-5所示。</p>
<p>如图7-5所示，向应用了滤波器的数据加上了<strong>偏置</strong>。偏置通常只有1个（1 × 1）（本例中，相对于应用了滤波器的4个数据，偏置只有1个），这个值会被<strong>加到应用了滤波器的所有元素上</strong>。</p>
<img src="../source/imgs/${fiilname}/image-20250913111730093.png" alt="image-20250913111730093" style="zoom:67%;" />

<h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>在进行卷积层的处理之前，有时要<strong>向输入数据的周围填入固定的数据</strong>（比如0等），这称为<strong>填充</strong>（padding），是卷积运算中经常会用到的处理。比如，在图7-6的例子中，对大小为(4, 4)的输入数据应用了幅度为1的填充。“<strong>幅度为1的填充</strong>”是指用幅度为1像素的0填充周围。</p>
<img src="../source/imgs/${fiilname}/image-20250913111919701.png" alt="image-20250913111919701" style="zoom:50%;" />

<p>使用填充主要是为了<strong>调整输出的大小</strong>。比如，对大小为(4, 4)的输入数据应用(3, 3)的滤波器时，输出大小变为(2, 2)，相当于输出大小比输入大小缩小了2个元素。这在反复进行多次卷积运算的深度网络中会成为问题。为什么呢？因为如果每次进行卷积运算都会缩小空间，那么在某个时刻输出大小就有可能变为 1，导致无法再应用卷积运算。为了避免出现这样的情况，就要使用填充。在刚才的例子中，将填充的幅度设为1，那么相对于输入大小(4, 4)，输出大小也保持为原来的(4, 4)。因此，卷积运算就可以在保持空间大小不变的情况下将数据传给下一层。</p>
<h3 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h3><p>应用滤波器的位置间隔称为<strong>步幅</strong>（stride）。之前的例子中步幅都是1，如果将步幅设为2，则如图7-7所示，应用滤波器的窗口的间隔变为2个元素。</p>
<img src="../source/imgs/${fiilname}/image-20250913112226658.png" alt="image-20250913112226658" style="zoom:50%;" />

<p>步幅可以指定应用滤波器的间隔。</p>
<p>综上，增大步幅后，输出大小会变小。而增大填充后，输出大小会变大。如果将这样的关系写成算式，会如何呢？接下来，我们看一下对于填充和步幅，如何计算输出大小。</p>
<p>这里，假设输入大小为(H, W)，滤波器大小为(FH, FW)，输出大小为(OH, OW)，填充为P，步幅为S。</p>
<img src="../source/imgs/${fiilname}/image-20250913220538308.png" alt="image-20250913220538308" style="zoom:50%;" />

<img src="../source/imgs/${fiilname}/image-20250913220620533.png" alt="image-20250913220620533" style="zoom:50%;" />

<p>这里需要注意的是，虽然只要代入值就可以计算输出大小，但是所设定的值必须使<img src="../source/imgs/${fiilname}/image-20250913220655204.png" alt="image-20250913220655204" style="zoom:50%;" />分别可以除尽。当输出大小无法除尽时（结果是小数时），需要采取报错等对策。顺便说一下，根据<strong>深度学习的框架的不同</strong>，当值无法除尽时，有时会向最接近的整数四舍五入，不进行报错而继续运行。</p>
<h3 id="3维数据的卷积运算"><a href="#3维数据的卷积运算" class="headerlink" title="3维数据的卷积运算"></a>3维数据的卷积运算</h3><p>图像是3维数据，除了高、长方向之外，还需要处理通道方向。这里，我们按照与之前相同的顺序，看一下对加上了通道方向的3维数据进行卷积运算的例子。</p>
<p>图7-8是卷积运算的例子，图7-9是计算顺序。这里以3通道的数据为例，展示了卷积运算的结果。和2维数据时（图7-3的例子）相比，可以发现纵深方向（通道方向）上特征图增加了。通道方向上有多个特征图时，会按通道进行输入数据和滤波器的卷积运算，并<strong>将结果相加</strong>，从而得到输出。</p>
<img src="../source/imgs/${fiilname}/image-20250913220857845.png" alt="image-20250913220857845" style="zoom:50%;" />

<img src="../source/imgs/${fiilname}/image-20250913220924250.png" alt="image-20250913220924250" style="zoom:60%;" />

<p>在3维数据的卷积运算中，<strong>输入数据和滤波器的通道数要设为相同的值</strong>。在这个例子中，输入数据和滤波器的通道数一致，均为3。滤波器大小可以设定为任意值（不过，<strong>每个通道的滤波器大小要全部相同</strong>）。这个例子中滤波器大小为(3, 3)，但也可以设定为(2, 2)、 (1, 1)、 (5, 5)等任意值。再强调一下，通道数只能设定为和输入数据的通道数相同的值（本例中为3）。</p>
<p>通道数为 C、高度为H、长度为W的数据的形状可以写成（C, H, W）。滤波器也一样，要按（channel, height, width）的顺序书写。比如，通道数为C、滤波器高度为FH（Filter Height）、长度为FW（Filter Width）时，可以写成（C, FH, FW）。</p>
<img src="../source/imgs/${fiilname}/image-20250913221152636.png" alt="image-20250913221152636" style="zoom:67%;" />

<p>如果要在通道方向上也拥有多个卷积运算的输出，该怎么做呢？为此，就需要用到<strong>多个滤波器</strong>（权重）。用图表示的话，如图7-11所示。</p>
<img src="../source/imgs/${fiilname}/image-20250913221249515.png" alt="image-20250913221249515" style="zoom:50%;" />

<p>通过应用FN个滤波器，输出特征图也生成了FN个。如果将这FN个特征图汇集在一起，就得到了形状为(FN, OH, OW)的方块。将这个方块传给下一层，就是CNN的处理流。</p>
<p>关于卷积运算的滤波器，也必须考虑滤波器的数量。因此，作为4维数据，滤波器的权重数据要按(output_channel, input_ channel , height, width)的顺序书写。比如，通道数为3、大小为5 × 5的滤波器有20个时，可以写成(20, 3, 5, 5)。</p>
<p>卷积运算中（和全连接层一样）<strong>存在偏置</strong>。在图7-11的例子中，如果进一步追加偏置的加法运算处理，则结果如下面的图7-12所示。</p>
<p>图7-12中，每个通道只有一个偏置。这里，偏置的形状是(FN, 1, 1)，滤波器的输出结果的形状是(FN, OH, OW)。这两个方块相加时，要对滤波器的输出结果(FN, OH, OW)<strong>按通道加上相同的偏置值</strong>。另外，不同形状的方块相加时，可以基于NumPy的广播功能轻松实现（1.5.5节）。</p>
<img src="../source/imgs/${fiilname}/image-20250913221526687.png" alt="image-20250913221526687" style="zoom:50%;" />

<h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>需要将在各层间传递的数据保存为4维数据。具体地讲，就是按(batch_num, channel, height, width)的顺序保存数据。比如，将图7-12中的处理改成对N个数据进行批处理时，数据的形状如图7-13所示。</p>
<p>图7-13的批处理版的数据流中，在各个数据的开头添加了批用的维度。像这样，数据作为4维的形状在各层间传递。这里需要注意的是，网络间传递的是4维数据，对这N个数据进行了卷积运算。也就是说，批处理将N次的处理汇总成了1次进行。</p>
<img src="../source/imgs/${fiilname}/image-20250913221932677.png" alt="image-20250913221932677" style="zoom:50%;" />

<h2 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h2><p>池化是<strong>缩小高、长方向上的空间</strong>的运算。比如，如图7-14所示，进行将2 × 2的区域集约成1个元素的处理，缩小空间大小。</p>
<img src="../source/imgs/${fiilname}/image-20250913222046256.png" alt="image-20250913222046256" style="zoom:50%;" />

<p>图7-14的例子是按步幅2进行2 × 2的Max池化时的处理顺序。“Max池化”是获取最大值的运算，“2 × 2”表示目标区域的大小。一般来说，<strong>池化的窗口大小会和步幅设定成相同的值</strong>。比如， 3 × 3的窗口的步幅会设为3， 4 × 4的窗口的步幅会设为4等。</p>
<p>除了Max池化之外，还有Average池化等。相对于Max池化是从目标区域中取出最大值，<strong>Average池化</strong>则是计算目标区域的平均值。在图像识别领域，主要使用Max池化。因此，本书中说到“池化层”时，指的是Max池化。</p>
<p>池化层有以下<strong>特征</strong>：</p>
<p><strong>没有要学习的参数</strong></p>
<p>池化层和卷积层不同，没有要学习的参数。池化只是从目标区域中取最大值（或者平均值），所以不存在要学习的参数。</p>
<p><strong>通道数不发生变化</strong></p>
<p>经过池化运算，输入数据和输出数据的通道数不会发生变化。如图7-15所示，计算是按通道独立进行的。</p>
<p><strong>对微小的位置变化具有鲁棒性（健壮）</strong></p>
<p>输入数据发生微小偏差时，池化仍会返回相同的结果。因此，池化对输入数据的微小偏差具有鲁棒性。比如， 3 × 3的池化的情况下，如图7-16所示，池化会吸收输入数据的偏差（根据数据的不同，结果有可能不一致）。</p>
<img src="../source/imgs/${fiilname}/image-20250913222423357.png" alt="image-20250913222423357" style="zoom:50%;" />

<h2 id="卷积层和池化层的实现"><a href="#卷积层和池化层的实现" class="headerlink" title="卷积层和池化层的实现"></a>卷积层和池化层的实现</h2><h3 id="4维数组"><a href="#4维数组" class="headerlink" title="4维数组"></a>4维数组</h3><p>CNN中各层间传递的数据是4维数据。所谓4维数据，比如数据的形状是(10, 1, 28, 28)，则它对应10个高为28、长为28、通道为1的数据。用Python来实现的话，如下所示。</p>
<pre><code class="hljs plaintext">&gt;&gt;&gt; x = np.random.rand(10, 1, 28, 28) # 随机生成数据
&gt;&gt;&gt; x.shape
(10, 1, 28, 28)</code></pre>

<p>如果要访问第1个数据，只要写 x[0]就可以了。<code>&gt;&gt;&gt; x[0].shape # (1, 28, 28)</code>  </p>
<p>如果要访问第1个数据的第1个通道的空间数据：<code>&gt;&gt;&gt; x[0, 0] # 或者x[0][0]</code>  </p>
<h3 id="基于-im2col的展开"><a href="#基于-im2col的展开" class="headerlink" title="基于 im2col的展开"></a>基于 im2col的展开</h3><p>如果老老实实地实现卷积运算，估计要重复好几层的 for语句。这样的实现有点麻烦，而且， NumPy中存在使用for语句后处理变慢的缺点（NumPy中，访问元素时最好不要用 for语句）。这里，我们不使用 for语句，而是使用im2col这个便利的函数进行简单的实现。</p>
<p>im2col是一个函数，将输入数据展开以适合滤波器（权重）。如图7-17所示，对3维的输入数据<strong>应用im2col</strong>后，<strong>数据转换为2维矩阵</strong>（正确地讲，是把包含批数量的4维数据转换成了2维数据）。</p>
<img src="../source/imgs/${fiilname}/image-20250914191528335.png" alt="image-20250914191528335" style="zoom:50%;" />

<p>im2col会把输入数据展开以适合滤波器（权重）。具体地说，如图7-18所示，对于输入数据，<strong>将应用滤波器的区域（3维方块）横向展开为1列</strong>。 im2col会在所有应用滤波器的地方进行这个展开处理。</p>
<img src="../source/imgs/${fiilname}/image-20250914191948788.png" alt="image-20250914191948788" style="zoom:50%;" />

<p>在图7-18中，为了便于观察，将步幅设置得很大，以使滤波器的应用区域不重叠。而在实际的卷积运算中，滤波器的应用区域几乎都是重叠的。在滤波器的应用区域重叠的情况下，使用im2col展开后，展开后的元素个数会多于原方块的元素个数。因此，使用im2col的实现存在比普通的实现<strong>消耗更多内存</strong>的缺点。但是，汇总成一个大的矩阵进行计算，对计算机的计算颇有益处。</p>
<p>使用 im2col展开输入数据后，之后就只需将卷积层的滤波器（权重）纵向展开为1列，并计算2个矩阵的乘积即可（参照图7-19）。这和全连接层的Affi ne层进行的处理基本相同。</p>
<p>如图7-19所示，基于 im2col方式的<strong>输出结果是2维矩阵</strong>。因为CNN中数据会保存为4维数组，所以要将2维输出数据<strong>转换</strong>为合适的形状。以上就是卷积层的实现流程。</p>
<img src="../source/imgs/${fiilname}/image-20250914192306122.png" alt="image-20250914192306122" style="zoom:50%;" />

<h3 id="卷积层的实现"><a href="#卷积层的实现" class="headerlink" title="卷积层的实现"></a>卷积层的实现</h3><pre><code class="hljs plaintext">def im2col(input_data, filter_h, filter_w, stride=1, pad=0):
    &quot;&quot;&quot;

    Parameters
    ----------
    input_data : 由(数据量, 通道, 高, 长)的4维数组构成的输入数据
    filter_h : 滤波器的高
    filter_w : 滤波器的长
    stride : 步幅
    pad : 填充

    Returns
    -------
    col : 2维数组
    &quot;&quot;&quot;
    N, C, H, W = input_data.shape
    out_h = (H + 2*pad - filter_h)//stride + 1
    out_w = (W + 2*pad - filter_w)//stride + 1

    img = np.pad(input_data, [(0,0), (0,0), (pad, pad), (pad, pad)], &#x27;constant&#x27;)
    col = np.zeros((N, C, filter_h, filter_w, out_h, out_w))

    for y in range(filter_h):
        y_max = y + stride*out_h
        for x in range(filter_w):
            x_max = x + stride*out_w
            col[:, :, y, x, :, :] = img[:, :, y:y_max:stride, x:x_max:stride]

    col = col.transpose(0, 4, 5, 1, 2, 3).reshape(N*out_h*out_w, -1)
    return col</code></pre>

<p>重塑为2D矩阵：</p>
<ul>
<li>行数：<code>N * out_h * out_w</code>（所有输出位置）</li>
<li>列数：<code>C * filter_h * filter_w</code>（每个位置的滤波器窗口）</li>
</ul>
<p>现在使用im2col来实现卷积层。这里我们将卷积层实现为名为Convolution的类。</p>
<pre><code class="hljs plaintext">class Convolution:
    def __init__(self, W, b, stride=1, pad=0):
        self.W = W
        self.b = b
        self.stride = stride
        self.pad = pad
    def forward(self, x):
        FN, C, FH, FW = self.W.shape
        N, C, H, W = x.shape
        out_h = int(1 + (H + 2*self.pad - FH) / self.stride)
        out_w = int(1 + (W + 2*self.pad - FW) / self.stride)
        col = im2col(x, FH, FW, self.stride, self.pad)
        col_W = self.W.reshape(FN, -1).T # 滤波器的展开
        out = np.dot(col, col_W) + self.b
        out = out.reshape(N, out_h, out_w, -1).transpose(0, 3, 1, 2)
        return out</code></pre>

<p>卷积层的初始化方法将滤波器（权重）、偏置、步幅、填充作为参数接收。滤波器是 (FN, C, FH, FW)的 4 维形状。另外， FN、 C、 FH、 FW分别是 Filter Number（滤波器数量）、 Channel、 Filter Height、 Filter Width的缩写。</p>
<p>这里通过 reshape(FN,-1)将参数指定为 -1，这是reshape的一个便利的功能。通过在 reshape时指定为 -1， reshape函数会自动计算 -1维度上的元素个数，以使多维数组的元素个数前后一致。比如， (10, 3, 5, 5)形状的数组的元素个数共有750个，指定 reshape(10,-1)后，就会转换成(10, 75)形状的数组。forward的实现中，最后会将输出大小转换为合适的形状。转换时使用了NumPy的transpose函数。 transpose会更改多维数组的轴的顺序。</p>
<img src="../source/imgs/${fiilname}/image-20250914202637781.png" alt="image-20250914202637781" style="zoom:50%;" />

<p>以上就是卷积层的 forward处理的实现。通过使用 im2col进行展开，基本上可以像实现全连接层的Affine层一样来实现。接下来是卷积层的反向传播的实现，因为和Affine层的实现有很多共通的地方，所以就不再介绍了。但有一点需要注意，在<strong>进行卷积层的反向传播时，必须进行im2col的逆处理</strong>。</p>
<p>“必须进行 im2col 的逆处理” 指的是将梯度信息从展开的矩阵形式转换回原始图像格式的关键步骤。</p>
<p><strong>反向传播过程：</strong></p>
<ol>
<li>计算输出梯度（损失函数对输出的导数）</li>
<li><strong>关键步骤：将梯度转换回 im2col 格式</strong></li>
<li>计算滤波器梯度：<code>滤波器梯度 = im2col(input)^T × 输出梯度</code></li>
<li><strong>关键步骤：计算输入梯度（需要 im2col 的逆操作）</strong></li>
</ol>
<ul>
<li>前向传播通过 <code>im2col</code> 改变了数据表示形式</li>
<li>反向传播必须沿相同路径反向传播梯度</li>
<li>需要将梯度从矩阵形式映射回原始图像格式</li>
</ul>
<pre><code class="hljs plaintext">def col2im(col, input_shape, filter_h, filter_w, stride=1, pad=0):
    &quot;&quot;&quot;

    Parameters
    ----------
    col :
    input_shape : 输入数据的形状（例：(10, 1, 28, 28)）
    filter_h :
    filter_w
    stride
    pad

    Returns
    -------

    &quot;&quot;&quot;
    N, C, H, W = input_shape
    out_h = (H + 2*pad - filter_h)//stride + 1
    out_w = (W + 2*pad - filter_w)//stride + 1
    col = col.reshape(N, out_h, out_w, C, filter_h, filter_w).transpose(0, 3, 4, 5, 1, 2)

    img = np.zeros((N, C, H + 2*pad + stride - 1, W + 2*pad + stride - 1))
    for y in range(filter_h):
        y_max = y + stride*out_h
        for x in range(filter_w):
            x_max = x + stride*out_w
            img[:, :, y:y_max:stride, x:x_max:stride] += col[:, :, y, x, :, :]

    return img[:, :, pad:H + pad, pad:W + pad]</code></pre>

<h3 id="池化层的实现"><a href="#池化层的实现" class="headerlink" title="池化层的实现"></a>池化层的实现</h3><p>池化层的实现和卷积层相同，都使用im2col展开输入数据。不过，池化的情况下，在通道方向上是独立的，这一点和卷积层不同。具体地讲，如图7-21所示，<strong>池化的应用区域按通道单独展开</strong>。</p>
<img src="../source/imgs/${fiilname}/image-20250914205228236.png" alt="image-20250914205228236" style="zoom:50%;" />

<p>像这样展开之后，只需对展开的矩阵求各行的最大值，并转换为合适的形状即可（图7-22）。</p>
<img src="../source/imgs/${fiilname}/image-20250914205402764.png" alt="image-20250914205402764" style="zoom:50%;" />

<p>Python的实现示例：</p>
<pre><code class="hljs plaintext">class Pooling:
    def __init__(self, pool_h, pool_w, stride=1, pad=0):
        self.pool_h = pool_h
        self.pool_w = pool_w
        self.stride = stride
        self.pad = pad
    def forward(self, x):
        N, C, H, W = x.shape
        out_h = int(1 + (H - self.pool_h) / self.stride)
        out_w = int(1 + (W - self.pool_w) / self.stride)
        # 展开(1)
        col = im2col(x, self.pool_h, self.pool_w, self.stride, self.pad)
        col = col.reshape(-1, self.pool_h*self.pool_w)
        # 最大值(2)
        out = np.max(col, axis=1)
        # 转换(3)
        out = out.reshape(N, out_h, out_w, C).transpose(0, 3, 1, 2)
        return out</code></pre>

<p>池化层的实现按下面3个阶段进行：</p>
<p>1.展开输入数据。2.求各行的最大值。3.转换为合适的输出大小。</p>
<h2 id="CNN的实现"><a href="#CNN的实现" class="headerlink" title="CNN的实现"></a>CNN的实现</h2><p>要实现如图7-23所示的CNN。</p>
<img src="../source/imgs/${fiilname}/image-20250914210146223.png" alt="image-20250914210146223" style="zoom:50%;" />

<p>自己去看</p>
<h2 id="CNN的可视化"><a href="#CNN的可视化" class="headerlink" title="CNN的可视化"></a>CNN的可视化</h2><h3 id="第1层权重的可视化"><a href="#第1层权重的可视化" class="headerlink" title="第1层权重的可视化"></a>第1层权重的可视化</h3><p>第1层的卷积层的权重的形状是(30, 1, 5, 5)，即30个大小为5 × 5、通道为1的滤波器。滤波器大小是5 × 5、通道数是1，意味着滤波器可以可视化为1通道的灰度图像。现在，我们将卷积层（第1层）的滤波器显示为图像。这里，我们来比较一下学习前和学习后的权重，结果如图7-24所示。</p>
<p>图7-24中，学习前的滤波器是随机进行初始化的，所以在黑白的浓淡上没有规律可循，但学习后的滤波器变成了有规律的图像。我们发现，通过学习，滤波器被更新成了有规律的滤波器，比如从白到黑渐变的滤波器、含有块状区域（称为blob）的滤波器等。</p>
<img src="../source/imgs/${fiilname}/image-20250914210654169.png" alt="image-20250914210654169" style="zoom:50%;" />

<p>右边的有规律的滤波器在“观察”什么，答案就是它在观察边缘（颜色变化的分界线）和斑块（局部的块状区域）等。比如，左半部分为白色、右半部分为黑色的滤波器的情况下，如图7-25所示，会对垂直方向上的边缘有响应。</p>
<img src="../source/imgs/${fiilname}/image-20250914210719918.png" alt="image-20250914210719918" style="zoom:50%;" />

<p>图7-25中显示了选择两个学习完的滤波器对输入图像进行卷积处理时的结果。我们发现“滤波器1”对垂直方向上的边缘有响应，“滤波器2</p>
<p>”对水平方向上的边缘有响应。</p>
<p>由此可知，卷积层的滤波器会提取边缘或斑块等原始信息。而刚才实现的CNN会将这些原始信息传递给后面的层。</p>
<h3 id="基于分层结构的信息提取"><a href="#基于分层结构的信息提取" class="headerlink" title="基于分层结构的信息提取"></a>基于分层结构的信息提取</h3><p>第1层的卷积层中提取了边缘或斑块等“低级”信息，那么在堆叠了多层的CNN中，各层中又会提取什么样的信息呢？</p>
<p>图7-26中展示了进行一般物体识别（车或狗等）的8层CNN。这个网络结构的名称是下一节要介绍的AlexNet。 AlexNet网络结构堆叠了多层卷积层和池化层，最后经过全连接层输出结果。图7-26的方块表示的是中间数据，对于这些中间数据，会连续应用卷积运算。</p>
<img src="../source/imgs/${fiilname}/image-20250914210954006.png" alt="image-20250914210954006" style="zoom:50%;" />

<p>如图7-26所示，如果堆叠了多层卷积层，则随着<strong>层次加深</strong>，<strong>提取的信息也愈加复杂、抽象</strong>，这是深度学习中很有意思的一个地方。最开始的层对简单的边缘有响应，接下来的层对纹理有响应，再后面的层对更加复杂的物体部件有响应。也就是说，随着层次加深，神经元从简单的形状向“高级”信息变化。换句话说，就像我们理解东西的“含义”一样，响应的对象在逐渐变化。</p>
<h2 id="具有代表性的CNN"><a href="#具有代表性的CNN" class="headerlink" title="具有代表性的CNN"></a>具有代表性的CNN</h2><p><strong>LeNet</strong></p>
<p>LeNet在1998年被提出，是进行手写数字识别的网络。如图7-27所示，它有连续的卷积层和池化层（正确地讲，是只“抽选元素”的子采样层），最后经全连接层输出结果。</p>
<img src="../source/imgs/${fiilname}/image-20250914211135593.png" alt="image-20250914211135593" style="zoom:50%;" />

<p>和“现在的CNN”相比， LeNet有几个不同点。第一个不同点在于激活函数。 LeNet中使用sigmoid函数，而现在的CNN中主要使用ReLU函数。此外，原始的LeNet中使用子采样（subsampling）缩小中间数据的大小，而现在的CNN中Max池化是主流。</p>
<p><strong>AlexNet</strong></p>
<img src="../source/imgs/${fiilname}/image-20250914211227133.png" alt="image-20250914211227133" style="zoom:50%;" />

<p>AlexNet叠有多个卷积层和池化层，最后经由全连接层输出结果。虽然结构上AlexNet和LeNet没有大的不同，但有以下几点差异。</p>
<p>• 激活函数使用ReLU。</p>
<p>• 使用进行局部正规化的LRN（Local Response Normalization）层。</p>
<p>• 使用Dropout。</p>
<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p>深度学习是加深了层的深度神经网络。基于之前介绍的网络，只需通过叠加层，就可以创建深度网络。</p>
<h2 id="加深网络"><a href="#加深网络" class="headerlink" title="加深网络"></a>加深网络</h2><p>创建一个如图8-1所示的网络结构的CNN（一个比之前的网络都深的网络）。这里使用的卷积层全都是3 × 3的小型滤波器，特点是随着层的加深，通道数变大（卷积层的通道数从前面的层开始按顺序以16、 16、 32、 32、 64、 64的方式增加）。此外，如图8-1所示，插入了池化层，以逐渐减小中间数据的空间大小；并且，后面的全连接层中使用了Dropout层。</p>
<img src="../source/imgs/${fiilname}/image-20250916111157835.png" alt="image-20250916111157835" style="zoom:50%;" />

<p>这个网络使用He初始值作为权重的初始值，使用Adam</p>
<p>更新权重参数。把上述内容总结起来，这个网络有如下特点。</p>
<p>• 基于3× 3的小型滤波器的卷积层。</p>
<p>• 激活函数是ReLU。</p>
<p>• 全连接层的后面使用Dropout层。</p>
<p>• 基于Adam的最优化。</p>
<p>• 使用He初始值作为权重初始值。</p>
<p>对于手写数字识别这样一个比较简单的任务，没有必要将网络的表现力提高到那么高的程度。因此，可以说加深层的好处并不大。而之后要介绍的大规模的一般物体识别的情况，因为问题复杂，所以加深层对提高识别精度大有裨益。</p>
<p>集成学习、学习率衰减、 Data Augmentation（数据扩充）等都有助于提高识别精度。尤其是Data Augmentation，虽然方法很简单，但在提高识别精度上效果显著。</p>
<p>Data Augmentation基于算法“人为地”扩充输入图像（训练图像）。具体地说，如图8-4所示，对于输入图像，通过施加旋转、垂直或水平方向上的移动等微小变化，增加图像的数量。这在数据集的图像数量有限时尤其有效。</p>
<img src="../source/imgs/${fiilname}/image-20250916152546197.png" alt="image-20250916152546197" style="zoom:50%;" />

<p>除了如图8-4所示的变形之外， Data Augmentation还可以通过其他各种方法扩充图像，比如裁剪图像的“crop处理”、将图像左右翻转的“flip处理”（flip处理只在不需要考虑图像对称性的情况下有效。）等。对于一般的图像，施加亮度等外观上的变化、放大缩小等尺度上的变化也是有效的。</p>
<p><strong>加深层的好处</strong>：</p>
<p><strong>可以减少网络的参数数量</strong>。说得详细一点，就是与没有加深层的网络相比，加深了层的网络可以用更少的参数达到同等水平（或者更强）的表现力。这一点结合卷积运算中的滤波器大小来思考就好理解了。比如，图8-5展示了由5 × 5的滤波器构成的卷积层。</p>
<img src="../source/imgs/${fiilname}/image-20250916153339950.png" alt="image-20250916153339950" style="zoom:50%;" />

<img src="../source/imgs/${fiilname}/image-20250916153356093.png" alt="image-20250916153356093" style="zoom:50%;" />

<p>一次5 × 5的卷积运算的区域可以由两次3 × 3的卷积运算抵充。并且，相对于前者的参数数量25（5 × 5），后者一共是18（2 × 3 × 3），通过叠加卷积层，参数数量减少了。而且，这个参数数量之差会随着层的加深而变大。比如，重复三次3 × 3的卷积运算时，参数的数量总共是27。而为了用一次卷积运算“观察”与之相同的区域，需要一个7 × 7的滤波器，此时的参数数量是49。</p>
<p><strong>叠加小型滤波器</strong>来加深网络的好处是<strong>可以减少参数的数量，扩大感受野</strong>（receptive field，给神经元施加变化的某个局部空间区域）。并且，通过叠加层，将 <strong>ReLU等</strong>激活函数夹在卷积层的中间，进一步提高了网络的表现力。这是因为向网络添加了基于激活函数的“非线性”表现力，通过<strong>非线性函数</strong>的叠加，可以表现更加复杂的东西。  </p>
<p>加深层的另一个好处就是<strong>使学习更加高效</strong>。与没有加深层的网络相比，通过加深层，可以减少学习数据，从而高效地进行学习。为了直观地理解这一点，CNN的卷积层会分层次地提取信息。具体地说，在前面的卷积层中，神经元会对边缘等简单的形状有响应，随着层的加深，开始对纹理、物体部件等更加复杂的东西有响应。</p>
<p>我们先牢记这个网络的分层结构，然后考虑一下“狗”的识别问题。要用浅层网络解决这个问题的话，卷积层需要一下子理解很多“狗”的特征。“狗”有各种各样的种类，根据拍摄环境的不同，外观变化也很大。因此，要理解“狗”的特征，需要大量富有差异性的学习数据，而这会导致学习需要花费很多时间。</p>
<p>不过，通过加深网络，就可以分层次地分解需要学习的问题。因此，各层需要学习的问题就变成了更简单的问题。比如，最开始的层只要专注于学习边缘就好，这样一来，只需用较少的学习数据就可以高效地进行学习。这是为什么呢？因为和印有“狗”的照片相比，包含边缘的图像数量众多，并且边缘的模式比“狗”的模式结构更简单。</p>
<p>通过加深层，<strong>可以分层次地传递信息</strong>。比如，因为提取了边缘的层的下一层能够使用边缘的信息，所以应该能够高效地学习更加高级的模式。也就是说，通过加深层，可以<strong>将各层要学习的问题分解成容易解决的简单问题</strong>，从而可以进行高效的学习。</p>
<h2 id="深度学习的高速化"><a href="#深度学习的高速化" class="headerlink" title="深度学习的高速化"></a>深度学习的高速化</h2><p>深度学习中什么样的处理比较耗时。图8-14中以AlexNet的 forward处理为对象，用饼图展示了各层所耗费的时间。</p>
<p>从图中可知， AlexNex中，<strong>大多数时间都被耗费在卷积层上</strong>。实际上，卷积层的处理时间加起来占GPU整体的95%，占CPU整体的89%！因此，如何高速、高效地进行卷积层中的运算是深度学习的一大课题。虽然图8-14是推理时的结果，不过学习时也一样，卷积层中会耗费大量时间。</p>
<img src="../source/imgs/${fiilname}/image-20250916155041776.png" alt="image-20250916155041776" style="zoom:50%;" />

<p>卷积层中进行的运算可以追溯至乘积累加运算。因此，深度学习的高速化的主要课题就变成了如何高速、高效地进行大量的乘积累加运算。</p>
<p>GPU计算，是指基于GPU进行通用的数值计算的操作。</p>
<p>深度学习中需要进行大量的<strong>乘积累加运算</strong>（或者<strong>大型矩阵的乘积运算</strong>）。这种大量的<strong>并行运算</strong>正是GPU所擅长的（反过来说， CPU比较擅长连续的、复杂的计算）。因此，与使用单个CPU相比，使用GPU进行深度学习的运算可以达到惊人的高速化。下面我们就来看一下基于GPU可以实现多大程度的高速化。图8-15是基于CPU和GPU进行AlexNet的学习时分别所需的时间。</p>
<p>从图中可知，使用CPU要花40天以上的时间，而使用GPU则可以将时间缩短至6天。此外，还可以看出，通过<strong>使用cuDNN</strong>这个最优化的库，可以进一步实现高速化。</p>
<img src="../source/imgs/${fiilname}/image-20250916160121430.png" alt="image-20250916160121430" style="zoom:50%;" />

<p>大多数深度学习框架只受益于NVIDIA的GPU。这是因为深度学习的框架中使用了NVIDIA提供的CUDA这个面向GPU计算的综合开发环境。</p>
<p>通过 im2col可以将卷积层进行的运算转换为大型矩阵的乘积。相比按小规模的单位进行计算，GPU更擅长计算大规模的汇总好的数据。也就是说，通过基于 im2col以大型矩阵的乘积的方式汇总计算，更容易发挥出GPU的能力。</p>
<p>为了进一步提高深度学习所需的计算的速度，可以考虑在<strong>多个GPU或者多台机器</strong>上进行分布式计算。现在的深度学习框架中，出现了好几个支持多GPU或者多机器的分布式学习的框架。其中， Google的TensorFlow、微软的CNTK（Computational Network Toolki）在开发过程中高度重视分布式学习。以大型数据中心的低延迟· 高吞吐网络作为支撑，基于这些框架的分布式学习呈现出惊人的效果。</p>
<p>基于分布式学习，可以达到何种程度的高速化呢？图8-16中显示了基于TensorFlow的分布式学习的效果。</p>
<img src="../source/imgs/${fiilname}/image-20250916160828227.png" alt="image-20250916160828227" style="zoom:50%;" />

<p>如图8-16所示，随着GPU个数的增加，学习速度也在提高。实际上，与使用1个GPU时相比，使用100个GPU（设置在多台机器上，共100个）似乎可以实现56倍的高速化。</p>
<p>关于分布式学习，“如何进行分布式计算”是一个非常难的课题。它包含了机器间的通信、数据的同步等多个无法轻易解决的问题。可以将这些难题都交给TensorFlow等优秀的框架。</p>
<p>在深度学习的高速化中，除了计算量之外，内存容量、总线带宽等也有可能成为瓶颈。关于内存容量，需要考虑将大量的权重参数或中间数据放在内存中。关于总线带宽，当流经GPU（或者CPU）总线的数据超过某个限制时，就会成为瓶颈。考虑到这些情况，我们希望尽可能<strong>减少流经网络的数据的位数</strong>。</p>
<p>计算机中为了表示实数，主要使用64位或者32位的浮点数。通过使用较多的位来表示数字，虽然数值计算时的误差造成的影响变小了，但计算的处理成本、内存使用量却相应地增加了，还给总线带宽带来了负荷。</p>
<p>关于数值精度（用几位数据表示数值），我们已经知道<strong>深度学习并不那么需要数值精度的位数</strong>。这是神经网络的一个重要性质。这个性质是基于神经网络的健壮性而产生的。这里所说的健壮性是指，比如，即便输入图像附有一些小的噪声，输出结果也仍然保持不变。可以认为，正是因为有了这个健壮性，流经网络的数据即便有所“劣化”，对输出结果的影响也较小。</p>
<p>计算机中表示小数时，有32位的单精度浮点数和64位的双精度浮点数等格式。根据以往的实验结果，在深度学习中，即便是<strong>16位的半精度浮点数</strong>（half float），也可以顺利地进行学习。</p>
<p>以往的深度学习的实现中并没有注意数值的精度，不过Python中一般使用64位的浮点数。 NumPy中提供了16位的半精度浮点数类型（不过，只有16位类型的存储，运算本身不用16位进行），即便使用NumPy的半精度浮点数，识别精度也不会下降。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-python暑假" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/07/08/python%E6%9A%91%E5%81%87/" class="article-date">
  	<time datetime="2025-07-08T01:52:38.000Z" itemprop="datePublished">2025-07-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/08/python%E6%9A%91%E5%81%87/">
        python暑假
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1><p>1、在 Python 中，判断一个字符串（或任何序列）中有多少个不重复的元素，最简单、最可靠的方法是使用 set (集合)。</p>
<p>2、多字符替换</p>
<pre><code class="hljs plaintext"># 创建映射表：将&quot;aeiou&quot;替换为&quot;12345&quot;
table = str.maketrans(&quot;aeiou&quot;, &quot;12345&quot;)
text = &quot;hello world&quot;
result = text.translate(table)  # 输出: &quot;h2ll4 w4rld&quot;</code></pre>



<h1 id="如何对字典元素进行排序"><a href="#如何对字典元素进行排序" class="headerlink" title="如何对字典元素进行排序"></a>如何对字典元素进行排序</h1><p>1、按键排序（升序）</p>
<pre><code class="hljs plaintext">my_dict = &#123;&#x27;banana&#x27;: 3, &#x27;apple&#x27;: 4, &#x27;pear&#x27;: 1, &#x27;orange&#x27;: 2&#125;

# 方法1：返回排序后的键值对元组列表
sorted_items = sorted(my_dict.items())  # 默认按键升序
print(sorted_items)  # list类型
# 输出: [(&#x27;apple&#x27;, 4), (&#x27;banana&#x27;, 3), (&#x27;orange&#x27;, 2), (&#x27;pear&#x27;, 1)]

# 方法2：生成有序字典（Python 3.7+）
from collections import OrderedDict
sorted_dict = OrderedDict(sorted(my_dict.items()))
print(sorted_dict)  # 输出: OrderedDict([(&#x27;apple&#x27;, 4), (&#x27;banana&#x27;, 3), ...])</code></pre>

<p>OrderedDict是<code>collections</code> 模块提供的特殊字典子类，会记录键的插入顺序，按插入顺序返回元素。</p>
<p>2、按值排序（升序）</p>
<pre><code class="hljs plaintext"># 使用lambda函数指定按值排序
sorted_items = sorted(my_dict.items(), key=lambda item: item[1])
print(sorted_items)  
# 输出: [(&#x27;pear&#x27;, 1), (&#x27;orange&#x27;, 2), (&#x27;banana&#x27;, 3), (&#x27;apple&#x27;, 4)]</code></pre>

<p>3、降序排序</p>
<p>加上reverse关键字。</p>
<h1 id="split分割字符串"><a href="#split分割字符串" class="headerlink" title="split分割字符串"></a>split分割字符串</h1><p>针对字符串 <code>&#39;2/5 4/15 1/30 -2/60 8/3&#39;</code> 进行分隔处理，’&#x2F;‘和’ ‘作为分割符</p>
<pre><code class="hljs plaintext"># 原始字符串
input_str = &#x27;2/5 4/15 1/30 -2/60 8/3&#x27;

# 方法1：分两步处理（先按空格分割，再按斜杠分割）
parts = input_str.split()
result = []
for fraction in parts:
    numerator, denominator = fraction.split(&#x27;/&#x27;)
    result.append((numerator, denominator))

print(&quot;方法1结果:&quot;, result)
# 输出: [(&#x27;2&#x27;, &#x27;5&#x27;), (&#x27;4&#x27;, &#x27;15&#x27;), (&#x27;1&#x27;, &#x27;30&#x27;), (&#x27;-2&#x27;, &#x27;60&#x27;), (&#x27;8&#x27;, &#x27;3&#x27;)]

# 方法2：使用列表推导式（更简洁）
result_clean = [frac.split(&#x27;/&#x27;) for frac in input_str.split()]
print(&quot;方法2结果:&quot;, result_clean)
# 输出: [[&#x27;2&#x27;, &#x27;5&#x27;], [&#x27;4&#x27;, &#x27;15&#x27;], [&#x27;1&#x27;, &#x27;30&#x27;], [&#x27;-2&#x27;, &#x27;60&#x27;], [&#x27;8&#x27;, &#x27;3&#x27;]]</code></pre>

<p>假如有多个字符要作为分割的标准，要如何进行分割？</p>
<pre><code class="hljs plaintext">import re

text = &quot;apple;banana,cherry|date:fig&quot;
separators = &quot;;,|: &quot;  # 分隔符列表（含空格）

# 方法1：使用字符类 []
result = re.split(r&#x27;[;,|: ]+&#x27;, text)

# 方法2：使用替代符号 |
result = re.split(r&#x27;;|,|\||:|\s+&#x27;, text)  # \s 包含所有空白字符

print(f&quot;分割结果: &#123;result&#125;&quot;)
# 输出: [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;, &#x27;date&#x27;, &#x27;fig&#x27;]</code></pre>

<p>处理连续分割符</p>
<pre><code class="hljs plaintext">text = &quot;data1,,data2;;data3  data4&quot;
result = [s for s in re.split(r&#x27;[,\s;]+&#x27;, text) if s]  # 过滤空字符串

print(f&quot;过滤空值结果: &#123;result&#125;&quot;)
# 输出: [&#x27;data1&#x27;, &#x27;data2&#x27;, &#x27;data3&#x27;, &#x27;data4&#x27;]</code></pre>

<p>在<code>result = re.split(r&#39;[;,|: ]+&#39;, text)</code>中，<code>[;,|: ]</code>+是一个<strong>字符类</strong>（方括号 <code>[]</code>），但它没有使用捕获分组括号(),正则表达式引擎会找到所有匹配的分隔符，但不会在结果中保留它们，最终结果只包含非分隔符部分。</p>
<p><code>result = re.split(r&#39;([-+=])&#39;, text)</code> 使用了捕获分组括号 <code>()</code>，所以会将分隔符也包含在结果中</p>
<h1 id="Python的-和"><a href="#Python的-和" class="headerlink" title="Python的 &#x2F;&#x2F; 和 %"></a>Python的 &#x2F;&#x2F; 和 %</h1><ul>
<li>a &#x2F;&#x2F; b：结果向下取整（向负无穷方向）。例如，7 &#x2F;&#x2F; 3 &#x3D; 2，但 -7 &#x2F;&#x2F; 3 &#x3D; -3。</li>
<li>a % b：结果的符号与<strong>除数b</strong>的符号相同。例如，-7 % 3 &#x3D; 2 (因为 -3 * 3 + 2 &#x3D; -7)。</li>
</ul>
<h1 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h1><p>python中使用round(number,decimal)函数进行四舍五入操作，number是要四舍五入的函数，decimal是舍入到第几位小数，默认为0。</p>
<p>在python中round的四舍五入是银行家舍入，当舍入位置正好在中间（即 0.5）时，会选择最接近的偶数。</p>
<p>2.5 处于两个整数之间：2 是偶数，3 是奇数 → 选择 2。</p>
<p>在这里如果想要使用原始的四舍五入的话，需要自己编写一个函数。</p>
<pre><code class="hljs plaintext">def round_traditional(x):
    return int(x + 0.5) if x &gt; 0 else int(x - 0.5)

print(round_traditional(2.5))  # 3
print(round_traditional(3.5))  # 4</code></pre>

<p>向上取整：math.ceil()</p>
<p>向下取整：math.floor()</p>
<h1 id="判断字符串为空"><a href="#判断字符串为空" class="headerlink" title="判断字符串为空"></a>判断字符串为空</h1><p>直接判断</p>
<pre><code class="hljs plaintext">s = &quot;&quot;  # 空字符串

# 简洁的判断方式
if not s:
    print(&quot;字符串为空&quot;)
    
# 等价于
if s == &quot;&quot;:
    print(&quot;字符串为空&quot;)</code></pre>

<pre><code class="hljs plaintext">方法 1：直接布尔判断
def is_empty(s):
    return not s
长度判断
def is_empty(s):
    return len(s) == 0
与空字符串比较
def is_empty(s):
    return s == &quot;&quot;</code></pre>

<h1 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h1><p>1、通过元组实现多级排序</p>
<pre><code class="hljs plaintext">data = [
    (&#x27;Alice&#x27;, 25, 90),
    (&#x27;Bob&#x27;, 30, 85),
    (&#x27;Charlie&#x27;, 25, 95),
    (&#x27;David&#x27;, 30, 80)
]

# 第一优先级：年龄升序（正数），第二优先级：分数降序（负数）
sorted_data = sorted(data, key=lambda x: (x[1], -x[2]))</code></pre>

<p>2、自定义排序函数</p>
<pre><code class="hljs plaintext">def custom_sort(item):
    # 返回一个元组定义排序优先级
    return (item[1], -item[2])  # 年龄升序，分数降序

sorted_data = sorted(data, key=custom_sort)</code></pre>

<p>3、多次排序</p>
<pre><code class="hljs plaintext"># 先按次要条件排序，再按主要条件排序（重要：从最次要开始）
temp = sorted(data, key=lambda x: x[2], reverse=True)  # 分数降序
sorted_data = sorted(temp, key=lambda x: x[1])         # 年龄升序</code></pre>

<h1 id="赋最大值或最小值"><a href="#赋最大值或最小值" class="headerlink" title="赋最大值或最小值"></a>赋最大值或最小值</h1><p>最大值初始化</p>
<pre><code class="hljs plaintext"># 使用 float(&#x27;inf&#x27;) 表示最大浮点数
max_val = float(&#x27;inf&#x27;)

# 也可以使用 sys.maxsize (系统支持的最大整数值)
import sys
max_val = sys.maxsize</code></pre>

<p>最小值初始化</p>
<pre><code class="hljs plaintext"># 使用 float(&#x27;-inf&#x27;) 表示最小浮点数
min_val = float(&#x27;-inf&#x27;)

# 对于包含负数的场景
min_val = sys.maxsize * -1</code></pre>

<h1 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque(双端队列)"></a>deque(双端队列)</h1><p>collections.deque是<strong>双向链表的实现</strong>，支持高效的两端操作（<code>O(1)</code>时间）。</p>
<p><strong>固定长度支持</strong>：通过<code>maxlen</code>参数限制队列长度，<strong>超长时自动丢弃另一端元素</strong>（如<code>deque([1,2,3], maxlen=3)</code>添加新元素会移除旧元素）</p>
<pre><code class="hljs plaintext">from collections import deque
dq = deque() #可以通过索引的方式访问
dq.append(&#x27;a&#x27;)          # 右侧添加 → deque([&#x27;a&#x27;])
dq.appendleft(&#x27;b&#x27;)      # 左侧添加 → deque([&#x27;b&#x27;, &#x27;a&#x27;])
dq.pop()                # 右侧删除 → 返回 &#x27;a&#x27;
dq.popleft()            # 左侧删除 → 返回 &#x27;b&#x27;
clear() # 清空所有元素
extend(iterable)	# 在右端批量添加元素 dq.extend([4,5]) → deque([1,2,3,4,5])
extendleft(iterable)	# 在左端批量添加元素（添加顺序逆序）	dq.extendleft([0,-1]) → deque([-1,0,1,2,3])</code></pre>

<p>通过这个<strong>实现队列</strong>或<strong>栈</strong>：</p>
<p>队列 (FIFO)：append入队 + popleft出队</p>
<p>栈 (LIFO)：append入栈 + pop出栈</p>
<h1 id="Counter（计数器）"><a href="#Counter（计数器）" class="headerlink" title="Counter（计数器）"></a>Counter（计数器）</h1><pre><code class="hljs plaintext">from collections import Counter</code></pre>

<p>统计可哈希对象（如字符串、列表）中元素的频率，返回形如<code>&#123;元素: 次数&#125;</code>的字典子类。</p>
<p>访问不存在的键返回<code>0</code>而非<code>KeyError</code>。</p>
<p>提供加法（<code>+</code>）、减法（<code>-</code>）、交集（<code>&amp;</code>）、并集（<code>|</code>）等集合操作。</p>
<pre><code class="hljs plaintext">Counter(iterable)	通过可迭代对象（如列表、字符串）初始化	Counter(&quot;hello&quot;) → &#123;&#x27;h&#x27;:1, &#x27;e&#x27;:1, &#x27;l&#x27;:2, &#x27;o&#x27;:1&#125;
Counter(**kwargs)	通过关键字参数初始化	Counter(a=3, b=2) → &#123;&#x27;a&#x27;:3, &#x27;b&#x27;:2&#125;
c[key]	返回键对应的计数（键不存在时返回0）	c[&#x27;a&#x27;] → 3；c[&#x27;x&#x27;] → 0
most_common(n)	返回前n个高频元素及计数	Counter(&#x27;abracadabra&#x27;).most_common(2) → [(&#x27;a&#x27;,5), (&#x27;b&#x27;,2)]
update(iterable)	批量增加计数（支持可迭代对象、字典或Counter）	c.update([&#x27;a&#x27;,&#x27;d&#x27;]) → &#123;&#x27;a&#x27;:4, &#x27;b&#x27;:2, &#x27;d&#x27;:1&#125;
subtract(iterable)	批量减少计数（允许负值）	c.subtract(&#123;&#x27;a&#x27;:2&#125;) → &#123;&#x27;a&#x27;:2, &#x27;b&#x27;:2&#125;
elements()	返回所有元素的迭代器（按计数重复）	list(Counter(a=2,b=1).elements()) → [&#x27;a&#x27;,&#x27;a&#x27;,&#x27;b&#x27;]
c1 + c2	合并计数（相同键的计数相加）	Counter(a=3)+Counter(a=1,b=2) → &#123;&#x27;a&#x27;:4, &#x27;b&#x27;:2&#125;
c1 - c2	计算计数差（保留正计数）	Counter(a=3,b=1)-Counter(a=1,b=2) → &#123;&#x27;a&#x27;:2&#125;
c1 &amp; c2	交集（取相同键的最小计数）	Counter(a=3,b=1) &amp; Counter(a=2,b=2) → &#123;&#x27;a&#x27;:2, &#x27;b&#x27;:1&#125;</code></pre>

<p>快速分析单词&#x2F;字符频率：</p>
<pre><code class="hljs plaintext">text = &quot;the quick brown fox jumps over the lazy dog&quot;
word_count = Counter(text.split())
top_words = word_count.most_common(3)  # [(&#x27;the&#x27;, 2), (&#x27;quick&#x27;, 1), (&#x27;brown&#x27;, 1)]</code></pre>

<h1 id="match-case"><a href="#match-case" class="headerlink" title="match-case"></a>match-case</h1><p>Python 3.10 引入的模式匹配语法.</p>
<pre><code class="hljs plaintext">match value:
       case &quot;A&quot;:
           return &quot;Case A&quot;
       case &quot;B&quot;:
           return &quot;Case B&quot;
       case _:  # 默认分支
           return &quot;Default&quot;</code></pre>

<p>支持类型、结构匹配（如列表、元组）：</p>
<pre><code class="hljs plaintext">def handle_data(data):
    match data:
        case [x, y]:
            return f&quot;坐标: (&#123;x&#125;, &#123;y&#125;)&quot;
        case &#123;&quot;name&quot;: name, &quot;age&quot;: age&#125;:
            return f&quot;用户: &#123;name&#125;, &#123;age&#125;岁&quot;
        case int() | float() as num:
            return f&quot;数字: &#123;num&#125;&quot;
        case _:
            return &quot;未知类型&quot;

print(handle_data([3, 4]))           # 输出: 坐标: (3, 4)
print(handle_data(&#123;&quot;name&quot;: &quot;Alice&quot;&#125;)) # 输出: 用户: Alice, None岁</code></pre>

<h1 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h1><p><strong><code>bin()</code></strong>: 十进制 → 二进制（返回带前缀 <code>0b</code> 的字符串）</p>
<pre><code class="hljs plaintext">num = 42
binary = bin(num)        # &#x27;0b101010&#x27;
pure_binary = bin(num)[2:]  # &#x27;101010&#x27;（切片去前缀）</code></pre>

<p><strong><code>oct()</code></strong>: 十进制 → 八进制（前缀 <code>0o</code>）</p>
<pre><code class="hljs plaintext">octal = oct(42)[2:]      # &#x27;52&#x27;</code></pre>

<p><strong><code>hex()</code></strong>: 十进制 → 十六进制（前缀 <code>0x</code>，<strong>字母小写</strong>）</p>
<pre><code class="hljs plaintext">hex_str = hex(42)[2:]    # &#x27;2a&#x27;
hex_upper = hex(42)[2:].upper()  # &#x27;2A&#x27;（转大写）</code></pre>

<p><strong><code>int()</code></strong>: 其他进制 → 十进制（需<strong>指定源进制基数</strong>）</p>
<pre><code class="hljs plaintext">decimal = int(&#x27;101010&#x27;, 2)   # 二进制 → 十进制 → 42
decimal = int(&#x27;2A&#x27;, 16)       # 十六进制 → 42
decimal = int(&#x27;52&#x27;, 8)        # 八进制 → 42</code></pre>

<h1 id="sys模块调整递归深度"><a href="#sys模块调整递归深度" class="headerlink" title="sys模块调整递归深度"></a>sys模块调整递归深度</h1><p>Python 默认递归深度约 1000 层</p>
<pre><code class="hljs plaintext">import sys

# 获取当前递归深度限制
current_limit = sys.getrecursionlimit()
print(f&quot;当前递归深度限制: &#123;current_limit&#125;&quot;)

# 设置新的递归深度限制
sys.setrecursionlimit(10000)  # 提高到 10000 层

# 递归函数示例
def deep_recursion(n):
    if n &lt;= 0:
        return 0
    return deep_recursion(n-1) + 1

try:
    result = deep_recursion(5000)  # 尝试深度递归
except RecursionError as e:
    print(f&quot;递归错误: &#123;e&#125;&quot;)
    # 获取当前调用栈深度
    frames = sys._getframe()
    depth = 0
    while frames:
        depth += 1
        frames = frames.f_back
    print(f&quot;实际达到的递归深度: &#123;depth&#125;&quot;)</code></pre>

<p><code>sys._getframe()</code> ，它返回一个<strong>帧对象（frame object）</strong>，该对象代表了当前调用栈中的一个执行帧。</p>
<pre><code class="hljs plaintext">import sys

# 基本调用形式
frame = sys._getframe([depth])

​depth​ (可选参数)：指定要获取的栈帧深度
0：当前帧（默认值）
1：调用当前函数的帧
2：调用调用者的帧，依此类推</code></pre>

<pre><code class="hljs plaintext">f_back	指向调用者帧的引用	caller_frame = frame.f_back</code></pre>

<h1 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h1><p>在 Python 中实现定制排序主要依靠内置函数 <code>sorted()</code> 和列表方法 <code>list.sort()</code> 的 <code>key</code> 和 <code>reverse</code> 参数，结合自定义规则函数或 lambda 表达式。</p>
<pre><code class="hljs plaintext">fruits = [&#x27;banana&#x27;, &#x27;apple&#x27;, &#x27;grape&#x27;]
fruits.sort(key=len)  # 按长度排序</code></pre>

<pre><code class="hljs plaintext"># 按字符串长度排序
words = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]
sorted_words = sorted(words, key=len)  # 输出：[&#x27;apple&#x27;, &#x27;cherry&#x27;, &#x27;banana&#x27;][1,3]

# 按元组第二个元素排序
pairs = [(1, 3), (4, 1), (2, 5)]
sorted_pairs = sorted(pairs, key=lambda x: x[1])  # 输出：[(4, 1), (1, 3), (2, 5)][2,6]</code></pre>

<pre><code class="hljs plaintext"># 按学生年龄降序排序
students = [&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25&#125;, &#123;&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 20&#125;]
sorted_students = sorted(students, key=lambda s: s[&quot;age&quot;], reverse=True)
# 输出：[&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 25&#125;, &#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;age&#x27;: 20&#125;][8,10]</code></pre>

<p>多级排序（多个条件）：</p>
<p>先按年龄升序，年龄相同再按姓名升序。</p>
<pre><code class="hljs plaintext">students = [(&quot;Alice&quot;, 25), (&quot;Bob&quot;, 20), (&quot;Charlie&quot;, 25)]
sorted_students = sorted(students, key=lambda x: (x[1], x[0]))
# 输出：[(&#x27;Bob&#x27;, 20), (&#x27;Alice&#x27;, 25), (&#x27;Charlie&#x27;, 25)][5,8]</code></pre>

<p>使用 <code>functools.cmp_to_key</code> 实现传统比较函数</p>
<pre><code class="hljs plaintext">from functools import cmp_to_key

def compare(x, y):
    if x % 2 == y % 2:  # 奇偶性相同
        return x - y    # 数值升序
    elif x % 2 == 1:    # x为奇数则排前面
        return -1
    else:
        return 1

numbers = [3, 1, 2, 4]
sorted_numbers = sorted(numbers, key=cmp_to_key(compare))
# 输出：[1, 3, 2, 4]（奇数在前、升序）[2,6]</code></pre>

<pre><code class="hljs plaintext">from functools import cmp_to_key

def multi_sort(a, b):
    if a.score != b.score:
        return b.score - a.score  # 成绩降序
    return a.age - b.age         # 年龄升序

students.sort(key=cmp_to_key(multi_sort))</code></pre>

<p>如果要比较的对象是类的话，也可以选择在类中重写它的’&lt;’运算符，也就是<code>__lt__</code>方法：</p>
<pre><code class="hljs plaintext">class Task:
    def __init__(self, priority, desc):
        self.priority = priority
        self.desc = desc
    def __lt__(self, other):  # 定义比较规则
        return self.priority &lt; other.priority  # 数值小优先

heap = []
heap.append(Task(3, &quot;Low&quot;))
heap.append(Task(1, &quot;High&quot;))
heap.sort()
# 效果和使用lambda表达式的效果一样：heap.sort(key=lambda x: x.priority)
for item in heap:
    print(item.priority)</code></pre>

<h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><p>在模块顶层（函数、类外部）定义的变量自动成为全局变量，可在模块内任何地方访问。</p>
<pre><code class="hljs plaintext"># 模块顶层定义的全局变量
global_count = 0  # 可被模块内所有函数访问
MAX_ATTEMPTS = 3  # 通常用大写表示常量

def increment():
    global global_count  # 声明使用全局变量
    global_count += 1     # 修改全局变量

def get_count():
    return global_count   # 可直接读取

increment()
print(get_count())  # 输出: 1</code></pre>

<p>在函数内部要修改全局变量时，必须使用 <code>global</code> 关键字声明：</p>
<pre><code class="hljs plaintext">total = 0  # 全局变量

def add_values(a, b):
    global total  # 声明使用全局变量
    total = a + b  # 修改全局变量

add_values(5, 3)
print(total)  # 输出: 8</code></pre>

<p>如果不使用 <code>global</code>，Python 会创建一个同名的局部变量。</p>
<h1 id="functools"><a href="#functools" class="headerlink" title="functools"></a>functools</h1><p> <strong>reduce：累积计算</strong></p>
<p><strong>功能</strong>：对可迭代对象进行累积操作，返回单一结果。<br>​<strong>参数</strong>​：</p>
<ul>
<li><code>function</code>：二元操作函数（如<code>lambda x, y: x+y</code>）</li>
<li><code>iterable</code>：可迭代对象</li>
<li><code>initializer</code>：初始值（可选）</li>
</ul>
<pre><code class="hljs plaintext">from functools import reduce

# 计算阶乘（无初始值）
factorial = reduce(lambda x, y: x * y, range(1, 6))  # 120</code></pre>

<p><strong>cmp_to_key：兼容传统比较</strong></p>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><ol>
<li><p>abs(x)<br>功能：返回数值 x 的绝对值。</p>
</li>
<li><p>all(iterable)</p>
</li>
</ol>
<p>功能：如果给定的可迭代对象中所有元素都为真（或可迭代对象为空），则返回 True，否则返回 False。</p>
<ol start="3">
<li>any(iterable)</li>
</ol>
<p>功能：如果给定的可迭代对象中至少有一个元素为真，则返回 True，否则返回 False。</p>
<ol start="4">
<li>bin(x)</li>
</ol>
<p>功能：将整数 x 转换为二进制字符串。</p>
<p>5.chr(i)</p>
<p>功能：返回整数 i 对应的字符。</p>
<p>6.complex([real[, imag]])</p>
<p>功能：返回一个复数。</p>
<pre><code class="hljs plaintext">print(complex(2, 3))  # 输出 (2+3j)</code></pre>

<p>7、**<code>divmod(a, b)</code>**</p>
<p><strong>功能</strong>：返回除法的商和余数。</p>
<p>8、**<code>enumerate(iterable, start=0)</code>**</p>
<p><strong>功能</strong>：将一个可迭代对象组合为一个索引序列，返回 (index, value) 对。</p>
<pre><code class="hljs plaintext">for idx, val in enumerate([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]):    print(idx, val)
0 a
1 b
2 c</code></pre>

<p>9、**<code>eval(expression, globals=None, locals=None)</code>**</p>
<p><strong>功能</strong>：执行一个字符串表达式，并返回表达式的结果。</p>
<pre><code class="hljs plaintext">print(eval(&quot;3 + 5&quot;))  # 输出 8</code></pre>

<p>10、filter(function, iterable)<br>功能：筛选出可迭代对象中符合条件的元素。</p>
<pre><code class="hljs plaintext">print(list(filter(lambda x: x &gt; 0, [-1, 2, 3, -4])))  # 输出 [2, 3]</code></pre>

<p>11、float(x)<br>功能：将 x 转换为浮点数。</p>
<p>12、hash(x)<br>功能：返回对象 x 的哈希值。</p>
<p>13、**<code>hex(x)</code>**</p>
<p><strong>功能</strong>：将整数 <code>x</code> 转换为十六进制字符串</p>
<p>14、**<code>int(x, base=10)</code>**</p>
<p><strong>功能</strong>：将 <code>x</code> 转换为整数。</p>
<p>15、**<code>isinstance(obj, classinfo)</code>**</p>
<p><strong>功能</strong>：检查对象 <code>obj</code> 是否是 <code>classinfo</code> 类或其子类的实例。</p>
<pre><code class="hljs plaintext">print(isinstance(5, int))  # 输出 True</code></pre>

<p>16、**<code>iter(iterable)</code>**</p>
<p><strong>功能</strong>：返回一个迭代器。</p>
<pre><code class="hljs plaintext">it = iter([1, 2, 3])print(next(it))  # 输出 1</code></pre>

<p>17、**<code>max(iterable, \*[, key, default])</code>**</p>
<p><strong>功能</strong>：返回可迭代对象中的最大值。</p>
<pre><code class="hljs plaintext">print(max([1, 2, 3]))  # 输出 3</code></pre>

<p>18、**<code>min(iterable, \*[, key, default])</code>**</p>
<p><strong>功能</strong>：返回可迭代对象中的最小值。</p>
<p>19、**<code>next(iterator[, default])</code>**</p>
<p><strong>功能</strong>：返回迭代器的下一个元素。如果没有元素，返回 <code>default</code>。</p>
<p>20、**<code>oct(x)</code>**</p>
<p><strong>功能</strong>：将整数 <code>x</code> 转换为八进制字符串。</p>
<p>21、**<code>ord(c)</code>**</p>
<p><strong>功能</strong>：返回字符 <code>c</code> 的 Unicode 码。</p>
<p>22、**<code>pow(x, y[, z])</code>**</p>
<p><strong>功能</strong>：返回 <code>x</code> 的 <code>y</code> 次方。如果提供了 <code>z</code>，则返回 <code>x**y % z</code>。</p>
<p>23、**<code>print(\*objects, sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout)</code>**</p>
<p>24、**<code>reversed(seq)</code>**</p>
<p><strong>功能</strong>：返回一个反转的迭代器。</p>
<pre><code class="hljs plaintext">print(list(reversed([1, 2, 3])))  # 输出 [3, 2, 1]</code></pre>

<p>25、**<code>str([object])</code>**</p>
<p><strong>功能</strong>：将对象转换为字符串。</p>
<p>26、**<code>sum(iterable, /, start=0)</code>**</p>
<p><strong>功能</strong>：返回可迭代对象中所有元素的和，<code>start</code> 是初始值。</p>
<p>27、**<code>zip(\*iterables)</code>**</p>
<p><strong>功能</strong>：将多个可迭代对象“压缩”成一个元组的迭代器。</p>
<pre><code class="hljs plaintext">print(list(zip([1, 2], [&#x27;a&#x27;, &#x27;b&#x27;])))  # 输出 [(1, &#x27;a&#x27;), (2, &#x27;b&#x27;)]</code></pre>

<p>28、<img src="/../source/imgs/$%7Bfiilname%7D/image-20250724170051900.png" alt="image-20250724170051900"></p>
<p><code>set.pop()</code> 方法用于<strong>随机移除并返回集合中的一个元素</strong>，不传入参数。</p>
<p>29、<img src="/../source/imgs/$%7Bfiilname%7D/image-20250724170249487.png" alt="image-20250724170249487"></p>
<p>rfind()和rindex()</p>
<p>30、<img src="/../source/imgs/$%7Bfiilname%7D/image-20250724170405999.png" alt="image-20250724170405999"></p>
<p>31、<strong>sorted(Iterable, key&#x3D;函数(排序规则), reverse&#x3D;False)</strong></p>
<ul>
<li>Iterable: 可迭代对象</li>
<li>key: 排序规则(排序函数), 在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数. 根据函数运算的结果进行排序</li>
<li>reverse: 是否是倒序. True: 倒序, False: 正序</li>
</ul>
<h1 id="sys-stdin-readline"><a href="#sys-stdin-readline" class="headerlink" title="sys.stdin.readline()"></a>sys.stdin.readline()</h1><pre><code class="hljs plaintext">import sys
line = sys.stdin.readline()
n, pipe_len = map(int, line.split())
valves = []
for _ in range(n):
    valves.append(list(map(int, sys.stdin.readline().split())))
print(valves)
输入：
3 10
1 1
6 5
10 2
输出：
[[1, 1], [6, 5], [10, 2]]</code></pre>

<p>sys.stdin.readline()：从标准输入（stdin）读取一行数据，<strong>包含行尾换行符</strong> <code>\n</code></p>
<pre><code class="hljs plaintext">import sys
data = sys.stdin.readline()  # 输入&quot;Hello&quot; → 返回&quot;Hello\n&quot;</code></pre>

<p>需手动调用<code>.strip()</code>或<code>.rstrip(&#39;\n&#39;)</code>移除多余字符：</p>
<pre><code class="hljs plaintext">name = sys.stdin.readline().strip()  # 输入&quot;Alice\n&quot; → 返回&quot;Alice&quot;</code></pre>

<p><strong>循环逐行读</strong>：迭代处理大规模输入</p>
<pre><code class="hljs plaintext">for line in sys.stdin:
    processed_line = line.strip()</code></pre>

<p>高效读取大规模测试数据：</p>
<pre><code class="hljs plaintext">import sys
n = int(sys.stdin.readline().strip())  # 读取第一行（数据量）
data = [sys.stdin.readline().strip() for _ in range(n)]  # 读取后续n行</code></pre>

<h1 id="优先队列-heapq"><a href="#优先队列-heapq" class="headerlink" title="优先队列 heapq"></a>优先队列 heapq</h1><p>Python的<code>heapq</code>模块提供了基于列表的最小堆实现，常用于高效管理优先级队列。</p>
<p>数据结构：</p>
<p>实现<strong>最小堆</strong>（父节点值 ≤ 子节点值），堆顶元素（<code>heap[0]</code>）始终为最小值。</p>
<p>底层使用列表存储，通过下标关系维护堆结构：父节点索引为<code>(i-1)//2</code>，子节点为<code>2*i+1</code>和<code>2*i+2</code>。</p>
<p>常用方法：</p>
<p>heap &#x3D; []</p>
<table>
<thead>
<tr>
<th align="center"><strong>方法</strong></th>
<th align="center"><strong>功能</strong></th>
<th align="center"><strong>示例</strong></th>
<th align="center"><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>heappush(heap, item)</code></td>
<td align="center">插入元素并维护堆结构</td>
<td align="center"><code>heapq.heappush(heap, (2, &quot;task&quot;))</code></td>
<td align="center">动态添加元素到堆</td>
</tr>
<tr>
<td align="center"><code>heappop(heap)</code></td>
<td align="center">弹出堆顶最小元素</td>
<td align="center"><code>min_val = heapq.heappop(heap)</code></td>
<td align="center">获取并移除最小值</td>
</tr>
<tr>
<td align="center"><code>heapify(x)</code></td>
<td align="center">将列表原地转为堆</td>
<td align="center"><code>heapq.heapify([5, 1, 3]) # [1,5,3]</code></td>
<td align="center">初始化无序列表为堆</td>
</tr>
<tr>
<td align="center"><code>heappushpop(heap, item)</code></td>
<td align="center">插入后弹出最小值</td>
<td align="center"><code>min_val = heapq.heappushpop(heap, 4)</code></td>
<td align="center">组合操作（效率更高）</td>
</tr>
<tr>
<td align="center"><code>heapreplace(heap, item)</code></td>
<td align="center">弹出最小值后插入</td>
<td align="center"><code>min_val = heapq.heapreplace(heap, 4)</code></td>
<td align="center">更新堆顶元素</td>
</tr>
<tr>
<td align="center"><code>nlargest(n, iterable)</code></td>
<td align="center">返回前n个最大元素</td>
<td align="center"><code>heapq.nlargest(3, [4,1,7]) # [7,4,1]</code></td>
<td align="center">快速获取Top N大值</td>
</tr>
<tr>
<td align="center"><code>nsmallest(n, iterable)</code></td>
<td align="center">返回前n个最小元素</td>
<td align="center"><code>heapq.nsmallest(2, [4,1,7]) # [1,4]</code></td>
<td align="center">快速获取Top N小值</td>
</tr>
</tbody></table>
<p><code>nlargest</code>&#x2F;<code>nsmallest</code> 适合单次查询，频繁操作建议用堆维护。</p>
<p><code>heappushpop</code> 比先<code>push</code>再<code>pop</code>效率更高（减少一次堆调整）</p>
<p><code>heapq</code>可插入<strong>任意可比较对象</strong>。</p>
<p>添加的元素为基本数据类型（具有可比性）：</p>
<ul>
<li>数字（<code>int</code>、<code>float</code>）：按数值大小比较</li>
<li>字符串（<code>str</code>）：按字典序比较</li>
<li>布尔值（<code>bool</code>）：<code>False</code> &lt; <code>True</code></li>
</ul>
<p>添加的元素为<strong>元组（Tuple）</strong>：按元素顺序逐级比较（最常用）</p>
<pre><code class="hljs plaintext"># 元组 (优先级, 数据)
heapq.heappush(heap, (2, &#x27;task1&#x27;))  
heapq.heappush(heap, (1, &#x27;task2&#x27;))  # (1, ...) 优先级更高</code></pre>

<p><strong>实现自定义排序：</strong></p>
<p><strong>定义 <code>__lt__</code> 方法（推荐）</strong></p>
<p>在类中重写 <code>&lt;</code> 运算符，heapq 自动根据此方法比较</p>
<p><strong>方法<code>__lt__</code>返回的是boolean值，True是self排前面，False是other排前面。</strong></p>
<pre><code class="hljs plaintext">import heapq
class Task:
    def __init__(self, priority, desc):
        self.priority = priority
        self.desc = desc
    def __lt__(self, other):  # 定义比较规则
        return self.priority &lt; other.priority  # 数值小优先

heap = []
heapq.heappush(heap, Task(3, &quot;Low&quot;))
heapq.heappush(heap, Task(1, &quot;High&quot;))
print(heapq.heappop(heap).desc)  # 输出：&quot;High&quot;</code></pre>

<p><strong>自定义类优先队列</strong></p>
<pre><code class="hljs plaintext">import heapq

class Job:
    def __init__(self, name, urgency):
        self.name = name
        self.urgency = urgency  # 1-10，值越小越紧急
    def __lt__(self, other):
        return self.urgency &lt; other.urgency

# 创建堆并操作
jobs = []
heapq.heappush(jobs, Job(&quot;Fix Bug&quot;, 2))
heapq.heappush(jobs, Job(&quot;Write Docs&quot;, 5))
heapq.heappush(jobs, Job(&quot;Deploy&quot;, 1))

while jobs:
    job = heapq.heappop(jobs)
    print(f&quot;[Urgency &#123;job.urgency&#125;] &#123;job.name&#125;&quot;)
# 输出：
# [Urgency 1] Deploy
# [Urgency 2] Fix Bug
# [Urgency 5] Write Docs</code></pre>

<p>元素本身可以是可变对象（如列表、自定义类实例），但<strong>禁止在堆内直接修改影响排序的关键属性</strong>（如优先级）。</p>
<p>若需更新优先级，先移除旧元素 → 修改 → 重新插入</p>
<p><strong>利用heapq实现最大堆</strong></p>
<p>直接使用 <code>heapq.nlargest()</code> 获取前 K 个最大值，无需维护堆结构。</p>
<pre><code class="hljs plaintext">import heapq

data = [5, 7, 9, 4, 3]

# 获取前 K 个最大值
top_k = heapq.nlargest(3, data)  # [9, 7, 5]
print(top_k) 

# 获取最大值
max_val = heapq.nlargest(1, data)[0]  # 9</code></pre>

<p>插入时取负数，取出时再取负还原。</p>
<pre><code class="hljs plaintext">import heapq

# 创建最大堆
max_heap = []
data = [5, 7, 9, 4, 3]

# 插入元素（取负）
for num in data:
    heapq.heappush(max_heap, -num)  # 存入：[-9, -7, -5, -4, -3]

# 弹出最大值
max_val = -heapq.heappop(max_heap)  # 取出：9 → 堆变为[-7, -5, -4, -3]
print(max_val)  # 输出：9

# 查看堆顶（不弹出）
peek = -max_heap[0]  # 当前最大值：7</code></pre>

<p>适用于数值型数据（整数、浮点数），非数值类型（如字符串）需转换为数值或封装元组(-priority, data)处理。</p>
<p>重写 <code>__lt__</code> 方法反转比较逻辑，使对象在堆中“大值”被视为“小值”，建一个新类。</p>
<pre><code class="hljs plaintext">import heapq

class MaxHeapObj:
    def __init__(self, val):
        self.val = val
    def __lt__(self, other):
        return self.val &gt; other.val  # 反转比较规则
    def __repr__(self):
        return str(self.val)

# 封装对象
max_heap = []
data = [5, 7, 9, 4, 3]
for num in data:
    heapq.heappush(max_heap, MaxHeapObj(num))

# 弹出最大值
max_obj = heapq.heappop(max_heap).val  # 9
print(max_obj)</code></pre>

<p>适用于复杂对象（需自定义比较规则），需保留原始数据的场景（避免取负导致混淆）。</p>
<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><pre><code class="hljs plaintext">class BitArray:
    def __init__(self, num_bits):
        # 每个整数元素用于存储 32 位
        self.bits_per_element = 32
        # 计算所需的整数数量
        self.array_size = (num_bits + self.bits_per_element - 1) // self.bits_per_element
        # 初始化全零数组
        self.arr = [0] * self.array_size
        # 存储实际位数
        self.num_bits = num_bits
    
    def get_bit(self, i):
        &quot;&quot;&quot;获取指定位置（i）的位状态（0或1）&quot;&quot;&quot;
        if not 0 &lt;= i &lt; self.num_bits:
            raise IndexError(f&quot;位索引超出范围: &#123;i&#125;&quot;)
        
        # 计算整数索引和位索引
        num_index = i // self.bits_per_element
        bit_index = i % self.bits_per_element
        
        # 获取位状态
        return (self.arr[num_index] &gt;&gt; bit_index) &amp; 1
    
    def set_bit(self, i, value=1):
        &quot;&quot;&quot;设置指定位置（i）的位状态为 1 或 0&quot;&quot;&quot;
        if not 0 &lt;= i &lt; self.num_bits:
            raise IndexError(f&quot;位索引超出范围: &#123;i&#125;&quot;)
        
        num_index = i // self.bits_per_element
        bit_index = i % self.bits_per_element
        
        if value == 1:
            # 设置为 1：使用位或操作
            self.arr[num_index] |= (1 &lt;&lt; bit_index)
        elif value == 0:
            # 设置为 0：使用位与操作配合掩码
            self.arr[num_index] &amp;= ~(1 &lt;&lt; bit_index)
        else:
            raise ValueError(&quot;值必须是 0 或 1&quot;)
    
    def __str__(self):
        &quot;&quot;&quot;以二进制字符串形式显示位数组状态&quot;&quot;&quot;
        # 为每个整数创建 32 位的二进制字符串
        # 并连接所有位（只显示实际的 num_bits 位）
        all_bits = &#x27;&#x27;.join(f&quot;&#123;x:032b&#125;&quot; for x in self.arr)
        return all_bits[:self.num_bits]

if __name__ == &quot;__main__&quot;:
    # 使用示例：参考图片中的 Java 代码逻辑
    num_bits = 200  # 假设总位数大于178
    bit_array = BitArray(num_bits)
    
    # 测试案例1：获取和设置第178位
    print(f&quot;第178位的初始状态: &#123;bit_array.get_bit(178)&#125;&quot;)
    
    # 将178位设置为1
    bit_array.set_bit(178, 1)
    print(f&quot;将178位设置为1后的状态: &#123;bit_array.get_bit(178)&#125;&quot;)
    
    # 将178位设置为0
    bit_array.set_bit(178, 0)
    print(f&quot;将178位设置为0后的状态: &#123;bit_array.get_bit(178)&#125;&quot;)
    
    # 测试输出完整位状态
    print(&quot;\n完整位状态:&quot;)
    print(bit_array)
    
    # 测试错误处理
    try:
        bit_array.set_bit(300)  # 超出范围
    except IndexError as e:
        print(f&quot;\n错误测试: &#123;e&#125;&quot;)</code></pre>

<h1 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h1><p>Python的<code>bisect</code>模块是一个基于二分查找算法的标准库模块，专门用于在<strong>已排序的列表</strong>中高效地查找、插入元素，并保持列表的有序性。其核心优势是通过二分查找（时间复杂度O(log n)）替代线性操作（O(n)），显著提升大规模数据处理的效率。</p>
<p>插入新元素时直接将其放置在正确位置，无需调用<code>sort()</code>重新排序。</p>
<p>查找元素：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">功能描述</th>
<th align="center">示例（输入列表<code>a = [1, 3, 4, 4, 6]</code>）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>bisect_left(a, x)</code></td>
<td align="center">返回第一个<strong>大于或等于</strong><code>x</code>的元素的索引（重复时靠左）</td>
<td align="center"><code>bisect_left(a, 4)</code> → <code>2</code></td>
</tr>
<tr>
<td align="center"><code>bisect_right(a, x)</code></td>
<td align="center">返回第一个<strong>大于</strong><code>x</code>的元素的索引（重复时靠右）</td>
<td align="center"><code>bisect_right(a, 4)</code> → <code>4</code></td>
</tr>
<tr>
<td align="center"><code>bisect()</code>（别名：<code>bisect_right</code>）</td>
<td align="center">与<code>bisect_right</code>功能相同，推荐使用更明确的命名</td>
<td align="center"><code>bisect(a, 4)</code> → <code>4</code></td>
</tr>
</tbody></table>
<p>插入元素：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">功能描述</th>
<th align="center">示例（输入列表<code>a = [1, 3, 4, 6]</code>）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>insort_left(a, x)</code></td>
<td align="center">将<code>x</code>插入到第一个<strong>大于或等于</strong><code>x</code>的位置（重复时靠左）</td>
<td align="center"><code>insort_left(a, 4)</code> → <code>[1, 3, 4, 4, 6]</code></td>
</tr>
<tr>
<td align="center"><code>insort_right(a, x)</code></td>
<td align="center">将<code>x</code>插入到第一个<strong>大于</strong><code>x</code>的位置（重复时靠右）</td>
<td align="center"><code>insort_right(a, 4)</code> → <code>[1, 3, 4, 4, 4, 6]</code></td>
</tr>
<tr>
<td align="center"><code>insort()</code>（别名：<code>insort_right</code>）</td>
<td align="center">与<code>insort_right</code>功能相同，默认使用此方法</td>
<td align="center"><code>insort(a, 5)</code> → <code>[1, 3, 4, 5, 6]</code></td>
</tr>
</tbody></table>
<p>也可以用于自定义的类元素：</p>
<pre><code class="hljs plaintext">import bisect
class Task:
    def __init__(self, priority, desc):
        self.priority = priority
        self.desc = desc
    def __lt__(self, other):  # 定义比较规则
        return self.priority &lt; other.priority # 数值小优先

heap = []
heap.append(Task(3, &quot;Low&quot;))
heap.append(Task(1, &quot;High&quot;))
heap.sort()
for item in heap:
    print(item.priority)
bisect.insort(heap,Task(2, &#x27;Middle&#x27;))
for item in heap:
    print(item.priority)</code></pre>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-机器学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="article-date">
  	<time datetime="2025-05-08T12:23:38.000Z" itemprop="datePublished">2025-05-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">
        机器学习
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="机器学习是什么"><a href="#机器学习是什么" class="headerlink" title="机器学习是什么"></a>机器学习是什么</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/3de7ec9ae75d52a8b074555bcefbc9fe_.jpg" alt="3de7ec9ae75d52a8b074555bcefbc9fe_"></p>
<p>目前存在几种不同类型的学习算法。主要的两种类型被我们称之为监督学习和无监督学习。监督学习这个想法是指，我们将教计算机如何去完成任务，而在无监督学习中，我们打算让它自己进行学习。</p>
<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习指的就是我们给学习算法一个数据集，这个数据集由“正确答案”组成。在房价的例子中，我们给了一系列房子的数据，我们给定数据集中每个样本的正确价格，即它们实际的售价然后运用学习算法，算出更多的正确答案。</p>
<p><strong>回归问题</strong>：试着推测出一个连续值的结果。下面的房子例子就是回归问题，要推测的结果就是房子的价格。</p>
<img src="../source/imgs/${fiilname}/67f278633b69c123d1c93d555408016.jpg" alt="67f278633b69c123d1c93d555408016" style="zoom:67%;" />

<p>回归这个词的意思是，我们在试着推测出这一系列连续值属性。</p>
<p><strong>分类问题</strong>，分类指的是，我们试着推测出<strong>离散的输出值</strong>：0或1，良性或恶性。感觉就是判断给出的数据属于哪一类。</p>
<img src="../source/imgs/${fiilname}/d7af2031bf79a5b02eeedb033358c4d.jpg" alt="d7af2031bf79a5b02eeedb033358c4d" style="zoom:67%;" />

<p>在这个例子中只有一个特征，就是肿瘤的尺寸，在其它一些机器学习问题中，可能会遇到不止一种特征。举个例子，我们不仅知道肿瘤的尺寸，还知道对应患者的年龄。在其他机器学习问题中，通常有更多的特征，比如肿块密度，肿瘤细胞尺寸的一致性和形状的一致性等等，还有一些其他的特征。之后会讲一个算法，叫支持向量机，里面有一个巧妙的数学技巧，能让计算机处理无限多个特征。</p>
<p>回归问题和分类问题都属于监督学习，其基本思想是，数据集中的每个样本都有相应的“正确答案”，再根据这些样本作出预测，就像房子和肿瘤的例子中做的那样。回归问题，即通过回归来推出一个连续的输出；分类问题，其目标是推出一组离散的结果。</p>
<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>不同于监督学习的数据的样子，即无监督学习中没有任何的标签或者是有相同的标签或者就是没标签。所以我们已知数据集，却不知如何处理，也未告知每个数据点是什么，任何信息都不知道，只知道是一个数据集。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/a4588fb01a01f7e1fb17e6c89241650.jpg" alt="a4588fb01a01f7e1fb17e6c89241650"></p>
<p>这个图是上面肿瘤的例子，⭕代表良性，❌代表恶性，在监督学习中有这种标志说明是什么情况，但在无监督学习中没有标志，只是数据。</p>
<p>针对数据集，无监督学习能判断出数据有两个不同的聚集簇。这是一个，那是另一个，二者不同。是的，无监督学习算法可能会把这些数据分成两个不同的簇，这个就叫做聚类算法。</p>
<img src="../source/imgs/${fiilname}/46a41b85419ef28ecb55b469f6c7c89.jpg" alt="46a41b85419ef28ecb55b469f6c7c89" style="zoom:67%;" />

<p>无监督学习就是我们没法提前告知算法一些信息。</p>
<p>就是这里是有一堆数据，我不知道数据里面有什么，我不知道谁是什么类型，我甚至不知道人们有哪些不同的类型，这些类型又是什么。但你能自动地找到数据中的结构吗？就是说你要自动地聚类那些个体到各个类，我没法提前知道哪些是哪些。因为我们没有给算法正确答案来回应数据集中的数据，所以这就是无监督学习。</p>
<p>上面的都是<strong>聚类</strong>的例子，聚类只是无监督学习的一种。</p>
<p>接下来介绍的鸡尾酒宴问题属于无监督学习中的<strong>盲源分离</strong>问题。</p>
<p>可能在一个这样的鸡尾酒宴中的两个人，他俩同时都在说话，假设现在是在个有些小的鸡尾酒宴中。我们放两个麦克风在房间中，因为这些麦克风在两个地方，离说话人的距离不同每个麦克风记录下不同的声音，虽然是同样的两个说话人。听起来像是两份录音被叠加到一起，或是被归结到一起，产生了我们现在的这些录音。另外，这个算法还会区分出两个音频资源，这两个可以合成或合并成之前的录音，实际上，鸡尾酒算法的第一个输出结果是：</p>
<p>1，2，3，4，5，6，7，8，9，10,</p>
<p>第二个输出是这样：</p>
<p>1，2，3，4，5，6，7，8，9，10。</p>
<p>第一个输出代表分离出的第一个声源，第二个输出代表分离出的第二个声源。</p>
<p>这里的数字序列可能是对分离后信号的简化表示。实际应用中，输出是时间序列信号（如音频波形），每个数字可能代表某个时间点的信号强度或特征。无需去深度思考。</p>
<h1 id="单变量线性回归"><a href="#单变量线性回归" class="headerlink" title="单变量线性回归"></a>单变量线性回归</h1><h2 id="模型表示"><a href="#模型表示" class="headerlink" title="模型表示"></a>模型表示</h2><p>监督学习的第一个例子。预测住房价格的，我们要使用一个数据集，数据集包含俄勒冈州波特兰市的住房价格。在这里，我要根据不同房屋尺寸所售出的价格，画出我的数据集。比方说，如果你朋友的房子是1250平方尺大小，你要告诉他们这房子能卖多少钱。	</p>
<p>它被称作监督学习是因为对于每个数据来说，我们给出了“正确的答案”，即告诉我们：根据我们的数据来说，房子实际的价格是多少，而且，更具体来说，这是一个回归问题。回归一词指的是，我们根据之前的数据预测出一个准确的输出值，对于这个例子就是价格。</p>
<p><strong>在监督学习中我们有一个数据集，这个数据集被称训练集。</strong></p>
<p><strong>在整个课程中用小写的m来表示训练样本的数目。</strong></p>
<p>假如上面房子的回归问题的训练集（<strong>Training Set</strong>）如下表所示：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250508215836945.png" alt="image-20250508215836945"></p>
<img src="../source/imgs/${fiilname}/image-20250508215909094.png" alt="image-20250508215909094" style="zoom:40%;" />

<p>将训练集“喂”给我们的学习算法，进而学习得到一个假设h，然后将我们要预测的房屋的尺寸作为输入变量输入给h，预测出该房屋的交易价格作为输出变量输出为结果。</p>
<p>h表示的是一个函数，由学习算法根据训练集输出，输入是房屋尺寸大小，输出的是房子价格。</p>
<p>h的一种可能表达方式为：<br>$$<br>h_θ (x)&#x3D;θ_0+θ_1 x<br>$$<br>因为只含有<strong>一个特征&#x2F;输入变量</strong>，因此这样的问题叫作单变量线性回归问题。</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520100402742.png" alt="image-20250520100402742"></p>
<p>有一个像这样的训练集， 𝑚代表了训练样本的数量，比如 𝑚 &#x3D; 47。而我们的假设函数，也就是用来进行预测的函数，是这样的线性函数形式<br>$$<br>h_θ (x)&#x3D;θ_0+θ_1 x<br>$$<br>接下来为我们的模型选择合适的<strong>参数</strong>（ parameters） 𝜃0 和 𝜃1，在房价问题这个例子中便是直线的斜率和在𝑦 轴上的截距。  我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的<strong>差距</strong>（下图中蓝线所指）就是<strong>建模误差</strong>（ modeling error）。  <img src="/../source/imgs/$%7Bfiilname%7D/image-20250520101109903.png" alt="image-20250520101109903">目标便是选择出可以使得建模误差的平方和能够最小的模型参数， 即使得代价函数<img src="../source/imgs/${fiilname}/image-20250520101757329.png" alt="image-20250520101757329" style="zoom:50%;" />最小。</p>
<p>绘制一个等高线图，三个坐标分别为𝜃0和𝜃1 和𝐽(𝜃0, 𝜃1)：  <img src="../source/imgs/${fiilname}/image-20250520101905831.png" alt="image-20250520101905831" style="zoom:33%;" />可以看出在三维空间中存在一个使得𝐽(𝜃0, 𝜃1)最小的点。  </p>
<p>代价函数也被称作平方误差函数，有时也被称为平方误差代价函数，代价函数是解决回归问题最常用的手段。</p>
<h2 id="代价函数的直观理解"><a href="#代价函数的直观理解" class="headerlink" title="代价函数的直观理解"></a>代价函数的直观理解</h2><p>代价函数是用来干嘛的，我们为什么要用它。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520102928659.png" alt="image-20250520102928659"></p>
<p>为了便于理解，使𝜃0&#x3D;0。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520103215675.png" alt="image-20250520103215675"></p>
<p>yi代表的是训练集中的数据。h𝜃的参数是x，J的参数是𝜃1。上图可以看出当𝜃1&#x3D;1时，代价函数J&#x3D;0。</p>
<p>接下来时当𝜃1&#x3D;0.5时：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250520104130361.png" alt="image-20250520104130361"></p>
<p>等于1时：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520104249847.png" alt="image-20250520104249847"></p>
<p>对于每个𝜃1的值，都对应着一个假设函数的值或者一条直线，并且根据每个不同的𝜃1，我们都可以得到一个不同的J(𝜃1)的值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520104644091.png" alt="image-20250520104644091"></p>
<h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>梯度下降是一个用来求函数最小值的算法，我们将使用梯度下降算法来求出代价函数𝐽(𝜃0, 𝜃1) 的最小值。  </p>
<p>梯度下降背后的思想是：开始时我们随机选择一个参数的组合(𝜃0, 𝜃1, . . . . . . , 𝜃𝑛)，计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到到到一个局部最小值，因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值，选择不同的初始参数组合，可能会找到不同的局部最小值。  </p>
<p>这个算法是怎么工作的，可以这样想：想象一下你正站立在山的一点上，  在梯度下降算法中，我们要做的就是旋转 360 度，看看我们的周围哪个方向可以最快下山。来到山坡上，我们站在山坡上的一点，你看一下周围，你会发现最佳的下山方向，你再看看周围，然后再一次想想，我应该从什么方向下山？然后你按照自己的判断又迈出一步，重复上面的步骤，从这个新的点，你环顾四周，并决定从什么方向将会最快下山，然后又迈进了一小步，并依此类推，直到你接近局部最低点的位置。</p>
<p>批量梯度下降算法的公式为：  <img src="../source/imgs/${fiilname}/image-20250520110754153.png" alt="image-20250520110754153" style="zoom:50%;" /></p>
<p>上面那行英语的意思是，反复用这个公式直到收敛。其中𝑎是学习率，它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大，在批量梯度下降中，我们每一次都同时让所有的参数减去学习速率乘以代价函数的导数。  </p>
<p>符号<code>:=</code>的意思是赋值，这是一个赋值运算符。单独的<code>=</code>代表的是比较运算符。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520145329030.png" alt="image-20250520145329030"></p>
<p>梯度下降中，我们要同时更新𝜃0和𝜃1，当 𝑗 &#x3D; 0 和𝑗 &#x3D; 1时，会产生更新，所以你将更新𝐽(𝜃0)和𝐽(𝜃1)。  记住，要<strong>同时更新</strong>，不能先更新一个再更新另一个，先更新其中一个的话会导致接下来算出的微分项的值出现变换，因为其中一个值变了。</p>
<h2 id="梯度下降的直观理解"><a href="#梯度下降的直观理解" class="headerlink" title="梯度下降的直观理解"></a>梯度下降的直观理解</h2><p>梯度下降算法：<img src="../source/imgs/${fiilname}/image-20250520150117798.png" alt="image-20250520150117798" style="zoom:50%;" />，描述：对𝜃赋值，使得𝐽(𝜃)按梯度下降最快方向进行，一直迭代下去，最终得到局部最小值。其中𝑎是学习率，它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。  </p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520150210495.png" alt="image-20250520150210495"></p>
<p>求导的目的，基本上可以说取这个红点的切线，  现在，这条线有一个正斜率，也就是说它有正导数，因此，我得到的新的𝜃1， 𝜃1更新后等于𝜃1减去一个正数乘以𝑎。  </p>
<p>如果𝑎太小或𝑎太大会出现什么情况：  </p>
<p>如果𝑎太小了，即我的学习速率太小，结果就是只能这样像小宝宝一样一点点地挪动，去努力接近最低点，这样就需要很多步才能到达最低点，所以如果𝑎太小的话，可能会很慢，因为它会一点点挪动，它会需要很多步才能到达全局最低点。</p>
<p>如果𝑎太大，那么梯度下降法可能会越过最低点，甚至可能无法收敛，下一次迭代又移动了一大步，越过一次，又越过一次，一次次越过最低点，直到你发现实际上离最低点越来越远，所以，如果𝑎太大，它会导致无法收敛，甚至发散。  </p>
<p>假设将𝜃1初始化在局部最低点，因为它已经在一个局部的最优处或局部最低点，结果是局部最优点的导数将等于零，使得𝜃1不再改变，因此，如果你的参数已经处于局部最低点，那么梯度下降法更新其实什么都没做，它不会改变参数的值。这也解释了为什么即使学习速率𝑎保持不变时，梯度下降也可以收敛到局部最低点。  </p>
<p>在梯度下降法中，当我们接近局部最低点时，梯度下降法会自动采取更小的幅度，这是因为当我们接近局部最低点时，很显然在局部最低时导数等于零，所以当我们接近局部最低时，导数值会自动变得越来越小，所以梯度下降将自动采取较小的幅度，这就是梯度下降的做法。所以实际上没有必要再另外减小𝑎。  </p>
<p>可以用梯度下降算法来最小化任何代价函数𝐽，不只是线性回归中的代价函数𝐽。  </p>
<h2 id="梯度下降的线性回归"><a href="#梯度下降的线性回归" class="headerlink" title="梯度下降的线性回归"></a>梯度下降的线性回归</h2><p>用梯度下降算法，并将其应用于具体的拟合直线的线性回归算法里。  </p>
<p>先计算微分项：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520151937828.png" alt="image-20250520151937828"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520152054863.png" alt="image-20250520152054863"></p>
<p>所以，算法会被改写为：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520152212561.png" alt="image-20250520152212561"></p>
<p>不断重复，直到收敛。记住，𝜃0和𝜃1要同时更新。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520152415146.png" alt="image-20250520152415146"></p>
<p>使用梯度下降算法是因为它更容易到达局部最小值，而根据初始化的不同，会得到不同的局部最优解。但是，事实证明，用于线性回归的代价函数总是一个弓形样子的函数，叫作凸函数，这种函数没有局部最优解，只有一个全局最优解。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520152728280.png" alt="image-20250520152728280"></p>
<p>一般来说初始化参数的时候都设为0。</p>
<p>刚刚使用的算法，有时也称为批量梯度下降。  ”批量梯度下降”，指的是在梯度下降的每一步中，我们都用到了所有的训练样本，在梯度下降中，在计算微分求导项时，我们需要进行求和运算，所以，在每一个单独的梯度下降中，我们最终都要计算这样一个东西，这个项需要对所有𝑚个训练样本求和。  </p>
<h1 id="多变量线性回归"><a href="#多变量线性回归" class="headerlink" title="多变量线性回归"></a>多变量线性回归</h1><h2 id="多维特征"><a href="#多维特征" class="headerlink" title="多维特征"></a>多维特征</h2><p>对房价模型增加更多的特征，例如房间数楼层等，构成一个含有多个变量的模型，模型中的特征为(𝑥1, 𝑥1, . . . , 𝑥𝑛)。  </p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250705112627927.png" alt="image-20250705112627927"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250705112649877.png" alt="image-20250705112649877"></p>
<p>这上面的公式是𝜃TX的原因是上面的X(2)是一列，形状是[4,1]，jupyter里面的数据的形状是[1,4]，所以里面的公式是X𝜃T，具体的情况要具体分析，记住基本公式，参数乘以变量。</p>
<h2 id="多变量梯度下降"><a href="#多变量梯度下降" class="headerlink" title="多变量梯度下降"></a>多变量梯度下降</h2><p>在多变量线性回归中的代价函数，这个代价函数是所有建模误差的平方和，即： <img src="../source/imgs/${fiilname}/image-20250705145029436.png" alt="image-20250705145029436" style="zoom:50%;" />，其中<br>$$<br>h_θ (x)&#x3D;θ^T X&#x3D;θ_0+θ_1 x_1+θ_2 x_2+…+θ_n x_n<br>$$<br>多变量线性回归的批量梯度下降算法为：<img src="../source/imgs/${fiilname}/image-20250705145632954.png" alt="image-20250705145632954" style="zoom:80%;" /></p>
<p>即<img src="../source/imgs/${fiilname}/image-20250705145701988.png" alt="image-20250705145701988" style="zoom:80%;" />，求导得：<img src="../source/imgs/${fiilname}/image-20250705145729471.png" alt="image-20250705145729471" style="zoom:80%;" /></p>
<p>跟前面单变量的公式没有什么大变化，就是求导后需要计算的变多了。</p>
<p>计算代价函数的代码如下：</p>
<pre><code class="hljs plaintext">def computeCost(X, y, theta):
    inner = np.power(((X * theta.T) - y), 2)
    return np.sum(inner) / (2 * len(X))</code></pre>

<h2 id="梯度下降法实践-1-特征缩放"><a href="#梯度下降法实践-1-特征缩放" class="headerlink" title="梯度下降法实践 1-特征缩放"></a>梯度下降法实践 1-特征缩放</h2><p>在我们面对多维特征问题的时候，我们要保证这些特征都具有<strong>相近的尺度</strong>，这将帮助梯度下降算法更快地收敛。</p>
<p>以房价问题为例，假设我们使用两个特征，房屋的尺寸和房间的数量，尺寸的值为 0- 2000 平方英尺，而房间数量的值则是 0-5，以两个参数分别为横纵坐标，绘制<strong>代价函数</strong>的等高线图（在这里先忽略𝜃0），<img src="../source/imgs/${fiilname}/image-20250705151217067.png" alt="image-20250705151217067" style="zoom:50%;" /></p>
<p>能看出图像会显得很扁，梯度下降算法需要非常多次的迭代才能收敛。</p>
<p>解决的方法是尝试将所有特征的尺度都尽量缩放到**-1 到 1** 之间。 ，这也是在做特征缩放时的通常目的，但其实并不严格要求必须是-1到1，在这些附近都可以，重点是将范围靠近-1到1。所以，如果有一个特征也就是变量的范围是-0.0001到0.0001的话，得对其进行扩展。一般在-3到3，-1&#x2F;3到1&#x2F;3都是可以的。</p>
<p>除了将特征除以它的最大值外，还可以进行一种叫作均值归一化的工作，包括：</p>
<p>1、将原来的变量值减去平均值除以（最大值-最小值），一般用这个就足够了</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/3f7dac1d8c77ee704aca91562a78b88.jpg" alt="3f7dac1d8c77ee704aca91562a78b88"></p>
<p>2、<br>$$<br>x_n&#x3D;(x_n-μ_n)&#x2F;s_n，其中 μ_n是平均值，s_n是标准差。<br>$$</p>
<h2 id="梯度下降法实践-2-学习率"><a href="#梯度下降法实践-2-学习率" class="headerlink" title="梯度下降法实践 2-学习率"></a>梯度下降法实践 2-学习率</h2><p>如何确定梯度下降算法在正常工作，画图表：</p>
<img src="../source/imgs/${fiilname}/image-20250706210423707.png" alt="image-20250706210423707" style="zoom:80%;" />

<p>梯度下降算法的每次迭代受到学习率的影响，如果学习率𝑎过小，则达到收敛所需的迭代次数会非常高；如果学习率𝑎过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。</p>
<p>通常可以考虑尝试些学习率：𝛼 &#x3D; 0.01， 0.03， 0.1， 0.3， 1， 3， 10</p>
<h2 id="特征和多项式回归"><a href="#特征和多项式回归" class="headerlink" title="特征和多项式回归"></a>特征和多项式回归</h2><p>多项式回归，可以使用线性回归的方式来拟合非常复杂的函数，或者是非线性函数。</p>
<p>以预测房价模型为例（在线性回归模型中你可以选择提供的特征作为特征，也可以选择自己创建一个新的特征，哎下面的例子中，题目给了临街宽度和纵深两个特征，我们也可以自己创建一个特征——面积，这样子可以简化线性回归模型，得到一个更好的模型）：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250706211418121.png" alt="image-20250706211418121"></p>
<p>线性回归并不适用于所有数据，有时我们需要曲线来适应我们的数据，二次方或者三次方模型：<br>$$<br>h_θ (x)&#x3D;θ_0+θ_1 x_1+θ_2 x_2^2，h_θ (x)&#x3D;θ_0+θ_1 x_1+θ_2 x_2^2+θ_3 x_3^3<br>$$<br>另外，我们可以令<br>$$<br>𝑥_2 &#x3D; 𝑥_2^2, 𝑥_3 &#x3D; 𝑥_3^3<br>$$<br>，从而将模型转化为线性回归模型，由于次方的存在导致参数范围被扩大了很多，所以在运行梯度下降算法前，必须进行<strong>特征缩放</strong>。除了上面给出的这一种，还有一种是开平方：<br>$$<br>h_θ (x)&#x3D;θ_0+θ_1 (size)+θ_2 \sqrt{size}<br>$$<br>通过不同的参数形式，最后的曲线也会有所不同。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250706212254715.png" alt="image-20250706212254715"></p>
<h2 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h2><p>到目前为止，我们都在使用梯度下降算法，但是对于某些线性回归问题，正规方程方法是更好的解决方案。如：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250706214657023.png" alt="image-20250706214657023"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250706214739079.png" alt="image-20250706214739079"></p>
<p>运用正规方程方法求解参数：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250706214804481.png" alt="image-20250706214804481"></p>
<p>对于那些<strong>不可逆的矩阵</strong>（通常是因为特征之间不独立，如同时包含英尺为单位的尺寸和米为单位的尺寸两个特征，也有可能是特征数量大于训练集的数量），正规方程方法是<strong>不能用</strong>的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250706214841139.png" alt="image-20250706214841139"></p>
<p>只要特征变量的数目并不大，标准方程是一个很好的计算参数𝜃的替代方法。具体地说，只要特征变量数量小于一万，通常使用标准方程法，而不使用梯度下降法。  </p>
<pre><code class="hljs plaintext">import numpy as np
def normalEqn(X, y):
	theta = np.linalg.inv(X.T@X)@X.T@y # X.T@X 等价于 X.T.dot(X)，X是ndarray数组
	return theta</code></pre>

<p>注意，这里返回的theta不是一个数，而是一个元组。</p>
<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p>在分类问题中，要预测的变量y是离散的值。  </p>
<p>在分类问题中，我们尝试预测的是结果是否属于某一个类（例如正确或错误），从二元的分类问题开始。</p>
<p>我们将因变量可能属于的两个类分别称为负向类和正向类，则因变量 y&#x3D;0或1 ，其中 0 表示负向类，1 表示正向类。</p>
<p>逻辑回归算法的性质是：它的输出值永远在 0 到 1 之间。  逻辑回归算法是一个分类算法，适用于y取离散的值的情况下。</p>
<h2 id="假说表示"><a href="#假说表示" class="headerlink" title="假说表示"></a>假说表示</h2><p>为什么线性回归算法不适用于分类问题？</p>
<p>根据线性回归模型我们只能预测连续的值，然而对于分类问题（例子是肿瘤分类），我们需要输出0或1，我们可以预测：<br>$$<br>当h_θ (x)&gt;&#x3D;0.5时，预测 y&#x3D;1。<br>当h_θ (x)&lt;0.5时，预测 y&#x3D;0 。<br>$$<br>没有极端数据出现的时候使用线性回归算法看着也可以，但一旦极端数据出现，整体的判断标准就会被破坏。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250707095415565.png" alt="image-20250707095415565"></p>
<p>有极端数据出现：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250707095442011.png" alt="image-20250707095442011"></p>
<p>所以线性回归模型并不适用于分类问题。</p>
<p>逻辑回归模型的假设是：<br>$$<br>h_θ(x)&#x3D;g(θ^T X)其中：X 代表特征向量，g代表逻辑函数是一个常用的逻辑函数，S形函数，公式为： g(z)&#x3D;\frac{1}{1+e^{-z} }。<br>$$<br>θT*X，这个就是<strong>线性回归模型的结果</strong>（这里的参数向量θ是n行1列的，X的数据是一列一列的），所以逻辑回归模型是对线性回归模型的值进行处理。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250707100936257.png" alt="image-20250707100936257"></p>
<pre><code class="hljs plaintext">import numpy as np
def sigmoid(z):
	return 1 / (1 + np.exp(-z))</code></pre>

<p>ℎ𝜃(𝑥)的意思是，对于给定的输入变量，根据选择的参数计算输出变量&#x3D;1 的可能性。如果对于给定的𝑥，通过已经确定的参数计算得出ℎ𝜃(𝑥) &#x3D; 0.7，则表示有 70%的几率𝑦为正向类，相应地𝑦为负向类的几率为 1-0.7&#x3D;0.3。</p>
<p><strong>逻辑回归的本质</strong>：逻辑回归是一种<strong>线性分类模型</strong>。它通过一个<strong>线性方程</strong>（例如，<em>z</em>&#x3D;<em>θ</em>0+<em>θ</em>1<em>x</em>1+<em>θ</em>2<em>x</em>2）将输入特征（如测试1和测试2的结果）<strong>映射</strong>到一个<strong>概率值</strong>（通过sigmoid函数）。决策边界（即区分接受&#x2F;抛弃的阈值）是线性的，比如一条直线（在二维特征空间中）。</p>
<h2 id="判定边界"><a href="#判定边界" class="headerlink" title="判定边界"></a>判定边界</h2><img src="../source/imgs/${fiilname}/image-20250707102404958.png" alt="image-20250707102404958" style="zoom:67%;" />

<p>根据逻辑回归模型的这个图，我们知道当𝑧 &#x3D; 0 时，𝑔(𝑧) &#x3D; 0.5；𝑧 &gt; 0 时，𝑔(𝑧) &gt; 0.5；𝑧 &lt; 0 时，𝑔(𝑧) &lt; 0.5；</p>
<p>又 𝑧 &#x3D; 𝜃𝑇𝑥 ，即：</p>
<p>𝜃𝑇𝑥 &gt;&#x3D; 0 时，预测 𝑦 &#x3D; 1；𝜃𝑇𝑥 &lt; 0 时，预测 𝑦 &#x3D; 0。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250707102617314.png" alt="image-20250707102617314"></p>
<p>对于上面那个模型，我们可以很明显地看出是一条直线将预测结果分成两部分。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250707102727734.png" alt="image-20250707102727734"></p>
<p>又两个例子可以看出，我们要根据分界线的形状来判断我们应该使用的分界线函数是什么。</p>
<h2 id="代价函数-1"><a href="#代价函数-1" class="headerlink" title="代价函数"></a>代价函数</h2><p>对于线性回归模型，定义的代价函数是所有模型误差的平方和。要是将逻辑回归模型的函数代入到这个代价函数中，得到的代价函数将是一个非凸函数，这意味着代价函数会有许多局部最小值，这将影响梯度下降算法寻找全局最小值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250707103625333.png" alt="image-20250707103625333"></p>
<p>定义代价函数为：<br>$$<br>J(θ)&#x3D;\frac{1}{m} ∑_{i&#x3D;1}^mCost(h_θ (x^i ),y^i )<br>$$<br><img src="/../source/imgs/$%7Bfiilname%7D/image-20250707104627579.png" alt="image-20250707104627579"></p>
<p>h𝜃x的取值范围在0~1。</p>
<p>这样构建的Cost函数的特点是：当实际的 𝑦 &#x3D; 1 且ℎ𝜃(𝑥)也为 1 时误差为 0，当 𝑦 &#x3D; 1 但ℎ𝜃(𝑥)不为 1 时误差随着ℎ𝜃(𝑥)变小而变大；当实际的 𝑦 &#x3D; 0 且ℎ𝜃(𝑥)也为 0 时代价为 0，当𝑦 &#x3D; 0 但ℎ𝜃(𝑥)不为 0 时误差随着 ℎ𝜃(𝑥)的变大而变大。</p>
<p>将Cost函数进行简化，就是用一个表达式表达出来，如下：<br>$$<br>Cost(h_θ (x),y)&#x3D;-y×log(h_θ (x))-(1-y)×log(1-h_θ (x))<br>$$<br>代入代价函数为：<br>$$<br>J(θ)&#x3D;-\frac{1}{m}∑_{i&#x3D;1}^m[y^{(i)} log(h_θ (x^{(i)} ))+(1-y^{(i)})log(1-h_θ (x^{(i)} ))]<br>$$</p>
<pre><code class="hljs plaintext">import numpy as np
def cost(theta, X, y):
  theta = np.matrix(theta)
  X = np.matrix(X)
  y = np.matrix(y)
  first = np.multiply(-y, np.log(sigmoid(X* theta.T)))
  second = np.multiply((1 - y), np.log(1 - sigmoid(X* theta.T)))
  return np.sum(first - second) / (len(X))</code></pre>

<p>sigmoid函数在上面定义了。</p>
<p>梯度下降算法的公式和前面的一样，记住，<strong>同时更新</strong>所有参数。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250707111211261.png" alt="image-20250707111211261"></p>
<p>通过观察梯度下降算法的式子可以发现，这个式子和之前线性回归的梯度下降算法的式子是一样的，但<strong>ℎ𝜃(𝑥)的式子是不同的</strong>。</p>
<p>特征缩放的技巧也适用于逻辑回归。</p>
<h2 id="高级优化"><a href="#高级优化" class="headerlink" title="高级优化"></a>高级优化</h2><p>共轭梯度法，BFGS (变尺度法) 和 L-BFGS (限制变尺度法) 就是一些更高级的优化算法，它们需要有一种方法来计算 𝐽(𝜃)，以及需要一种方法计算导数项，然后使用比梯度下降更复杂的算法来最小化代价函数。  </p>
<p>这三种算法的具体细节可以不用取探究，因为过于复杂。</p>
<p>使用这其中任何一个算法，通常不需要手动选择学习率 𝛼，所以对于这些算法的一种思路是，给出计算导数项和代价函数的方法，你可以认为算法有一个智能的内部循环，而且，事实上，他们确实有一个智能的内部循环，称为线性搜索算法，它可以自动尝试不同的学习速率 𝛼，并自动选择一个好的学习速率 𝛼，因此它甚至可以为每次迭代选择不同的学习速率。  </p>
<p>最好不要使用 L-BGFS、 BFGS 这些算法，除非你是数值计算方面的专家。</p>
<p>如何使用这些算法，这些算法适合在很大的机器学习问题中使用。</p>
<p>在jupyter中利用的是python中的<code>scipy.optimize.fmin_tnc()</code>函数，这是一个使用截断牛顿法（TNC）寻找局部最小值的优化函数，特别适用于有界约束的优化问题。</p>
<h2 id="寻找决策边界"><a href="#寻找决策边界" class="headerlink" title="寻找决策边界"></a>寻找决策边界</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250709171344091.png" alt="image-20250709171344091"></p>
<p>所以jupyter中的寻找决策边界会除以第三个参数值。</p>
<h2 id="构造多项式特征"><a href="#构造多项式特征" class="headerlink" title="构造多项式特征"></a>构造多项式特征</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250710155849606.png" alt="image-20250710155849606"></p>
<p>由上图可知其中没有线性决策界限，来良好的分开两类数据，原数据有两个特征，x1和x2，可以明显看出就这两个特征无法较好拟合这些数据，所以要构造从原始特征的多项式中得到的特征，即通过数学变换，将原始特征（ <em>x</em>1 和 <em>x</em>2）扩展为一组新特征，这些新特征是原始特征的高阶多项式组合（例如，<em>x</em>1平方、<em>x</em>2平方、<em>x</em>1×<em>x</em>2、<em>x</em>1立方 等）。然后，在这些新特征上训练逻辑回归模型。</p>
<p><strong>为什么能解决非线性问题</strong>：尽管逻辑回归本身是线性的，但通过添加非线性特征（如平方项或交互项），模型在扩展后的高维特征空间中学习到的决策边界仍然是线性的，但这个边界在原始特征空间中会呈现为曲线、椭圆或其他非线性形状。这相当于给模型“添加了非线性能力”，而不改变其核心算法。</p>
<p>首先要选择<strong>阶数</strong>，阶数决定了多项式的复杂性。从二阶开始（通常足够处理大多数非线性问题），然后根据模型性能调整。</p>
<p>平方项：捕捉单个测试的非线性效应。</p>
<p>交互项（<em>x</em>1×<em>x</em>2）：捕捉两个测试的联合效应。</p>
<p>由于选择了高阶数的模型，为了避免过拟合，通常还要进行正则化操作。</p>
<h2 id="多类别分类：一对多"><a href="#多类别分类：一对多" class="headerlink" title="多类别分类：一对多"></a>多类别分类：一对多</h2><p>如何使用逻辑回归来解决多类别分类问题。</p>
<p>之前的二元分类问题的图，和现在的多类分类问题的图：<img src="../source/imgs/${fiilname}/image-20250709173446894.png" alt="image-20250709173446894" style="zoom:80%;" /></p>
<p>用 3 种不同的符号来代表 3 个类别，问题就是给出 3 个类型的数据集，如何得到一个学习算法来进行分类呢？</p>
<p>面对二元分类问题可以使用逻辑回归，也可以将数据集一分为二为正类和负类，而一对多的分类思想，我们可以将其用在多类分类问题上，这个方法也被称为”一对余”方法。</p>
<p>现在我们有一个训练集，好比上图表示的有 3 个类别，我们用三角形表示 𝑦 &#x3D; 1，方框表示𝑦 &#x3D; 2，叉叉表示 𝑦 &#x3D; 3。使用一个训练集将三元分类问题转化为<strong>三个二元分类问题</strong>，先从用三角形代表的类别 1 开始，实际上我们可以创建一个，新的”伪”训练集，类型 2 和类型 3 定为负类，类型 1 设定为正类，我们创建一个新的训练集，如下图所示的那样，我们要拟合出一个合适的分类器。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250709175113715.png" alt="image-20250709175113715"></p>
<p>这里的三角形是正样本，而圆形代表负样本。可以这样想，设置三角形的值为 1，圆形的值为 0，下面可以训练一个标准的逻辑回归分类器，这样就得到一个边界。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250709175233890.png" alt="image-20250709175233890"></p>
<p>选择出哪一个分类器是可信度最高效果最好的，那么就可认为得到一个正确的分类，无论𝑖值是多少，我们都有最高的概率值，我们预测𝑦就是那个值。<br>$$<br>最后我们得到一系列的模型简记为： h_θ^{(i) } (x)&#x3D;p(y&#x3D;i|x;θ)其中：i&#x3D;(1,2,3….k)<br>$$</p>
<h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><h2 id="过拟合的问题"><a href="#过拟合的问题" class="headerlink" title="过拟合的问题"></a>过拟合的问题</h2><p>就是过于强调拟合原始数据。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250709201037517.png" alt="image-20250709201037517"></p>
<p>第一个模型是一个线性模型，欠拟合，不能很好地适应训练集；第三个模型是一个四次方的模型，过于强调拟合原始数据，而丢失了算法的本质：预测新数据。可以看出，若给出一个新的值使之预测，它将表现的很差，是过拟合，虽然能非常好地适应我们的训练集但在新输入变量进行预测时可能会效果不好。</p>
<p>分类问题中也存在这样的问题：<img src="../source/imgs/${fiilname}/image-20250709201149549.png" alt="image-20250709201149549" style="zoom:80%;" /></p>
<p>以多项式理解， 𝑥 的次数越高，拟合的越好，但相应的预测的能力就可能变差。</p>
<p>如何处理过拟合问题：</p>
<p>1.丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙，例如 PCA</p>
<p>2.正则化。 保留所有的特征，但是减少参数的大小。</p>
<h2 id="代价函数-2"><a href="#代价函数-2" class="headerlink" title="代价函数"></a>代价函数</h2><p>在上面过拟合的回归问题中有以下模型：<br>$$<br>h_θ (x)&#x3D;θ_0+θ_1 x_1+θ_2 x_2^2+θ_3 x_3^3+θ_4 x_4^4<br>$$<br>正是高次项导致了过拟合的产生，所以如果能让这些高次项的系数接近于0的话，那就能很好的拟合了。</p>
<p>所以我们要做的就是在一定程度上<strong>减小</strong>这些参数𝜃的值，这就是<strong>正则化的基本方法</strong>。我们决定要减少𝜃3和𝜃4的大小，我们要做的便是修改代价函数，在其中𝜃3和𝜃4设置一点惩罚。这样做的话，在尝试最小化代价时也会将这个惩罚纳入考虑中，并最终导致选择较小一些的𝜃3和𝜃4。惩罚就是在代价函数中使𝜃3和𝜃4的占比变高，使得在最小化代价函数时，也会更多地考虑这两个参数。<br>$$<br>修改后的代价函数：min\frac{1}{2m}[∑_{i&#x3D;1}^m[(h_θ (x^{(i)} )-y^{(i)} )^2+1000θ_3^2+10000θ_4^2]]<br>$$<br>假如有非常多的特征，我们并不知道其中哪些特征要惩罚，那么就对所有的特征进行惩罚，并且让代价函数最优化的软件来选择这些惩罚的程度。这样的结果是得到了一个较为简单的能防止过拟合问题的假设：<br>$$<br>J(θ)&#x3D;\frac{1}{2m}[∑_{i&#x3D;1}^m(h_θ (x^{(i)})-y^{(i)})^2+λ∑_{j&#x3D;1}^nθ_j^2 ]<br>$$<br>其中𝜆又称为正则化参数，根据惯例，我们<strong>不对𝜃0 进行惩罚</strong>。经过正则化处理的模型与原模型的可能对比如下图所示：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250709202809943.png" alt="image-20250709202809943"></p>
<p>如果选择的正则化参数λ<strong>过大</strong>，则会把所有的参数<strong>都最小化</strong>了，导致模型变成 ℎ𝜃(𝑥) &#x3D; 𝜃0，也就是上图中红色直线所示的情况，造成<strong>欠拟合</strong>。  </p>
<h2 id="正则化线性回归"><a href="#正则化线性回归" class="headerlink" title="正则化线性回归"></a>正则化线性回归</h2><p>正则化<strong>线性回归</strong>的代价函数是：<br>$$<br>J(θ)&#x3D;\frac{1}{2m}[∑_{i&#x3D;1}^m(h_θ (x^{(i)})-y^{(i)})^2+λ∑_{j&#x3D;1}^nθ_j^2 ]<br>$$<br>由于𝜃0没有进行正则化，所以梯度下降算法将会分成两种情况：<img src="../source/imgs/${fiilname}/image-20250709210159349.png" alt="image-20250709210159349" style="zoom:50%;" /></p>
<p>对第二个式子（𝑗 &#x3D; 1,2, . . . , 𝑛 ）进行调整可以得到：<br>$$<br>θ_j:&#x3D;θ_j (1-a \frac{λ}{m})-a \frac{1}{m} ∑_{i&#x3D;1}^m(h_θ (x^{(i)})-y^{(i)})x_j^{(i)}<br>$$<br>可以看出，正则化线性回归的梯度下降算法的变化在于，每次都在原有算法更新规则的基础上令𝜃值减少了一个额外的值。</p>
<p>利用正规方程来求解正则化线性回归模型：<img src="../source/imgs/${fiilname}/image-20250709211926347.png" alt="image-20250709211926347" style="zoom:50%;" />，图中的矩阵尺寸为 (𝑛 + 1) ∗ (𝑛 + 1)，因为不算𝜃0还有n个特征。</p>
<h2 id="正则化的逻辑回归模型"><a href="#正则化的逻辑回归模型" class="headerlink" title="正则化的逻辑回归模型"></a>正则化的逻辑回归模型</h2><p>这是正则化的<strong>逻辑回归</strong>的代价函数。</p>
<p>给代价函数增加一个正则化的表达式，得到代价函数：<br>$$<br>J(θ)&#x3D;\frac{1}{m} ∑_{i&#x3D;1}^m[-y^{(i)} log(h_θ (x^{(i)} ))-(1-y^{(i)} )log(1-h_θ (x^{(i)} ))]+\frac{λ}{2m} ∑_{j&#x3D;1}^nθ_j^2<br>$$</p>
<pre><code class="hljs plaintext">import numpy as np
def costReg(theta, X, y, learningRate):
    theta = np.matrix(theta)
    X = np.matrix(X)
    y = np.matrix(y)
    first = np.multiply(-y, np.log(sigmoid(X*theta.T)))
    second = np.multiply((1 - y), np.log(1 - sigmoid(X*theta.T)))
    reg = (learningRate / (2 * len(X))* np.sum(np.power(theta[:,1:theta.shape[1]],2))
    return np.sum(first - second) / (len(X)) + reg</code></pre>

<img src="../source/imgs/${fiilname}/image-20250709213440950.png" alt="image-20250709213440950" style="zoom:67%;" />

<p>这边的 h 函数是sigmoid函数。</p>
<p><strong>𝜃0不参与其中的任何一个正则化</strong>。</p>
<p>接下来的课程中，我们将学习一个非常强大的非线性分类器，无论是<strong>线性回归</strong>问题，还是<strong>逻辑回归</strong>问题，都可以<strong>构造多项式</strong>来解决。你将逐渐发现还有更强大的非线性分类器，可以用来解决多项式回归问题。  </p>
<h1 id="神经网络：表述"><a href="#神经网络：表述" class="headerlink" title="神经网络：表述"></a>神经网络：表述</h1><h2 id="非线性假设"><a href="#非线性假设" class="headerlink" title="非线性假设"></a>非线性假设</h2><p>无论是线性回归还是逻辑回归都有这样一个缺点，即：当特征太多时，计算的负荷会非常大。</p>
<p>使用非线性的多项式项，能够帮助我们建立更好的分类模型，但相应的我们要计算的特征数会大大增多，普通的逻辑回归模型，不能有效地处理这么多的特征，这时候就需要神经网络。</p>
<h2 id="模型表示-1"><a href="#模型表示-1" class="headerlink" title="模型表示"></a>模型表示</h2><p>神经网络模型建立在很多神经元之上，每一个神经元又是一个个学习模型。这些神经元（也叫激活单元）采纳一些特征作为输出，并且根据本身的模型提供一个输出。</p>
<p>以逻辑回归模型作为学习模型的神经元示例：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250710173745443.png" alt="image-20250710173745443"></p>
<p>解读：上面的黄圈看作是神经元，左边的蓝圈和黄圈的连线看作是输入&#x2F;树突，黄圈右边的线看作是输出&#x2F;轴突。通过树突传递一些信息，然后神经元做一些计算，然后通过轴突输出计算结果。这个图表表示的是对h的计算，而h是sigmoid函数。x1、x2、x3是输入结点，额外的结点x0被称为<strong>偏置单位</strong>，因为x0总是等于1。x0可画可不画，根据具体情况来。</p>
<p>在神经网络中，参数𝜃又可被称为权重。</p>
<p>上面的一个小黄圈代表一个单一的神经元，而神经网络是不同的神经元组合在一起的集合。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250710175318298.png" alt="image-20250710175318298"></p>
<p>第一层叫作输入层，在这一层输入特征项x1、x2、x3；最后一层（第3层）叫作输出层，因为这一层的神经元输出假设的最终计算结果；中间的一层称作隐藏层，神经网络中可以有不止一个隐藏层，非输出层和输入层的都叫做隐藏层。</p>
<p>在隐藏层出现的蓝色圈被称作偏置单位，它的值永远是1。</p>
<p>下面的图有3个输入单元和3个隐藏单元。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250710213148069.png" alt="image-20250710213148069"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250710213208144.png" alt="image-20250710213208144"></p>
<p>每一个𝑎都是由上一层所有的𝑥和每一个𝑥所对应的参数决定的，这样从左到右的算法称为前向传播算法。</p>
<img src="../source/imgs/${fiilname}/image-20250710213756450.png" alt="image-20250710213756450" style="zoom:67%;" />  

<p><code>𝜃*X</code>不会等于a，因为g(𝜃*X)&#x3D;a</p>
<img src="../source/imgs/${fiilname}/image-20250710215327579.png" alt="image-20250710215327579" style="zoom:70%;" />

<p>这边要转置应该是因为是一行一行地输入数据的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250710220504253.png" alt="image-20250710220504253"></p>
<p><strong>要注意偏置单位的添加。</strong></p>
<p>如果我们暂时只看第二层和第三层的话：<img src="../source/imgs/${fiilname}/image-20250710215557120.png" alt="image-20250710215557120" style="zoom:33%;" /></p>
<p>可以发现，其实神经网络就像是 logistic regression，只不过我们把 logistic regression 中的输入向量[𝑥1 ∼ 𝑥3] 变成了中间层的[𝑎1(2) ∼ 𝑎3(2)], 即:<img src="../source/imgs/${fiilname}/image-20250710215730645.png" alt="image-20250710215730645" style="zoom:50%;" /></p>
<p>特征项a1、a2、a3是作为输入的函数来学习的，所以在神经网络中，它没有使用输入特征x1、x2、x3来训练逻辑回归，而是自己根据a1、a2、a3来训练逻辑回归，所以如果在𝜃1中选择了不同的参数，那就可以学习到比较复杂的特征，就可以得到一个更好的假设，比使用原始输入时得到的假设更好（构造多项式特征？这里的特征也是通过学习模型得出来的）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250710221653096.png" alt="image-20250710221653096"></p>
<p>神经网络中神经元相互连接的方式称为神经网络的架构。</p>
<h2 id="特征和直观理解"><a href="#特征和直观理解" class="headerlink" title="特征和直观理解"></a>特征和直观理解</h2><p>从本质上讲，神经网络能够通过<strong>学习</strong>得出其自身的一系列特征（在预设的<strong>网络架构</strong>和<strong>激活函数</strong>框架下，通过训练数据<strong>动态调整权重参数</strong>，使用梯度下降等优化算法调整，使模型逼近目标函数。）。在普通的逻辑回归中，我们被限制为使用数据中的原始特征𝑥1, 𝑥2, . . . , 𝑥𝑛，我们虽然可以使用一些二项式项来组合这些特征，但是我们仍然受到这些原始特征的限制。在神经网络中，原始特征只是输入层，在我们上面三层的神经网络例子中，第三层也就是输出层做出的预测利用的是第二层的特征，而非输入层中的原始特征，我们可以认为第二层中的特征是神经网络通过学习后自己得出的一系列用于预测输出变量的新特征。  </p>
<p>神经网络中，单层神经元（无中间层）的计算可用来表示逻辑运算，比如逻辑与(AND)、逻辑或(OR)。  </p>
<p>逻辑与，用下面的这样一个神经网络表示AND函数：<img src="../source/imgs/${fiilname}/image-20250711153715449.png" alt="image-20250711153715449" style="zoom:50%;" /></p>
<p>$$<br>其中θ_0&#x3D;-30,θ_1&#x3D;20,θ_2&#x3D;20 我们的输出函数h_θ (x)即为：h_Θ (x)&#x3D;g(-30+20x_1+20x_2 )<br>$$<br>为什么要这样设置参数？根据g(x)的图像和真值表得出。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250711153927581.png" alt="image-20250711153927581"></p>
<p>再根据同样的步骤设计OR函数（三个权重分别为-10， 20， 20），它与AND函数的区别就是参数的取值不同。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250711154030163.png" alt="image-20250711154030163"></p>
<p>当输入特征为布尔值（ 0 或 1）时，我们可以用一个单一的激活层可以作为二元逻辑运算符，为了表示不同的运算符，我们只需要选择不同的权重即可。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250711154327345.png" alt="image-20250711154327345"></p>
<img src="../source/imgs/${fiilname}/image-20250711154521895.png" alt="image-20250711154521895" style="zoom:67%;" />

<p>我们可以利用神经元来<strong>组合</strong>成更为复杂的神经网络以实现更复杂的运算。  </p>
<p>实现 XNOR 功能（输入的两个值必须一样，均为 1 或均为 0），即：XNOR &#x3D; (x1 AND x2) OR((NOT x1)AND(NOT x2))</p>
<p>首先构造一个能表达(NOT x1)AND(NOT x2)部分的神经元：(!x1)交(!x2) &#x3D; !(x1并x2) &#x3D; 非AND<img src="../source/imgs/${fiilname}/image-20250711155524524.png" alt="image-20250711155524524" style="zoom:36%;" /></p>
<p>然后将表示 AND 的神经元和表示(NOT x1)AND(NOT x2)的神经元以及表示 OR 的神经元进行组合：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250711155624715.png" alt="image-20250711155624715"></p>
<h2 id="多类分类"><a href="#多类分类" class="headerlink" title="多类分类"></a>多类分类</h2><p>如果我们要训练一个神经网络算法来识别路人、汽车、摩托车和卡车，在输出层我们应该有 4 个值。例如，第一个值为 1 或 0 用于预测是否是行人，第二个值用于判断是否为汽车。</p>
<p>输入向量𝑥有三个维度，两个中间层，输出层 4 个神经元分别用来表示 4 类，也就是每一个数据在输出层都会出现[𝑎 𝑏 𝑐 𝑑]𝑇，且𝑎, 𝑏, 𝑐, 𝑑中仅有一个为 1，表示当前类。下面是该神经网络的可能结构示例：  </p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250711160844709.png" alt="image-20250711160844709"></p>
<p>我们不用1代表行人，2代表车这种形式，而是构造四个分类器，输出1或0，根据哪个位置是1来判断是什么。</p>
<h1 id="神经网络的学习"><a href="#神经网络的学习" class="headerlink" title="神经网络的学习"></a>神经网络的学习</h1><h2 id="代价函数-3"><a href="#代价函数-3" class="headerlink" title="代价函数"></a>代价函数</h2><p>假设神经网络的训练样本有𝑚个，每个包含一组输入𝑥和一组输出信号𝑦。L：神经网络结构的总层数；Sl（这是小L）：第 l 层的单元个数也就是神经元的数量，不包括 l 层的偏差单元。𝑆𝐿代表最后一层中处理单元的个数。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250711165618966.png" alt="image-20250711165618966"></p>
<p>二元分类问题只有一个输出单元，所以只有一个输出结果。</p>
<p>多元分类问题，也就是K类分类问题，会有K个输出单元，输出是一个K维向量。</p>
<p>先来看一下逻辑回归问题中的代价函数：<br>$$<br>J(θ)&#x3D;\frac{1}{m} ∑_{i&#x3D;1}^m[-y^{(i)} log(h_θ (x^{(i)} ))-(1-y^{(i)} )log(1-h_θ (x^{(i)} ))]+\frac{λ}{2m} ∑_{j&#x3D;1}^nθ_j^2<br>$$<br>在逻辑回归中，我们只有一个输出变量，又称标量，也就是只有一个逻辑输出单元，也只有一个因变量y，但在神经网络中会有K个逻辑输出单元。<br>$$<br>h_θ (x)∈R^K，(h_θ (x))_i&#x3D;i^th output<br>$$<br>h(x)是一个K维向量；h(x)i 代表的是第 i 个输出，也就是它选择了输出向量中的第 i 个元素。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250711171756403.png" alt="image-20250711171756403"></p>
<p>首先要计算从1到K的每一个逻辑回归算法的代价函数的和。最后的那个正则化的求和项，它是将所有的参数（除了i &#x3D; 0的，也就是偏差单位）都加起来。最后正则项的 j 的范围的s l+1 的l+1应该是下标，可以看下面那个图。</p>
<p><strong>上面θ的 j 和 i 应该反了</strong><img src="../source/imgs/${fiilname}/image-20250713205157804.png" alt="image-20250713205157804" style="zoom:33%;" />应该是这样的<img src="../source/imgs/${fiilname}/image-20250714102913373.png" alt="image-20250714102913373" style="zoom:33%;" /></p>
<p><img src="../source/imgs/${fiilname}/image-20250711173149157.png" alt="image-20250711173149157" style="zoom:33%;" />根据这个图可以知道，参数的行号是从1开始计数的，所以上面的 i 是从1开始的。</p>
<p>正则化的那一项只是排除了每一层 θ0后，每一层的θ矩阵的和。最里层的循环 j 循环所有的行（由 Sl +1 层的激活单元数决定），循环 i 则循环所有的列，由该层（ Sl 层）的激活单元数所决定。</p>
<p>上面那个公式的意思就是：h(θ）与真实值之间的距离为每个样本-每个类输出的加和，对参数进行<strong>regularization</strong>的<strong>bias</strong>项处理所有参数的平方和。</p>
<h2 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h2><p>就是让代价函数最小化的算法，因为是从最后往前算误差的，所以叫作反向传播算法，之前的是从第一层开始正向一层一层进行计算，直到最后一层的ℎ𝜃(𝑥)，所以是正向传播算法。<br>$$<br>为了计算偏导数项\frac{∂}{∂Θ_{ij}^{(l)} } J(Θ)，我们需要采用一种反向传播算法，也就是首先计算最后一层的误差，然后再一层一层反向求出各层的误差，<br>$$<br>直到倒数第二层。 以一个例子来说明反向传播算法，参数是这样的<img src="../source/imgs/${fiilname}/image-20250714102913373.png" alt="image-20250714102913373" style="zoom:33%;" /></p>
<p>假设我们的训练集只有一个实例(𝑥, 𝑦），我们的神经网络是一个四层的神经网络，其中𝐾 &#x3D; 4， 𝑆𝐿 &#x3D; 4， 𝐿 &#x3D; 4：先利用前向传播算法计算一下输出结果。<img src="../source/imgs/${fiilname}/image-20250714103257364.png" alt="image-20250714103257364" style="zoom:50%;" /></p>
<p>接下来计算导数项。</p>
<p><img src="../source/imgs/${fiilname}/image-20250714103443302.png" alt="image-20250714103443302" style="zoom:33%;" />代表第 l 层的第 j 个结点的误差。</p>
<p>由于现在用来举例的只有一个样本，所以误差可以写为<img src="../source/imgs/${fiilname}/image-20250714103857506.png" alt="image-20250714103857506" style="zoom:33%;" />，向量形式是<img src="../source/imgs/${fiilname}/image-20250714103924438.png" alt="image-20250714103924438" style="zoom:33%;" /></p>
<p>当算出最后一层的误差后，就向前计算前面几层的误差。</p>
<p><code>·*</code>代表的是两个向量的对应元素相乘。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250714104343510.png" alt="image-20250714104343510"></p>
<p>没有𝛿(1)，因为第一层是输入层，所以不会存在误差。</p>
<p>一个单元造成的误差是这个单元对下一层的每一个单元造成的误差的总和，所以参数矩阵要转置求这个单元造成的误差和。可以求出偏差单位的误差，但在计算的时候可以不加，造成的影响不大。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250714114449182.png" alt="image-20250714114449182"><br>$$<br>假设λ&#x3D;0，即我们不做任何正则化处理时有：\frac{∂}{∂Θ_{ij}^{(l)} } J(Θ)&#x3D;a_j^{(l)} δ_i^{l+1}<br>$$<br>上面式子中上下标的含义： </p>
<p>𝑙 代表目前所计算的是第几层。</p>
<p>𝑗 代表目前计算层中的激活单元的下标。</p>
<p>𝑖 代表下一层(l+1层)中误差单元的下标，是受到权重矩阵中第𝑖行影响的下一层中的误差单元的下标。</p>
<p>假设有m个训练样本，用<img src="../source/imgs/${fiilname}/image-20250714110943856.png" alt="image-20250714110943856" style="zoom:50%;" />表示误差矩阵，第 𝑙+1 层的第 𝑖 个激活单元受到第 𝑗个参数影响而导致的误差。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250714110323781.png" alt="image-20250714110323781"></p>
<p>上面的 l 的范围感觉应该是1~l-1，因为误差矩阵是关于参数矩阵，而参数矩阵没有 L。</p>
<p>公式里的那个1&#x2F;m是乘以后面的和的。</p>
<h2 id="梯度检验"><a href="#梯度检验" class="headerlink" title="梯度检验"></a>梯度检验</h2><p>当我们对一个较为复杂的模型（例如神经网络）使用梯度下降算法时，可能会存在一些不容易察觉的错误，意味着，虽然代价看上去在不断减小，但最终的结果可能并不是最优解。</p>
<p>为了避免这样的问题，我们采取一种叫做<strong>梯度的数值检验方法</strong>。这种方法的思想是通过<strong>估计梯度值</strong>来检验我们计算的导数值是否真的是我们要求的。</p>
<p>对梯度的估计采用的方法是在代价函数上沿着切线的方向选择离两个非常近的点然后计算两个点的平均值用以估计梯度。即对于某个特定的 𝜃，我们计算出在 𝜃-𝜀 处和 𝜃+𝜀 的代价值（ 𝜀是一个非常小的值，通常选取 0.001，𝜀不要取太小，不然会出现数值问题），然后求两个代价的平均，用以估计在 𝜃处的代价值（用数值的方法计算近似的导数）。下面那张图的𝜃是一个实数。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250714152302979.png" alt="image-20250714152302979"></p>
<p>更普遍的情况，𝜃是一个n维向量，它可能是神经网络参数<img src="../source/imgs/${fiilname}/image-20250819215309138.png" alt="image-20250819215309138" style="zoom:33%;" />等的展开形式。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250714152538713.png" alt="image-20250714152538713"></p>
<p>最后我们还需要对通过反向传播方法计算出的偏导数进行检验。根据反向传播算法计算出来的偏导数存储在矩阵<img src="../source/imgs/${fiilname}/image-20250714153307330.png" alt="image-20250714153307330" style="zoom:50%;" />中，然后将其与上面的数值计算的方法计算出来的近似的梯度值进行比较，如果误差在几位小数之内就认为反向传播算法的实现是<strong>正确</strong>的，然后在接下来的训练过程中都<strong>不再使用</strong>这个验证程序，因为它的计算量很大，而反向传播是一种更为简单的计算方法。</p>
<p>步骤：DVec就是反向传播算出来的导数值，gradApprox是数值计算算出来的近似梯度值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250714153726453.png" alt="image-20250714153726453"></p>
<p><strong>用数值方法计算导数是用来确定反向传播实现是否正确的方法，但是不止可以用来验证反向传播，也可以用来验证类似的复杂模型的梯度下降算法。</strong></p>
<h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><p>任何优化算法都需要一些初始的参数。到目前为止我们都是初始所有参数为 0，这样的初始方法对于逻辑回归来说是可行的，但是对于神经网络来说是不可行的。如果我们令所有的初始参数都为 0，这将意味着我们第二层的所有激活单元都会有相同的值，算出来的误差值也都是相同的值，之后进行梯度下降后的值也都相同。同理，如果我们初始所有的参数都为一个非 0 的数，结果也是一样的。</p>
<p>为了解决这个问题，神经网络变量的初始化方式采用随机初始化，通常初始参数为正负𝜀之间接近于0的随机值，然后进行反向传播，执行梯度检查，使用梯度下降或者其它优化算法。</p>
<h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250714155124333.png" alt="image-20250714155124333"></p>
<h1 id="应用机器学习的建议"><a href="#应用机器学习的建议" class="headerlink" title="应用机器学习的建议"></a>应用机器学习的建议</h1><h2 id="决定下一步做什么"><a href="#决定下一步做什么" class="headerlink" title="决定下一步做什么"></a>决定下一步做什么</h2><p>当我们运用训练好了的模型来预测未知数据的时候发现有较大的误差，我们下一步可以做什么？</p>
<p>获得更多的训练实例通常是有效的，但代价较大，下面的方法也可能有效，可考虑先采用下面的几种方法。</p>
<p>1.尝试减少特征的数量；2.尝试获得更多的特征；3.尝试增加多项式特征；4.尝试减少正则化程度λ； 5.尝试增加正则化程度λ</p>
<p>我们不应该随机选择上面的某种方法来改进我们的算法，而是运用一些机器学习诊断法来帮助我们知道上面哪些方法对我们的算法是有效的。“诊断法”的意思是：这是一种测试法，你通过执行这种测试，能够深入了解某种算法到底是否有用。这通常也能够告诉你，要想改进一种算法的效果，什么样的尝试，才是有意义的。</p>
<h2 id="评估一个假设"><a href="#评估一个假设" class="headerlink" title="评估一个假设"></a>评估一个假设</h2><p>如何判断一个假设函数是过拟合的呢？</p>
<p>对于特征变量只有一个的简单例子，可以直接对假设函数h(x)进行画图，但对于特征变量不止一个的这种一般情况，还有像有很多特征变量的问题，想要通过画出假设函数来进行观察，就会变得很难甚至是不可能实现。</p>
<p>为了检验算法是否过拟合，我们将数据分成<strong>训练集</strong>和<strong>测试集</strong>，通常用 70%的数据作为训练集，用剩下 30%的数据作为测试集。很重要的一点是训练集和测试集均<strong>要含有各种类型</strong>的数据，通常我们要对数据进行“<strong>洗牌</strong>”，然后再分成训练集和测试集。</p>
<p>在通过训练集让我们的模型学习得出其参数后，对测试集运用该模型，我们有两种方式计算误差：</p>
<p> 1.对于线性回归模型，我们利用测试集数据计算代价函数 J</p>
<p>2.对于逻辑回归模型，我们除了可以利用测试数据集来计算代价函数外，还可以计算误分类的比率（感觉就是准确率），也就是对每一个测试集实例计算<img src="../source/imgs/${fiilname}/image-20250721163110688.png" alt="image-20250721163110688" style="zoom:50%;" />，然后对结果求平均。</p>
<h2 id="模型选择和交叉验证集"><a href="#模型选择和交叉验证集" class="headerlink" title="模型选择和交叉验证集"></a>模型选择和交叉验证集</h2><p>假设我们要在 10 个不同次数的二项式模型之间进行选择：<img src="../source/imgs/${fiilname}/image-20250721163448041.png" alt="image-20250721163448041" style="zoom:50%;" /></p>
<p>虽然越高次数的多项式模型越能够适应我们的训练数据集，但是适应训练数据集并不代表着能推广至一般情况，我们应该选择一个更能适应一般情况的模型。我们需要使用交叉验证集来帮助选择模型。</p>
<p>即：使用 60%的数据作为训练集，使用 20%的数据作为交叉验证集，使用 20%的数据作为测试集。</p>
<p>模型选择的方法为：</p>
<ol>
<li><p>使用训练集训练出 10 个模型</p>
</li>
<li><p>用 10 个模型分别对<strong>交叉验证集</strong>计算得出交叉验证误差（代价函数的值）</p>
</li>
<li><p>选取代价函数值最小的模型</p>
</li>
<li><p>用步骤 3 中选出的模型对测试集计算得出推广误差（代价函数的值）</p>
</li>
</ol>
<h2 id="诊断偏差和方差"><a href="#诊断偏差和方差" class="headerlink" title="诊断偏差和方差"></a>诊断偏差和方差</h2><p>当一个学习算法的表现不理想时，多半是出现两种情况：要么是偏差比较大，要么是方差比较大。换句话说，出现的情况要么是欠拟合，要么是过拟合问题。</p>
<p>高偏差和高方差的问题基本上来说是欠拟合和过拟合的问题。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250721165003029.png" alt="image-20250721165003029"></p>
<p>通常会通过将训练集和交叉验证集的代价函数误差与多项式的次数绘制在同一张图表上来帮助分析：</p>
<p><img src="../source/imgs/${fiilname}/image-20250721165252491.png" alt="image-20250721165252491" style="zoom:50%;" /><img src="../source/imgs/${fiilname}/image-20250721165312076.png" alt="image-20250721165312076" style="zoom:50%;" /></p>
<p>对于训练集，当多项式次数 𝑑 较小时，模型拟合程度更低，误差较大；随着 𝑑 的增长，拟合程度提高，误差减小。</p>
<p>对于交叉验证集，当 𝑑 较小时，模型拟合程度低，误差较大；但是随着 𝑑 的增长，误差呈现先减小后增大的趋势，<strong>转折点</strong>是我们的模型开始<strong>过拟合训练数据集</strong>的时候。</p>
<p>交叉验证集误差较大，如何判断是方差还是偏差呢？  根据上面的图表可以知道：</p>
<p>训练集误差和交叉验证集<strong>误差近似</strong>时：偏差&#x2F;欠拟合</p>
<p>交叉验证集误差<strong>远大于</strong>训练集误差时：方差&#x2F;过拟合  </p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250721165430462.png" alt="image-20250721165430462"></p>
<h2 id="正则化和偏差-方差"><a href="#正则化和偏差-方差" class="headerlink" title="正则化和偏差&#x2F;方差"></a>正则化和偏差&#x2F;方差</h2><p>在训练模型的过程中，一般会使用一些正则化方法来防止过拟合。但是正则化的程度可能会太高或太小了，即我们在选择 λ 的值时也需要思考与刚才选择多项式模型次数类似的问题。  <img src="/../source/imgs/$%7Bfiilname%7D/image-20250721165724178.png" alt="image-20250721165724178"></p>
<p>选择一系列的想要测试的 𝜆 值，通常是 0-10 之间的呈现 2 倍关系的值（如： 0,0.01,0.02,0.04,0.08,0.15,0.32,0.64,1.28,2.56,5.12,10共 12 个），同样把数据分为训练集、交叉验证集和测试集。  </p>
<p>选择𝜆的方法为：</p>
<p>1.使用训练集训练出 12 个不同程度正则化的模型</p>
<p>2.用 12 个模型分别对交叉验证集计算的出交叉验证误差</p>
<p>3.选择得出交叉验证误差最小的模型</p>
<p>4.运用步骤 3 中选出模型对测试集计算得出推广误差，我们也可以同时将训练集和交叉验证集模型的代价函数误差与 λ 的值绘制在一张图表上：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250721170136816.png" alt="image-20250721170136816"></p>
<p>在训练时，代价函数是有加上正则项的，而在后面计算训练集和交叉验证集的误差时是没有加上正则项的，因为λ越大，会导致正则项在训练时的代价函数中的比例越大，导致theta变小，拟合效果变差，所以训练集和交叉验证集的误差就会变大。</p>
<p>当 𝜆 较小时，训练集误差较小（过拟合）而交叉验证集误差较大，这对应着高方差问题。</p>
<p>随着 𝜆 的增加，训练集误差不断增加（欠拟合），而交叉验证集误差则是先减小后增加，这对应着高偏差问题。</p>
<h2 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h2><p>可以使用学习曲线来判断某一个学习算法是否处于偏差、方差问题，学习曲线是将训练集误差和交叉验证集误差作为<strong>训练集实例数量（ 𝑚）</strong>的函数绘制的图表，所以m一般都是一个常数，但我们需要自行对m进行取值，比如说取10，20，30等，然后绘制出曲线。即，如果我们有 100 行数据，我们从 1 行数据开始，逐渐学习更多行的数据。</p>
<p>绘制学习曲线，先绘制出 J(train)，然后再画出 J(cv)。</p>
<p>当训练较少行数据的时候，训练的模型将能够非常完美地适应较少的训练数据，但是训练出来的模型却不能很好地适应交叉验证集数据或测试集数据。在训练数据很少的情况下，即使使用了正则化，拟合的效果仍然会很好。随着训练集样本的增加，平均训练误差是逐渐增大的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250721173115254.png" alt="image-20250721173115254"></p>
<p>当学习算法处于高偏差&#x2F;欠拟合情形时，学习曲线如下，作为例子，用一条直线来适应下面的数据，可以看出，无论训练集有多么大，误差都不会有太大改观：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250721173448391.png" alt="image-20250721173448391"></p>
<p><strong>也就是说在高偏差&#x2F;欠拟合的情况下，增加数据到训练集不一定能有帮助。</strong></p>
<p>当学习算法处于高方差情形时，假设使用一个非常高次的多项式模型，并且<strong>正则化非常小</strong>，可以看出，当交叉验证集误差远大于训练集误差时，往训练集增加更多数据可以提高模型的效果。虽然随着训练样本的增多， J(train)会越来越大，因为训练样本越多时，就越难与训练数据拟合得很好，但总体来说训练集误差还是很小。</p>
<p>因为函数对数据过拟合，所以交叉验证集误差会一直都很大，即便选择了一个比较合适得训练集样本数，所以交叉验证集和训练集误差之间始终会有一段很大的差距。但如果继续增大样本数的话，可以发现这两条线在相互靠近。</p>
<p><img src="../source/imgs/${fiilname}/image-20250721174433396.png" alt="image-20250721174433396" style="zoom:40%;" />增大样本数<img src="../source/imgs/${fiilname}/image-20250721174644797.png" alt="image-20250721174644797" style="zoom:60%;" /></p>
<p><strong>也就是说在高方差&#x2F;过拟合的情况下，增加更多数据到训练集可能可以提高算法效果。</strong>  </p>
<h2 id="决定下一步做什么-1"><a href="#决定下一步做什么-1" class="headerlink" title="决定下一步做什么"></a>决定下一步做什么</h2><pre><code class="hljs plaintext">1. 获得更多的训练实例——解决高方差
2. 尝试减少特征的数量——解决高方差
3. 尝试获得更多的特征——解决高偏差
4. 尝试增加多项式特征——解决高偏差
5. 尝试减少正则化程度 λ——解决高偏差
6. 尝试增加正则化程度 λ——解决高方差</code></pre>

<p><strong>神经网络</strong>的方差和偏差：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250721175546856.png" alt="image-20250721175546856"></p>
<p>使用较小的神经网络，类似于参数较少的情况，容易导致高偏差和欠拟合，但计算代价较小。使用较大的神经网络，类似于参数较多的情况，容易导致高方差和过拟合，虽然计算代价比较大，但是可以通过正则化手段来调整而更加适应数据。</p>
<p>通常选择较大的神经网络并采用正则化处理会比采用较小的神经网络效果要好。</p>
<p>对于神经网络中的隐藏层的层数的选择，通常从一层开始逐渐增加层数，为了更好地作选择，可以把数据分为训练集、交叉验证集和测试集，针对不同隐藏层层数的神经网络训练神经网络， 然后选择交叉验证集代价最小的神经网络。</p>
<h1 id="机器学习系统的设计"><a href="#机器学习系统的设计" class="headerlink" title="机器学习系统的设计"></a>机器学习系统的设计</h1><p>以一个垃圾邮件分类器算法为例进行讨论。</p>
<p>为了解决这样一个问题，我们首先要做的决定是如何选择并表达特征向量𝑥。我们可以选择一个由 100 个最常出现在垃圾邮件中的词所构成的列表，根据这些词是否有在邮件中出现，来获得我们的特征向量（出现为 1，不出现为 0），尺寸为 100×1。</p>
<p>为了构建这个分类器算法，我们可以做很多事，例如：</p>
<ol>
<li><p>收集更多的数据，让我们有更多的垃圾邮件和非垃圾邮件的样本</p>
</li>
<li><p>基于邮件的路由信息开发一系列复杂的特征</p>
</li>
<li><p>基于邮件的正文信息开发一系列复杂的特征，包括考虑截词的处理</p>
</li>
<li><p>为探测刻意的拼写错误（把 watch 写成 w4tch）开发复杂的算法</p>
</li>
</ol>
<p>在上面这些选项中，非常难决定应该在哪一项上花费时间和精力，作出明智的选择，比随着感觉走要更好。当我们使用机器学习时，总是可以“头脑风暴”一下，想出一堆方法来试试。</p>
<h2 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h2><p>如果你准备研究机器学习的东西，或者构造机器学习应用程序，最好的实践方法不是建立一个非常复杂的系统，拥有多么复杂的变量；而是<strong>构建一个简单的算法</strong>，这样你可以很快地实现它。</p>
<p>研究机器学习的问题时，先很快地把结果搞出来，即便运行得不完美，但是也把它运行一遍，最后通过<strong>交叉验证</strong>来检验数据。一旦做完，你可以画出<strong>学习曲线</strong>，通过画出学习曲线，以及<strong>检验误差</strong>，来找出你的算法是否有<strong>高偏差和高方差</strong>的问题，或者别的问题。在这样分析之后，再来决定用<strong>更多的数据</strong>训练，或者加入<strong>更多的特征变量</strong>是否有用。</p>
<p>因为我们并不能提前知道是否需要复杂的特征变量，或者是否需要更多的数据，还是别的什么。提前知道应该做什么，是非常难的，因为缺少证据，缺少学习曲线。因此，很难知道应该把时间花在什么地方来提高算法的表现。但是当实践一个非常简单即便不完美的方法时，就可以通过画出学习曲线来做出进一步的选择。</p>
<p>除了画学习曲线外还有一个方法就是进行误差分析，例如当我们在构造垃圾邮件分类器时，我会看一看我的交叉验证数据集，然后亲自看一看哪些邮件被算法错误地分类。因此，通过这些被算法错误分类的垃圾邮件与非垃圾邮件，你可以发现某些系统性的规律：什么类型的邮件总是被错误分类。经常地这样做之后，这个过程能启发你构造新的特征变量，或者告诉你：现在这个系统的短处，然后启发你如何去提高它。</p>
<p>具体一点就是，检验交叉验证集中我们的算法产生错误预测的所有邮件，看：是否能将这些邮件按照类分组。例如医药品垃圾邮件，仿冒品垃圾邮件或者密码窃取邮件等。然后看分类器对哪一组邮件的预测误差最大，并着手优化。思考怎样能改进分类器。例如，发现是否缺少某些特征，记下这些特征出现的次数。</p>
<p>误差分析并不总能帮助我们判断应该采取怎样的行动。有时我们需要<strong>尝试不同的模型</strong>，然后进行比较，在模型比较时，用数值来判断哪一个模型更好更有效，通常我们是<strong>看交叉验证集的误差</strong>。</p>
<p>因此，在构造学习算法的时候，总是会去尝试很多新的想法，实现出很多版本的学习算法，如果每一次实践新想法的时候，都要手动地检测这些例子，去看看是表现差还是表现好，那么这很难让你做出决定。但是通过一个<strong>量化的数值评估</strong>（那些代码里自己计算的准确度？），你可以看看这个数字，误差是变大还是变小了。你可以通过它更快地实践你的新想法，它基本上非常直观地告诉你：你的想法是提高了算法表现，还是让它变得更坏，这会大大提高你实践算法时的速度。</p>
<p><strong>在交叉验证集上来实施误差分析</strong></p>
<h2 id="类偏斜的误差度量"><a href="#类偏斜的误差度量" class="headerlink" title="类偏斜的误差度量"></a>类偏斜的误差度量</h2><p>误差度量值：设定某个实数来评估你的学习算法，并衡量它的表现。</p>
<p>类偏斜情况表现为我们的训练集中有非常多的同一种类的实例，只有很少或没有其他类的实例。</p>
<p>例如我们希望用算法来预测癌症是否是恶性的，在我们的训练集中，只有 0.5%的实例是恶性肿瘤。假设我们编写一个非学习而来的算法，在所有情况下都预测肿瘤是良性的，那么误差只有 0.5%。然而我们通过训练而得到的神经网络算法却有 1%的误差。这时，误差的大小是不能视为评判算法效果的依据的。</p>
<p>我们将算法预测的结果分成四种情况：</p>
<ol>
<li><p>正确肯定（ True Positive,TP）：预测为真，实际为真</p>
</li>
<li><p>正确否定（ True Negative,TN）：预测为假，实际为假</p>
</li>
<li><p>错误肯定（ False Positive,FP）：预测为真，实际为假</p>
</li>
<li><p>错误否定（ False Negative,FN）：预测为假，实际为真</p>
</li>
</ol>
<p>查准率（Precision）&#x3D;TP&#x2F;(TP+FP)。例，在所有我们预测有恶性肿瘤的病人中，实际上有恶性肿瘤的病人的百分比，越高越好。</p>
<p>查全率（Recall）&#x3D;TP&#x2F;(TP+FN)。例，在所有实际上有恶性肿瘤的病人中，成功预测有恶性肿瘤的病人的百分比，越高越好。</p>
<p>对于刚才那个总是预测病人肿瘤为良性的算法，其查全率是 0。</p>
<h2 id="查准率和查全率之间的权衡"><a href="#查准率和查全率之间的权衡" class="headerlink" title="查准率和查全率之间的权衡"></a>查准率和查全率之间的权衡</h2><p>假设，我们的算法输出的结果在 0-1 之间，我们使用阀值 0.5 来预测真和假。</p>
<p>如果我们希望只在非常确信的情况下预测为真（肿瘤为恶性），即我们希望更高的查准率，我们可以使用比 0.5 更大的阀值，如 0.7， 0.9。这样做我们会减少错误预测病人为恶性肿瘤的情况，同时却会增加未能成功预测肿瘤为恶性的情况。</p>
<p>如果我们希望提高查全率，尽可能地让所有有可能是恶性肿瘤的病人都得到进一步地检查、诊断，我们可以使用比 0.5 更小的阀值，如 0.3。</p>
<p>可以将不同阀值情况下，查全率与查准率的关系绘制成图表，曲线的形状根据数据的不同而不同：threshould是临界值的意思</p>
<img src="../source/imgs/${fiilname}/image-20250721214238005.png" alt="image-20250721214238005" style="zoom:50%;" />

<p>查准率-召回率曲线会有多种形状</p>
<p>有一个帮助我们选择这个阀值的方法。一种方法是计算 F1 值（ F1 Score），其计算公式为：<br>$$<br>F_1 Score:2 \frac{PR}{P+R}<br>$$<br>我们选择使得 F1 值最高的阀值。</p>
<h1 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h1><h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><p>在监督学习中，许多学习算法的性能都非常类似，因此，重要的不是该选择使用学习算法 A 还是学习算法 B，而更重要的是，应用这些算法时，表现情况通常依赖于你的水平。比如：你为学习算法所设计的特征量的选择，以及如何选择正则化参数，诸如此类的事。</p>
<p>与逻辑回归和神经网络相比，支持向量机，或者简称 SVM，在学习复杂的非线性方程时提供了一种更为清晰，更加强大的方式。</p>
<p>从逻辑回归开始来展示如何一点一点修改来得到本质上的支持向量机。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250723154655767.png" alt="image-20250723154655767"></p>
<p>逻辑回归中一个训练样本所对应代价函数表达式：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250723154803433.png" alt="image-20250723154803433"></p>
<p>当y&#x3D;1时，只有第一项起了作用。对第一项进行修改，得出SVM中将要使用的代价函数（粉色线），由两段直线组成，暂时不用考虑左侧直线的斜率，因为那个不重要，这个将要使用的代价函数是在y&#x3D;1的前提条件下的。新的代价函数叫作cost1(z)</p>
<img src="../source/imgs/${fiilname}/image-20250723155621382.png" alt="image-20250723155621382" style="zoom:50%;" />

<p>当y&#x3D;0时，新的代价函数叫作cost0(z)</p>
<img src="../source/imgs/${fiilname}/image-20250723155656291.png" alt="image-20250723155656291" style="zoom:50%;" />

<p>然后接下来开始构造支持向量机。</p>
<p>这是逻辑回归中所用到的代价函数<img src="../source/imgs/${fiilname}/image-20250723155830604.png" alt="image-20250723155830604" style="zoom:35%;" /></p>
<p>对于支持向量机来说，要将里面的两项进行替换：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250723160141378.png" alt="image-20250723160141378"></p>
<p>但实际上，对于支持向量机来说，代价函数的书写会有所不同。首先要去掉1&#x2F;m这一项，去掉之后也会得出同样的theta最优值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250723160335561.png" alt="image-20250723160335561"></p>
<p>因为1&#x2F;𝑚 仅是个常量，因此，你知道在这个最小化问题中，无论前面是否有1&#x2F;𝑚 这一项，最终我所得到的最优值𝜃都是一样的。这里我的意思是，先给你举一个实例，假定有一最小化问题：即要求当<img src="../source/imgs/${fiilname}/image-20250723160432705.png" alt="image-20250723160432705" style="zoom:40%;" />取得最小值时的𝑢值，这时最小值为：当𝑢 &#x3D; 5时取得最小值。  </p>
<p>现在，如果我们想要将这个目标函数乘上常数 10，这里我的最小化问题就变成了：求使得10 × (𝑢 - 5)2 + 10最小的值𝑢，然而，使得这里最小的𝑢值仍为 5。因此将一些常数乘以你的最小化项，这并不会改变最小化该方程时得到𝑢值。因此，这里我所做的是删去常量𝑚。也相同的，我将目标函数乘上一个常量𝑚，并不会改变取得最小值时的𝜃值。  </p>
<p>用A来表示不包括正则项的部分，也就是训练样本的代价，用B来表示不包括lamda的正则项。这就相当于我们想要最小化𝐴加上正则化参数𝜆乘以𝐵，𝐴 + 𝜆 × 𝐵  ，我们所做的是通过设置不同正则参数𝜆达到优化目的。这样，我们就能够权衡对应的项，即最小化𝐴，是使得训练样本拟合的更好。还是保证正则参数足够小，也即是对于 B 项而言。  </p>
<p>但对于支持向量机，按照惯例，我们将使用一个不同的参数替换这里使用的𝜆来权衡这两项。就是第一项和第二项我们依照惯例使用一个不同的参数称为𝐶，同时改为优化目标， 𝐶 × 𝐴 + 𝐵因此，在逻辑回归中，如果给定𝜆，一个非常大的值，意味着给予 B 更大的权重。而这里，就对应于将𝐶 设定为非常小的值，那么，相应的将会给𝐵比给𝐴更大的权重。因此，这只是一种不同的方式来控制这种权衡或者一种不同的方法，即用参数来决定是更关心第一项的优化，还是更关心第二项的优化。当然你也可以把这里的参数𝐶 考虑成1&#x2F;𝜆，同 1&#x2F;𝜆所扮演的角色相同，并且这两个方程或这两个表达式并不相同，因为𝐶 &#x3D; 1&#x2F;𝜆，但是也并不全是这样，如果当𝐶 &#x3D; 1&#x2F;𝜆时，这两个优化目标应当得到相同的值，相同的最优值 𝜃。<img src="../source/imgs/${fiilname}/image-20250723161453967.png" alt="image-20250723161453967" style="zoom:50%;" /></p>
<p>因此，这就得到了在支持向量机中我们的整个优化目标函数。然后最小化这个目标函数，得到 SVM 学习到的参数𝐶。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250723161626830.png" alt="image-20250723161626830"></p>
<p>有别于逻辑回归输出的概率，在这里，当最小化代价函数得到参数𝜃时，支持向量机会直接预测y的值等于1还是等于0</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250723161853417.png" alt="image-20250723161853417"></p>
<h2 id="大边界的直观理解"><a href="#大边界的直观理解" class="headerlink" title="大边界的直观理解"></a>大边界的直观理解</h2><p>人们有时将支持向量机看作是大间距分类器。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250723173243880.png" alt="image-20250723173243880"></p>
<p>这是支持向量机模型的代价函数，左边是关于𝑧的代价函数cos𝑡1(𝑧)，此函数用于正样本，而右边是关于𝑧的代价函数cos𝑡0(𝑧)，横轴表示𝑧，现在让我们考虑一下，最小化这些代价函数的必要条件是什么。如果你有一个正样本， 𝑦 &#x3D; 1，则只有在𝑧 &gt;&#x3D; 1时，代价函数cos𝑡1(𝑧)才等于 0。</p>
<p>换句话说，如果你有一个正样本，我们会希望𝜃𝑇𝑥&gt;&#x3D;1，反之，如果𝑦 &#x3D; 0，它只有在𝑧 &lt;&#x3D; -1的区间里函数值为 0。</p>
<p>事实上，（可以放入逻辑回归问题中理解）如果有一个正样本𝑦 &#x3D; 1，则其实我们仅仅要求𝜃𝑇𝑥大于等于 0，就能将该样本恰当分出，这是因为如果𝜃𝑇𝑥&gt;0 大的话，我们的模型代价函数值为 0，类似地，如果有一个负样本，则仅需要𝜃𝑇𝑥&lt;&#x3D;0 就会将负例正确分离，但是，支持向量机的要求更高，不仅仅要能正确分开输入的样本，即不仅仅要求𝜃𝑇𝑥&gt;0，我们需要的是比 0 值大很多，比如大于等于 1，我也想分离负例时比 0 小很多，比如我希望它小于等于-1，这就相当于在支持向量机中嵌入了一个额外的安全因子，或者说<strong>安全的间距因子</strong>。</p>
<p>在支持向量机中，这个因子会导致什么结果。接下来考虑一个特例，将这个常数𝐶设置成一个非常大的值。比如假设𝐶的值为 100000 或者其它非常大的数，然后来观察支持向量机会给出什么结果？</p>
<p>如果 𝐶非常大，则最小化代价函数的时候，我们将会很希望找到一个使第一项为 0 的最优解，因为cost&#x3D;𝐶 × 𝐴 + 𝐵。因此，让我们尝试在代价项的第一项为 0 的情形下理解该优化问题。</p>
<p>输入一个训练样本标签为𝑦 &#x3D; 1，想令第一项为 0，需要做的是找到一个𝜃，使得𝜃𝑇𝑥 &gt;&#x3D; 1，类似地，对于一个训练样本，标签为𝑦 &#x3D; 0，为了使cos𝑡0(𝑧) 函数的值为 0，我们需要𝜃𝑇𝑥 &lt;&#x3D; -1。因此，现在考虑优化问题。选择参数，使得第一项等于 0，因此这个函数的第一项为 0，因此是𝐶乘以 0 加上二分之一乘以第二项。这里第一项是𝐶乘以 0，因此可以将其删去。</p>
<p>这将遵从以下的约束：<br>$$<br>θ^T x^{(i)}&gt;&#x3D;1，如果 y^{(i)}是等于1 的;θ^T x^{(i)}&lt;&#x3D;-1，如果样本i是一个负样本<br>$$<br>具体而言，如果你考察这样一个数据集，其中有正样本，也有负样本，可以看到这个数据集是线性可分的。</p>
<img src="../source/imgs/${fiilname}/image-20250723174423968.png" alt="image-20250723174423968" style="zoom:50%;" />

<p>粉色和绿色的决策边界仅仅是勉强分开，这些决策边界看起来都不是特别好的选择，支持向量机将会选择这个黑色的决策边界。</p>
<p>黑线看起来是更稳健的决策界。在分离正样本和负样本上它显得的更好。数学上来讲，这条黑线有更大的距离，这个距离叫做<strong>间距</strong>。</p>
<img src="../source/imgs/${fiilname}/image-20250723174612817.png" alt="image-20250723174612817" style="zoom:50%;" />

<p>当画出这两条额外的蓝线，我们看到黑色的决策界和训练样本之间有更大的最短距离。然而粉线和蓝线离训练样本就非常近，在分离样本的时候就会比黑线表现差。因此，这个距离叫做<strong>支持向量机的间距</strong>，而这是支持向量机具有鲁棒性的原因，因为它努力用一个最大间距来分离样本。因此支持向量机有时被称为<strong>大间距分类器</strong>。</p>
<p>鲁棒性：指模型在面对数据中的噪声、异常值、干扰或环境变化时，仍能保持稳定预测性能的能力。也就是模型的“抗干扰”和“抗压”能力。</p>
<p>支持向量机模型的做法，即努力将正样本和负样本用<strong>最大的间距</strong>分开。</p>
<p>在上面将这个大间距分类器中的正则化因子常数𝐶设置的非常大，因此对这样的一个数据集，也许我们将选择这样的决策界，从而最大间距地分离开正样本和负样本。那么在让代价函数最小化的过程中，我们希望找出在𝑦 &#x3D; 1和𝑦 &#x3D; 0两种情况下都使得代价函数中左边的这一项尽量为零的参数。如果我们找到了这样的参数，则我们的最小化问题便转变成：<img src="../source/imgs/${fiilname}/image-20250723175052807.png" alt="image-20250723175052807" style="zoom:67%;" /></p>
<p>但是，当你使用大间距分类器的时候，你的学习算法会受异常点的影响。比如我们加入一个额外的正样本。</p>
<img src="../source/imgs/${fiilname}/image-20250723175151165.png" alt="image-20250723175151165" style="zoom:50%;" />

<p>在这里，如果加了这个样本，为了将样本用最大间距分开，也许最终会得到一条类似粉色这样的决策界，仅仅基于一个异常值，仅仅基于一个样本，就将我的决策界从这条黑线变到这条粉线，这实在是不明智的。而如果正则化参数𝐶，设置的非常大，这事实上正是支持向量机将会做的。</p>
<p>**但如果将 C 设置的不要太大，则最终会得到这条黑线。当𝐶不是非常非常大的时候，它可以忽略掉一些异常点的影响，得到更好的决策界。 **</p>
<p>数据如果不是线性可分的，支持向量机也会将它们恰当分开。</p>
<p>因此，大间距分类器的描述，仅仅是从直观上给出了<strong>正则化参数𝐶非常大</strong>的情形，同时，要提醒你𝐶的作用类似于1&#x2F;𝜆， 𝜆是我们之前使用过的正则化参数，因此：</p>
<p><strong>𝐶 较大时，相当于 𝜆 较小，可能会导致过拟合，高方差。</strong></p>
<p><strong>𝐶 较小时，相当于 𝜆 较大，可能会导致低拟合，高偏差。</strong></p>
<h2 id="大边界分类背后的数学（-选修）"><a href="#大边界分类背后的数学（-选修）" class="headerlink" title="大边界分类背后的数学（ 选修）"></a>大边界分类背后的数学（ 选修）</h2><p>向量内积：有两个向量u和v，两个都是二维向量<img src="../source/imgs/${fiilname}/image-20250724201740274.png" alt="image-20250724201740274" style="zoom:40%;" />，<img src="../source/imgs/${fiilname}/image-20250724201902313.png" alt="image-20250724201902313" style="zoom:50%;" />也叫做向量𝑢和𝑣之间的内积。</p>
<p>除了这种计算方式外还有一种计算方式。</p>
<p>先把这两个向量画出来，向量𝑢即在横轴上，取值为某个𝑢1，而在纵轴上，高度是某个𝑢2作为𝑢的第二个分量。向量v也按同样的步骤画出来。 ∥𝑢∥表示𝑢的范数，即𝑢的长度，即向量𝑢的欧几里得长度。<br>$$<br>∥u∥&#x3D;\sqrt{(u_1^2+u_2^2 )},这是向量𝑢的长度，它是一个实数。<br>$$<br>计算内积：将向量𝑣投影到向量𝑢上，做一个直角投影，或者说一个 90 度投影将其投影到𝑢上，接下来度量这条红线的长度。称这条红线的长度为𝑝，因此𝑝就是长度，或者说是向量𝑣投影到向量𝑢上的量。<img src="../source/imgs/${fiilname}/image-20250724202521124.png" alt="image-20250724202521124" style="zoom:50%;" /><br>$$<br>公式是u^T v&#x3D;p⬝∥u∥<br>$$<br>因为𝑢𝑇𝑣 &#x3D; 𝑣𝑇𝑢。因此如果你将𝑢和𝑣交换位置，将𝑢投影到𝑣上，而不是将𝑣投影到𝑢上，然后做同样的计算，只是把𝑢和𝑣的位置交换一下，你事实上可以得到同样的结果。申明一点，在这个等式中𝑢的范数是一个实数， 𝑝也是一个实数，因此𝑢𝑇𝑣就是两个实数正常相乘。</p>
<p><strong>𝑝事实上是有符号的，即它可能是正值，也可能是负值。</strong></p>
<p>这种情况下的p就是负值<img src="../source/imgs/${fiilname}/image-20250724202737933.png" alt="image-20250724202737933" style="zoom:50%;" /></p>
<img src="../source/imgs/${fiilname}/image-20250724203531832.png" alt="image-20250724203531832" style="zoom:67%;" />

<p>这是支持向量机模型中的目标函数，为了让它更容易分析，忽略掉截距，令𝜃0 &#x3D; 0，将特征数𝑛置为 2，因此仅有两个特征𝑥1, 𝑥2，现在来看一下支持向量机的优化目标函数，这个式子可以写作：<br>$$<br>\frac{1}{2} (θ_1^2+θ_2^2 )&#x3D;\frac{1}{2} {(\sqrt{θ_1^2+θ_2^2 })}^2<br>$$<br>后面括号里面的那一项是向量𝜃的范数，或者说是向量𝜃的长度,因此支持向量机做的全部事情，就是<strong>极小化参数向量𝜃范数的平方，或者说长度的平方</strong>。</p>
<p>深入理解𝜃Tx的含义，𝜃和𝑥(𝑖)就类似于𝑢和𝑣 。<img src="../source/imgs/${fiilname}/image-20250724204552407.png" alt="image-20250724204552407" style="zoom:67%;" /></p>
<p>看这个图，考察一个单一的训练样本，我有一个正样本在这里，用一个叉来表示这个样本𝑥(𝑖)，意思是在水平轴上取值为𝑥1(𝑖)，在竖直轴上取值为𝑥2(𝑖)，然后将参数向量也画上去，那么内积<img src="../source/imgs/${fiilname}/image-20250724204757937.png" alt="image-20250724204757937" style="zoom:50%;" />将会是什么？</p>
<p>使用之前的计算方式就是将训练样本投影到参数向量𝜃，然后将投影的长度画成红色。𝑝(𝑖)用来表示这是第 𝑖个训练样本在参数向量𝜃上的投影。根据我们之前的内容，𝜃𝑇𝑥(𝑖)将会等于𝑝 乘以向量 𝜃 的长度或范数。这就等于𝜃1 ⋅ 𝑥1(𝑖) + 𝜃2 ⋅ 𝑥2(𝑖)。这两种方式是等价的，都可以用来计算𝜃和𝑥(𝑖)之间的内积。</p>
<p>这里表达的意思是：这个𝜃𝑇𝑥(𝑖) &gt;&#x3D; 1的约束是可以被𝑝(𝑖) ⋅ ∥𝜃∥ &gt;&#x3D; 1这个约束所代替的。因为𝜃𝑇𝑥(𝑖) &#x3D; 𝑝(𝑖) ⋅ ∥𝜃∥ ，将其写入我们的优化目标。前面说过优化函数可以写为<img src="../source/imgs/${fiilname}/image-20250724210137118.png" alt="image-20250724210137118" style="zoom:50%;" /></p>
<img src="../source/imgs/${fiilname}/image-20250724205949128.png" alt="image-20250724205949128" style="zoom:67%;" />

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250724211020353.png" alt="image-20250724211020353"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250724211042793.png" alt="image-20250724211042793"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250724211153497.png" alt="image-20250724211153497"></p>
<p>以上就是为什么支持向量机最终会找到大间距分类器的原因。因为它试图<strong>极大化这些𝑝(𝑖)的范数</strong>，它们是训练样本到决策边界的距离。最后一点，我们的推导自始至终使用了这个简化<strong>假设</strong>，就是<strong>参数𝜃0 &#x3D; 0</strong>。</p>
<p>𝜃0 &#x3D; 0的意思是我们让决策界通过原点。如果你令𝜃0不是 0 的话，含义就是你希望决策界不通过原点。即便𝜃0不等于 0，支持向量机仍然会找到正样本和负样本之间的大间距分隔。</p>
<h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>给 定 一 个 训 练 实 例 𝑥 ， 我 们 利 用 𝑥 的 各 个 特 征 与 我 们 预 先 选 定 的 地 标(landmarks)𝑙(1), 𝑙(2), 𝑙(3)的近似程度来选取新的特征𝑓1, 𝑓2, 𝑓3。<img src="../source/imgs/${fiilname}/image-20250724214443211.png" alt="image-20250724214443211" style="zoom:67%;" /><br>$$<br>例如：f_1&#x3D;similarity(x,l^{(1)})&#x3D;e^{(-\frac{∥x-l^{(1)} ∥^2}{2σ^2 })}<br>$$</p>
<p>$$<br>其中∥x-l^{(1)} ∥^2&#x3D;∑_{j&#x3D;1}^n(x_j-l_j^{(1)})^2，为实例𝑥中所有特征与地标𝑙(1)之间的距离的平方的和。<br>$$</p>
<p>上例中的𝑠𝑖𝑚𝑖𝑙𝑎𝑟𝑖𝑡𝑦(𝑥, 𝑙(1))就是核函数，具体而言，这里是一个高斯核函数。这个函数与正态分布没什么实际上的关系，只是看上去像而已。</p>
<p>这些地标的作用是什么？如果一个训练实例𝑥与地标𝐿之间的距离近似于 0，则新特征 𝑓近似于<img src="../source/imgs/${fiilname}/image-20250724214955023.png" alt="image-20250724214955023" style="zoom:50%;" />，如果训练实例𝑥与地标𝐿之间距离较远，则𝑓近似于<img src="../source/imgs/${fiilname}/image-20250724215029521.png" alt="image-20250724215029521" style="zoom:50%;" />。</p>
<p>假设我们的训练实例含有两个特征[𝑥1 𝑥2]，给定地标𝑙(1)与不同的𝜎值，见下图：<img src="../source/imgs/${fiilname}/image-20250724215112385.png" alt="image-20250724215112385" style="zoom:60%;" /></p>
<p>图中水平面的坐标为 𝑥1， 𝑥2而垂直坐标轴代表𝑓。可以看出，只有当𝑥与𝑙(1)重合时𝑓才具有最大值。随着𝑥的改变𝑓值改变的速率受到𝜎2的控制。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250724215153621.png" alt="image-20250724215153621"></p>
<p><strong>如何选择地标？</strong></p>
<p>通常是根据训练集的数量选择地标的数量，即如果训练集中有𝑚个实例，则选取𝑚个地标，并且令:𝑙(1) &#x3D; 𝑥(1), 𝑙(2) &#x3D; 𝑥(2), . . . . . , 𝑙(𝑚) &#x3D; 𝑥(𝑚)。这样做的好处在于：现在得到的新特征是建立在原有特征与训练集中所有其他特征之间距离的基础之上的，即：</p>
<img src="../source/imgs/${fiilname}/image-20250724220214226.png" alt="image-20250724220214226" style="zoom:50%;" />

<p>下面我们将核函数运用到支持向量机中，修改我们的支持向量机假设为：</p>
<p>给定𝑥，计算新特征𝑓，当𝜃𝑇𝑓 &gt;&#x3D; 0 时，预测 𝑦 &#x3D; 1，否则反之。</p>
<p>相应地修改代价函数为：<img src="../source/imgs/${fiilname}/image-20250724220321510.png" alt="image-20250724220321510" style="zoom:67%;" />，在计算这个的时候还需要做一些调整，用<img src="../source/imgs/${fiilname}/image-20250724220419238.png" alt="image-20250724220419238" style="zoom:50%;" />代替<img src="../source/imgs/${fiilname}/image-20250724220439325.png" alt="image-20250724220439325" style="zoom:50%;" />，其中𝑀是根据我们选择的核函数而不同的一个矩阵。这样做的原因是为了简化计算。</p>
<p>理论上讲，我们也可以在逻辑回归中使用核函数，但是上面使用 𝑀来简化计算的方法不适用于逻辑回归，因此计算将非常耗费时间。</p>
<p>逻辑回归的核心是建模样本术语某个类别的概率，输出是一个概率值（0到1之间），它本质上是概率模型。SVM的目标是找到一个几何间隔最大的超平面进行硬分类（每个样本只能被明确划分到一个类别，逻辑回归是软分类，最终分类取概率最高的类别），输出的是确定的类别标签（如+1&#x2F;-1），本质上是几何间隔最大化模型。</p>
<p>可以直接使用现有的软件包来最小化支持向量机的代价函数，但在使用这些软件包最小化我们的代价函数之前，我们通常需要<strong>编写核函数</strong>，并且如果我们使用高斯核函数，那么在使用之前进行<strong>特征缩放</strong>是非常必要的。</p>
<p>另外，支持向量机也可以不使用核函数，不使用核函数又称为线性核函数，当我们不采用非常复杂的函数，或者我们的训练集特征非常多而实例非常少的时候，可以采用这种不带核函数的支持向量机。</p>
<h2 id="使用支持向量机"><a href="#使用支持向量机" class="headerlink" title="使用支持向量机"></a>使用支持向量机</h2><p>在高斯核函数之外我们还有其他一些选择，如：</p>
<p>多项式核函数（ Polynomial Kernel）</p>
<p>字符串核函数（ String kernel）</p>
<p>卡方核函数（ chi-square kernel）</p>
<p>直方图交集核函数（ histogram intersection kernel）等等…</p>
<p>这些核函数的目标也都是根据训练集和地标之间的距离来构建新特征，这些核函数需要满足 Mercer’s 定理，才能被支持向量机的优化软件正确处理。</p>
<p><strong>多类分类问题</strong></p>
<p>假设我们利用之前介绍的一对多方法来解决一个多类分类问题。如果一共有𝑘个类，则我们需要𝑘个模型，以及𝑘个参数向量𝜃。我们同样也可以训练𝑘个支持向量机来解决多类分类问题。但是大多数支持向量机软件包都有内置的多类分类功能，我们只要直接使用即可。</p>
<p>尽管不写自己的 SVM 的优化软件，但是也需要做几件事：</p>
<p>1、是提出参数𝐶的选择。因为偏差&#x2F;方差在这方面的性质。</p>
<p>2、也需要选择内核参数或你想要使用的相似函数，其中一个选择是：选择不需要任何内核参数，没有内核参数的理念，也叫线性核函数。因此，如果有人说他使用了线性核的 SVM（支持向量机），这就意味这他使用了不带有核函数的 SVM（支持向量机）。</p>
<p><strong>如何选择逻辑回归模型和支持向量机模型</strong></p>
<p>𝑛为特征数， 𝑚为训练样本数。</p>
<p>(1)如果相较于𝑚而言， 𝑛要大许多，即训练集数据量不够支持我们训练一个复杂的非线性模型，我们选用逻辑回归模型（模型相对简单，可以通过正则化来强制减少有效特征数量或参数大小，进一步抵抗过拟合）或者不带核函数的支持向量机（本质上是找一个最大化边距的线性分割超平面）。</p>
<p>放弃学习复杂的非线性关系，专注于找到一个稳健的线性决策边界，首要目标是防止过拟合。</p>
<p>(2)如果𝑛较小，而且𝑚大小中等，例如𝑛在 1-1000 之间，而𝑚在 10-10000之间，使用高斯核函数的支持向量机。</p>
<p>(3)如果𝑛较小，而𝑚较大，例如𝑛在 1-1000 之间，而𝑚大于 50000，则使用支持向量机会非常慢（计算成本爆炸），解决方案是创造、增加更多的特征（生成原始特征的多项式组合），然后使用逻辑回归或不带核函数的支持向量机。</p>
<p><strong>核心原则：</strong></p>
<ul>
<li>**特征少 (n 小)**：更容易构建复杂的非线性模型而不过拟合（数据相对充足）。</li>
<li>**特征多 (n 大)**：使用复杂模型非常容易过拟合，需要简化模型或更多数据。</li>
<li>**样本少 (m 小)**：不足以支撑复杂模型训练，需要使用简单模型防止过拟合。</li>
<li>**样本多 (m 大)**：能支撑更复杂模型的训练，但有些复杂模型（如带核函数的SVM）会变得非常慢。</li>
</ul>
<p>值得一提的是，神经网络在以上三种情况下都可能会有较好的表现，但是训练神经网络可能非常慢，选择支持向量机的原因主要在于它的代价函数是凸函数，不存在局部最小值。</p>
<p>当有非常非常大的训练集，且用高斯核函数的情况下，经常会做的是尝试手动地创建，拥有更多的特征变量，然后用逻辑回归或者不带核函数的支持向量机。</p>
<p>逻辑回归和不带核函数的支持向量机它们都是非常相似的算法，不管是逻辑回归还是不带核函数的 SVM，通常都会做相似的事情，并给出相似的结果。但是根据实现的情况，其中一个可能会比另一个更加有效。</p>
<p><strong>神经网络使用于什么时候呢？</strong></p>
<p>对于所有的这些问题，对于所有的这些不同体系一个设计得很好的神经网络也很有可能会非常有效。有一个缺点是，或者说是有时可能不会使用神经网络的原因是：对于许多这样的问题，神经网络训练起来可能会特别慢。</p>
<p>SVM 是一种<strong>凸优化问题</strong>。因此，好的 SVM优化软件包总是会找到全局最小值，或者接近它的值。对于 SVM 你<strong>不需要担心局部最优</strong>。</p>
<p>不能确定需要使用哪种算法没关系，算法确实很重要。但是通常更加重要的是：你有多少数据，你有多熟练是否擅长做误差分析和排除学习算法，指出如何设定新的特征变量和找出其他能决定你学习算法的变量等方面。</p>
<h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><h2 id="无监督学习：简介"><a href="#无监督学习：简介" class="headerlink" title="无监督学习：简介"></a>无监督学习：简介</h2><p>在非监督学习中，我们的数据没有附带任何标签，我们拿到的数据就是这样的：<img src="../source/imgs/${fiilname}/image-20250804205845167.png" alt="image-20250804205845167" style="zoom:40%;" /></p>
<p>在这里有一系列点，却没有标签。因此，训练集可以写成只有𝑥(1),𝑥(2)…..一直到𝑥(𝑚)，没有任何标签𝑦。</p>
<p>在非监督学习中，我们需要将一系列无标签的训练数据，输入到一个算法中，然后我们告诉这个算法，快去为我们找找这个数据的<strong>内在结构</strong>。图上的数据看起来可以分成两个分开的点集（称为<strong>簇</strong>），一个能够<strong>找到这些点集</strong>的算法（不只是找到簇，也可以是找到其他类型的结构或者其他的一些模式），就被称为聚类算法。</p>
<h2 id="K-均值算法"><a href="#K-均值算法" class="headerlink" title="K-均值算法"></a>K-均值算法</h2><p>K-均值是最普及的聚类算法，算法接受一个未标记的数据集，然后将数据聚类成不同的组。</p>
<p>也可以使用这个算法进行图像压缩。</p>
<p>K-均值是一个<strong>迭代算法</strong>，假设我们想要将数据聚类成 n 个组，其方法为:</p>
<ol>
<li>首先选择𝐾个随机的点，称为聚类中心；</li>
<li>对于数据集中的每一个数据，按照距离𝐾个中心点的距离，将其与距离最近的中心点关联起来，与同一个中心点关联的所有点聚成一类。</li>
<li>计算每一个组的平均值，将该组所关联的中心点移动到平均值的位置。</li>
<li>重复步骤 2-4 直至中心点不再变化。</li>
</ol>
<p>下面是一个聚类示例：</p>
<p><img src="../source/imgs/${fiilname}/image-20250804211343346.png" alt="image-20250804211343346" style="zoom:33%;" /><img src="../source/imgs/${fiilname}/image-20250804211403431.png" alt="image-20250804211403431" style="zoom:33%;" /><img src="../source/imgs/${fiilname}/image-20250804211438583.png" alt="image-20250804211438583" style="zoom:33%;" /></p>
<p>用𝜇1,𝜇2,…,𝜇𝑘 来表示聚类中心，用𝑐(1),𝑐(2),…,𝑐(𝑚)来存储与第𝑖个实例数据最近的聚类中心的索引， K-均值算法的伪代码如下：  </p>
<pre><code class="hljs plaintext">Repeat &#123;
for i = 1 to m
c(i) := index (form 1 to K) of cluster centroid closest to x(i)
for k = 1 to K
μk := average (mean) of points assigned to cluster k
&#125;</code></pre>

<p>算法分为两个步骤，第一个 for 循环是赋值步骤，即：对于每一个样例𝑖，计算其应该属于的类。第二个 for 循环是聚类中心的移动，即：对于每一个类𝐾，重新计算该类的质心。</p>
<p>K-均值算法也可以很便利地用于将数据分为许多不同组，即使在没有非常明显区分的组群的情况下也可以。下图所示的数据集包含身高和体重两项特征构成的，利用 K-均值算法将数据分为三类，用于帮助确定将要生产的 T-恤衫的三种尺寸。（感觉是你想分成几类就选择几个随机点）</p>
<img src="../source/imgs/${fiilname}/image-20250804211755437.png" alt="image-20250804211755437" style="zoom:67%;" />

<h2 id="优化目标-1"><a href="#优化目标-1" class="headerlink" title="优化目标"></a>优化目标</h2><p>K-均值最小化问题，是要最小化所有的数据点与其所关联的聚类中心点之间的距离之和，因此 K-均值的代价函数（又称畸变函数 ）为：<br>$$<br>J(c^{(1)},…,c^{(m)},μ_1,…,μ_K)&#x3D;\frac{1}{m} ∑_{i&#x3D;1}^m∥X^{(i)}-μ_{c^{(i)} } ∥^2,其中μ_{c^{(i)} }代表与x^{(i)}最近的聚类中心点。<br>$$<br>我们的的优化目标便是找出使得代价函数最小的 𝑐(1),𝑐(2),…,𝑐(𝑚)和𝜇1,𝜇2,…,𝜇𝑘：<img src="../source/imgs/${fiilname}/image-20250804213232602.png" alt="image-20250804213232602" style="zoom:33%;" /></p>
<pre><code class="hljs plaintext">Repeat &#123;
for i = 1 to m
c(i) := index (form 1 to K) of cluster centroid closest to x(i)
for k = 1 to K
μk := average (mean) of points assigned to cluster k
&#125;</code></pre>

<p>根据这个代码可以看出，第一个循环是用于减小𝑐(𝑖)引起的代价，而第二个循环则是用于减小𝜇𝑖引起的代价。迭代的过程一定会是每一次迭代都在减小代价函数。</p>
<h2 id="随机初始化-1"><a href="#随机初始化-1" class="headerlink" title="随机初始化"></a>随机初始化</h2><p>在运行 K-均值算法的之前，我们首先要<strong>随机初始化</strong>所有的聚类中心点，下面介绍怎样做：</p>
<ol>
<li><p>我们应该选择𝐾 &lt; 𝑚，即聚类中心点的个数要小于所有训练集实例的数量</p>
</li>
<li><p>随机选择𝐾个训练实例，然后令𝐾个聚类中心分别与这𝐾个训练实例相等</p>
</li>
</ol>
<p>K-均值的一个问题在于，它有可能会停留在一个局部最小值处，而这取决于初始化的情况。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250804213840471.png" alt="image-20250804213840471"></p>
<p>为了解决这个问题，我们通常需要<strong>多次运行</strong> K-均值算法，每一次都重新进行随机初始化，最后再比较多次运行 K-均值的结果，选择<strong>代价函数最小</strong>的结果。这种方法在<strong>𝐾较小</strong>的时候（ 2–10）还是可行的，但是如果𝐾较大，这么做也可能不会有明显地改善。</p>
<h2 id="选择聚类数"><a href="#选择聚类数" class="headerlink" title="选择聚类数"></a>选择聚类数</h2><p>通常是需要根据不同的问题，人工进行选择的。选择的时候思考我们运用 K-均值算法聚类的动机是什么，然后选择能最好服务于该目的标聚类数。</p>
<p>“肘部法则”  ：我们所需要做的是改变𝐾值，也就是聚类类别数目的总数。我们先用一个聚类来运行 K 均值聚类方法。这就意味着，所有的数据都会分到一个聚类里，然后计算成本函数或者计算畸变函数𝐽。 𝐾代表聚类数。</p>
<p>这是比较清晰的图：<img src="../source/imgs/${fiilname}/image-20250804215200845.png" alt="image-20250804215200845" style="zoom:67%;" /></p>
<p>这种模式，它的畸变值会迅速下降，从 1 到 2，从 2 到 3 之后，你会在 3 的时候达到一个肘点。在此之后，畸变值就下降的非常慢，看起来就像使用 3 个聚类来进行聚类是正确的，这是因为那个点是曲线的肘点，畸变值下降得很快， 𝐾 &#x3D; 3之后就下降得很慢，那么我们就选𝐾 &#x3D; 3。当你应用“肘部法则”的时候，如果你得到了一个像上面这样的图，那么这将是一种用来选择聚类个数的合理方法。</p>
<p>这是不明显的图，模拟两可：<img src="../source/imgs/${fiilname}/image-20250804215306763.png" alt="image-20250804215306763" style="zoom:67%;" /></p>
<h2 id="参考资料：相似度-距离计算，衡量指标"><a href="#参考资料：相似度-距离计算，衡量指标" class="headerlink" title="参考资料：相似度&#x2F;距离计算，衡量指标"></a>参考资料：相似度&#x2F;距离计算，衡量指标</h2><p>1.相似度&#x2F;距离计算方法总结</p>
<p>(1). 闵可夫斯基距离 Minkowski&#x2F;（其中欧式距离： 𝑝 &#x3D; 2)<br>$$<br>dist(X,Y)&#x3D;(∑_{i&#x3D;1}^n|x_i-y_i | ^p )^{\frac{1}{p} }<br>$$<br>(2). 杰卡德相似系数(Jaccard<br>$$<br>J(A,B)&#x3D;\frac{|A∩B|}{|A∪B|}<br>$$<br>(3). 余弦相似度(cosine similarity</p>
<p>𝑛维向量𝑥和𝑦的夹角记做𝜃，根据余弦定理，其余弦值为：<br>$$<br>cos(θ)&#x3D;\frac{x^T y}{|x|⋅|y|}&#x3D;\frac{∑_{i&#x3D;1}^n x_i y_i }{\sqrt{∑_{i&#x3D;1}^n x_i^2 } \sqrt{∑_{i&#x3D;1}^n y_i^2 } }<br>$$<br><img src="../source/imgs/${fiilname}/image-20250805153425546.png" alt="image-20250805153425546" style="zoom:50%;" /></p>
<p>没看懂这个</p>
<p>2.聚类的衡量指标</p>
<p>(1). 均一性： 𝑝</p>
<p>类似于精确率，一个簇中只包含一个类别的样本，则满足均一性。其实也可以认为就是正确率(每个聚簇中正确分类的样本数占该聚簇总样本数的比例和)</p>
<p>(2). 完整性：𝑟</p>
<p>类似于召回率，同类别样本被归类到相同簇中，则满足完整性;(每个聚簇中正确分类的样本数占该类型的总样本数比例的和)</p>
<p>(3). V-measure:</p>
<p>均一性和完整性的加权平均（这里的β是自己定义的吗？）<br>$$<br>V&#x3D;\frac{(1+β^2)<em>pr}{β^2</em>p+r}<br>$$<br>(4). 轮廓系数</p>
<p>样本𝑖的轮廓系数： 𝑠(𝑖)</p>
<p>簇内不相似度:计算样本𝑖到同簇其它样本的平均距离为𝑎(𝑖)，应尽可能小。</p>
<p>簇间不相似度:计算样本𝑖到其它簇𝐶𝑗的所有样本的平均距离𝑏𝑖𝑗，应尽可能大。</p>
<p>轮廓系数𝑠(𝑖)值越接近 1 表示样本𝑖聚类越合理，越接近-1，表示样本𝑖应该分类到另外的簇中，近似为 0，表示样本𝑖应该在边界上;所有样本的𝑠(𝑖)的均值被成为聚类结果的轮廓系数<br>$$<br>s(i)&#x3D;\frac{b(i)-a(i)}{\max{a(i),b(i)} }<br>$$</p>
<h1 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h1><h2 id="动机一：数据压缩"><a href="#动机一：数据压缩" class="headerlink" title="动机一：数据压缩"></a>动机一：数据压缩</h2><p>进行降维的原因之一是数据压缩。</p>
<p>数据压缩不仅允许我们压缩数据，因而使用较少的计算机内存或磁盘空间，它也让我们加快我们的学习算法。</p>
<p>降维是什么，举个例子，我们收集的数据集，有许多，许多特征，绘制两个在这里。</p>
<img src="../source/imgs/${fiilname}/image-20250805155521913.png" alt="image-20250805155521913" style="zoom:50%;" />

<p>假设我们未知两个的特征： 𝑥1:长度：用厘米表示； 𝑥2：是用英寸表示同一物体的长度。</p>
<p>这个例子的意思是：假使我们要采用两种不同的仪器来测量一些东西的尺寸，其中一个仪器测量结果的单位是英寸，另一个仪器测量的结果是厘米，我们希望将测量的结果作为我们机器学习的特征。现在的问题的是，两种仪器对同一个东西测量的结果不完全相等（由于误差、精度等），而将两者都作为特征有些重复，因而，我们希望将这个二维的数据降至一维。</p>
<p>我们不想有<strong>高度冗余</strong>的特征。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250805160659551.png" alt="image-20250805160659551"></p>
<p>像上面的图，画一条绿色的线，接下来测量各个点在这条绿色的线上的位置作为新的特征 z ，这样就将原来x的二位特征转化为了只需要用一个实数就能表示的特征。</p>
<p>接下来是将3D的特征转化维2D的，下图看不出来但途中的所有特征大致都在同一个平面上。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250805161345527.png" alt="image-20250805161345527"></p>
<p>这样的处理过程可以被用于把任何维度的数据降到任何想要的维度，例如将 1000 维的特征降至 100 维。</p>
<h2 id="动机二：数据可视化"><a href="#动机二：数据可视化" class="headerlink" title="动机二：数据可视化"></a>动机二：数据可视化</h2><p>在许多机器学习问题中，如果我们能将数据可视化（前面的练习题中都是先将数据可视化再进行训练），我们便能寻找到一个更好的解决方案，降维可以帮助我们。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250805162016564.png" alt="image-20250805162016564"></p>
<p>假使我们有有关于许多不同国家的数据，每一个特征向量都有 50 个特征（如 GDP，人均 GDP，平均寿命等）。如果要将这个 50 维的数据可视化是不可能的。使用降维的方法将其降至 2 维，我们便可以将其可视化了。假设将50个特征变为了两个特征z1、z2来描述。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250805162213089-1754382134100-1.png" alt="image-20250805162213089"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250805162458273.png" alt="image-20250805162458273"></p>
<p>这样做的问题在于，降维的算法只负责减少维数，新产生的特征的意义就必须由我们自己去发现了。</p>
<h2 id="主成分分析问题"><a href="#主成分分析问题" class="headerlink" title="主成分分析问题"></a>主成分分析问题</h2><p>主成分分析(PCA)是最常见的降维算法。</p>
<p>在 PCA 中，我们要做的是找到一个方向向量（这个找到的方向向量不管是正的还是负的都没关系，因为这两个向量都定义了同一条直线），当我们把所有的数据都投射到该向量上时，我们希望投射平均均方误差能尽可能地小。方向向量是一个<strong>经过原点</strong>的向量，而投射误差是从特征向量向该方向向量<strong>作垂线</strong>的长度。<img src="../source/imgs/${fiilname}/image-20250805162911167.png" alt="image-20250805162911167" style="zoom:33%;" /></p>
<p>主成分分析问题的描述：问题是要将𝑛维数据降至𝑘维，目标是找到向量𝑢(1),𝑢(2),…,𝑢(𝑘)使得总的投射误差最小。</p>
<p>正式的说，PCA做的是将数据进行投影，寻找k个向量对数据进行投影，进而最小化投影距离（也就是数据点和投影之后点的距离）。在下面这个例子中，就是想将点投影到二维平面上，所以投影误差就是这个点和投影到二维平面上的点的距离。</p>
<img src="../source/imgs/${fiilname}/image-20250805164427640.png" alt="image-20250805164427640" style="zoom:50%;" />

<p>主成分分析与线性回归是两种不同的算法。主成分分析最小化的是<strong>投射误差</strong>，而线性回归尝试的是最小化<strong>预测误差</strong>。线性回归的目的是预测结果，而主成分分析不作任何预测。</p>
<p>PCA 将𝑛个特征降维到𝑘个，可以用来进行数据压缩，但 PCA要保证降维后，还要保证数据的特性损失最小。</p>
<p>PCA 技术的一大好处是对数据进行降维的处理。我们可以对新求出的“主元”向量的重要性进行排序（新特征按其所解释的原始数据方差大小<strong>从高到低排序</strong>（第一主成分包含最多信息）），根据需要取前面最重要的部分（通常满足累计方差贡献率&gt;85%），将后面的维数省去，可以达到降维从而简化模型或是对数据进行压缩的效果。同时最大程度的保持了原有数据的信息。</p>
<ul>
<li><strong>传统特征选择</strong>：直接删除部分原始特征列，可能丢失重要信息</li>
<li><strong>PCA降维</strong>：用原特征<strong>线性组合</strong>构建信息更集中的新特征</li>
</ul>
<img src="../source/imgs/${fiilname}/image-20250805165259994.png" alt="image-20250805165259994" style="zoom:50%;" />

<p>累计方差贡献率是PCA降维中选择主成分数量的核心依据，表示前k个主成分所携带的原始数据信息量占比。<br>$$<br>第 i 个主成分（PC_i）的方差贡献率 &#x3D;\frac{λ_i}{∑_{j&#x3D;1}^pλ_j}<br>$$</p>
<ul>
<li><em>λi</em>：PCA求解的第 <em>i</em> 个特征值（代表该主成分的方差）</li>
<li><em>p</em>：原始特征维度总数</li>
<li>意义：PCᵢ <strong>单独解释的原始数据变异比例</strong></li>
</ul>
<p>$$<br>累计方差贡献率是&#x3D;∑_{i&#x3D;1}^k\frac{λ_i}{∑_{j&#x3D;1}^pλ_j}<br>$$</p>
<img src="../source/imgs/${fiilname}/image-20250805170349704.png" alt="image-20250805170349704" style="zoom:50%;" />

<img src="../source/imgs/${fiilname}/image-20250805170413323.png" alt="image-20250805170413323" style="zoom:50%;" />

<img src="../source/imgs/${fiilname}/image-20250805170433913.png" alt="image-20250805170433913" style="zoom:50%;" />

<p>PCA 技术的一个很大的优点是，它是完全无参数限制的。在 PCA 的计算过程中完全不需要人为的设定参数或是根据任何经验模型对计算进行干预，最后的结果只与数据相关，与用户是独立的。</p>
<p>但是，这一点同时也可以看作是缺点。如果用户对观测对象有一定的先验知识，掌握了数据的一些特征，却无法通过参数化等方法对处理过程进行干预，可能会得不到预期的效果，效率也不高。</p>
<h2 id="主成分分析算法"><a href="#主成分分析算法" class="headerlink" title="主成分分析算法"></a>主成分分析算法</h2><p>PCA 减少𝑛维到𝑘维：</p>
<p>第一步是均值归一化。我们需要计算出所有特征的均值<img src="../source/imgs/${fiilname}/image-20250805203858727.png" alt="image-20250805203858727" style="zoom:25%;" />，然后令<img src="../source/imgs/${fiilname}/image-20250805201849380.png" alt="image-20250805201849380" style="zoom:50%;" />（这将使每个特征的均值为0)。如果特征是在不同的数量级上，我们还需要将其除以标准差 ，也就是<img src="../source/imgs/${fiilname}/image-20250805204038114.png" alt="image-20250805204038114" style="zoom:25%;" />（这就相当于前面的特征缩放）。</p>
<p>第二步是计算协方差矩阵 𝛴（大写希腊字母sigma）： ∑ <img src="../source/imgs/${fiilname}/image-20250805201918176.png" alt="image-20250805201918176" style="zoom:50%;" />，xi 是n×1矩阵</p>
<pre><code class="hljs plaintext">对于一个数据集，协方差矩阵 C 的目标是描述不同特征之间的关系。
矩阵的对角线元素 C[i, i] 是第 i 个特征的方差。
非对角线元素 C[i, j] 是第 i 个特征和第 j 个特征的协方差。
因此，如果你的数据集有 n 个特征，那么协方差矩阵一定是一个 (n, n) 的方阵。
X 是一个 (m, n) 矩阵，其中 m 是样本数，n 是特征数，所以计算协方差矩阵为X.T * X（X是矩阵）</code></pre>

<p>第三步是计算协方差矩阵𝛴的特征向量：在 Octave 里我们可以利用奇异值分解来求解， [U, S, V]&#x3D; svd(sigma)。</p>
<p>这会返回三个矩阵，而我们需要的只是第一个矩阵U。</p>
<p>在python中则是：</p>
<pre><code class="hljs plaintext">U, S, V = np.linalg.svd(cov) # cov是协方差矩阵</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250805203105783-1754397066593-3.png" alt="image-20250805203105783"></p>
<p>上式中的𝑈是一个具有与数据之间最小投射误差的方向向量构成的矩阵。如果我们希望将数据从𝑛维降至𝑘维，我们只需要从𝑈中选取前𝑘个向量，获得一个𝑛 × 𝑘维度的矩阵，我们用𝑈𝑟𝑒𝑑𝑢𝑐𝑒表示，然后通过如下计算获得要求的新特征向量𝑧(𝑖):<br>$$<br>z^{(i)}&#x3D;U_{reduce}^T*x^{(i)}<br>$$<br>其中𝑥是𝑛 × 1维的，因此结果为𝑘 × 1维度。</p>
<p><strong>PCA要做的是尝试找到一个线或面，把数据投影到这个线或面上，以便最小化平方投影误差。</strong></p>
<h2 id="选择主成分的数量"><a href="#选择主成分的数量" class="headerlink" title="选择主成分的数量"></a>选择主成分的数量</h2><p>PCA算法是将n维的变为k维的，这个k也叫做主成分的数字。</p>
<p>主要成分分析是减少投射的平均均方误差：<img src="../source/imgs/${fiilname}/image-20250805210049481.png" alt="image-20250805210049481" style="zoom:40%;" /></p>
<p>训练集的方差为：<img src="../source/imgs/${fiilname}/image-20250805210124059.png" alt="image-20250805210124059" style="zoom:50%;" />，所以<strong>总方差就是训练集中的平均长度</strong>，意思是，平均来说，我的训练样本距离全零向量的距离，或者说我的训练样本距离原点有多远。</p>
<p>我们希望在平均均方误差与训练集方差的比例尽可能小的情况下选择尽可能小的𝑘值。</p>
<p>如果我们希望这个比例小于 1%，就意味着原本数据的方差有 99%都保留下来了，如果我们选择保留 95%的方差，便能非常显著地降低模型中特征的维度了。</p>
<img src="../source/imgs/${fiilname}/image-20250805210529939.png" alt="image-20250805210529939" style="zoom:50%;" />

<p>可以先令𝑘 &#x3D; 1，然后进行主要成分分析，获得𝑈𝑟𝑒𝑑𝑢𝑐𝑒和𝑧，然后计算比例是否小于1%。如果不是的话再令𝑘 &#x3D; 2，如此类推，直到找到可以使得比例小于 1%的最小𝑘 值（原因是各个特征之间通常情况存在某种相关性）。<img src="../source/imgs/${fiilname}/image-20250805211027964.png" alt="image-20250805211027964" style="zoom:35%;" /></p>
<p>这是一个比较低效的过程，吴恩达介绍的是用Octave简化这个过程，python的做法是</p>
<h2 id="重建的压缩表示"><a href="#重建的压缩表示" class="headerlink" title="重建的压缩表示"></a>重建的压缩表示</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250805211643733.png" alt="image-20250805211643733"></p>
<p>PCA 算法，我们可能有一个这样的样本。如图中样本𝑥(1),𝑥(2)。我们做的是，我们把这些样本投射到图中这个一维平面。给定一个点𝑧(1)，我们怎么能回去这个原始的二维空间呢？<br>$$<br>x为2维，z为1维，z&#x3D;U_{reduce}^T x，相反的方程为：x_{appox}&#x3D;U_{reduce}⋅z，x_{appox}≈x<br>$$<br><img src="/../source/imgs/$%7Bfiilname%7D/image-20250805211847056.png" alt="image-20250805211847056"></p>
<p>这就是你从低维表示𝑧回到未压缩的表示𝑥，我们也把这个过程称为重建原始数据。</p>
<p>为什么进行恢复原始数据的操作后，数据和原始数据不一样？</p>
<p><strong>因为PCA是一种有损压缩技术。</strong> 在降维（投影）的过程中，我们为了用更少的维度来表示数据，主动地<strong>丢弃了一部分信息</strong>。因此，当我们试图从降维后的数据恢复时，这部分被丢弃的信息是无法找回的，所以恢复后的数据和原始数据不一样。</p>
<h2 id="主成分分析法的应用建议"><a href="#主成分分析法的应用建议" class="headerlink" title="主成分分析法的应用建议"></a>主成分分析法的应用建议</h2><img src="../source/imgs/${fiilname}/image-20250805212102691.png" alt="image-20250805212102691" style="zoom:50%;" />

<p>使用PCA来加速学习算法，可以将数据的维度减少5倍或者10倍，在保留较大方差的前提下，这样做几乎不影响性能、分类精度，而且通过较低的维度数据，算法会运行地很快。</p>
<p>使用PCA去防止过拟合不是很推荐，这是一种非常糟糕的应用，虽然它的效果可能会很好，但这不是一种很好的方式去处理过拟合问题，最好应该使用规则化来防止过拟合。</p>
<p>在使用PCA之前，应该考虑只使用原始数据去训练学习算法。</p>
<h1 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h1><h2 id="问题的动机"><a href="#问题的动机" class="headerlink" title="问题的动机"></a>问题的动机</h2><p>这是机器学习算法的一个常见应用。这种算法的一个有趣之处在于：它虽然主要用于非监督学习问题，但从某些角度看，它又类似于一些监督学习问题。</p>
<p>什么是异常检测？</p>
<p>假想你是一个飞机引擎制造商，当你生产的飞机引擎从生产线上流出时，你需要进行QA(质量控制测试)，而作为这个测试的一部分，你测量了飞机引擎的一些特征变量，比如引擎运转时产生的热量，或者引擎的振动等等。  </p>
<p>这样一来，你就有了一个数据集，从𝑥(1)到𝑥(𝑚)，如果你生产了𝑚个引擎的话，你将这些数据绘制成图表，图里的每个点、每个叉，都是你的无标签数据。这样，异常检测问题可以定义如下：假设后来有一天，你有一个新的飞机引擎从生产线上流出，而你的新飞机引擎有特征变量𝑥𝑡𝑒𝑠𝑡。所谓的异常检测问题就是：我们希望知道这个新的飞机引擎是否有某种异常。</p>
<p>给定数据集<img src="../source/imgs/${fiilname}/image-20250809154247719.png" alt="image-20250809154247719" style="zoom:50%;" />，假使数据集是正常的，我们希望知道新的数据 𝑥𝑡𝑒𝑠𝑡是不是异常的，即这个测试数据不属于该组数据的几率。我们所构建的模型应该能根据该测试数据的位置告诉我们其属于一组数据的可能性 𝑝(𝑥)。</p>
<img src="../source/imgs/${fiilname}/image-20250809154602440.png" alt="image-20250809154602440" style="zoom:50%;" />

<p>上图中，在蓝色圈内的数据属于该组数据的可能性较高，而越是偏远的数据，其属于该组数据的可能性就越低。</p>
<p>这种方法称为密度估计，表达如下：<img src="../source/imgs/${fiilname}/image-20250809154629373.png" alt="image-20250809154629373" style="zoom:50%;" /></p>
<p>模型𝑝(𝑥) 为我们计算其属于一组数据的可能性， 通过𝑝(𝑥) &lt; 𝜀检测非正常用户。</p>
<p>异常检测主要用来识别欺骗。可以根据这些特征构建一个模型，可以用这个模型来识别那些不符合该模式的用户或者物品啥的。</p>
<h2 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h2><p>高斯分布，也称为正态分布。<br>$$<br>如果我们认为变量 x 符合高斯分布 x∼N(μ,σ^2)则其概率密度函数为： p(x,μ,σ^2)&#x3D;\frac{1}{\sqrt{2π }σ} exp(\frac{-(x-μ)^2}{2σ^2 })<br>$$</p>
<p>$$<br>μ和σ^2的计算方法:μ&#x3D;\frac{1}{m} ∑_{i&#x3D;1}^mx^{(i)} ，σ^2&#x3D;\frac{1}{m} ∑_{i&#x3D;1}^m( x^{(i)}-μ)^2<br>$$</p>
<p>样例：<img src="../source/imgs/${fiilname}/image-20250809155851001.png" alt="image-20250809155851001" style="zoom:50%;" /></p>
<p>注：机器学习中对于方差我们通常只除以𝑚而非统计学中的(𝑚 - 1)。这里顺便提一下，在实际使用中，到底是选择使用1&#x2F;𝑚还是1&#x2F;(𝑚 - 1)其实区别很小，只要你有一个还算大的训练集，在机器学习领域大部分人更习惯使用1&#x2F;𝑚这个版本的公式。这两个版本的公式在理论特性和数学特性上稍有不同，但是在实际使用中，他们的区别甚小，几乎可以忽略不计。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>应用高斯分布开发异常检测算法。</p>
<p>对于给定的数据集 <img src="../source/imgs/${fiilname}/image-20250814163934252.png" alt="image-20250814163934252" style="zoom:50%;" />，我们要针对每一个特征计算 𝜇 和 𝜎2 的估计值。</p>
<p>一旦我们获得了平均值和方差的估计值，给定新的一个训练实例，根据模型计算 𝑝(𝑥)：<br>$$<br>p(x)&#x3D;∏_{j&#x3D;1}^np(x_j;μ_j,σ_j^2)&#x3D;∏_{j&#x3D;1}^n \frac{1}{\sqrt{2π} σ_j} exp(\frac{-{(x_j-μ_j) }^2}{2σ_j^2 })<br>$$<br>选择一个𝜀，将𝑝(𝑥) &#x3D; 𝜀作为判定边界，当𝑝(𝑥) &gt; 𝜀时预测数据为正常数据，否则为异常。  </p>
<p>下图是一个由两个特征的训练集，以及特征的分布情况：</p>
<img src="../source/imgs/${fiilname}/image-20250809160601061.png" alt="image-20250809160601061" style="zoom:50%;" />

<p>下面的三维图表表示的是密度估计函数， 𝑧轴为根据两个特征的值所估计𝑝(𝑥)值：<img src="../source/imgs/${fiilname}/image-20250809160636306.png" alt="image-20250809160636306" style="zoom:50%;" /></p>
<h2 id="开发和评价一个异常检测系统"><a href="#开发和评价一个异常检测系统" class="headerlink" title="开发和评价一个异常检测系统"></a>开发和评价一个异常检测系统</h2><p>异常检测算法是一个非监督学习算法，意味着我们无法根据结果变量 𝑦 的值来告诉我们数据是否真的是异常的。</p>
<p>但如果有一些带标签的数据能够指明哪些是异常样本，哪些是非异常样本，那么这就是我们要找的能够评价异常检测算法的标准算法。当我们开发一个异常检测系统时，我们从带标记（异常或正常）的数据着手，我们从其中选择一部分正常数据用于构建训练集，然后用剩下的正常数据和异常数据混合的数据构成交叉检验集和测试集。</p>
<p>异常检测算法的推导和评价方法如下：</p>
<p>例如：我们有 10000 台正常引擎的数据，有 20 台异常引擎（通常在20~50个）的数据。 我们这样分配数据：</p>
<p>6000 台正常引擎（可能也有一些异常数据被分到训练集中，但没什么关系）的数据作为训练集</p>
<p>2000 台正常引擎和 10 台异常引擎的数据作为交叉检验集</p>
<p>2000 台正常引擎和 10 台异常引擎的数据作为测试集</p>
<p>具体的评价方法如下：</p>
<ol>
<li><p>根据训练集数据，我们估计特征的平均值和方差并构建𝑝(𝑥)函数</p>
</li>
<li><p>对交叉检验集，我们尝试使用不同的𝜀值作为阀值，并预测数据是否异常，根据 F1 值或者查准率与查全率的比例来选择 𝜀</p>
</li>
<li><p>选出 𝜀 后，针对测试集进行预测，计算异常检验系统的𝐹1值，或者查准率与查全率之比。</p>
</li>
</ol>
<h2 id="异常检测与监督学习对比"><a href="#异常检测与监督学习对比" class="headerlink" title="异常检测与监督学习对比"></a>异常检测与监督学习对比</h2><p>对于一些数据，我们知道它们哪些是异常，哪些是正常的，为什么我们不用监督学习算法，逻辑回归或者神经网络从我们带标签的数据中直接学习，并预测 y 的值是1还是0。</p>
<p>下面的对比有助于选择采用监督学习还是异常检测：</p>
<table>
<thead>
<tr>
<th>异常检测</th>
<th>监督学习</th>
</tr>
</thead>
<tbody><tr>
<td>非常少量的正向类（异常数据 y&#x3D;1）, 大量的负向类（y&#x3D;0)  ，一般将这些正向类作为交叉验证集和测试集</td>
<td>同时有大量的正向类和负向类</td>
</tr>
<tr>
<td>许多不同种类的异常，非常难。根据非常  少量的正向类数据来训练算法。</td>
<td>有足够多的正向类实例，足够用于训练  算法，未来遇到的正向类实例可能与训练集中的非常近似。</td>
</tr>
<tr>
<td>未来遇到的异常可能与已掌握的异常、非常的不同。</td>
<td></td>
</tr>
<tr>
<td>例如： 欺诈行为检测 生产（例如飞机引擎）检测数据中心的计算机运行状况</td>
<td>例如：邮件过滤器 天气预报 肿瘤分类</td>
</tr>
</tbody></table>
<p>在异常检测算法中，正例的数量很少，以至于对于一个学习算法来说，它无法从正例中学习到足够的知识，所以，我们应该采用大量的反例让它学习，学习关于反例，关于 x 的模型 p ，然后保留小数量的正例用于评估我们的算法，这些正例要么用于交叉验证集要么用于测试集。</p>
<p>另外，对于很多技术公司可能会遇到的一些问题，通常来说，<strong>正样本的数量很少</strong>，甚至有时候是 0，也就是说，出现了太多没见过的不同的异常类型（对于垃圾邮件问题，虽然垃圾邮件的类别很多，但数量同样很多，所以一般看作是监督学习问题），那么对于这些问题，通常应该使用的算法就是<strong>异常检测算法</strong>。</p>
<h2 id="选择特征"><a href="#选择特征" class="headerlink" title="选择特征"></a>选择特征</h2><p>对于异常检测算法，我们使用的特征是至关重要的，下面谈谈如何选择特征：</p>
<p>异常检测假设特征符合高斯分布，如果数据的分布不是高斯分布，异常检测算法也能够工作，但是最好还是将数据转换成高斯分布，例如使用对数函数： 𝑥 &#x3D; 𝑙𝑜𝑔(𝑥 + 𝑐)，其中 𝑐为非负常数； 或者<img src="../source/imgs/${fiilname}/image-20250811162044495.png" alt="image-20250811162044495" style="zoom:50%;" />， 𝑐为 0-1 之间的一个分数，等方法。</p>
<p><strong>（在 python 中，通常用 np.log1p()函数， 𝑙𝑜𝑔1𝑝就是 𝑙𝑜𝑔(𝑥 + 1)，可以避免出现负数结果，反向函数就是 np.expm1()）</strong>这句还没搞懂怎么用。</p>
<p>如果数据不是高斯分布的，通常需要使用一些转换算法来对数据进行处理，使数据更像高斯分布。</p>
<img src="../source/imgs/${fiilname}/image-20250811162757802.png" alt="image-20250811162757802" style="zoom:80%;" />

<p>这只是转换的一种方法，也有可能使log(x+1)或者使log(x+常数)或者x的n次方(0&lt;n&lt;1)等，目的是使数据分布更像高斯分布。</p>
<p>如何得到异常检测算法的特征变量？通常通过<strong>误差分析</strong>步骤。这跟前面监督学习的误差分析步骤是差不多的，先完整地训练出一个学习算法，然后在一组交叉验证集上验证算法，然后找出那些出错的样本，然后看看能不能找到一些其它的特征变量来帮助学习算法让它在交叉预测集中判断出错的样本中表现得更好。</p>
<p>在异常检测中，我们希望p(x)值对于正常样本来说是比较大的，而对异常样本来说值是很小的。</p>
<p>误差分析：</p>
<p>一个常见的问题是一些异常的数据可能也会有较高的𝑝(𝑥)值，因而被算法认为是正常的。这种情况下误差分析能够帮助我们，我们可以分析那些被算法错误预测为正常的数据，观察能否找出一些问题。我们可能能从问题中发现我们需要增加一些新的特征，增加这些新特征后获得的新算法能够帮助我们更好地进行异常检测。</p>
<img src="../source/imgs/${fiilname}/image-20250811164443660.png" alt="image-20250811164443660" style="zoom:50%;" />

<p>绿色的x是异常样本，在只有x1特征时可以看出它的p(x)的值很大，所以现在就要再找出一个特征使它能和正常样本分开。</p>
<p>我们通常可以通过将一些相关的特征进行组合，来获得一些新的更好的特征（异常数据的该特征值异常地大或小）。</p>
<h2 id="多元高斯分布（选修）"><a href="#多元高斯分布（选修）" class="headerlink" title="多元高斯分布（选修）"></a>多元高斯分布（选修）</h2><p>假使我们有两个相关的特征，而且这两个特征的值域范围比较宽，这种情况下，一般的高斯分布模型可能不能很好地识别异常数据。其原因在于，一般的高斯分布模型尝试的是去同时抓住两个特征的偏差，因此创造出一个比较大的判定边界。</p>
<p>下图中是两个相关特征，洋红色的线（根据 ε 的不同其范围可大可小）是一般的高斯分布模型获得的判定边界，很明显绿色的 X 所代表的数据点很可能是异常值，但是其𝑝(𝑥)值却仍然在正常范围内。多元高斯分布将创建像图中蓝色曲线所示的判定边界。</p>
<img src="../source/imgs/${fiilname}/image-20250811165630148.png" alt="image-20250811165630148" style="zoom:50%;" />





<h2 id="使用多元高斯分布进行异常检测（-选修）"><a href="#使用多元高斯分布进行异常检测（-选修）" class="headerlink" title="使用多元高斯分布进行异常检测（ 选修）"></a>使用多元高斯分布进行异常检测（ 选修）</h2><h1 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h1><h2 id="问题形式化"><a href="#问题形式化" class="headerlink" title="问题形式化"></a>问题形式化</h2><p>从一个例子开始定义推荐系统的问题。</p>
<p>假使我们是一个电影供应商，我们有 5 部电影和 4 个用户，我们要求用户为电影打分。</p>
<img src="../source/imgs/${fiilname}/image-20250811180052523.png" alt="image-20250811180052523" style="zoom:67%;" />

<p>我们希望构建一个算法来预测他们每个人可能会给他们没看过的电影打多少分，并以此作为推荐的依据。</p>
<p>下面引入一些标记：</p>
<p><img src="../source/imgs/${fiilname}/image-20250811180203188.png" alt="image-20250811180203188" style="zoom:50%;" />代表用户的数量</p>
<p><img src="../source/imgs/${fiilname}/image-20250811180219413.png" alt="image-20250811180219413" style="zoom:50%;" />代表电影的数量</p>
<p>𝑟(𝑖, 𝑗) 如果用户 𝑗 给电影 𝑖 评过分则 𝑟(𝑖, 𝑗) &#x3D; 1</p>
<p><img src="../source/imgs/${fiilname}/image-20250811180235353.png" alt="image-20250811180235353" style="zoom:50%;" />代表用户 𝑗 给电影 𝑖 的评分</p>
<p>𝑚𝑗代表用户 𝑗 评过分的电影的总数</p>
<h2 id="基于内容的推荐系统"><a href="#基于内容的推荐系统" class="headerlink" title="基于内容的推荐系统"></a>基于内容的推荐系统</h2><p>在一个基于内容的推荐系统算法中，我们假设对于我们希望推荐的东西有一些数据，这些数据是有关这些东西的特征。</p>
<p>在我们的例子中，我们可以假设每部电影都有两个特征，如𝑥1代表电影的浪漫程度， 𝑥2代表电影的动作程度。</p>
<img src="../source/imgs/${fiilname}/image-20250811180843788.png" alt="image-20250811180843788" style="zoom:67%;" />

<p>则每部电影都有一个特征向量，如𝑥(1)是第一部电影的特征向量为[0.9 0]。</p>
<p>下面我们要基于这些特征来构建一个推荐系统算法。 假设我们采用线性回归模型，我们可以针对每一个用户都训练一个线性回归模型，如𝜃(1)是第一个用户的模型的参数。 于是，我们有：<br>$$<br>θ^{(j)}用户 j 的参数向量，x^{(i)}电影 i 的特征向量<br>$$</p>
<p>$$<br>对于用户 j 和电影 i，我们预测评分为：(θ^{(j)} )^T x^{(i)}<br>$$</p>
<p>代价函数：</p>
<p>针对用户 𝑗，该线性回归模型的代价为预测误差的平方和，加上正则化项：<br>$$<br>\underset{θ(j)}{min} \frac{1}{2} \underset{i:r(i,j)&#x3D;1}{∑}((θ^{(j)} )^T x^{(i)}-y^{(i,j)} )^2 +\frac{λ}{2} ∑_{k&#x3D;1}^n(θ_k^{(j)} )^2<br>$$<br>其中 𝑖: 𝑟(𝑖, 𝑗)表示我们只计算那些用户 𝑗 评过分的电影。在一般的线性回归模型中，误差项和正则项应该都是乘以1&#x2F;2𝑚，在这里我们<strong>将𝑚去掉</strong>。并且我们<strong>不对方差项𝜃0进行正则化处理</strong>。</p>
<p>上面的代价函数只是针对一个用户的，为了学习所有用户，我们将所有用户的代价函数求和：<br>$$<br>\underset{θ^{(1)},…,θ^{(n_u)} }{min}\frac{1}{2} ∑_{j&#x3D;1}^{n_u}\underset{i:r(i,j)&#x3D;1}{∑}((θ^{(j)} )^T x^{(i)}-y^{(i,j)} )^2 +\frac{λ}{2} ∑_{j&#x3D;1}^{n_u}∑_{k&#x3D;1}^n( θ_k^{(j)} )^2<br>$$<br>如果我们要用梯度下降法来求解最优解，我们计算代价函数的偏导数后得到梯度下降的更新公式为：<br>$$<br>θ_k^{(j)}:&#x3D;θ_k^{(j)}-α\underset{i:r(i,j)&#x3D;1}{∑}((θ^{(j)} )^T x^{(i)}-y^{(i,j)})x_k^{(i)} (for  k&#x3D;0)<br>$$</p>
<p>$$<br>θ_k^{(j)}:&#x3D;θ_k^{(j)}-α(\underset{i:r(i,j)&#x3D;1}{∑}((θ^{(j)} )^T x^{(i)}-y^{(i,j)})x_k^{(i)}+λθ_k^{(j)}) (for  k≠0)<br>$$</p>
<h2 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h2><p>这种方法能够自行学习所要使用的特征。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250811203319599.png" alt="image-20250811203319599"></p>
<p>假设有一个数据集，部分数据如上图。我们可以知道假如要搜集像这样的数据，要让每一个人都看完每部电影再搜集他们觉得每部电影的浪漫指数或者动作指数啥的，很麻烦，而且通常还希望得到除了这两个特征之外的特征信息，那要怎么样才能得到这些特征信息。</p>
<p>那就转换一下问题，假设我们有以下数据集，且我们可以从用户那边得到相关参数：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250811203855955.png" alt="image-20250811203855955"></p>
<p>那我们根据这些参数理论上可以推出每部电影的x1和x2值。</p>
<p>以第一部电影为例子，我们需要满足这些条件：<img src="../source/imgs/${fiilname}/image-20250811204416647.png" alt="image-20250811204416647" style="zoom:50%;" /></p>
<p>所以可以推出第一部电影的特征为（包括x0）：<img src="../source/imgs/${fiilname}/image-20250811204452265.png" alt="image-20250811204452265" style="zoom:50%;" /></p>
<p>将这一问题标准化到任意特征x(i)，相当于是x(i)变成了要求的参数，原本的参数变成了训练用的数据集：<br>$$<br>\underset{x^{(1)},…,x^{(n_m)} }{min}\frac{1}{2} ∑_{i&#x3D;1}^{n_m}\underset{j:r(i,j)&#x3D;1}{∑}((θ^{(j)} )^T x^{(i)}-y^{(i,j)} )^2+\frac{λ}{2} ∑_{i&#x3D;1}^{n_m}∑_{k&#x3D;1}^n( x_k^{(i)} )^2  <br>$$<br>但是如果我们既没有用户的参数，也没有电影的特征，这两种方法都不可行了。<strong>协同过滤算法</strong>可以<strong>同时学习这两者</strong>。</p>
<p>我们的优化目标便改为同时针对<strong>𝑥和𝜃</strong>进行。<img src="../source/imgs/${fiilname}/image-20250811205604710.png" alt="image-20250811205604710" style="zoom:50%;" /></p>
<p>从这个代价函数我们可以看出来，如果将x作为常量，那就详相当于<img src="../source/imgs/${fiilname}/image-20250812103124335.png" alt="image-20250812103124335" style="zoom:43%;" />，如果将theta作为常量，那就相当于<img src="../source/imgs/${fiilname}/image-20250812103222594.png" alt="image-20250812103222594" style="zoom:50%;" /></p>
<p>优化问题的目标是：<img src="../source/imgs/${fiilname}/image-20250812103502485.png" alt="image-20250812103502485" style="zoom:67%;" /></p>
<p>这个学习算法的<strong>前提</strong>是：<img src="../source/imgs/${fiilname}/image-20250812103714953.png" alt="image-20250812103714953" style="zoom:50%;" />，电影特征没有x0&#x3D;1，那用户的参数也就没有theta0（也就是截距）了，所以这个学习算法中所求得的特征和theta都是<strong>n维向量</strong>。<strong>为什么</strong>要这样设置呢？因为我们现在是在学习所有特征，所以没有必要去将这个等于1的特征值固定死，因为如果算法真的需要一个特征永远为1的话，那它可以选择靠自己去获得1这个数值，可以选择将x1设置为1，所以没必要将原本1这个特征固定住。</p>
<p>对代价函数求偏导数的结果如下：<img src="../source/imgs/${fiilname}/image-20250811210654760.png" alt="image-20250811210654760" style="zoom:50%;" /></p>
<p>由于前提的存在，所以这边要对所有的参数theta和特征x做正则化，不需要区分出k&#x3D;0的情况。</p>
<p>注：在协同过滤从算法中，我们通常不使用方差项，如果需要的话，算法会自动学得。</p>
<p>协同过滤算法使用步骤如下：</p>
<ol>
<li><p>初始 <img src="../source/imgs/${fiilname}/image-20250811211112036.png" alt="image-20250811211112036" style="zoom:50%;" />为一些随机小值</p>
</li>
<li><p>使用梯度下降算法最小化代价函数</p>
</li>
<li><p>在训练完算法后，我们预测<img src="../source/imgs/${fiilname}/image-20250811210947397.png" alt="image-20250811210947397" style="zoom:50%;" />为用户 𝑗 给电影 𝑖 的评分</p>
</li>
</ol>
<p>通过这个学习过程获得的特征矩阵包含了有关电影的重要数据，这些数据不总是人能读懂的，但是我们可以用这些数据作为给用户推荐电影的依据。</p>
<p>例如，如果一位用户正在观看电影 𝑥(𝑖)，我们可以寻找另一部电影𝑥(𝑗)，依据两部电影的特征向量之间的距离<img src="../source/imgs/${fiilname}/image-20250811211208218.png" alt="image-20250811211208218" style="zoom:50%;" />的大小。</p>
<h2 id="向量化：低秩矩阵分解"><a href="#向量化：低秩矩阵分解" class="headerlink" title="向量化：低秩矩阵分解"></a>向量化：低秩矩阵分解</h2><p>有关该算法的向量化实现，以及有关该算法可以做的其他事情  。通过学习特征参数，来找到相关电影和产品。  </p>
<p>举例子： 1.当给出一件产品时，你能否找到与之相关的其它产品。</p>
<p>2.一位用户最近看上一件产品，有没有其它相关的产品，你可以推荐给他。我将要做的是：实现一种选择的方法，写出协同过滤算法的预测情况。</p>
<p>我们有关于五部电影的数据集，我将要做的是，将这些用户的电影评分，进行分组并存到一个矩阵中。</p>
<p>我们有五部电影，以及四位用户，那么 这个矩阵 𝑌 就是一个 5 行 4 列的矩阵，它将这些电影的用户评分数据都存在矩阵里：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250812111555349.png" alt="image-20250812111555349"></p>
<p>评分：<img src="../source/imgs/${fiilname}/image-20250812111608091.png" alt="image-20250812111608091" style="zoom:67%;" /></p>
<p>找到相关影片：<img src="../source/imgs/${fiilname}/image-20250812111631498.png" alt="image-20250812111631498" style="zoom:67%;" /></p>
<p>依据的是两部电影的特征向量之间的距离<img src="../source/imgs/${fiilname}/image-20250811211208218.png" alt="image-20250811211208218" style="zoom:50%;" />的大小。</p>
<p>因为已经对特征参数向量进行了学习，那么我们就可以来度量两部电影之间的相似性。例如说：电影 𝑖 有一个特征向量𝑥(𝑖)，你是否能找到一部不同的电影 𝑗，保证两部电影的<strong>特征向量之间的距离</strong>𝑥(𝑖)和𝑥(𝑗)很小，那就能很有力地表明电影𝑖和电影 𝑗 在某种程度上有相似。总结一下，当用户在看某部电影 𝑖 的时候，如果你想找 5 部与电影 i 非常相似的电影，为了能给用户推荐 5 部新电影，你需要做的是找出电影 𝑗，在这些不同的电影 j 中与我们要找的电影 𝑖 的距离最小，这样你就能给你的用户推荐几部不同的电影了。</p>
<h2 id="推行工作上的细节：均值归一化"><a href="#推行工作上的细节：均值归一化" class="headerlink" title="推行工作上的细节：均值归一化"></a>推行工作上的细节：均值归一化</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250812112457099.png" alt="image-20250812112457099"></p>
<p>如果我们新增一个用户 Eve，并且 Eve 没有为任何电影评分，那么我们以什么为依据为 Eve 推荐电影呢？</p>
<p>假如不做任何处理按原数据来学习那会有以下结果：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250812112606974.png" alt="image-20250812112606974"></p>
<p>由于Eve没有为任何一部电影评分，所以theta5作用于最后一个正则项<img src="../source/imgs/${fiilname}/image-20250812112840919.png" alt="image-20250812112840919" style="zoom:40%;" />，这边假设特征数量为2，由于我们希望选择theta5使得最终的正则化项越小越好，所以最后theta5&#x3D;[0 0]，那也就会导致Eve的电影评分<img src="../source/imgs/${fiilname}/image-20250812113044662.png" alt="image-20250812113044662" style="zoom:40%;" />都为0，而这个电影评分是没有意义的，这个评分也说明Eve对任何一部电影都不感兴趣，所以也无法为她推荐电影。但均值归一化可以解决这个问题。</p>
<p>我们首先需要对结果 𝑌矩阵进行均值归一化处理，将每一个用户对某一部电影的评分减去所有用户对该电影评分的平均值：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250812113732314.png" alt="image-20250812113732314"></p>
<p>然后我们利用这个新的 𝑌 矩阵来训练算法。 如果我们要用新训练出的算法来预测评分，则需要将平均值重新加回去，预测<img src="../source/imgs/${fiilname}/image-20250812113801950.png" alt="image-20250812113801950" style="zoom:50%;" />，对于 Eve，我们的新模型会认为她给每部电影的评分都是该电影的平均分，这样会更有意义一点。</p>
<h1 id="大规模机器学习"><a href="#大规模机器学习" class="headerlink" title="大规模机器学习"></a>大规模机器学习</h1><h2 id="大型数据集的学习"><a href="#大型数据集的学习" class="headerlink" title="大型数据集的学习"></a>大型数据集的学习</h2><p>如果我们有一个低偏差的模型，增加数据集的规模可以帮助你获得更好的结果。</p>
<p>以线性回归模型为例，每一次梯度下降迭代，我们都需要计算训练集的误差的平方和，如果我们的学习算法需要有 20 次迭代，这便已经是非常大的计算代价。</p>
<p>首先应该做的事是去检查一个这么大规模的训练集是否真的必要，也许我们只用 1000个训练集也能获得较好的效果，我们可以绘制学习曲线来帮助判断。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815205718086.png" alt="image-20250815205718086"></p>
<h2 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h2><p>如果我们一定需要一个大规模的训练集，我们可以尝试使用随机梯度下降法（ SGD） 来代替批量梯度下降法。</p>
<p>接下来的是以线性回归为例子，但随机梯度下降的思想也可以应用于其它学习算法，比如逻辑回归、神经网络或其它依靠梯度下降进行训练的算法。</p>
<p>在随机梯度下降法中，我们定义代价函数为一个单一训练实例的代价：<br>$$<br>cost(θ,(x^{(i)},y^{(i)} ))&#x3D;\frac{1}{2} (h_θ (x^{(i)} )-y^{(i)} )^2<br>$$<br>随机梯度下降算法为：首先对训练集<strong>随机打乱</strong>（可以稍微快一点收敛），就是将所有m个训练样本重新排序，然后：</p>
<p>通常训练一次就够了，最多到10次</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815211106705.png" alt="image-20250815211106705"></p>
<p>所以，随机梯度下降算法实际上就是扫描所有的训练样本，首先是第一组训练样本(x(1),y(1))，然后只根据这个训练样本对参数theta进行修改，完成上面的那个内层循环之后，转向第二个训练样本，然后对参数theta进行修改，……，以此类推直到完成所有训练样本。</p>
<p>随机梯度下降算法在每一次计算之后便更新参数 𝜃 ，而不需要首先将所有的训练集求和。</p>
<p>但是这样的算法存在的问题是，不是每一步都是朝着”正确”的方向迈出的。因此算法虽然会逐渐走向全局最小值的位置，但是可能无法站到那个最小值的那一点，而是<strong>在最小值点附近徘徊</strong>。一般使用随机梯度下降法也能得到一个很接近全局最小值的参数，对于实际应用的目的来说是足够用的。</p>
<img src="../source/imgs/${fiilname}/image-20250815212032789.png" alt="image-20250815212032789" style="zoom:50%;" />

<h2 id="小批量梯度下降"><a href="#小批量梯度下降" class="headerlink" title="小批量梯度下降"></a>小批量梯度下降</h2><p>小批量梯度下降算法是介于批量梯度下降算法和随机梯度下降算法之间的算法，<strong>每计算常数𝑏次</strong>训练实例，<strong>便更新一次</strong>参数 𝜃 。</p>
<p>一次使用b个样本。感觉应该是while循环，或者是for循环加步长step</p>
<img src="../source/imgs/${fiilname}/image-20250815212348946.png" alt="image-20250815212348946" style="zoom:50%;" />

<p>下面是视频里的：<img src="../source/imgs/${fiilname}/image-20250815212819097.png" alt="image-20250815212819097" style="zoom:40%;" /></p>
<p>通常令 𝑏 在 2-100 之间。这样做的好处在于，我们可以用<strong>向量化</strong>的方式来循环𝑏个训练实例。</p>
<h2 id="随机梯度下降收敛"><a href="#随机梯度下降收敛" class="headerlink" title="随机梯度下降收敛"></a>随机梯度下降收敛</h2><p>在批量梯度下降中，我们可以令代价函数 𝐽 为迭代次数的函数，绘制图表，根据图表来判断梯度下降是否收敛。但是，在大规模的训练集的情况下，这是不现实的，因为计算代价太大了。</p>
<p>在随机梯度下降中，我们在每一次更新 𝜃 <strong>之前</strong>都计算一次代价，然后<strong>每𝑥次迭代后</strong>，求出这<strong>𝑥次</strong>对训练实例计算<strong>代价的平均值</strong>，然后绘制这些平均值与𝑥次迭代的次数之间的函数图表。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815213532214.png" alt="image-20250815213532214"></p>
<p>当我们绘制这样的图表时，可能会得到一个颠簸不平但是不会明显减少的函数图像（如上面左下图中蓝线所示）。我们可以<strong>增加𝛼</strong>来使得函数<strong>更加平缓</strong>，也许便能看出下降的趋势了（如上面左下图中红线所示）；或者可能函数图表仍然是颠簸不平且不下降的（如洋红色线所示），那么我们的模型本身可能存在一些错误。</p>
<p>如果我们得到的曲线如上面右下方所示，不断地上升，那么我们可能会需要选择一个较小的学习率𝛼。</p>
<p>左上角的图可以很明显地看出来是在收敛，红色的线是采用了更小地学习率，因此可以看到它收敛的速度变慢了，但最后得到的效果可能更好。</p>
<p>我们也可以令学习率随着迭代次数的增加而减小，例如令：<br>$$<br>α&#x3D;\frac{const1}{iterationNumber+const2}<br>$$<br>随着我们不断地靠近全局最小值，通过减小学习率，我们迫使算法收敛而非在最小值附近徘徊。 但是通常我们不需要这样做便能有非常好的效果了，对𝛼进行调整所耗费的计算通常不值得。</p>
<p>这种方法不需要定时地扫描整个训练集，来算出整个样本集的代价函数，而是只需要每次对最新 1000 个，或者多少个样本，求一下平均值。</p>
<h2 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h2><p>一种新的大规模的机器学习机制，叫做在线学习机制，在线学习机制让我们可以模型化问题。</p>
<p>使用不同版本的在线学习机制算法，从大批的涌入又离开网站的用户身上进行学习。特别要提及的是，如果你有一个由连续的用户流引发的连续的数据流，进入你的网站，你能做的是使用一个在线学习机制，从数据流中学习用户的偏好，然后使用这些信息来优化一些关于网站的决策。</p>
<p>在线学习算法指的是对<strong>数据流</strong>而非离线的静态数据集的学习。</p>
<p>假使我们正在经营一家物流公司，每当一个用户询问从地点 A 至地点 B 的快递费用时，我们给用户一个报价，该用户可能选择接受（ 𝑦 &#x3D; 1）或不接受（ 𝑦 &#x3D; 0）。</p>
<p>现在，我们希望构建一个模型，来预测用户接受报价使用我们的物流服务的可能性。因此报价 是我们的一个特征，其他特征为距离，起始地点，目标地点以及特定的用户数据。模型的输出是:𝑝(𝑦 &#x3D; 1)。</p>
<p>在线学习的算法与随机梯度下降算法有些类似，我们对<strong>单一的实例</strong>进行学习，而非对一个提前定义的训练集进行循环。</p>
<pre><code class="hljs plaintext">Repeat forever (as long as the website is running) &#123;
Get (𝑥, 𝑦) corresponding to the current user
𝜃: = 𝜃𝑗 − 𝛼(ℎ𝜃(𝑥) − 𝑦)𝑥𝑗
(for 𝑗 = 0: 𝑛)
&#125;</code></pre>

<p>一旦对一个数据的学习完成了，我们便可以丢弃该数据，不需要再存储它了。</p>
<p>这种方式的好处在于，我们的算法可以很好的适应用户的倾向性，算法可以针对用户的当前行为不断地更新模型以适应该用户。</p>
<p>每次交互事件<strong>并不只产生一个数据集</strong>，例如，我们一次给用户提供 3 个物流选项，用户选择 2 项，我们实际上可以获得 3 个新的训练实例，因而我们的算法可以一次从 3 个实例中学习并更新模型。  </p>
<p>我们所使用的这个算法与随机梯度下降算法非常类似，唯一的区别的是，我们不会使用一个固定的数据集，我们会做的是获取一个用户样本，从那个样本中学习，然后丢弃那个样本并继续下去。</p>
<p>在线学习的一个优点就是，如果你有一个<strong>变化</strong>的用户群，又或者你在尝试预测的事情，在缓慢<strong>变化</strong>，就像你的用户的品味在缓慢<strong>变化</strong>，这个在线学习算法，可以慢慢地调试你所学习到的假设，将其调节更新到最新的用户行为。</p>
<h2 id="映射化简和数据并行"><a href="#映射化简和数据并行" class="headerlink" title="映射化简和数据并行"></a>映射化简和数据并行</h2><p>如果我们用批量梯度下降算法来求解大规模数据集的最优解，我们需要对整个训练集进行循环，计算偏导数和代价，再求和，计算代价非常大。如果我们能够将我们的数据集分配给不多台计算机，让每一台计算机处理数据集的一个子集，然后我们将计算的结果汇总在求和。这样的方法叫做<strong>映射简化</strong>。</p>
<p>具体而言，如果任何学习算法能够表达为，对训练集的函数的求和，那么便能将这个任务分配给多台计算机（或者同一台计算机的不同 CPU 核心），以达到加速处理的目的。</p>
<h1 id="应用实例：图片文字识别"><a href="#应用实例：图片文字识别" class="headerlink" title="应用实例：图片文字识别"></a>应用实例：图片文字识别</h1><h2 id="问题描述和流程图"><a href="#问题描述和流程图" class="headerlink" title="问题描述和流程图"></a>问题描述和流程图</h2><p>图像文字识别应用所作的事是，从一张给定的图片中识别文字。</p>
<p>为了完成这样的工作，需要采取如下步骤：</p>
<p>1.文字侦测（ Text detection） ——将图片上的文字与其他环境对象分离开来</p>
<p>2.字符切分（ Character segmentation） ——将文字分割成一个个单一的字符</p>
<p>3.字符分类（ Character classification） ——确定每一个字符是什么</p>
<p>可以用任务流程图来表达这个问题，每一项任务可以由一个单独的小队来负责解决。</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口是一项用来从图像中抽取对象的技术。假使我们需要在一张图片中识别行人，首先要做的是用许多固定尺寸的图片来训练一个能够准确识别行人的模型。然后我们用之前训练识别行人的模型时所采用的图片尺寸在我们要进行行人识别的图片上进行剪裁，然后将剪裁得到的切片交给模型，让模型判断是否为行人，然后在图片上滑动剪裁区域重新进行剪裁，将新剪裁的切片也交给模型进行判断，如此循环直至将图片全部检测完。</p>
<p>一旦完成后，我们按比例放大剪裁的区域，再以新的尺寸对图片进行剪裁，将新剪裁的切片按比例缩小至模型所采纳的尺寸，交给模型进行判断，如此循环。</p>
<img src="../source/imgs/${fiilname}/image-20250817105612582.png" alt="image-20250817105612582" style="zoom:50%;" />

<p>滑动窗口技术也被用于文字识别，首先训练模型能够区分字符与非字符，然后，运用滑动窗口技术识别字符。<img src="../source/imgs/${fiilname}/image-20250817110333378.png" alt="image-20250817110333378" style="zoom:67%;" /></p>
<img src="../source/imgs/${fiilname}/image-20250817111412597.png" alt="image-20250817111412597" style="zoom:50%;" />

<p>白色区域说明文本检测系统发现了文本。黑色区域说明没有文本。深浅不同不同的灰色区域对于分类器输出的概率，所以可以理解为它找到了文本但不大确定。</p>
<p>一旦完成了字符的识别，我们将识别得出的区域进行一些扩展，然后将重叠的区域进行合并。接着我们以宽高比作为过滤条件，过滤掉高度比宽度更大的区域（认为单词的长度通常比高度要大）。下图中绿色的区域是经过这些步骤后被认为是文字的区域，而红色的区域是被忽略的。</p>
<img src="../source/imgs/${fiilname}/image-20250817105700648.png" alt="image-20250817105700648" style="zoom:50%;" />

<p>以上便是文字侦测阶段。 下一步是训练一个模型来完成将文字分割成一个个字符的任务，需要的训练集由单个字符的图片和两个相连字符之间的图片来训练模型。我们需要用有监督的学习学习算法，需要检查这些图像块并且尝试决定在图像块的中间是否存在两个字符的分割。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817110406871.png" alt="image-20250817110406871"></p>
<img src="../source/imgs/${fiilname}/image-20250817112216119.png" alt="image-20250817112216119" style="zoom:60%;" />



<p>模型训练完后，我们仍然是使用滑动窗口技术来进行字符识别。</p>
<p>以上便是字符切分阶段。 最后一个阶段是字符分类阶段，利用神经网络、支持向量机或者逻辑回归算法训练一个分类器即可。</p>
<h2 id="获取大量数据和人工数据"><a href="#获取大量数据和人工数据" class="headerlink" title="获取大量数据和人工数据"></a>获取大量数据和人工数据</h2><p>以我们的文字识别应用为例，我们可以字体网站下载各种字体，然后利用这些不同的字体配上各种不同的随机背景图片创造出一些用于训练的实例，这让我们能够获得一个无限大的训练集。这是从零开始创造实例。</p>
<p>另一种方法是，利用已有的数据，然后对其进行修改，例如将已有的字符图片进行一些扭曲、旋转、模糊处理。只要我们认为实际数据有可能和经过这样处理后的数据类似，我们便可以用这样的方法来创造大量的数据。有关获得更多数据的几种方法： </p>
<p>1.人工数据合成</p>
<p>2.手动收集、标记数据</p>
<p>3.众包</p>
<h2 id="上限分析：哪部分管道的接下去做"><a href="#上限分析：哪部分管道的接下去做" class="headerlink" title="上限分析：哪部分管道的接下去做"></a>上限分析：哪部分管道的接下去做</h2><p>在机器学习的应用中，我们通常需要通过几个步骤才能进行最终的预测，我们如何能够知道哪一部分最值得我们花时间和精力去改善呢？这个问题可以通过上限分析来回答。</p>
<p>回到我们的文字识别应用中，我们的流程图如下：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817112430003.png" alt="image-20250817112430003"></p>
<p>流程图中每一部分的输出都是下一部分的输入，上限分析中，我们选取一部分，手工提供 100%正确的输出结果，然后看应用的整体效果提升了多少。假使我们的例子中总体效果为 72%的正确率。</p>
<p>如果我们令文字侦测部分输出的结果 100%正确，发现系统的总体效果从 72%提高到了89%。这意味着我们很可能会希望投入时间精力来提高我们的文字侦测部分。</p>
<p>接着我们手动选择数据，让字符切分输出的结果 100%正确，发现系统的总体效果只提升了 1%，这意味着，我们的字符切分部分可能已经足够好了。</p>
<p>最后我们手工选择数据，让字符分类输出的结果 100%正确，系统的总体效果又提升了10%，这意味着我们可能也会应该投入更多的时间和精力来提高应用的总体表现。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-真题技巧" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/05/%E7%9C%9F%E9%A2%98%E6%8A%80%E5%B7%A7/" class="article-date">
  	<time datetime="2025-05-05T11:30:32.000Z" itemprop="datePublished">2025-05-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/05/%E7%9C%9F%E9%A2%98%E6%8A%80%E5%B7%A7/">
        真题技巧
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一个流程的优化，从两方面入手，第一它自己的数据状况，第二它所要求解的标准。</p>
<h1 id="窗口不回退（左边界和右边界不回退）"><a href="#窗口不回退（左边界和右边界不回退）" class="headerlink" title="窗口不回退（左边界和右边界不回退）"></a>窗口不回退（左边界和右边界不回退）</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250505193132149.png" alt="image-20250505193132149"></p>
<p>类似于滑动窗口，从最左边的点开始向右移动，第一个点记作L，计算下一个点和第一个点的距离是否在绳子长度以内，在的话就是可以覆盖，找到能覆盖的最右边的点记作R，在这个范围内的点数就是可以覆盖的数量，这样子只需要遍历一边过去就行。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250505194246711.png" alt="image-20250505194246711"></p>
<h1 id="打表法"><a href="#打表法" class="headerlink" title="打表法"></a>打表法</h1><p><strong>当一道题目，输入是一个整数，输出也是一个整数时，可以先写一个特别傻的解法，然后分析一下值的输出规律，进而优化代码。</strong></p>
<p>根据这个输出规律硬捏出代码，绝对是最优解，不要考虑是什么原理。当然不是所有题目都是这个特征，但可以解决4成的题目。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250505194423272.png" alt="image-20250505194423272"></p>
<p>奇数肯定不行，先判断是否是奇数。</p>
<p>普通解法：先看最多可以用几个8类型的袋子，不能全用8类型的袋子的话就开始一个一个的减，看下剩下的能不能用6类型的袋子解决。</p>
<p>优化：利用最小公倍数，6和8的最小公倍数是24，那么当剩下的苹果数量大于24还不能被完全装入的时候，接下来就不需要继续试了，说明肯定不能正好装下。因为大于24的部分是刚开始只用8类型的袋子装时剩下的，被验证过最后不能全用6类型的袋子正好装下，所以剩下的就不用继续试了。假如说你剩下27个，那24的用6的袋子装完后，还剩下3个，而这3个是你之前试过不成功的；继续往下试的话就是剩下35个，去掉24剩下11个，这个也是24个之前试过不行的。</p>
<p>使用24还有一个原因是，24用8袋子装比6袋子要少，所以大于24的，里面的24肯定用8装更好，但我们接下来是都用6装的，所以就已经落后了，而一旦剩下的大于24那只用6装肯定不是最少的。</p>
<p>奇数的可以直接判断不行，所以只是用来展示一下原理。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250505195959106.png" alt="image-20250505195959106"></p>
<p>最优解：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250505201104032.png" alt="image-20250505201104032"></p>
<p>如何得出这个答案，先算100以内的所有苹果的解，然后会发现18开始以后都是有规律的。</p>
<hr>
<p>有先手和后手两只动物吃草，每次只能吃4的某次方的草，给你个N代表一共有多少草，谁最先把草吃完谁赢（就是最后一口是谁吃的就是谁赢），请你返回谁会赢。</p>
<p>0份草的时候是后手赢，因为先手面对的是没有草的情况。</p>
<p>先手怎么试，先吃1份草，不能赢就先吃4，还不能就先吃16，这样试下去，有一次能赢就是先手赢。</p>
<p>最简单的办法：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250505223905068.png" alt="image-20250505223905068"></p>
<p>winner1(n-base)是后手面对的情况，是先手吃的子过程，如果winner1(n-base)返回的是后手赢，说明就是先手赢了，因为原本的后手在winner1(n-base)里是先手，而原本的先手就变成了后手。</p>
<p>防止溢出的意思是防止base超过int的范围。</p>
<p>接下来从0试到50，看下结果。<img src="/../source/imgs/$%7Bfiilname%7D/image-20250505224036221.png" alt="image-20250505224036221"></p>
<p>找到输出规律后，直接根据这个规律来写代码，不用关心数学原理。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250505224143505.png" alt="image-20250505224143505"></p>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506102832956.png" alt="image-20250506102832956"></p>
<p>基本思路：从左往右试，假设左边没有一个R，看下需要染几块，假设左边有一个R，有两个R……有n个R，分别算出各需要染色几块，然后选出最小的就行了。但这样需要一遍又一遍地遍历数组，时间复杂度较高。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506103714149.png" alt="image-20250506103714149"></p>
<p>下面的伪代码和题目刚好相反</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506104731826.png" alt="image-20250506104731826"></p>
<p>所以就对原数组先进行预处理，注意，<strong>下面讲得是将左边染成G，右边染成R的思路，和题目相反</strong>。</p>
<p>由于要将左边全部变成G，那我们从左往右计算分别有几个R，几个R代表需要染几次，所以创建一个A数组代表0~i 的R数量。</p>
<p>要将右边全部变成R，那我们从右往左计算分别有几个G，几个G代表需要染几次，所以创建一个B数组代表n-1~i 的G数量。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506103656809.png" alt="image-20250506103656809"></p>
<p>这样子，再按基本思路解题就可以直接从A，B两个数组直接获取答案了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506104805974.png" alt="image-20250506104805974"></p>
<p>先确定正方形，确定一个左上角点，然后枚举边长。</p>
<p><strong>一个元素是边长为1的正方形。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506105508077.png" alt="image-20250506105508077"></p>
<p>然后要验证这个正方形的四条边是不是都是1，需要遍历4条边。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506105730653.png" alt="image-20250506105730653"></p>
<p><strong>简化验证流程</strong></p>
<p>right代表的是一个矩阵内，每一个位置包含这个位置在内，右方有多少个<strong>连续</strong>的1。</p>
<p>down代表的是任何一个位置包含这个位置在内，下方有多少个<strong>连续</strong>的1。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506110138187.png" alt="image-20250506110138187"></p>
<p>如何利用呢？假设你这个点位于（4，5），边长是3，那就先验证right中的这个点够不够3，等于和超过都算，再看down里的这个点够不够3，都够的话，那就跳转到右边的那个点和下方的那个点（图里画圈的），看右边的点的下方是否够连续的3个1（包括自己），看下面的点的右边是否够连续的三个1，这样就把验证过程变成O(1)级别的了，信息都在right和down里。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506110252178.png" alt="image-20250506110252178"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506110718571.png" alt="image-20250506110718571"></p>
<p><strong>用二进制来拼。</strong></p>
<p>首先，如何利用1<del>5的返回0</del>1的：让1、2返回0，4、5返回1，3的话就重新生成。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506153421045.png" alt="image-20250506153421045"></p>
<p>想要等概率返回1<del>7，先弄一个函数等概率返回0</del>6，然后加1就行了。</p>
<p>如何生成呢？首先3个二进制位可以返回0~7，而二进制是0和1，那就是我们上面的r01函数所做的事情，返回0和1，但3位二进制可以返回7怎么办，返回7的话就重新生成就好了。</p>
<p>那我再res&#x3D;0的时候重新生成，那res的范围不就是1~7了吗。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506153830359.png" alt="image-20250506153830359"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506154516951.png" alt="image-20250506154516951"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506154037233.png" alt="image-20250506154037233"></p>
<p>假如是一个13<del>21的随机数生成器，要要这个随机生成30</del>59的数，那就用13<del>21的随机生成0和1（13</del>16为0，17<del>20为1，21重新生成），利用0和1拼出0</del>29然后加30就是30<del>59了（这个需要5个二进制位，表示范围是0</del>31，大于29的重新生成）。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506154528471.png" alt="image-20250506154528471"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250506154620329.png" alt="image-20250506154620329"></p>
<p>生成两个数，00和11都重新生成，将01定为0，10定为1，概率一样。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250508074957856.png" alt="image-20250508074957856"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250508075141848.png" alt="image-20250508075141848"></p>
<p>可以分N种情况，从左树一个结点都没有到右树一个结点都没有，将这些情况下的个数都加起来就是答案。普遍情况是左树i 个结点，右树N-i-1个结点，那么这种情况的二叉树结构数量为F(i)*F(N-i-1)。F(N)代表的是节点个数为N个的时候有几种二叉树结构。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250508075619603.png" alt="image-20250508075619603"></p>
<p>上面有个错误，应该是leftNum&lt;&#x3D;n-1。可以观察到这种题目肯定会有很多F(N)会重复用到，所以可以改为动态规划的方法。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250508075944201.png" alt="image-20250508075944201"></p>
<h1 id="关注宏观调度过程，不要关注局部怎么变"><a href="#关注宏观调度过程，不要关注局部怎么变" class="headerlink" title="关注宏观调度过程，不要关注局部怎么变"></a>关注宏观调度过程，不要关注局部怎么变</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519192940970.png" alt="image-20250519192940970"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519192554109.png" alt="image-20250519192554109"></p>
<p>解题方法是在左上角和右下角各画一个框，只打印框里的，当两个框错过的时候就是打印完成的时候。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519192754898.png" alt="image-20250519192754898"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519192919154.png" alt="image-20250519192919154"></p>
<p>(a,b)：左上角，(c,d)：右下角</p>
<p>a&#x3D;&#x3D;c代表这是一条横线，b&#x3D;&#x3D;d代表这是一条竖线</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519195608518.png" alt="image-20250519195608518"></p>
<p>如何用这个方法：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250519195747739.png" alt="image-20250519195747739"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519195811250.png" alt="image-20250519195811250"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519195921700.png" alt="image-20250519195921700"></p>
<p>按照这个看的话，当你旋转的时候只会跟这个数字所在的那一圈有关，跟里面的完全没有关系。</p>
<p>我的想法是，一个正方形矩阵，左上角和右上角的度数肯定是90°，所以左上角肯定移到右上角，然后左上角右边位置移到右下角下面位置，就按这个规律转过去就可以了。</p>
<p>他的思路是将这一圈框四个数，左上角，右上角，左下角，右下角，然后顺时针进行交换，然后轮第二个数，也顺时针进行交换，感觉就是我的思路的实现版。这个思路保证变量是有限的且容易实现。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519200927411.png" alt="image-20250519200927411"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519201359927.png" alt="image-20250519201359927"></p>
<p>c是下面那一行的横坐标，上面给出来的四个点就是要进行交换的四个点。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519201549972.png" alt="image-20250519201549972"></p>
<p>如何调用：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250519201602709.png" alt="image-20250519201602709"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519201701788.png" alt="image-20250519201701788"></p>
<p>zigzag方式打印：<img src="../source/imgs/${fiilname}/image-20250519201934133.png" alt="image-20250519201934133" style="zoom:40%;" /></p>
<p>想出来了！：两个点A和B，刚开始都停留在左上角，A就一直往右走，不能走了往下走，B就一直往下走，不能走了往右走，每次只移动一步，然后打印这两个点之间的斜线，要么从左下向右上，要么从右上向左下。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519202410731.png" alt="image-20250519202410731"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519202431675.png" alt="image-20250519202431675"></p>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p>最小栈问题：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520164225739.png" alt="image-20250520164225739"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520164445102.png" alt="image-20250520164445102"></p>
<p>两个栈，一个是存储数据的，还有一个是最小栈，存储各个状态下的最小值，如上图，Data压进一个3，min里面没有数直接压进3；Data压进4，min只压进当前状态下的最小值，由于3比4小，所以继续压进3，这个比较可以直接从min栈顶取数；Data压入2，此时2比3小，所以min压入2；Data压入6，6大于2，所以min压入2。</p>
<img src="../source/imgs/${fiilname}/image-20250520164932811.png" alt="image-20250520164932811" style="zoom:80%;" />

<p>使用两个栈实现队列结构</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520165101751.png" alt="image-20250520165101751"></p>
<p>所有数据都直接进入push栈，用户想要弹出数据，如果此时pop栈中没有元素，那就将push中的全部元素倒入pop中，然后pop弹出。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520165225678.png" alt="image-20250520165225678"></p>
<p>记住两点：push要倒东西一次性倒完；如果pop中有元素的话push中的元素就不能倒进pop中。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520165403435.png" alt="image-20250520165403435"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520165520945.png" alt="image-20250520165520945"></p>
<p>使用队列实现栈结构：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520165816161.png" alt="image-20250520165816161"></p>
<p>准备两个队列，用户想存入数据的话就一直压入队列中，如果用户想弹出数据的话，那就将队列中的最后一个数留在原队列中，其它的压入另一个队列，然后原队列弹出，接下来着另一个队列就成为了要压入数据的队列。如果用户还想要弹出的话，那就重复前面的步骤。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520170028315.png" alt="image-20250520170028315"></p>
<h1 id="动态规划的空间压缩技巧"><a href="#动态规划的空间压缩技巧" class="headerlink" title="动态规划的空间压缩技巧"></a>动态规划的空间压缩技巧</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520170308359.png" alt="image-20250520170308359"></p>
<p><strong>位置依赖</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250520170526307.png" alt="image-20250520170526307"></p>
<p>一个动态规划模型，一个二维表，用户只想要右下角的值，里面的一个元素依赖于上方和左边的元素。在这张表最上面的那一行的元素只依赖于左边的元素，这张表的最左边的那一列的元素只依赖于它们上方的元素。</p>
<p>这种模型，不需要申请一整张二维表，只需要申请一个数组就可以了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250523095435917.png" alt="image-20250523095435917"></p>
<p>假设一个动态规划需要它上面一行多个的值怎么办？<strong>从右往左更新</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250523095616471.png" alt="image-20250523095616471"></p>
<p>一个位置既跟我左边的值有关又跟我上边的值有关，怎么更新？</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250523095909654.png" alt="image-20250523095909654"></p>
<p>先更新第一个位置的f，然后把原位置的a用一个变量先存储起来，然后更新g，g更新完之后，变量需记住b，然后继续往下更新。</p>
<p>上面讲得都是先更新出第一行，然后依次往下更新。如果列很多怎么办，比如4*100万这种的。</p>
<p><strong>先更新一列，然后从左往右依次更新</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250523100513291.png" alt="image-20250523100513291"></p>
<p>哪些题目不能使用这个技巧？</p>
<p>一个点需要跳很远的位置，那就不能压缩。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250523100711523.png" alt="image-20250523100711523"></p>
<p>假如只跳两行，那可以使用三个数组来求解，先分别求出0，1，2行的值，然后求解第3行时使用第0行的数组进行求解。</p>
<p>但如果一个点跳的太远了，那么可能需要的数组就会很多，那就没有那么划算了。</p>
<p>按照这个理论，三层的动态规划问题也可以解决。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250523101112371.png" alt="image-20250523101112371"></p>
<p>第一行是要求的，第二，三行是依赖的位置。</p>
<h1 id="洗衣机问题"><a href="#洗衣机问题" class="headerlink" title="洗衣机问题"></a>洗衣机问题</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519185751748.png" alt="image-20250519185751748"></p>
<p>这道题考两个点：一是靠猜，二是考你怎么更新。</p>
<p>有物品的机器每轮可以扔出一件物品，往左往右都可以。</p>
<p>只看一台机器，以这台机器为分界点，可以看出左边和右边分别是缺了或者多了多少物品。负数代表缺，正数代表多。</p>
<p>（1）左右两边都缺</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519190901113.png" alt="image-20250519190901113"></p>
<p>那 i 这个机器至少需要经历25轮。所以只看一台机器，不管其它机器，两侧都缺的话，这台机器最少需要经历的轮数是<strong>两边的绝对值相加</strong>。左右皆正的话，在同一轮里，左边可以向右扔，右边可以向左扔。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519191322338.png" alt="image-20250519191322338"></p>
<p>将每个位置至少需要的轮数都求出来，那最大的轮数就是答案。</p>
<p>想到了，但不知道为什么是答案。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519191659043.png" alt="image-20250519191659043"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519192320107.png" alt="image-20250519192320107"></p>
<p>leftSum是左侧已经遍历过的累加和，i*avg是  i 位置的左侧需要的衣服。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250523101249901.png" alt="image-20250523101249901"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250523102201256.png" alt="image-20250523102201256"></p>
<p>这道问题和洗衣机问题很像，洗衣机问题只关注自己左右两侧的事，这道题<strong>只关注自己这一列可以放下多少水</strong>。</p>
<p>求解标准：<img src="../source/imgs/${fiilname}/image-20250523102951299.png" alt="image-20250523102951299" style="zoom:33%;" /></p>
<p>按照常理来说是要建立两个辅助数组，第一个辅助数组记录的是0<del>i位置的最大值，第二个辅助数组记录的是i</del>n-1位置的最大值。</p>
<p>但最优解是不要辅助数组。重点是看<strong>瓶颈由谁决定，由较小的那方决定</strong>。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250523103652655.png" alt="image-20250523103652655"></p>
<p>ALL记录的总水量，0位置和8位置肯定不会有水，max左记录的是左边已经遍历的最大值，max右记录的是右边已经遍历过的最大值，L和R是两个指针。</p>
<p>此时，已经可以求解R位置的水量了，因为max左&gt;max右，且左边还没遍历完它的最大值就已经是10了，所以max左的最小值肯定是目前的数，而max右代表着R位置右边的最大值，所以可以得出答案就是7-3&#x3D;4。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250523104041806.png" alt="image-20250523104041806"></p>
<p>注意：6位置的数据改变了。此时可以结算L位置的水量了。</p>
<p>max左较小就先结算L的水量，max右较小就先结算R的水量，两个一样大，L和R可以同时结算。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250523105054994.png" alt="image-20250523105054994"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250523105043895.png" alt="image-20250523105043895"></p>
<p>先求出全局最大值max，那当划分左右的时候，max在哪边哪边的最大值就是max，所以就分为了两种情况：max-max左，max-max右。而max-max左&#x3D;max-arr[0]，max-max右&#x3D;max-arr[n-1]。以左边为例，无论左边最大的数是谁，减arr[0]都是最好的，因为假如有数大于了arr[0]由于我们要差值最大，所以我们选择arr[0]，假如有数比arr[0]小，由于取得是最大值所以max左依旧等于arr[0]。</p>
<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250524165701127.png" alt="image-20250524165701127"></p>
<p>先看a，b是否长度一样，然后生成a+a的字符串，判断b是否是a+a的子串（easy）。</p>
<h1 id="咖啡问题"><a href="#咖啡问题" class="headerlink" title="咖啡问题"></a>咖啡问题</h1><p>先给你一个数组arr，数组里每一个值都是正数，一个数代表一台咖啡机的工作效率，代表冲咖啡的时间，一个咖啡机一次只能处理一杯咖啡，arr中有几个数就说明有几台咖啡机，拿到咖啡后喝咖啡的时间为0，参数N代表喝咖啡的人数，每人只喝一杯，参数a代表只有一台洗咖啡杯的机器，这个机器用a的时间洗一个咖啡杯，一次只能洗一个杯子，参数b代表咖啡杯不洗能变干净的时间，一直到所有咖啡杯都洗干净至少需要多少时间。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250525192410252.png" alt="image-20250525192410252"></p>
<p>假设有10个人，编号0~9，arr数组为[3,2,1]，先建立一个小根堆，小根堆中的元素为（时刻，冲咖啡的时间），代表在这个时刻咖啡机是可用的，按两个数值相加谁小谁排上面，也就是按结束时间的早晚排序的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250525192708945.png" alt="image-20250525192708945"></p>
<p>第0个人选择（0，2），记下，（0，2）转变为（2，2）扔回小根堆中。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250525192829082.png" alt="image-20250525192829082"></p>
<p>第1个人选择（0，3），记下，（0，3）转变为（3，3），扔回小根堆，就按这个规律选择咖啡机。</p>
<p>在最下面得到的数组也就是每个人有洗咖啡杯需求的时间的数组，接下来就看要怎么安排使得洗咖啡杯的时间最短。每个人有两种选择，洗咖啡机和挥发，这是一个从左往右进行尝试的问题。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250525194856655.png" alt="image-20250525194856655"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250525194841720.png" alt="image-20250525194841720"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250525194656768.png" alt="image-20250525194656768"></p>
<p>调用函数：process(drinks,a,b,0,0)</p>
<p>drinks是每个人喝完咖啡的时间，index代表轮到第几个人开始洗，washLine是洗咖啡的机器在什么时间点有空。</p>
<h1 id="斐波那契套路"><a href="#斐波那契套路" class="headerlink" title="斐波那契套路"></a>斐波那契套路</h1><p><strong>除了初始项之外，后面每一项都有严格的递归式的问题，那可以将时间复杂度变为logN。</strong></p>
<p>斐波那契问题</p>
<img src="../source/imgs/${fiilname}/image-20250529080502519.png" alt="image-20250529080502519" style="zoom:80%;" />

<p>这是线性代数的内容：这种式子它还存在着一个矩阵的式子，由于它最多只需要前两项，所以矩阵为二阶矩阵。<img src="/../source/imgs/$%7Bfiilname%7D/image-20250529080805523.png" alt="image-20250529080805523"></p>
<p>可以通过初始的几项将abcd求出来。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529080942966.png" alt="image-20250529080942966"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529081004144.png" alt="image-20250529081004144"></p>
<p>从而，可以得到以下结论：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250529081135418.png" alt="image-20250529081135418"></p>
<p>那求斐波那契问题就转化为了求矩阵n次方的问题。</p>
<p>怎么求矩阵的n次方最快，先探索怎么求一个数的n次方最快。</p>
<p>先将次方转化为二进制形式，然后重点关注哪一位上是有1的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529081726188.png" alt="image-20250529081726188"></p>
<p>假设t&#x3D;10，根据二进制每一位的值为t赋次方，哪一位上为1就乘以那一位的t的次方，上面的例子就是1，2，8，64为1，所以就要分别乘以t的1，2，8，64次方，可以算出等于75次方。一个数的n次方可以这样算，那同理矩阵也可以这样算。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529082257273.png" alt="image-20250529082257273"></p>
<p>假设t&#x3D;矩阵a，其它的同上，最后算结果的时候先乘以一个单位矩阵。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529082958862.png" alt="image-20250529082958862"></p>
<p>最后F(N)&#x3D;X+P，所以return <code>res[0][0] + res[1][0]</code></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529083111206.png" alt="image-20250529083111206"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529083223550.png" alt="image-20250529083223550"></p>
<p>两个矩阵m1、m2相乘的结果返回：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529083258528.png" alt="image-20250529083258528"></p>
<p>将这个规律进行推广，假设有下面的严格推导式：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529083727135.png" alt="image-20250529083727135"></p>
<p>必须给前5项作为初始项，所以矩阵为5阶矩阵。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529083954539.png" alt="image-20250529083954539"></p>
<p>由于初始几项可以自己算出来，所以就可以将这个5*5的矩阵算出来，算出来后就可以得出通式了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529084123403.png" alt="image-20250529084123403"></p>
<hr>
<p>有一个农场，它有母牛A，它只能生母牛，每年生一只母牛，小牛3年后成熟可以开始生育，问n年之后牛的数量。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529084504864.png" alt="image-20250529084504864"></p>
<p>规律是这个：<img src="../source/imgs/${fiilname}/image-20250529084702348.png" alt="image-20250529084702348" style="zoom:33%;" />因为，今年牛的数量&#x3D;去年牛的数量（不会死亡）+新生牛的数量（由于近三年新出生的小牛没成熟，不能生育，所以可以生育的是3年前的牛），所以会有一个3阶矩阵。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529085049373.png" alt="image-20250529085049373"></p>
<p>这种问题，只有矩阵和初始值会不一样，其它的都一样。</p>
<hr>
<p>假设一个农场初始有一只兔子，一只兔子每年生两个，小兔子两年成熟，兔子寿命为5年。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529085414824.png" alt="image-20250529085414824"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529085506855.png" alt="image-20250529085506855"></p>
<p>打表法！</p>
<p>然后你就会发现规律是斐波那契套路。</p>
<p>如果不用打表法，怎么发现规律是斐波那契套路。假设一个函数F(i)，意思是 i 长度的字符串，每个位置都可以为0或1，但 i 长度之前的位置的数必须为1。所以假如长度为8的话，那就需要调用F(7)，因为第一位必须为1，否则肯定不是达标字符串。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529091019271.png" alt="image-20250529091019271"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529091145102.png" alt="image-20250529091145102"></p>
<p>F(i)会等于什么，有两种情况，第一种是当 i 长度的字符串第一位为1时，那符合F函数的定义，所以会等于F(i-1)，第二种是当第一位为0时，那第二位必须为1，满足F函数定义，所以会等于F(i-2)。因此F(i) &#x3D; F(i-1) + F(i - 2)，斐波那契。</p>
<p>通过打表法发现规律最简单。</p>
<h1 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815153651442.png" alt="image-20250815153651442"></p>
<p>例子，假设有以下几个目录：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250815153805246.png" alt="image-20250815153805246"></p>
<p>建立一个前缀树：<img src="../source/imgs/${fiilname}/image-20250815153941424.png" alt="image-20250815153941424" style="zoom:50%;" /></p>
<p>根据深度优先遍历打印出来就可以了。重点是如何建立前缀树。</p>
<p>在java和python中<code>&#39;\&#39;</code>需要转义才可以表达出来，但是在java中要按<code>&#39;\&#39;</code>切割字符串就需要写成<img src="../source/imgs/${fiilname}/image-20250815154444725.png" alt="image-20250815154444725" style="zoom:50%;" />，但是在python中就只需要<img src="../source/imgs/${fiilname}/image-20250815155229837.png" alt="image-20250815155229837" style="zoom:67%;" /></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815155507139.png" alt="image-20250815155507139"></p>
<p>注意这边使用的是<strong>有序表</strong>，因为要顺序输出，Java 的 TreeMap&lt;String, Node&gt; 会自动按键（文件夹名）的字母顺序排序。在 Python 中，标准的 dict 从 3.7+ 版本开始会保持插入顺序，但不会自动排序。为了模拟 TreeMap 的行为，我们在打印时对字典的键进行排序 (sorted(node.next_map.keys()))。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815160359045.png" alt="image-20250815160359045"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815160712320.png" alt="image-20250815160712320"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815160542705.png" alt="image-20250815160542705"></p>
<p>python实现：</p>
<pre><code class="hljs plaintext">import collections

# 1. Node 类的定义
class Node:
    def __init__(self, name: str):
        self.name = name
        self.next_map = &#123;&#125;


def generate_folder_tree(folder_paths: list[str]) -&gt; Node:
    # head 是根节点，对应 Java 中的 new Node(&quot;&quot;)
    head = Node(&quot;&quot;)
    for path in folder_paths:
        # 按 &quot;\&quot; 分割路径，得到各级文件夹名
        parts = path.split(&#x27;\\&#x27;)
        current_node = head
        for part in parts:
            if part not in current_node.next_map:
                current_node.next_map[part] = Node(part)
            current_node = current_node.next_map[part]
    return head


def _print_process(node: Node, level: int):
    # 根节点 (level 0) 是一个虚拟节点，我们不打印它的名字
    if level != 0:
        # 生成缩进字符串，每级缩进2个空格
        indent = &quot;  &quot; * (level - 1)
        print(f&quot;&#123;indent&#125;&#123;node.name&#125;&quot;)

    # 为了模拟 Java TreeMap 的排序行为，我们在遍历前对键进行排序
    for key in sorted(node.next_map.keys()):
        next_node = node.next_map[key]
        _print_process(next_node, level + 1)


def print_folder_tree(folder_paths: list[str]):
    &quot;&quot;&quot;
    主函数，用于构建并打印文件夹结构树。
    &quot;&quot;&quot;
    if not folder_paths:
        return
    
    # 根据路径字符串，把前缀树建立好，头节点为 head
    head = generate_folder_tree(folder_paths)
    
    # 打印
    _print_process(head, 0)


if __name__ == &quot;__main__&quot;:
    # 创建一个示例路径列表
    paths = [
        &quot;a\\b\\c&quot;,
        &quot;a\\b\\d&quot;,
        &quot;a\\c\\e&quot;,
        &quot;b\\c\\f&quot;,
        &quot;a\\c\\z&quot;
    ]
    
    print(&quot;文件夹结构:&quot;)
    print_folder_tree(paths)</code></pre>

<p>上述代码用到了类型提示 或 类型注解，即<code>def __init__(self, name: str):</code>里的<code>**name: str**</code>正是类型提示的核心部分，name 是参数的名称。: str 是对这个参数的 “提示” 或 “注解”。它告诉阅读代码的人：“<strong>我期望 name 这个参数应该是一个字符串 (str) 类型。</strong>”</p>
<p>在<code>def generate_folder_tree(folder_paths: list[str]) -&gt; Node:</code>中，除了类型提示外，<code>**-&gt; Node**</code>是一个<strong>返回值类型提示</strong>，箭头 -&gt; 后面的部分用来注解函数的<strong>返回值类型</strong>。告诉我们：“<strong>这个函数执行完毕后，预计会返回一个 Node 类型的对象。</strong>”</p>
<p>自己写函数的话不需要这样写。</p>
<h1 id="二叉树套路"><a href="#二叉树套路" class="headerlink" title="二叉树套路"></a>二叉树套路</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815162713474.png" alt="image-20250815162713474"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815162812812.png" alt="image-20250815162812812"></p>
<p>最后返回2节点。</p>
<p>要转换的话，每部分分别返回头和尾：<img src="../source/imgs/${fiilname}/image-20250815163133326.png" alt="image-20250815163133326" style="zoom:40%;" /></p>
<p>左边部分的尾指向x，x的left指向左边部分的尾；右边部分的头指向x，x的right指向右边部分的头，最后返回左边部分的头和右边部分的尾作为x的头和尾。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815163459942.png" alt="image-20250815163459942"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815163822109.png" alt="image-20250815163822109"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815163551210.png" alt="image-20250815163551210"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815163750906.png" alt="image-20250815163750906"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815163938068.png" alt="image-20250815163938068"></p>
<img src="../source/imgs/${fiilname}/image-20250815164224120.png" alt="image-20250815164224120" style="zoom:50%;" />

<p>下面的是要求返回最大搜索二叉子树的头结点。要是比较的两个搜索二叉子树的节点个数一样这边返回一个就行。</p>
<p>以x开头的树，最大搜索二叉子树有两种情况，和x有关，和x无关。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815164609278.png" alt="image-20250815164609278"></p>
<p>与x有关的后面两个条件是，左max&lt;x，右min&gt;x。最终答案如果3）成立那就是3），不然就是1）或2）。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815165017924.png" alt="image-20250815165017924"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815165613014.png" alt="image-20250815165613014"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815165819713.png" alt="image-20250815165819713"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815170318703.png" alt="image-20250815170318703"></p>
<p>判断有可能性3的两个if条件是：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250815170420337.png" alt="image-20250815170420337"></p>
<h1 id="假设答案法"><a href="#假设答案法" class="headerlink" title="假设答案法"></a>假设答案法</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815171101885.png" alt="image-20250815171101885"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815180107695.png" alt="image-20250815180107695"></p>
<p>这道题目的流程是，cur代表的是和，初值为0。cur按顺序从头开始叠加，每当cur刚加完一个数后，如果cur&gt;0，max更新，如果cur&lt;0，设置cur&#x3D;0，max不更新。</p>
<p>以上面那个例子就是:cur&#x3D;3，max&#x3D;3；cur&#x3D;5,max&#x3D;5；cur&#x3D;4，5和4比较，5比较大，max不变；cur&#x3D;8,max&#x3D;8；cur&#x3D;-1&lt;0，max不比较，cur&#x3D;0；cur&#x3D;4&lt;max，不更新；一直算下去，最后max&#x3D;13。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815180553227.png" alt="image-20250815180553227"></p>
<p>为什么这样做？</p>
<p>这个流程在数组没有正数的情况下也是对的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815180841143.png" alt="image-20250815180841143"></p>
<p>假设椭圆形区域的数组既是这个数组中累加和最大的又是所有满足最大累加和子数组中最长的那个数组，在上面的例子中就是[1,1,1,1]。</p>
<p>假设椭圆形区域的开头是 i ，最后一个下标是 j ，那会有以下性质：</p>
<p>1）从 i 到end(end&lt;j)的区域的和都大于等于0</p>
<p>2）任何一个开头累加到i-1位置的和必小于0</p>
<p>面对这道题应该先假设答案，假设答案的时候发现设置什么样的流程可以将你这个答案找到，而且设计的这个流程时间复杂度要尽量低。</p>
<img src="../source/imgs/${fiilname}/image-20250815201250779.png" alt="image-20250815201250779" style="zoom:67%;" />

<p>例子：<img src="../source/imgs/${fiilname}/image-20250815201355980.png" alt="image-20250815201355980" style="zoom:50%;" /></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815201528371.png" alt="image-20250815201528371"></p>
<p>解这道题的流程是：必须包含0行且只包含0行，最大子矩阵和是多少；必须包含0，1行，且只包含0，1行，最大子矩阵和是多少；……；必须包含2行，且只包含2行，最大子矩阵和是多少。</p>
<p>那每一次情况要怎么求？</p>
<img src="../source/imgs/${fiilname}/image-20250815202109006.png" alt="image-20250815202109006" style="zoom:50%;" />



<p>0~0：就是只有一行数据，按上面那道题的解法来就可以了。</p>
<p>0~1：两行数据，同一列的数据相加，会得到这些数据-12，12，1，7，现在又变成只有一行数据了，那接下来就按上面的解法就行了。</p>
<p>求出来的答案再找出对应的矩阵就可以了：<img src="../source/imgs/${fiilname}/image-20250815202406269.png" alt="image-20250815202406269" style="zoom:50%;" /></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250815202533901.png" alt="image-20250815202533901"></p>
<p><strong>看到子矩阵问题就先想子数组是怎么办的，如果子数组的问题解决了，那就看能不能用压缩的方式将子矩阵的问题变成压缩之后子数组的问题。</strong></p>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817154310184.png" alt="image-20250817154310184"></p>
<p>‘X’位置不能放灯。</p>
<p>既然’X’位置不能放灯，那可不可以遍历，找到连续的’.’，三个三个一组求需要灯的数量。</p>
<img src="../source/imgs/${fiilname}/image-20250817154812958.png" alt="image-20250817154812958" style="zoom:50%;" />

<p>根据 i 位置是什么进行分类：1）i 位置是’X’，那不放灯；</p>
<p>​		2）i 位置是’.’，那要看i+1位置，（1）i+1位置是’X’，那灯放在 i 位置（2）i+1位置是’.’，那灯就放在i+1位置</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817155745273.png" alt="image-20250817155745273"></p>
<p><code>index = index+3</code>解决的就是2）（2）中情况，原本是在 index 位置直接放灯，但如果下一位置也是’.’的话，那就再下一位置放灯，因为灯会影响到左中右三个位置，所以让灯放在index+1位置，那index+2位置就不用考虑了，接下来直接考虑index+3就行了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823163405004.png" alt="image-20250823163405004"></p>
<p>先建立词频表。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823163606998.png" alt="image-20250823163606998"></p>
<p>接下来从头开始遍历字符串，遍历一个字符就在词频表中相对应的词频-1，当词频表中有一个为0时暂停，此时划定了一个范围，在例子中是a的词频为0了。这个划定的范围的意思是如果在这个范围内只留一个字符，剩下内容全删掉，能够保证不会有某种字符缺的范围。在这个范围内选择ASCII码最小的，在例子中选择在1位置的字符，那接下来就是将1前面的字符全部删掉，然后将剩下范围内的a全部删掉，最后得到bcbbct。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823164231092.png" alt="image-20250823164231092"></p>
<p>接下来再建立词频表。</p>
<p>重复上面的步骤，最后就可以得到答案。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823164700525.png" alt="image-20250823164700525"></p>
<h1 id="递增子序列问题"><a href="#递增子序列问题" class="headerlink" title="递增子序列问题"></a>递增子序列问题</h1><p>子序列，从左往右，可以不连续。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817170757860.png" alt="image-20250817170757860"></p>
<img src="../source/imgs/${fiilname}/image-20250817170853118.png" alt="image-20250817170853118" style="zoom:33%;" />

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817171510424.png" alt="image-20250817171510424"></p>
<p>dp数组：子序列必须以arr[i]结尾的情况下，最长递增子序列的长度。</p>
<p>dp[3]：由于arr[3]的值是6，左边比它小的数有3、1、2，那哪个比较好，因为2的数量比较多，所以选择dp[2]，然后加一。</p>
<p>这个动态规划的方法的时间复杂度为O(n^2)，接下来有探讨时间复杂度为O(n*logn)的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817172048580.png" alt="image-20250817172048580"></p>
<p>dp数组的含义和上面的还是一样的。</p>
<p>ends数组：刚开始全部都是无效区，如果一个位置在无效区中，认为它没有含义。如果一个位置在有效区里，那就有含义了，含义是所有长度为i+1的递增子序列中最小结尾是什么值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817172142872.png" alt="image-20250817172142872"></p>
<p>ends[0]&#x3D;3，无效区缩小，为什么后面还是无效区，因为没有长度为2、3、4、5、6的递增子序列，此时递增子序列是{3}，长度为1，最小值是3，所以ends[0]&#x3D;3。</p>
<p>接下来遍历到arr[1]&#x3D;2，然后在ends的有效区里二分地找大于2的最左的位置，那就是3，然后用2代替3。</p>
<p>为什么要这样代替呢？因为2的出现导致现在有两个递增子序列，没有形成长度为2的递增子序列，所以此时长度为1的递增子序列中最小结尾的值是2，所以2更新3。</p>
<p>那如何确认dp值呢？在ends数组中找到2连同自己在内左侧有几个数，一个数，所以dp值为1。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817172845568.png" alt="image-20250817172845568"></p>
<p>接下里是4，在ends的有效区中二分地找大于4的最左的位置，没找到，那就要扩充有效区，因为4的出现开始出现长度为2的递增子序列了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817173229593.png" alt="image-20250817173229593"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817173256602.png" alt="image-20250817173256602"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817201751304.png" alt="image-20250817201751304"></p>
<p>计算数字n能否被3整除有三种方法：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250817201923461.png" alt="image-20250817201923461"></p>
<p>其中第二种方法和第三种方法是等效的，所以采用第三种方法。</p>
<p>视频讲得是，判断10能否被3整除，就是看1+0能否被3整除，那么看1+0能否被3整除不就相当于10能否被3整除，这是一个等价命题。还有一个例子就是判断123能否被3整除看的是1+2+3能否被3整除，那1+2+3能否被3整除就相当于看123能否被3整除。</p>
<p>按照我的理解的话就是，例如12345678910，正常来说是算1+2+3+4+5+6+7+8+9+1+0，但如果1+2+3+4+5+6+7+8+9可以被3整除，那么后面再加上一个可以被3整除的数n的话，那么和也是能被3整除的，如果加上的n是不能被3整除的数的话，因为n不能被3整除，所以将n拆解开的和m也不能被3整除，那么原本加m的和也就不能被3整除，所以会等价于1+2+3+4+5+6+7+8+9+10。</p>
<h1 id="in-place-算法"><a href="#in-place-算法" class="headerlink" title="in place 算法"></a>in place 算法</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822201729757.png" alt="image-20250822201729757"></p>
<p>数组要按照这个规律排序，就是在 i 位置上放置的数的大小是i+1，达不到的话就说明缺少了i+1</p>
<p>假设5位置上放的是16，那我要将16放到15这个位置上，那会有以下几种情况：</p>
<p>1）15位置上放的就是16，那就不需要移动了</p>
<p>2）15位置上放的不是16，那就将16移动到15位置上，然后寻找15位置上的数应该放到哪里，一直这样下去，直到达成第一种情况</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822202422508.png" alt="image-20250822202422508"></p>
<p>0位置上放的是3，所以要放到2位置上，2位置上放的是1，所以先将1拿出来，3放到2上，然后寻找1的位置，1要放到0上，就是回到了初始点。那么当回到0的时候就直到这个循环已经结束了，所以接下来就轮到了1位置。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822202734573.png" alt="image-20250822202734573"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822202855167.png" alt="image-20250822202855167"></p>
<h1 id="递归跑不完，人为地用平凡解规定边界"><a href="#递归跑不完，人为地用平凡解规定边界" class="headerlink" title="递归跑不完，人为地用平凡解规定边界"></a>递归跑不完，人为地用平凡解规定边界</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822203256337.png" alt="image-20250822203256337"></p>
<p>上面题目没写全，初始人气值start也是偶数。</p>
<p>很多题目，限制条件是不全的，所以就需要自己去寻找一些边界条件，去找一些业务上的优化，通过平凡解的答案去规定限制条件。寻找base case条件。</p>
<p>根据题目我们可以知道，由于start和end都是偶数，所以start肯定可以通过一直加2来达到end，所以可以求出一个答案，这就是一个平凡解（看着像剪枝里的上界条件，那本算法课本里的）。所以当递归过程中求的币数大于这个答案时，那就可以不用继续了，因为肯定不是最优解。这就是找一个平凡解，人为地给递归增加限制（剪枝函数？）。</p>
<p>上面这种使用平凡解的优化是通用。</p>
<p>第二种优化（这种优化不具备通用性）：像这道题，有可能是人气超过end后不断地-2，然后得到最优解，那就是要规定最远能到达哪里，最远只能到达2*end的地方。</p>
<p>你可以继续从题目中寻找限制条件，但这道题只需要这两个条件就好了。</p>
<p>limitCoin是一个平凡解。aim是固定参数。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822205441673.png" alt="image-20250822205441673"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822205708724.png" alt="image-20250822205708724"></p>
<h1 id="图的宽度优先遍历"><a href="#图的宽度优先遍历" class="headerlink" title="图的宽度优先遍历"></a>图的宽度优先遍历</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822210658786.png" alt="image-20250822210658786"></p>
<p>给出的依赖关系其实是后序关系，就是这个活动做完后还需要去做什么活动。</p>
<p>这道题准确地来说应该是图的反向遍历。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822211805038.png" alt="image-20250822211805038"></p>
<p>为图的每一个节点都建一个专属的有序表，map的信息是，key代表这个节点到最后一个节点所需要的天数，value代表的是这个节点到最后一个节点所能获得的钱，这个有序表必须遵循天数增加钱也增加的规律。</p>
<p>从最后一个节点F开始，建立{5,1000}，然后找到它的前置节点，建立相对应的有序表，到达A节点的时候可以发现它有3个后置节点，所以它对应的有序表中就会有3条信息，因为要遵循天数增加钱也增加的规律，所以淘汰掉{12,1040}。最后要将各个节点对应的有序表合并到一个大表中，依旧遵循上面的规律。</p>
<img src="../source/imgs/${fiilname}/image-20250822212556681.png" alt="image-20250822212556681" style="zoom:50%;" />

<p>通过这张大表可以任意查询在某一个天数内获得的最大收益。</p>
<p>这个查询操作可以通过python中的bisect来查询。</p>
<h1 id="看到子串和子数组的问题就想每个位置结尾会怎么样"><a href="#看到子串和子数组的问题就想每个位置结尾会怎么样" class="headerlink" title="看到子串和子数组的问题就想每个位置结尾会怎么样"></a>看到子串和子数组的问题就想每个位置结尾会怎么样</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250509095933032.png" alt="image-20250509095933032"></p>
<p>按照上面的方法算，左括号count++，右括号count–，在过程中count的最大值就是深度。</p>
<hr>
<p>给你一个由左括号和右括号组成的字符串，请你找到最长的有效括号子串。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250509100607623.png" alt="image-20250509100607623"></p>
<p>有效的意思是，在这段字符串中任何左括号都有与之配对的右括号。</p>
<p>计算出以这个字符串中的每个字符结尾的情况下，最长的有效括号子串是多长，每个位置都计算出一个值，那答案就在其中。按照这个思路的话，这就变成了一个dp问题。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250509101340982.png" alt="image-20250509101340982"></p>
<p>由于必须是有效括号子串，所以当以左括号结尾是肯定是无效的，所以直接记作0.</p>
<p>要计算i 位置上的最大长度是是多少，先看一下i-1位置上的最大长度是多少，假如这个位置上的答案是4，那就看包括这个位置往前的4个字符的左边p位置是不是左括号（或者不考虑当前位置，在当前位置直接往前推4个位置，看那个位置上的是不是左括号），如果是左括号的话，那i 位置上的至少是6，不是的话就是0.</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250509101912689.png" alt="image-20250509101912689"></p>
<p>为什么至少是6呢？因为可能以p-1位置结尾的也有有效子串，而它们是相连的，所以要算上p-1位置的，而且只需要再加上这一段的长度，再往前就不需要考虑，因为如果再往前还有有效子串的话，那p-1位置的长度就会改变，所以不需要考虑，上面考虑是因为我在前一个字符结尾的基础上又添加了一对括号，扩充了，所以需要考虑，而这个是没扩充的，是已经计算完的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250509102746589.png" alt="image-20250509102746589"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250509103032327.png" alt="image-20250509103032327"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250509103117468.png" alt="image-20250509103117468"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250509103142411.png" alt="image-20250509103142411"></p>
<p>dp[0]肯定等于0，所以直接跳过。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823154442916.png" alt="image-20250823154442916"></p>
<p>1）假设 i 位置是a，那么往左推一定不能推到a出现的位置；</p>
<p>2）i-1结尾的时候它能推出来的最长无重复子串的位置是i-4，那么推 i 位置的最长无重复子串的位置时肯定不会超过i-4，那么就看i-4更近还是第一种情况的最远位置最近，哪一个更近哪一个就是答案；</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823155344808.png" alt="image-20250823155344808"></p>
<p>i-1位置的瓶颈是7，i 位置的瓶颈是i-5位置的 e ，所以它的瓶颈是5，两种情况5更近，所以 i 位置的答案就是5。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823155559521.png" alt="image-20250823155559521"></p>
<p>当 i 位置的瓶颈大于i-1位置时，此时的答案就是i-1位置的瓶颈+1。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823155814078.png" alt="image-20250823155814078"></p>
<p>为什么代码里面是求max，因为pre和map的value值代表的是位置，哪一个位置更大不就说明哪一个位置更近。</p>
<h1 id="边境距离问题"><a href="#边境距离问题" class="headerlink" title="边境距离问题"></a>边境距离问题</h1><p>常考，例子不多，之后去搜一些。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823160006906.png" alt="image-20250823160006906"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823160452686.png" alt="image-20250823160452686"></p>
<p>i 和 j 代表的不是位置，而是前缀长度。</p>
<p><code>dp[i][j]</code>代表的是str1[0<del>i]编辑成str2[0</del>j]的最小代价。</p>
<p>str[0]就说明str的前缀长度为0，是一个空串。</p>
<img src="../source/imgs/${fiilname}/image-20250823160935239.png" alt="image-20250823160935239" style="zoom:50%;" />

<p>先填写第一列和第一行，由于str1[0]是空串，所以编辑为str2[j]时代价都是插入代价的倍数；因为str2[0]是空串，所以str1[i]变为str2[0]时的代价都是删除代价的倍数。</p>
<p>要从str1[0<del>i-1]变为str2[0</del>j-1]，不管最后一个字符是什么样的都存在以下路径：</p>
<img src="../source/imgs/${fiilname}/image-20250823161956635.png" alt="image-20250823161956635" style="zoom:50%;" />

<p>第一条路径是将str1[0<del>i-2]编辑成str2[0</del>j-1]然后删去str1[i-1]，这个时候代价就等于<code>dp[i-1][j]+del(删除代价)</code>。</p>
<p>第二条路径是将str1[0<del>i-1]编辑成str2[0</del>j-2]然后加上str2[j-1]，这个时候代价就等于<code>dp[i][j-1]+add(插入代价)</code>。</p>
<p>第三种可能性是将str1[0<del>i-2]编辑成str2[0</del>j-2]然后将str1[i-1]替换成str2[j-1]，这个时候代价会等于<code>dp[i-1][j-1]+replace</code>。</p>
<p>第四种可能性，当str1[i-1]&#x3D;&#x3D;str2[j-1]时，代价会等于<code>dp[i-1][j-1]</code>。</p>
<p>dp的方向是从左往右，从上往下。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823163144279.png" alt="image-20250823163144279"></p>
<p>先看可能性3和可能性4谁先胜出，然后再和可能性1、可能性2比较。</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250508080015772.png" alt="image-20250508080015772"></p>
<p>括号要成对出现。只需用一个变量count从左往右遍历就行，ANS代表至少要添加的括号数。<img src="/../source/imgs/$%7Bfiilname%7D/image-20250508080520362.png" alt="image-20250508080520362"></p>
<p>如果缺右括号的话那直接在最左侧加就行了，所以如果count大于0可以等最后处理，但在这个过程中如果<strong>小于0的话需要立即处理</strong>（因为这种情况<code>”）（“</code>需要的是两个括号而不是零个），那就是ANS++，count归零。最后答案是ANS值再加上count。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250508081035763.png" alt="image-20250508081035763"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250508081654495.png" alt="image-20250508081654495"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250508081806730.png" alt="image-20250508081806730"></p>
<p>要求去重数字对，所以（0，2）只记录一次。</p>
<p>直接利用HashSet存储上面的数组，然后遍历查询，答案用非递减的方式记录，遍到0的时候找2，3的时候找5……</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250508082111156.png" alt="image-20250508082111156"></p>
<p>两个平均值一样的时候没法进行magic操作，两个平均值不一样的话不能从小的平均值中取数到大的平均值中，所以只能从大的拿数到小的里面。</p>
<p>平均值可能是小数，但你取的数只能是整数。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250508090504206.png" alt="image-20250508090504206"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250607161650555.png" alt="image-20250607161650555"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250508090723474.png" alt="image-20250508090723474"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250508090546117.png" alt="image-20250508090546117"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250509105927119.png" alt="image-20250509105927119"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250509105914741.png" alt="image-20250509105914741"></p>
<p>从左上角开始遍历查找的话复杂度非常大，所以根据这个二维数组的特点，我们从右上角开始查找，假如查找7的话，由于10大于7，那么它这一列就不用考虑了，左移继续判断，到达5时发现5比7小，所以左边肯定都小于7不用考虑，向下查找，一直到9，9大于7，所以左移，找到7。当查找的范围越界时说明该数组中不包含这个数，按照这种方法最多查找（行数+列数）次。</p>
<hr>
<p>有一个二维数组，每一行数，0肯定在1的左边，返回哪行的“1”最多，如果最多的“1”有多行的话，一起返回，比如下面那个例子，没有最后一行的话，就要返回2、3。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250509110639090.png" alt="image-20250509110639090"></p>
<p>思路和上一题一样，从右上角开始，用list来记录答案。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250509110948352.png" alt="image-20250509110948352"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250509111007290.png" alt="image-20250509111007290"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519203012201.png" alt="image-20250519203012201"></p>
<p>先用map统计它们出现的次数，然后可以直接用大根堆排序，但这样比较浪费空间，所以可以用小根堆排序，小根堆的大小始终设定为两个，一旦超过就弹出，直到大小变为两个。</p>
<p>扩展：要实现一个结构，这个结构可以接收字符串，用户可以随时调用一个函数，这个函数是用来显式目前的top K的，这个时候就不能使用原办法了，因为代价太大了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519203957420.png" alt="image-20250519203957420"></p>
<p>要解决问题就要实现图片里的三个结构，堆位置map： key是字符串，value是这个字符串在堆里的位置，如果不在堆里记作-1。</p>
<p>下面的图中，堆是按次数排序的，堆的大小为3。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519204454333.png" alt="image-20250519204454333"></p>
<p>判断词频表中的元素能不能进入堆了，要看堆有没有满，没满的话直接放。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519204518378.png" alt="image-20250519204518378"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519204610957.png" alt="image-20250519204610957"></p>
<p>D不在堆里面，所以位置标-1。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519204722066.png" alt="image-20250519204722066"></p>
<p>堆里面元素更新的过程就是先弹出，在插入，然后heapify，这几个方法就是算法那个笔记堆的知识里面的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519204916271.png" alt="image-20250519204916271"></p>
<p>heap是小根堆，index代表此时堆的大小，nodeIndexMap是元素在堆里的位置，strNodeMap是词频表。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519205455199.png" alt="image-20250519205455199"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519205703055.png" alt="image-20250519205703055"></p>
<p>preIndex代表在堆上的位置，curNode代表这个str是哪个Node。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519210132593.png" alt="image-20250519210132593"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519205902412.png" alt="image-20250519205902412"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519205917095.png" alt="image-20250519205917095"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250519205941042.png" alt="image-20250519205941042"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250525195708469.png" alt="image-20250525195708469"></p>
<p>遍历数组，寻找三种数，奇数，4的倍数的偶数，不是4的倍数的偶数。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250525200140870.png" alt="image-20250525200140870"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250525200320938.png" alt="image-20250525200320938"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529190456531.png" alt="image-20250529190456531"></p>
<p>使用有序表解决，我觉得使用优先队列也能解决，但没有有序表好。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529191058213.png" alt="image-20250529191058213"></p>
<p>先按难度从小到大排列，然后根据难度分组，同一难度的只保留钱最多的，然后再判断每个工作是否随着难度的提高钱也会增多，不是的去掉，最后留下来的就是一个难度从小到大，钱不断变多的序列。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529191411199.png" alt="image-20250529191411199"></p>
<p>里面有用到**floorKey()**，第一次看见它的使用。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529191904237.png" alt="image-20250529191904237"></p>
<p>业务题，看看就行，不通用。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529192123500.png" alt="image-20250529192123500"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529192259154.png" alt="image-20250529192259154"></p>
<p>要将合法字符串转化为int类型的数字时，使用负数接着，就是不管字符串是正是负，转化为int类型刚开始全是负数，因为负数表示的范围比正数大1，如果要表示的是负数的最小值，那负数不越界，但刚开始用正数的话就会越界。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529192813743.png" alt="image-20250529192813743"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250529193214780.png" alt="image-20250529193214780"></p>
<p>为什么cur&#x3D;’0’-str[i]，因为是用负数接着的，下面是直接加上cur，所以cur得为负的。</p>
<p>判断溢出的时候，第一个条件是判断乘10后会不会溢出，第二个条件是在乘10不会溢出的条件下判断加上cur会不会溢出。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817160552857.png" alt="image-20250817160552857"></p>
<p>从小到大，从简单到复杂。</p>
<p>coding问题，业务题。</p>
<p>下面的代码不是上面题目的答案，上面题目十下面代码的简单版本的题目。上面题目规定“11”念“一十一”，但下面是根据百位上是否有数字来判断“11”念“十一”还是“一十一”。</p>
<p>先搞定1~9。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817161031718.png" alt="image-20250817161031718"></p>
<p>因为有个“十”位，所以接下来搞定1~99。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817161150177.png" alt="image-20250817161150177"></p>
<p>百位</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817161215104.png" alt="image-20250817161215104"></p>
<p>千位</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817161229483.png" alt="image-20250817161229483"></p>
<p>拼“万”</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817161307351.png" alt="image-20250817161307351"></p>
<p>拼“亿”</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817161326836.png" alt="image-20250817161326836"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817162112335.png" alt="image-20250817162112335"></p>
<p>遍历数组肯定可以求出来，有没有更快的。</p>
<p>一直往左走，求深度。</p>
<p>接下来要关注的是根节点的右子树的最左节点有没有到达最后一层。</p>
<p>（1）如果到达了最后一层，那根节点的左子树肯定是满二叉树，然后接下来就看右树有多少节点，因为右树也是完全二叉树，所以递归就行；</p>
<img src="../source/imgs/${fiilname}/image-20250817162749312.png" alt="image-20250817162749312" style="zoom:50%;" />

<p>（2）如果没有到达最后一层，那右子树肯定是满二叉树，那接下来就看左子树，左子树肯定是完全二叉树，所以递归就行。</p>
<img src="../source/imgs/${fiilname}/image-20250817162854133.png" alt="image-20250817162854133" style="zoom:50%;" />

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817163448385.png" alt="image-20250817163448385"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250817163049279.png" alt="image-20250817163049279"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822213242933.png" alt="image-20250822213242933"></p>
<p>相当于有多少种加括号的方式可以得到答案。一个范围尝试的模型。</p>
<p>假设每一个二元运算都是最后结合的。f 函数的意思是从L到R的字符串范围内可以得到desire的方法数。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822213355541.png" alt="image-20250822213355541"></p>
<p>可以分为4种情况，1）1位置的并运算最后； 2）3位置的亦或最后； 3）5位置的或运算最后； 4）7位置的并运算最后</p>
<p>所以大流程就是枚举这个字符串中的所有逻辑符号，都假设它们是最后结合的。那具体到一个逻辑符号的时候，你后面的流程是什么。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822213852535.png" alt="image-20250822213852535"></p>
<p>T代表的是True，假设 i 位置是并运算要达到True，那两边都得达到True才行，所以最后的答案是a*b。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822214307316.png" alt="image-20250822214307316"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822214233266.png" alt="image-20250822214233266"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822214708227.png" alt="image-20250822214708227"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822214929771.png" alt="image-20250822214929771"></p>
<p>要将上述代码转化为动态规划，有3个可变参数，所以分为两种二维表，一张为True表，一张为False表。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822215456760.png" alt="image-20250822215456760"></p>
<p>先进行初始化，条件是R&gt;&#x3D;L，L和R位置上不会是逻辑符号。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822215524498.png" alt="image-20250822215524498"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250822215626320.png" alt="image-20250822215626320"></p>
<p>主要的难点在利用for循环跳过不需要求的点。看不懂的话就用上面的例子试一下。</p>
<p>动态规划是为递归返回值服务的，所以递归函数不填的东西动态规划都不要去碰。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823172848089.png" alt="image-20250823172848089"></p>
<p>输出的是1，2，27（每行一个数字）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823174056625.png" alt="image-20250823174056625"></p>
<p>记住：它是<strong>升序</strong>字符串，所以没有‘ba’这种的。</p>
<p>实现两个函数，f(N)：长度为N的子序列有多少个；g(char,len)：以char字符开头，长度为len的子序列有多少个。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823174651033.png" alt="image-20250823174651033"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823175224555.png" alt="image-20250823175224555"></p>
<p>例子的长度为3，所以长度为1，2的子序列肯定都排在它前面，所以第一步就是先加上长度为1和长度为2的子序列的个数。</p>
<p>第二步，由于这个字符串开头是d，所以以a、b、c开头的字符串都排在它前面，所以就先加上以这3个字符开头长度为3的子序列个数。</p>
<p>接下来是第二个字符，由于第一个字符是’d’，又要求是升序，所以接下来就是要加上以e、f、g、h、i 开头长度为2的子序列个数。</p>
<p>由于第二个字符是’j’，根据上一步的思路，继续加上相对应的子序列个数就能得出答案了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823175612029.png" alt="image-20250823175612029"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250823175635474.png" alt="image-20250823175635474"></p>
<h1 id="底部"><a href="#底部" class="headerlink" title="底部"></a>底部</h1>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-算法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/01/21/%E7%AE%97%E6%B3%95/" class="article-date">
  	<time datetime="2025-01-21T02:01:50.000Z" itemprop="datePublished">2025-01-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/01/21/%E7%AE%97%E6%B3%95/">
        算法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="亦或运算"><a href="#亦或运算" class="headerlink" title="亦或运算"></a>亦或运算</h2><p>无进位相加</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121102046322.png" alt="image-20250121102046322"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121102121598.png" alt="image-20250121102121598"></p>
<p>（1）a ^ 0 &#x3D; a；(2)a ^ a &#x3D; 0；(3)a ^ b &#x3D; b ^ a；(4)a ^ b ^ c &#x3D; a ^ (b ^ c)</p>
<p>一个数组中存在两个出现奇数次的数a和b，其它数的出现次数均为偶数次，如何找出这两个数。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121103410811.png" alt="image-20250121103410811"></p>
<p>将这个数组全部亦或后得到的数是a ^ b的结果，假设这个结果二进制表达式的第八位为1，则说明a和b第八位上的数不同，那么就可以将这些数分成第八位为0和第八位为1的，两组分别亦或后得到的两个数就是a和b。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121104242181.png" alt="image-20250121104242181"></p>
<p>上述代码存在错误，应该修改为：(cur &amp; rightone) &#x3D;&#x3D; 0。</p>
<p>对24行代码进行解析。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121104036793.png" alt="image-20250121104036793"></p>
<p>~：取反，&amp;：与运算。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>分成两部分，左边有序，右边无序，将右边无序的元素一个一个地插入有序的左边。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121104848202.png" alt="image-20250121104848202"></p>
<p>i 和 j 必须不同，排序结果是升序。</p>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>无序也可以二分。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121110412736.png" alt="image-20250121110412736"></p>
<p>（2）t值要更新</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121110844760.png" alt="image-20250121110844760"></p>
<p>（3）<img src="/../source/imgs/$%7Bfiilname%7D/image-20250121111005227.png" alt="image-20250121111005227"></p>
<p>局部最小定义：0位置上的数比1位置的要小，n-1位置上的数比n-2位置上的数要小，i 位置上的数比 i-1和 i+1的要小。</p>
<p>若不懂看视频1、的一小时48分左右。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>分成左右两部分进行排序，左边和右边分别排序完后合并在一起。递归算法。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122110946983.png" alt="image-20250122110946983"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122111006395.png" alt="image-20250122111006395"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122113611409.png" alt="image-20250122113611409"></p>
<p>暴力解很容易。</p>
<p>例子：1，3，4，2，5</p>
<p>转换原理：求小和，1的右边有四个数比1大，所以加4个1，3的右边有两个数比3大，所以加2个3，以此类推，要加1个4，1个2，0个5，小和为16。和右边进行比对，和归并排序中的merge有相似之处，可以改变merge来解决这个问题。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122113116941.png" alt="image-20250122113116941"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122113053228.png" alt="image-20250122113053228"></p>
<p>在归并排序的过程中利用merge方法进行小和计算。</p>
<p>1和3：1&lt;3，所以小和有一个1；</p>
<p>1，3和4：1，3&lt;4，所以小和加上一个1和一个3；</p>
<p>2和5：2&lt;5，加上一个2；</p>
<p>1，3，4和2，5：对1进行判断的时候，因为左右两边都是排好序的，所以1小于2时代表右边两个数都比1大，所以要加上2个1，这个可							  以根据右边的索引判断要加几个。</p>
<p>为了实现根据索引判断要加几个，必须进行排序。这个方法和归并排序很大的不同在于<strong>两数相等时必须先拷贝右组</strong>。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122115832420.png" alt="image-20250122115832420"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122115910638.png" alt="image-20250122115910638"></p>
<p>小和问题是求右边有多少个数比它大，逆序对问题是求右边有多少个数比它小。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122120541772.png" alt="image-20250122120541772"></p>
<p>问题一：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122160100922.png" alt="image-20250122160100922"></p>
<p>荷兰国旗问题：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122160408776.png" alt="image-20250122160408776"></p>
<p><strong>快排1.0</strong>：以数组的最后一个数作为标志值，小于这个数的全放在左边，大于这个数的放在右边（从倒数第二个位置开始放），最后将该数组的最后一个数也就是标志值与大于区域的第一个数交换位置，那么这个数的位置就固定下来了。接下来就是左右两个区域分别取该部分的最后一个数作为标志值重复前面的过程。</p>
<p>标志值为5，大于5的区域的第一个数是6，两数交换位置。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122161020308.png" alt="image-20250122161020308"></p>
<p><strong>快排2.0</strong>：相比于上面，这边多划分一个区域就是等于区域，相当于是荷兰国旗问题的思路，原理和1.0差不多，最后将最后一个数也就是标志值和大于区域的第一个数交换，那中间的就全是相同的数了，一次性搞定一部分，比1.0快一点，大于和小于区域按照同样思路做递归。</p>
<p><strong>快排3.0</strong>：不是取数组的最后一个数，而是在数组中<strong>随机</strong>取一个数作为标志值，然后将这个数和数组最右侧的数交换，接下来步骤和上面的一样。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122212616182.png" alt="image-20250122212616182"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122162955519.png" alt="image-20250122162955519"></p>
<p>swap是自己写的交换函数。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122162644379.png" alt="image-20250122162644379"></p>
<p>partition的功能就是返回两个数据，相等的值的左边界和右边界，存储在一个数组中返回，该数组的大小肯定是2。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="基础和移动"><a href="#基础和移动" class="headerlink" title="基础和移动"></a>基础和移动</h3><p>堆结构：形状是满二叉树，大根堆：每个节点的值都是以它为头结点的整棵树中的最大值，小根堆刚好相反。</p>
<p>优先级队列结构就是堆结构。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122221624828.png" alt="image-20250122221624828"></p>
<p><strong>原数组为空时不断存入数据如何形成大根堆</strong>：一个空数组，heapsize &#x3D; 0，存入一个数据，heapsize++，在存入一个数据时，将该数据和自己的父节点的数据进行比较，若小于父节点则不变，大于父节点就和父节点交换位置，然后和父节点的父节点比较，直到父节点大于该数据或者成为头结点也就是索引等于0时停止。后续继续存入数据则按照该规律进行排序，最后得出的数组就是大根堆。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122222952313.png" alt="image-20250122222952313"></p>
<p><strong>原本是大根堆，去除最大的数也就是头结点后，如何保持大根堆</strong>：去掉头结点后，将数组中的最后一个数调到头结点，heapsize–，相当于最后一个位置不储存数据了，然后头结点的两个子节点取最大值，若最大值大于头结点则交换，否则结束。若有交换，交换后假设该值在头结点的左孩子上，则该孩子节点的两个子节点取最大值并和该节点比较，直到最大值小于该节点的值或者没有孩子后结束。</p>
<p>下面代码可以表示去除任意一个节点，并将最后一个数据调到这个位置后进行的操作。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122223941451.png" alt="image-20250122223941451"></p>
<pre><code class="hljs plaintext">left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left]这句话是if的条件</code></pre>

<p>用户随意挑选一个数据进行更改如何保持大根堆：先进行heapInsert，再进行heapify。</p>
<h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><p><strong>堆排序1.0</strong>：假设原始数据是3，5，9，4，6，7，0；先将它变成大根堆，相当于是用户一个一个给你数据，然后开始堆排序，就是跟上面的<strong>往上移动</strong>一样，先3，后5，一直到0，最后大根堆是9，6，7，3，4，5，0，heapSize&#x3D;7。这个时候取出头结点，将堆的最后一个位置移到头结点，heapSize–，heapSize&#x3D;6说明将最后一个点剥离出去了，头结点此时值为0，heapify，重新变成大根堆。然后再取出头结点，将堆的最后一个移到头结点，heapSize–，重复之前的过程。当heapSize&#x3D;0时停止。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123103930682.png" alt="image-20250123103930682"></p>
<p><strong>堆排序2.0</strong>：用户给原始数据，直接从最后一个开始往前进行heapify将其变为大根堆，这个方法在将数据变为大根堆时时间复杂度更小，但总体时间复杂度不变，不过运行速度会更快一点。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123110009882.png" alt="image-20250123110009882"></p>
<h3 id="优先队列结构——默认小根堆"><a href="#优先队列结构——默认小根堆" class="headerlink" title="优先队列结构——默认小根堆"></a>优先队列结构——默认小根堆</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123110258347.png" alt="image-20250123110258347"></p>
<p>假设k&#x3D;6且是小根堆的话，说明最小值一定在前7个数中，因为每个数的移动距离不会超过6，所以将前7个数排序变为小根堆，头结点一定是最小值，将头结点取出，将第八个数放到头结点上，heapify使其重新变为小根堆，取出头结点，按这个规律一直取下去，最后完成排序。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123153505599.png" alt="image-20250123153505599"></p>
<p>下面是优先队列结构的简单运用：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123152645655.png" alt="image-20250123152645655"></p>
<p>不传任何东西，默认小根堆进行处理。</p>
<p>输出结果为3，4，4，8，9，10</p>
<p>poll()方法，弹出并移除数据。</p>
<p><strong>当题目只要求输入一个数据再输出一个数据时使用优先队列结构，若有什么复杂的操作或者想要以较小的代价排序的话必须自己手写堆。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207112728884.png" alt="image-20250207112728884"></p>
<p>大根堆和小根堆配合。</p>
<p>第一个数直接进大根堆。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207112924210.png" alt="image-20250207112924210"></p>
<p>第三条的意思是（较大size的根堆的大小 - 较小size的根堆的大小）大于等于2，则从较大根堆移动一个数到较小根堆。大根堆较大的话，就是大根堆堆顶弹出进小根堆；小根堆较大的话，就是小根堆的堆顶弹出进大根堆。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207113417142.png" alt="image-20250207113417142"></p>
<p>偶数个，两数相加除以2；奇数个，两个根堆中的一个。</p>
<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123154045390.png" alt="image-20250123154045390"></p>
<pre><code class="hljs plaintext">o1.id - o2.id &lt; 0，第一个参数o1排前面；&gt;0时第二个参数o2排前面；=0无所谓前后。
o2.id - o1.id &lt; 0，第一个参数o1排前面；&gt;0时第二个参数o2排前面；=0无所谓前后。</code></pre>

<p>例子：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250123154424680.png" alt="image-20250123154424680"></p>
<pre><code class="hljs plaintext">如果不提前写比较器的话，也可以选择匿名内部类的方法
Arrays.sort(students,new Comparator()&#123;
	@Override
    public int compare(Object o1, Object o2) &#123;
  		int i1 = (Integer) o1;
        int i2 = (Integer) o2;
        return i1 - i2;
  	&#125;
&#125;)</code></pre>

<p><strong>用于优先序列上：</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123155541734.png" alt="image-20250123155541734"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123155447433.png" alt="image-20250123155447433"></p>
<p>new AComp()是一个实现了Comparator的一个类。</p>
<p>现在输出是从大到小的顺序。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>不基于两数比较的排序。</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>在数比较小的时候用，比如计算员工年龄排序，创建一个大小为200的数组，几岁就在索引几++，最后输出排序结果的时候按数组里存储的数输出，比如17的数据时3，就输出三个17.</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>假设原始数据是17，13，25，100，72；首先最大是三位数，所以全部数据补成三位数为017，013，025，100，072。</p>
<p>然后创建10个桶，名字分别为0，1，2，~，9。</p>
<p>首先按照个位数将各个数据按照顺序扔到桶里再依次倒出。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123161955771.png" alt="image-20250123161955771"></p>
<p>然后按照十位数将各个数据按照顺序扔到桶里再依次倒出。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123162047429.png" alt="image-20250123162047429"></p>
<p>最后按照百位数将各个数据按照顺序扔到桶里再依次倒出。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123162114296.png" alt="image-20250123162114296"></p>
<p>下面的代码是优化过的，比较抽象，可以打草稿</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123162251124.png" alt="image-20250123162251124"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123162612579.png" alt="image-20250123162612579"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250123163530354.png" alt="image-20250123163530354"></p>
<p>digit表示最大的值有几个十进制位。</p>
<p>蓝色的代表以10为基底，是不会变的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250124102504931.png" alt="image-20250124102504931"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250124153307081.png" alt="image-20250124153307081"></p>
<p>一般选择快排，能用快排就用快排，快排虽然空间复杂度高，但实际上它的常数项低，跑得最快。</p>
<p>有空间限制，很容易就超出空间了，就使用堆排。</p>
<p>需要用到稳定性的时候，使用归并。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250124153843684.png" alt="image-20250124153843684"></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>hashSet，hashMap</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250124155118525.png" alt="image-20250124155118525"></p>
<h2 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250124155456379.png" alt="image-20250124155456379"></p>
<p>性能比哈希表差一点。</p>
<p>6、7不是哈希表是有序表，图里面写错了。</p>
<p><strong>不是基础类型的必须提供比较器。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250124155618417.png" alt="image-20250124155618417"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250124155909911.png" alt="image-20250124155909911"></p>
<h2 id="链表题"><a href="#链表题" class="headerlink" title="链表题"></a>链表题</h2><p>该种题目都要分成面试和笔试来做。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125204451739.png" alt="image-20250125204451739"></p>
<h3 id="其他题"><a href="#其他题" class="headerlink" title="其他题"></a>其他题</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125205203087.png" alt="image-20250125205203087"></p>
<p>笔试：设计一个栈，将链表存进去，根据先进后出的特性和链表比对。</p>
<p>面试：</p>
<p><strong>快慢指针</strong>：两个指针，快指针一次走两步，慢指针一次走一步，当快指针到达最后一个时，慢指针刚好到一半。</p>
<p>初始：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250125205349416.png" alt="image-20250125205349416"></p>
<p>中：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250125205420484.png" alt="image-20250125205420484"></p>
<p>当慢指针来到中点位置的时候，往下遍历，将后面的逆序，3指向空，头尾分别用一个指针记住，然后A和B一起往中间走，一步步比对，若全都一样则为回文数，如果有一个先到空，就停止。</p>
<p>最后：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250125205743374.png" alt="image-20250125205743374"></p>
<p>在返回最终结果true和false之前，将链表恢复，然后输出结果。（其实也可以不用管）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125210050670.png" alt="image-20250125210050670"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125210126810.png" alt="image-20250125210126810"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125205935571.png" alt="image-20250125205935571"></p>
<p>笔试：准备一个Node型的数组，将链表存进去，然后进行排序，排完序后按顺序串起来就可以了。</p>
<p>面试：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250125210657997.png" alt="image-20250125210657997"></p>
<p>六个变量：大于区域的头和尾：sH和sT；等于区域的头和尾：eH和eT；小于区域的头和尾：bH和bT。</p>
<p>记得考虑<strong>空指针</strong>问题。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125210934708.png" alt="image-20250125210934708"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125210949582.png" alt="image-20250125210949582"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125211013836.png" alt="image-20250125211013836"></p>
<p>若申请<strong>额外空间</strong>：</p>
<p>第一步：使用哈希表，key对应老节点，value对应新节点，就直接将老结点copy过去就好了。</p>
<p>第二步：利用map的get()方法创建连接方式</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125211514620.png" alt="image-20250125211514620"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125211549630.png" alt="image-20250125211549630"></p>
<p>不使用哈希表：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125211913381.png" alt="image-20250125211913381"></p>
<p>先创建克隆结点，将克隆结点直接串在原节点后面，克隆结点指向原结点的下一个结点，先不管rand。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125212121169.png" alt="image-20250125212121169"></p>
<p>然后一对一对的遍历，根据原结点的rand的next填充克隆结点的rand。</p>
<p>最后更改next，使得新老链表分离出来。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125212314914.png" alt="image-20250125212314914"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125212329218.png" alt="image-20250125212329218"></p>
<h3 id="找相交结点"><a href="#找相交结点" class="headerlink" title="找相交结点"></a>找相交结点</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125214328196.png" alt="image-20250125214328196"></p>
<p>相交就是共用结点的意思，两个结点的内存地址一样。</p>
<p>先思考一个函数如何实现一个可能有环的链表，有环的话返回第一个入环的结点，否则返回空的功能。</p>
<p>创建一个Set用来存储Node结点，遇到一个Node时，先判断Set中是否包含该Node，没有的话就添加进Set，然后继续遍历下一个Node，如果Set中包含了该Node，说明这就是第一个入环的结点。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125215119599.png" alt="image-20250125215119599"></p>
<p>快慢指针方法：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125215429577.png" alt="image-20250125215429577"></p>
<p>刚开始快慢指针都在头结点，快指针走两步，慢指针走一步。</p>
<p>如果有环的话，快指针和慢指针肯定会在环中相遇，且不会超过两圈（因为快指针的速度是慢指针的两倍）。</p>
<p><strong>当相遇的时候，快指针回到开头，慢指针不动，接下来两个指针每次分别都只走一步，它俩最后一定会在入环第一个结点相遇。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125220059752.png" alt="image-20250125220059752"></p>
<p>对于找<strong>公共交点</strong>的这道题目，给我们两个链表，这两个链表分别调用上面这个函数，就能找到这两个链表各自的第一个入环结点。</p>
<p><strong>先用getLoopNode方法判断是否有环。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125222216146.png" alt="image-20250125222216146"></p>
<p>loop1和loop2代表第一个链表和第二个链表的第一个入环结点。</p>
<p>（1）若是两个无环链表，两个相交的话，后面的部分肯定是公共部分。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125220611061.png" alt="image-20250125220611061"></p>
<p>先求各自的end结点和长度。</p>
<p>先判断end1和end2是否相等，若不相等则说明没有相交。如果相等的话，它们是相交部分的最后一个结点，那相交部分的第一个结点怎么找？链表1长度为100，先走20步，然后链表2从头结点出发，跟着走，它俩一定会在第一个相交结点处相遇。（因为相交之后的公共部分长度一样，所以长的链表先走差值部，然后短链表再走，那它们就会在第一个相交结点处相遇）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250201163731660.png" alt="image-20250201163731660"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125221834579.png" alt="image-20250125221834579"></p>
<p>（2）不可能相交</p>
<p>（3）都有环。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125222432566.png" alt="image-20250125222432566"></p>
<p>第二种情况和无环情况解法是一样的。</p>
<p>区分第一种和第三种：loop1继续往下，loop2不动，若loop1可以和loop2相遇，则是第三种，否则是第一种。若是第一种则无相交，返回null，若是第三种，则返回loop1和loop2都可以。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125222847462.png" alt="image-20250125222847462"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125223000824.png" alt="image-20250125223000824"></p>
<p>上面都是方法函数，这道题的主函数如下：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250125223039458.png" alt="image-20250125223039458"></p>
<h2 id="基础提升"><a href="#基础提升" class="headerlink" title="基础提升"></a>基础提升</h2><p>比如说输入40亿个数，要找出出现次数最多的那个数，要求空间小。可以使用哈希函数算出个个数的哈希码，然后%100，有一百个组，先进行分类，然后选出个数最多的那个组再进行查找，这样用的空间就少了。</p>
<p>去看java中关于哈希函数的内容。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250304154404400.png" alt="image-20250304154404400"></p>
<p>利用两张哈希表来解决，哈希表的操作的时间复杂度都是O(1)，不过是比较大的常数时间。</p>
<p>一表：&lt;value,index&gt;，二表：&lt;index,value&gt;，假设输入26个字母</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250304154939461.png" alt="image-20250304154939461"></p>
<p>假如删除的时候就直接删除，例如删除C，则两张表上面会出现空区域，那么当删除的数据很多的时候，空区域就会很多，那么随机返回任何一个key的时候可能就需要尝试很多次，所以不能直接删除，要将删除后的空洞填上。办法就是删除数据后拿最后一条记录补上这个空洞，然后删除最后一条记录，size–。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250304155458873.png" alt="image-20250304155458873"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250304155530758.png" alt="image-20250304155530758"></p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>只有add、check功能，要求占用内存小。</p>
<p>一般是用来做黑名单系统的，比如一个浏览器，将一部分假如黑名单中，那么这部分就不能被访问到，使用hashset记录的话，占用空间过大。可以使用bit类型的数组来记录，这样占用的空间就很少。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250304161110159.png" alt="image-20250304161110159"></p>
<p>使用int数组来表示bit数组，一个int占8B，32个bit，所以按理来说arr[0]可以表示0<del>31的状态，arr[1]就可以表示32</del>63的状态。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250304161541971.png" alt="image-20250304161541971"></p>
<p>numIndex是在int数组中的索引，bitIndex代表的是在arr[numIndex]的32位中是哪一位。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250304162034615.png" alt="image-20250304162034615"></p>
<p>上面是思路，布隆过滤器就是，比如一个字符串，通过n个哈希函数分别算出值然后%m，根据最后的结果将值变为1，查询一个字符串是不是在里面的时候，也是利用这些哈希函数进行相同的操作最后取出n个值，这n个值中有一个值不是1那它就不在里面。</p>
<p>布隆过滤器会存在错误，就是会将不应该进入黑名单中的人拉入黑名单，这是因为m有限，可能会发生冲突，然后恰好全都为1。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250309201821857.png" alt="image-20250309201821857"></p>
<p>设计一个infect函数，作用就是碰到1将那一片1都变成2，几次infect就是几个岛。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250309201958788.png" alt="image-20250309201958788"></p>
<p>N:宽，M:长，res:岛的数量。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250309202055116.png" alt="image-20250309202055116"></p>
<h1 id="字典序排列算法"><a href="#字典序排列算法" class="headerlink" title="字典序排列算法"></a>字典序排列算法</h1><p>从小到大寻找下一个字典序排列：</p>
<ul>
<li>从右向左找到第一个 i，使得 P[i] &lt; P[i+1]。如果找不到这样的 i，说明当前排列已经是最大的，下一个排列就是最小的排列（或者说，没有更大的排列了）。</li>
<li>从右向左找到第一个 j，使得 P[j] &gt; P[i]。</li>
<li>交换 P[i] 和 P[j]。</li>
<li>将 P[i+1] 到末尾的元素反转。</li>
</ul>
<img src="../source/imgs/${fiilname}/image-20250905112304107.png" alt="image-20250905112304107" style="zoom:50%;" />

<img src="../source/imgs/${fiilname}/image-20250905112318857.png" alt="image-20250905112318857" style="zoom:50%;" />

<p>对于上面这道题，它其实就是简单的排列组合，不要想复杂了，比如1 2 3 4 5 6 7 8 9 10，最大的数是10 9 8 7 6 5 4 3 2 1，而不是9开头的。</p>
<pre><code class="hljs plaintext">def next_permutation(arr):
    n = len(arr)
    k = -1
    for i in range(n - 2, -1, -1):
        if int(arr[i]) &lt; int(arr[i + 1]):
            k = i
            break
   # 下面这一步的含义是循环，就是当当前的数为最大数时，下一个需要出现的数就是最小数，在这题是不会出现这种情况的，不过可以了解一下
    if k == -1:
        arr.sort(key=lambda x: int(x))
        return arr

    l = -1
    for i in range(n - 1, k, -1):
        if int(arr[k]) &lt; int(arr[i]):
            l = i
            break

    arr[k], arr[l] = arr[l], arr[k]
    arr[k + 1:] = arr[k + 1:][::-1]
    return arr

n = int(input())
m = int(input())
initial = input().split()
for _ in range(m):
    initial = next_permutation(initial)
print(&#x27; &#x27;.join(initial))</code></pre>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250126102013983.png" alt="image-20250126102013983"></p>
<p>和c语言中的不大一样，因为java中没有指针这个定义。</p>
<p>把数据结构看一遍。</p>
<p>使用递归和非递归方法实现二叉树的遍历，</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先序遍历：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250126103755687.png" alt="image-20250126103755687"></p>
<p>Stack类继承自Vector类，上面的push(E e)是Stack类的专门方法，用于将元素压入栈顶，add(E e)是Vector的方法，在Stack中没有重写，不过可以达到和push相同的效果。</p>
<p>后序遍历：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250126104437731.png" alt="image-20250126104437731"></p>
<p>按照头右左的顺序将结点入栈，然后将弹出的结点压入另一个栈中，最后输出这个栈，结果就是左右头。</p>
<p>中序遍历：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250126104743413.png" alt="image-20250126104743413"></p>
<h2 id="二叉树相关概念及其实现判断"><a href="#二叉树相关概念及其实现判断" class="headerlink" title="二叉树相关概念及其实现判断"></a>二叉树相关概念及其实现判断</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250201212725729.png" alt="image-20250201212725729"></p>
<p>1、搜索二叉树就是左子树的值小于根的值，右子树的值大于根的值。</p>
<p>通过改写中序遍历来解决</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250201212120592.png" alt="image-20250201212120592"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250201212406972.png" alt="image-20250201212406972"></p>
<p>2、<img src="/../source/imgs/$%7Bfiilname%7D/image-20250201213141228.png" alt="image-20250201213141228"></p>
<p>这边解题的思路是利用宽度遍历来判断。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250201213714088.png" alt="image-20250201213714088"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250201213736743.png" alt="image-20250201213736743"></p>
<p>3、较麻烦的做法就是先求最大深度和总结点数，然后根据这俩之间的数学关系判断。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250201213938776.png" alt="image-20250201213938776"></p>
<h3 id="二叉树解题套路"><a href="#二叉树解题套路" class="headerlink" title="二叉树解题套路"></a>二叉树解题套路</h3><p>在<strong>可以向左子树要信息，可以向右子树要信息</strong>的情况下怎么解决题目。</p>
<p><strong>这个套路可以解决一切树型DP（动态规划）的问题。</strong></p>
<p>以第四题为例子。</p>
<p>4、<img src="/../source/imgs/$%7Bfiilname%7D/image-20250201214305319.png" alt="image-20250201214305319"></p>
<p>先列出可能性：一棵树是平衡二叉树说明它的左右子树都是平衡二叉树且第三个条件。</p>
<p>可能性固定后，整理需要左右子树给你提供什么样的信息。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250201214555337.png" alt="image-20250201214555337"></p>
<p>从上面可以看出左右子树所需要的信息是一样，都是是否是平衡二叉树以及高度是多少，递归套路。</p>
<p>在写的时候总是默认左子树给你一个信息，然后右子树给你一个信息，接着继续写如何利用这两个信息（返回的这两个信息包含了子树需要返回给你的全部信息，把它们当作都是有实值的）。最后一步肯定是返回你需要的信息，那么获得左右子树提供的信息后要写的就是如何利用这两个信息来得到你需要返回的信息。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250201215025511.png" alt="image-20250201215025511"></p>
<p>接下来以这个思路解决一下第一题。</p>
<p>可能性：左子树是搜索二叉树，右子树是搜索二叉树，左子树的最大值小于该点的值，右子树的最小值大于该点的值。</p>
<p>将这个可能性弄成一个全集。</p>
<p>提供信息：左子树要提供是否是二叉树，以及它的最大值；右子树要提供是否是二叉树，以及它的最小值。</p>
<p>现在要提供的信息不一样，但递归套路要求对每个结点的要求是一样的才叫递归，所以返回这棵树是否是二叉树以及它的最大最小值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250201221547300.png" alt="image-20250201221547300"></p>
<p>第三题</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250201222254105.png" alt="image-20250201222254105"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205101328312.png" alt="image-20250205101328312"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205101609023.png" alt="image-20250205101609023"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205102129465.png" alt="image-20250205102129465"></p>
<p><code>while o2 set1</code>意思是接下来就是不断寻找o2的父节点并对比是否在set1中，如果存在那就是最低公共祖先。</p>
<p>上面的方法好理解但时间和空间复杂度较高，下面的代码更好但较难理解。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205102648015.png" alt="image-20250205102648015"></p>
<p>这道题目会有以下几种情况（LCA代表最低公共祖先）：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205103010078.png" alt="image-20250205103010078"></p>
<p>第二种情况：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250205103419376.png" alt="image-20250205103419376"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205105238893.png" alt="image-20250205105238893"></p>
<p>1）x有右树的时候，x的后继节点一定是右树的<strong>最左</strong>结点；</p>
<p>2）<img src="/../source/imgs/$%7Bfiilname%7D/image-20250205104349168.png" alt="image-20250205104349168"></p>
<p>x不断地往上找，当找到一个结点是它父亲的左孩子时，这个结点的父亲就是x的后继节点，因为在中序遍历时，x一定是左树上最后一个打印的结点。</p>
<p><strong>但是在中序遍历中肯定会有一个结点它没有后继节点，就是在中序遍历时最后一个打印的结点，所以返回null。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205104936441.png" alt="image-20250205104936441"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205105009181.png" alt="image-20250205105009181"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205105823219.png" alt="image-20250205105823219"></p>
<p>就是null用特殊字符表示，一个结点的结束用下划线就行。先序，中序，后序道理都一样。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205110240515.png" alt="image-20250205110240515"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205110329291.png" alt="image-20250205110329291"></p>
<h2 id="树形dp套路（补充）"><a href="#树形dp套路（补充）" class="headerlink" title="树形dp套路（补充）"></a>树形dp套路（补充）</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250312151425680.png" alt="image-20250312151425680"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250312151619772.png" alt="image-20250312151619772"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250312151822306.png" alt="image-20250312151822306"></p>
<p>d到c 的距离为4。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250312152047419.png" alt="image-20250312152047419"></p>
<p>x是头结点。上图的最大距离在左树且不经过x。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250312152458466.png" alt="image-20250312152458466"></p>
<p><strong>很多题目都是根据头结点参与不参与来分类的。</strong></p>
<p>由上面的分类可以知道需要子树提供什么信息：子树的高和子树的最大距离。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250312152814154.png" alt="image-20250312152814154"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250312152943631.png" alt="image-20250312152943631"></p>
<p><strong>二叉树的递归套路是建立在如果我可以向左树和右树获取信息的情况下，我该如何求解我的答案有哪些可能性。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250312153135052.png" alt="image-20250312153135052"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250312153251843.png" alt="image-20250312153251843"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250312153840675.png" alt="image-20250312153840675"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250312153923596.png" alt="image-20250312153923596"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250312153953736.png" alt="image-20250312153953736"></p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="表示模板"><a href="#表示模板" class="headerlink" title="表示模板"></a>表示模板</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205154645472.png" alt="image-20250205154645472"></p>
<p>表示图的方法有很多，背好自己平时表达图的方式的算法模板，将遇到的新的图的表达方式转化为自己平时用的表达方式，再代入算法模板。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205160005296.png" alt="image-20250205160005296"></p>
<p>Node是原本的点，包含这个点的所有消息，Integer存储的是点所对应的编号，nodes就是点集合，edges是边集合。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205160221533.png" alt="image-20250205160221533"></p>
<p>value：自己的数据项（value前面的数据类型是具体情况具体分析）；in：入度；out：出度；nexts：代表由这个点发散出去的边所连接的点，它的直接邻居；edges：属于这个点的边有哪些。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205160750851.png" alt="image-20250205160750851"></p>
<p>weight：权值</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><strong>可以去看数据结构中图的相关算法。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205162522620.png" alt="image-20250205162522620"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205162721097.png" alt="image-20250205162721097"></p>
<p>应该是深度优先遍历。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205163210261.png" alt="image-20250205163210261"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205163511706.png" alt="image-20250205163511706"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205164308959.png" alt="image-20250205164308959"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205194235740.png" alt="image-20250205194235740"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205194254868.png" alt="image-20250205194254868"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205194723351.png" alt="image-20250205194723351"></p>
<p>从边的角度生成最小生成树。</p>
<p>最好使用并查集来实现，效率高，下面算法没有使用并查集，感觉不如数据结构里实现得简单。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205195608460.png" alt="image-20250205195608460"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205200333256.png" alt="image-20250205200333256"></p>
<p>利用上面得方法根据原理就可以得出具体实现了。</p>
<p>下面的实现是并查集方法。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205200645174.png" alt="image-20250205200645174"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205200708659.png" alt="image-20250205200708659"></p>
<p>从点的角度思考生成最小生成树。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205201211647.png" alt="image-20250205201211647"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205201317105.png" alt="image-20250205201317105"></p>
<p>上面的代码会将一条边重复放进优先队列中去，但不会影响结果，因为这条边所连接的点已经放进Set中了，会被排掉，只会增加常数处理时间。</p>
<p>for循环是为了解决出现森林的情况。若已经说明不会出现森林，则不需要for循环。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205201949955.png" alt="image-20250205201949955"></p>
<p>寻找最短路径。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205203117741.png" alt="image-20250205203117741"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250205202450221.png" alt="image-20250205202450221"></p>
<p><code>getMinDistanceAndUnselectedNode(distanceMap,selectedNodes)</code>代表的是要从distanceMap中挑选一个最小的记录，但这个最小记录不能是已经选过的，也就是这条记录不能在selectedNodes里。</p>
<h1 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207113608382.png" alt="image-20250207113608382"></p>
<p>按行来深度优先遍历。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207120032831.png" alt="image-20250207120032831"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207120636558.png" alt="image-20250207120636558"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207120835488.png" alt="image-20250207120835488"></p>
<h1 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250206164243423.png" alt="image-20250206164243423"></p>
<p>前缀树的结点定义：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250206164415198.png" alt="image-20250206164415198"></p>
<p>pass代表经过这个点几次，end代表这个点作为结尾几次，前缀树以一个空结点开始。</p>
<p>上面只准备了26条路，如果路径数量很多的话，可以用哈希表来表示，key代表有哪条路，value就代表通过这条路走向的结点。如果想要路径有序，那就使用有序表(TreeMap)。</p>
<p>建立一个前缀树：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250206164625577.png" alt="image-20250206164625577"></p>
<p>root代表根结点，根结点的p值代表有多少个字符串。或者理解成由多少个字符串以空作为前缀，而任何字符串都以空作为前缀。而如果加入空串的话，根结点的pass++，end++。</p>
<p>删除功能：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250206170956375.png" alt="image-20250206170956375"></p>
<p>在java中，只要让头结点为空，使得后面的数据无法被找到，那么jdk会自动帮你释放空间。</p>
<p>查询功能：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250206170448725.png" alt="image-20250206170448725"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250206170849000.png" alt="image-20250206170849000"></p>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p><strong>局部-&gt;整体</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250206202557603.png" alt="image-20250206202557603"></p>
<p>贪心算法的题目代码一般都不长。</p>
<p>![屏幕截图 2025-02-06 202653](..&#x2F;source&#x2F;imgs&#x2F;${fiilname}&#x2F;屏幕截图 2025-02-06 202653.png) </p>
<p>哪个会议结束时间早就先安排谁。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250206203539758.png" alt="image-20250206203539758"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250206203611969.png" alt="image-20250206203611969"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250206214257499.png" alt="image-20250206214257499"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207105407891.png" alt="image-20250207105407891"></p>
<p><strong>堆和排序是最经常使用的技巧。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207110318169.png" alt="image-20250207110318169"></p>
<p>哈夫曼树，easy。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207110747437.png" alt="image-20250207110747437"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207111054424.png" alt="image-20250207111054424"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207111700142.png" alt="image-20250207111700142"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207111718489.png" alt="image-20250207111718489"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207111848134.png" alt="image-20250207111848134"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207111805596.png" alt="image-20250207111805596"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207111821149.png" alt="image-20250207111821149"></p>
<p><code>peek()</code> 用于<strong>查看</strong>队列头部元素，不会移除。</p>
<p>如果队列为空，<code>peek()</code> 返回 <code>null</code>。</p>
<p><code>poll()</code> 用于<strong>取出</strong>队列头部元素，并将其从队列中移除。</p>
<h1 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212163204236.png" alt="image-20250212163204236"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212163505085.png" alt="image-20250212163505085"></p>
<p>数据结构书里递归那部分有讲过。</p>
<p>将 i 个目标从from移动到to上面去。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212164039953.png" alt="image-20250212164039953"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212164159420.png" alt="image-20250212164159420"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212164438479.png" alt="image-20250212164438479"></p>
<p>每个字符都有两种可能，要或者不要。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212164556767.png" alt="image-20250212164556767"></p>
<p>最后一个是空。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212164902148.png" alt="image-20250212164902148"></p>
<p>printtList，打印当前列表。自己补充printList和copyList方法。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212165215833.png" alt="image-20250212165215833"></p>
<p>第一个：例：abc-&gt;abc,acb,bac,bca,cab,cba</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250213204306260.png" alt="image-20250213204306260"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250213204335614.png" alt="image-20250213204335614"></p>
<p>解决第二个问题，排列里要求不重复，就是将上述代码中的注释部分去掉，变成：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250213204500043.png" alt="image-20250213204500043"></p>
<p>visit代表某一个字符试没试过。就比如说abca，当在试的时候，交换第一个位置，第一个a使得visit[0]&#x3D;true，那么当来到最后一个a的时候，由于visit[0]&#x3D;true，所以就不会将它与第一个位置互换。</p>
<p>如果不使用这个，直接对result进行去重，比如说变成set类型，也可以，但时间会比上面的代码长，因为上面的代码遇到重复字符就不试了，而set则是将字符存进result里才会去重。时间复杂度没有变化，但常数时间变了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250213205633376.png" alt="image-20250213205633376"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250213210541557.png" alt="image-20250213210541557"></p>
<p>f 代表先手拿牌，s 代表后手拿牌。为什么s 返回的是最小值，因为当你拿完牌后轮对手抓，对手一定会给你留接下来所有策略里值最小的，所以就返回最小值；当对手拿完牌后，对于剩下的牌你是先手，所以min里面是先手。</p>
<p>为什么win1有一个后手拿牌：因为当你后手的时候，一定是别人取走了两个先手里最好的那个先手，所以你只能取两个先手中较差的那个，<strong>后手拿牌不一定输</strong>。</p>
<p><strong>竟然后手已经比先手差了为什么还要比较，而不是win1直接返回先手。</strong>当数量为偶数个的时候，先手比&#x3D;必赢，但数量为奇数个的时候就不一定了，比如：1，3，1。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250213214711193.png" alt="image-20250213214711193"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250213215324521.png" alt="image-20250213215324521"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250214101922905.png" alt="image-20250214101922905"></p>
<p>依旧是从左往右尝试。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250214102158668.png" alt="image-20250214102158668"></p>
<p>分成这俩部分，前面是固定下来的。当i 位置为0时，它不能与任何的匹配，那就返回0；当i 不为0时，1）i 固定，i+1及后面的再判断；2）当i 上的数字是3~9，只能做一个决定就是i 固定；如果是1或2，那要么i 固定，当i 为1时，要么i 固定或者和i+1当作一个整体，当i 为2时，要么i 固定或者当 i+1 位置上的数小于7时可以一起看作一个整体。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250214102907223.png" alt="image-20250214102907223"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250214103001684.png" alt="image-20250214103001684"></p>
<p>从左往右尝试，i 要或者i 不要。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250214103656088.png" alt="image-20250214103656088"></p>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>相当于一个图状结构，查找函数就是查找两个元素的根节点是不是同一个元素，是的话就在同一个集合，否则相反。</p>
<p>两个函数：</p>
<p>1、boolean 类型的，查找两个元素是不是在同一个类型；</p>
<p>2、void 类型，将两个集合合并。元素少的集合挂在元素多的哪个集合下面。</p>
<p>下面的并查集相关算法适合比较复杂的元素，而比较简单的元素适合可以数组来表示，这个可以去看天梯赛题目的那道题，关于城市沦陷的题目。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250309203353276.png" alt="image-20250309203353276"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250309203446223.png" alt="image-20250309203446223"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250309203703200.png" alt="image-20250309203703200"></p>
<p>elementMap 相当于是自己一个元素对应这个元素自己的集合，就是每个元素当都建立一个自己的集合。</p>
<p>fatherMap 就是每个元素的集合的父节点是谁。</p>
<p>sizeMap 储存的是每个集合里面有多少个元素。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250309204216080.png" alt="image-20250309204216080"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250309204403251.png" alt="image-20250309204403251"></p>
<p>这边的findHead方法最后会将这条路径上的所有结点都直接指向代表节点。</p>
<h1 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h1><p>注意值的变化，在Find函数里面，要注意在更新父节点的时候也要更新权值。</p>
<img src="../source/imgs/${fiilname}/image-20250323170141181.png" alt="image-20250323170141181" style="zoom:50%;" />

<pre><code class="hljs plaintext">输入：
5 3 3
1 5 15
4 5 9
2 3 5
1 5
1 3
1 2
输出：
15
6
UNKNOWN</code></pre>

<pre><code class="hljs plaintext">import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
//带权并查集
public class Main &#123;

    public static int[] father;    //记录根节点
    public static long[] value; //value[i]代表i到其根节点的路径长度
    public static StreamTokenizer st=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    public static void main(String[] args) throws IOException&#123;
        int N=nextInt();    //数组长度
        int M=nextInt();    //已知的部分和数量
        int Q=nextInt();    //询问的部分和数量
        father=new int[N+1];
        value=new long[N+1];
        init(N);
        for(int i=0;i&lt;M;i++) &#123;
            int left=nextInt();
            int right=nextInt();
            long s=nextLong();
            left--;
            union(left,right,s);
        &#125;
        for(int i=0;i&lt;Q;i++) &#123;
            int left=nextInt();
            int right=nextInt();
            left--;
            int leftFather=find(left);
            int rightFather=find(right);
            if(leftFather==rightFather) &#123;
                System.out.println(value[left]-value[right]);
            &#125;else &#123;
                System.out.println(&quot;UNKNOWN&quot;);
            &#125;
        &#125;
        
    &#125;
    public static void init(int n) &#123;
        for(int i=0;i&lt;=n;i++) &#123;
            father[i]=i;
        &#125;
    &#125;
    //带权并查集得到查找操作
    public static int find(int x) &#123;
        if(father[x]==x) &#123;
            return x;
        &#125;else &#123;
            int tmp=father[x];
            father[x]=find(father[x]);
            value[x]+=value[tmp];
            return father[x];
        &#125;
    &#125;
    //带权并查集合并操作
    public static void union(int left,int right,long s) &#123;
        int leftFather = find(left);
        int rightFather=  find(right);
        if(leftFather!=rightFather) &#123;
            //让小根节点指向大根节点
            int min=Math.min(leftFather,rightFather);
            int max=Math.max(leftFather,rightFather);
            father[min]=max;
            value[min]=Math.abs(-value[left]+value[right]+s);
        &#125;
    
    &#125;
    public static int nextInt() throws IOException&#123;
        st.nextToken();
        return (int)st.nval;
    &#125;
    public static long nextLong() throws IOException&#123;
        st.nextToken();
        return (long) st.nval;
    &#125;
&#125;</code></pre>

<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>我记得数据结构里有这个，可以去看一下。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250309213018590.png" alt="image-20250309213018590"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250310194826414.png" alt="image-20250310194826414"></p>
<p>i1是在str1中比对的位置，i2是在str2中比对的位置。</p>
<p>求解next[]数组（next值的含义是从头开始的字符串和i 位置的前缀一样的最大字符个数）：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250310200058872.png" alt="image-20250310200058872"></p>
<p>求i 位置的next值为多少，那就看i-1位置的next值为多少，假设为n，接下来就看str2[n]是否等于str2[i -1]，如果等于的话，那么next[i]&#x3D;n+1；如果不相等的话：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250310200607912.png" alt="image-20250310200607912"></p>
<p>因为next[i-1]&#x3D;8，所以接下来跳转到str2[next[8]]，看它是否和i-1位置的相等，还不相等的话，根据上图跳转到str2[next[3]]，看是否相等，不相等的话因为已经到头了，所以next[i]&#x3D;0。如果哪一个等于的话，那next[i]&#x3D;那个位置的next值加一。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250310201517882.png" alt="image-20250310201517882"></p>
<p>cn是和i-1的字符比对的索引。</p>
<h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250310201854862.png" alt="image-20250310201854862"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250310202620879.png" alt="image-20250310202620879"></p>
<p>扩充原字符串：在原字符串的两侧和每个字符的中间都添加一个特殊字符（不要求是原字符串中没有出现的）。</p>
<p>然后接下来在扩充字符串上面寻找最大回文子串的长度，就是以一个字符为中心向左右两边扩充比对，最后每个字符都可以得到以它为中心的回文子串的长度，最后将这个长度 &#x2F;2 得到的答案都是原字符串的回文子串的长度之一。这个方法不会漏掉原字符串中回文子串为偶数个时的答案。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250310204440628.png" alt="image-20250310204440628"></p>
<p>R是回文子串的最大右边界，R只会增大，初始值为-1；</p>
<p>C是记录最大右边界时那个回文子串的中心索引。</p>
<p>接下来优化寻找最大回文子串的过程：</p>
<p>1）当作为中心的索引超过R时，没有任何优化，就直接往两边扩寻找回文子串，记得更新R和C；</p>
<p>2）来到的点在最大回文右边界也就是R中时，</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250310205302627.png" alt="image-20250310205302627"></p>
<p>i’ 是i 关于C的对称点，L是以C为中心的回文区域的左边界。</p>
<p>回文半径（该点的最大回文子串的长度&#x2F;2），回文区域（该点的回文子串索引区域）</p>
<p>2）1、i’ 点的回文区域在[L,R]（没有压线情况）中时，i 点的回文半径就等于i’ 点的回文半径。</p>
<p><strong>下面举例所用的字符串自己在脑海中加上特殊字符。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250310205716520.png" alt="image-20250310205716520"></p>
<p>2）2、i’ 的回文区域有一部分已经在[L,R]外面了，i 的回文区域就是[R’,R]，R’是R关于i 的对称点，L’是L关于i’ 的对称点。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250310211130867.png" alt="image-20250310211130867"></p>
<p>2）3、压线：i’的回文区域与L压线，这种情况有一部分是你不需要验证的，从R+1位置开始继续比对。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250310211602778.png" alt="image-20250310211602778"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250310211808183.png" alt="image-20250310211808183"></p>
<p>循环中第一次求的pArr[i]是至少不用验证的区域半径。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250310212715770.png" alt="image-20250310212715770"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250310212728622.png" alt="image-20250310212728622"></p>
<p>max-1就是原字符串中最大回文字符串的长度，不用想为什么，证明出来的。</p>
<p>这个方法不仅可以解决回文子串的问题，<strong>回文半径数组</strong>的信息可以帮你解决很多回文问题。</p>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311151600585.png" alt="image-20250311151600585"></p>
<p>窗口：L和R是窗口的左右边界，刚开始的时候都在最左边，只能往右边移动，L不能超过R。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311152208645.png" alt="image-20250311152208645"></p>
<p>创建一个双端队列，<strong>里面存储的是索引</strong>，里面是按大小排序的，头是最大值，尾是最小值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311152747213.png" alt="image-20250311152747213"></p>
<p>R移动：开始的时候R向右移动，依次存进3、2，接下来要存进4，因为这个双端队列的特殊性，4要排在头不能排在比它小的数后面，所以要依次弹出2、3，弹出的数不去找回，然后存进4。<strong>要严格保证单调性</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311153028263.png" alt="image-20250311153028263"></p>
<p>L移动：L向右移动时，要把L前面的数弹出队列，如下面的例子，L前面的索引是0，那就看队列的头存储的索引是不是小于等于0，是的话删除，检查下一个头，不是的话就不用弹出了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311153615301.png" alt="image-20250311153615301"></p>
<p>窗口存储的是在依次过期的情况下成为最大值的可能性，当你要存进去一个比队列的部分数要大的值时，说明这些值不可能成为最大值了，所以弹出。</p>
<p>下面的例子，原本队列中有存储5，当你再存进去一个5时，要把前面的那个5弹出去，因为新加进去的5比前面那个5晚过期，前面那个5再也没机会成为最大值了，留一个5就够了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311154138823.png" alt="image-20250311154138823"></p>
<p>上面的方法复杂度为O(N)。</p>
<p>上面讲得窗口时R和L随时前进任意值的情况，而这道题要求的是前进固定的值，更加简单。</p>
<p>最小值同理，和上面的反过来。</p>
<p>下面的是针对这道题实现的代码，作用是形成一个窗口。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311154856276.png" alt="image-20250311154856276"></p>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311155235509.png" alt="image-20250311155235509"></p>
<p>下面讲得是，想要知道一个数组中的每个数，左边离它最近比它<strong>大</strong>的和右边离它最近比它<strong>大</strong>的数分别是谁。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311155516233.png" alt="image-20250311155516233"></p>
<p>0-&gt;5：索引0上的5。栈中依旧只放下标。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311155754804.png" alt="image-20250311155754804"></p>
<p>接下来要向栈中放入6，不能改变栈的单调性，所以要弹出数据。弹出数据的话，那么关于这个数的相关信息就开始生成了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311155924029.png" alt="image-20250311155924029"></p>
<p>首先弹出2，左边离它最近比它大的数就是它下面压着的数，右边离它最近比它大的数就是当前要存进栈中的数据。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311160137312.png" alt="image-20250311160137312"></p>
<p>假如没有那个7（数，下面讲的都是索引），那么栈中最后会剩下3个数，进入清算阶段。依次弹出栈中的数据，例如，先弹出6，左边离它最近比它大的数是它下面压着的5，由于此时没有新入栈的，所以右边离它最近比它大的数就无。栈底的3，都是无。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311160424162.png" alt="image-20250311160424162"></p>
<p>时间复杂度O(N)。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311160814920.png" alt="image-20250311160814920"></p>
<p>这道题的数组是正数数组。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250311161231131.png" alt="image-20250311161231131"></p>
<p>假设当前子数组必须包含当前数，且当前数必须是子数组中的最小值。</p>
<p>步骤：1、以5为最小值，A最大的是5本身为1个数组；</p>
<p>​			2、以3为最小值，此时有两个子数组[3]和[5,3]，A最大的是[5,3]；</p>
<p>​			3、以1为最小值，最大的是整个数组……</p>
<p>​			依次这样下去</p>
<p>为什么说这道题是单调栈呢：因为每个数，它最左边离它最近比它小的数是它不能扩的位置，最右边离它最近比它小的数是它不能扩的位置，这就是单调栈的原理。</p>
<p>5，3，2，1，6，7，8，4</p>
<p>小-&gt;大</p>
<p>进0</p>
<p>0；进1，-&gt;0（-1，1）</p>
<p>1；进2，-&gt;1(-1,2)</p>
<p>2; 进3，-&gt;2(-1,3)</p>
<p>3；进4，5，6</p>
<p>3，4，5，6；进7，-&gt;6(5,7)，-&gt;5(4,7)，-&gt;4(3,7)</p>
<p>3，7；清算：-&gt;7(3,8)，-&gt;3(-1,8)</p>
<h1 id="大数据题目（资源限制类题目）"><a href="#大数据题目（资源限制类题目）" class="headerlink" title="大数据题目（资源限制类题目）"></a>大数据题目（资源限制类题目）</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250315192832948.png" alt="image-20250315192832948"></p>
<h2 id="范围内搜索（位图）"><a href="#范围内搜索（位图）" class="headerlink" title="范围内搜索（位图）"></a>范围内搜索（位图）</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250315155603835.png" alt="image-20250315155603835"></p>
<p>1）布隆过滤器，也就是利用整型数组来存储数据，每一位代表一个数，一个int可以代表32个数。这个大概需要500多MB</p>
<p>进阶题目：</p>
<p>2）假如要求3KB呢。先将3KB变成整型数组，算下需要多少个int，那就是3000&#x2F;4&#x3D;750（4是一个int的大小），然后算2的多少次方最接近750，是2的9次方也就是512。由于需要算的范围是2的31次方减1，这个刚好可以被512整除，因为（2的32次方-1）有2的32次方个数&#x2F;2的9次方 可以整除，就是刚好可以被划分成大小相等的512份，每份的数为8388608个。接下来，就是以这个为划分，arr[0]代表0<del>8388608，arr[1]代表8388608</del>    ，将每个数除以8388608得到索引，然后arr[索引]++，全部遍历完后找到arr[]中没有达到8388608的数组，在它代表的范围中继续遍历。就是说有一个数组没有到达8388608，那么就在这个数组代表的范围上继续分成512份。然后继续遍历这40亿个数，不在这个范围上的就不要了，在这个范围上的就是这512个区间细分，继续寻找没有达标的那一个数组。然后按上面的方法继续寻找，随着范围越来越小，最后就会锁定没有出现的数。</p>
<p>3）假如要求1KB，那就1000&#x2F;4，找最接近这个数的2的次方。然后按第二种方法来寻找。</p>
<p>4）只能申请有限几个变量。先将些数据二分，如果满的话，那两边的数量应该都是2的31次方除以2，找到没有满的那一边继续二分，最后就可以找到这个数了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250315172556936.png" alt="image-20250315172556936"></p>
<p>普通：</p>
<p>1）利用哈希函数做分流。</p>
<p>2）位图的升级：用两位来表示一个数的状态。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250315172904350.png" alt="image-20250315172904350"></p>
<p>补充：范围查找</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250315173522739.png" alt="image-20250315173522739"></p>
<p>因为要寻找中位数，那从arr[0]加到arr[n]，当和等于20亿的时候，就找到中位数所在的范围了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250315192345996.png" alt="image-20250315192345996"></p>
<p>假如你加到499是18亿，加上500是23亿，超过了20亿，那么接下来就是在arr[500]上寻找第2亿个数就行了，将大块变成小块按前面的范围搜索方法继续查找，最后就可以找出来了。</p>
<h2 id="二维堆"><a href="#二维堆" class="headerlink" title="二维堆"></a>二维堆</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250315164647121.png" alt="image-20250315164647121"></p>
<p>普通问题：利用布隆过滤器或者算URL的哈希码来解决。</p>
<p>补充：没听懂。但讲得方法是将原本的数据分成一个个小文件，利用大根堆给每个小文件的词汇搜索量进行排序，然后再建立一个大堆，将每个堆的第一个扔进大堆中，然后选大堆中的第一个弹出，找到这个元素原本是哪个堆的，将那个堆中的这个元素弹出，然后再将这个堆的第一个元素扔进大堆中进行排序，周而复始直到数量达标。由于是堆，所以调整代价低。</p>
<p>这种方法叫作二维堆，是堆上堆的结构。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250315171723965.png" alt="image-20250315171723965"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250315172125743.png" alt="image-20250315172125743"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250315172140201.png" alt="image-20250315172140201"></p>
<h1 id="暴力递归-动态规划"><a href="#暴力递归-动态规划" class="headerlink" title="暴力递归-&gt;动态规划"></a>暴力递归-&gt;动态规划</h1><p>整体脉络是要找尝试的方法。</p>
<h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>优化：优化后时间复杂度会降低<img src="/../source/imgs/$%7Bfiilname%7D/image-20250316153124352.png" alt="image-20250316153124352"></p>
<p>上面的下面用例子来解释。</p>
<p>题目：有一个机器人在1~N的格子上移动，每次只能移动到附近的格子，不能超过1或者N，题目给出K步，和开始的位置S，结束的位置E，问经过K步移动到E共有几种方法。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316161737199.png" alt="image-20250316161737199"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316155421451.png" alt="image-20250316155421451"></p>
<p>接下来要改进这个方法<img src="/../source/imgs/$%7Bfiilname%7D/image-20250316155016868.png" alt="image-20250316155016868"></p>
<p>通过这张图可以发现f(2,2)的值跟它前面的情况没有关系，之前的决定不影响f(2,2)的结果，这样的情况就可以进行忆化搜索改进（不用考虑位置依赖关系），就是建立一个缓存存储各情况的最后结果，但碰到相同的情况时可以直接得到值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316155700668.png" alt="image-20250316155700668"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316155434507.png" alt="image-20250316155434507"></p>
<p>上面代码应该有问题，f2里面调用的函数应该不是f1而是f2。</p>
<p>接下来进行严格表结构改进（考虑位置依赖）。</p>
<p>先画一张二维表（cur为横轴，rest为竖轴），根据的是f1函数。这张二维表就是f1的所有可能情况。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316162412677.png" alt="image-20250316162412677"></p>
<p>上述S&#x3D;2,E&#x3D;4,K&#x3D;4。</p>
<p>由walkWays1得知我们需要的是4，2位置的值，由f1函数的basecase可以得知(0,4)位置的值为1，其它都为0.</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316162634484.png" alt="image-20250316162634484"></p>
<p>不可能到达0列，所以全为叉。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316162719991.png" alt="image-20250316162719991"></p>
<p>由f1的第二种和第三种情况可以知道1列的值依赖于它的右上角，就是等于右上角的值，而5列的值依赖于它的左上角。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316162839500.png" alt="image-20250316162839500"></p>
<p>最后一种情况，由f1可知，它的值&#x3D;它的右上角加上左上角的值。</p>
<p>所以根据上述规律可以得出(4,2)位置的值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316163118981.png" alt="image-20250316163118981"></p>
<p>下一题</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316163258604.png" alt="image-20250316163258604"></p>
<p>一个数组，里面的都是每个硬币的面值，要找达到目标值所需的最少硬币数。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316164323567.png" alt="image-20250316164323567"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316164337649.png" alt="image-20250316164337649"></p>
<p>忆化搜索改进：</p>
<p>dp数组代表的是递归方法的所有可能性，-1代表无效解，0是一个答案，那就用-2来代表还没算过。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316171455162.png" alt="image-20250316171455162"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316171747948.png" alt="image-20250316171747948"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250418104103680.png" alt="image-20250418104103680"></p>
<p>严格表结构改进：</p>
<p>根据初级算法来画这个表。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316172545374.png" alt="image-20250316172545374"></p>
<p>根据这个表先设置初始值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316172854666.png" alt="image-20250316172854666"></p>
<p>先这样子，中间空白位置还要填充。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316172946002.png" alt="image-20250316172946002"></p>
<p>上面的意思是，现在位置在(5,2)已经拿了5块钱，现在在索引2的位置，如果要拿5块钱的话，接下来就会到达(0,3)位置，不拿的话就会处于(5,3)位置。<img src="/../source/imgs/$%7Bfiilname%7D/image-20250316173137982.png" alt="image-20250316173137982"></p>
<p>从这个可以得知，位于中间的位置依赖的是它的左下方或者下方的位置，所以填的位置应该是从左往右，每个格子都依赖它的左下角，整体从下往上，这是计算动态规划表格子的顺序。</p>
<p>每一个格子的逻辑和刚开始的那个初级递归函数是一样的，所以对于每个格子的处理可以将那个递归函数直接拷贝过来再进行一些处理就行。由于处理顺序是从下往上的，所以在计算这个格子的值时可以直接去下面那一行的值，将递归调用的过程变成动态规划表取值的过程，拷贝过去后注意边界和越界条件。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316191213179.png" alt="image-20250316191213179"></p>
<p>完整代码为：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316191347930.png" alt="image-20250316191347930"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250316191357222.png" alt="image-20250316191357222"></p>
<p><strong>变成严格表位置依赖的方法</strong>：</p>
<p>1、分析可变参数的变化范围，一个参数一维表，两个参数二维表，三个参数三维表；</p>
<p>2、标出你要计算的终止位置；</p>
<p>3、标出不要计算直接出答案的位置；</p>
<p>4、推普遍的位置是如何依赖其它位置的；</p>
<p>5、推出严格表是从哪些格子推到哪些格子，最终来到终止位置。</p>
<p>顺序定了后，具体怎么求把递归所求的东西拷贝过去，递归改动态规划表求值的过程就结束了。</p>
<h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250213205633376.png" alt="image-20250213205633376"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250213210541557.png" alt="image-20250213210541557"></p>
<p>f 代表先手拿牌，s 代表后手拿牌。</p>
<p>画出初始二维表</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250317195638841.png" alt="image-20250317195638841"></p>
<p>这两个函数是相互套的，要算普遍位置的位置依赖的话就需要同时用到两张表。<img src="/../source/imgs/$%7Bfiilname%7D/image-20250317195851551.png" alt="image-20250317195851551"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250317195912315.png" alt="image-20250317195912315"></p>
<p>f 的对角线可以帮助s 求1的那条对角线，s 的对角线可以帮助f 求1的那条对角线，这样互相求就可以得到最后答案了。看不懂就琢磨原函数。<img src="/../source/imgs/$%7Bfiilname%7D/image-20250317200138150.png" alt="image-20250317200138150"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250317201030919.png" alt="image-20250317201030919"></p>
<p>题目是：给你一个正数数组，数组中没有重复值，假如这个数组中的数代表的是货币面值，每个货币有任意张，给你一个目标值，问组成这个目标值的方法数是多少。<img src="/../source/imgs/$%7Bfiilname%7D/image-20250317201346961.png" alt="image-20250317201346961"></p>
<p>接下里画二维表<img src="/../source/imgs/$%7Bfiilname%7D/image-20250317201635914.png" alt="image-20250317201635914"></p>
<p>画位置依赖，这个举例用的是一块钱的</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250317201748150.png" alt="image-20250317201748150"></p>
<p>这个是5块的<img src="/../source/imgs/$%7Bfiilname%7D/image-20250317201851864.png" alt="image-20250317201851864"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250317202641268.png" alt="image-20250317202641268"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250317203127641.png" alt="image-20250317203127641"></p>
<h2 id="状态DP-哈密顿路径"><a href="#状态DP-哈密顿路径" class="headerlink" title="状态DP(哈密顿路径)"></a>状态DP(哈密顿路径)</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250404202124343.png" alt="image-20250404202124343"></p>
<pre><code class="hljs plaintext">public class Main &#123;

    static boolean[][] gragh;
    
    public static void main(String[] args) &#123;
        solve();
//        System.out.println(&quot;881012367360&quot;);
    &#125;
    public static void solve()&#123;
        gragh = new boolean[22][22];
        for (int i = 1; i &lt;= 21; i++) &#123;
            for (int j = 1; j &lt;= 21; j++) &#123;
                if (gcd(i, j) == 1) &#123;
                    gragh[i][j] = true;
                &#125;
            &#125;
        &#125;
        int tot = 1 &lt;&lt; 22;
        long[][] dp = new long[tot][22];
        dp[2][1] = 1;//从 1 出发、只访问了 1，最后停在 1，方案数是 1	
        //状态转移部分
        for (int S = 2; S &lt;= tot - 2; S++) &#123;//枚举所有可能的访问状态 S，S 是一个整数，二进制表示哪些点被访问过。
            for (int i = 2; i &lt;= 21; i++) &#123;//从第二个点开始算，因为第一个点已经访问了，
//            	这个代表的是j-&gt;i的路线数=到达i的路线总数，而我们从1出发，所以算的话从2开始
                if (((S &gt;&gt; i) &amp; 1) == 1) &#123;//枚举状态 S 的倒数第二个点（上一步是哪个点 j 到了 i）
                    for (int j = 1; j &lt;= 21; j++) &#123;
                        if (gragh[i][j] &amp;&amp; (((S ^ (1 &lt;&lt; i)) &gt;&gt; j) &amp; 1) == 1) &#123;
                            dp[S][i] += dp[S ^ (1 &lt;&lt; i)][j];
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        long ans = 0;
        for (int i = 2; i &lt;= 21; i++) &#123;
            ans += dp[tot - 2][i];
        &#125;
        System.out.println(ans);
    &#125;

    public static int gcd(int num1, int num2) &#123;
        if (num2 == 0) &#123;
            return num1;
        &#125; else &#123;
            return gcd(num2, num1 % num2);
        &#125;
    &#125;
&#125;</code></pre>

<p>这段代码是一个 <strong>状态压缩动态规划（DP）</strong> 的实现，用于统计从节点 <code>1</code> 出发，经过所有 21 个互不相同、两两互质的节点的一种路径总数（即在互质图中求<strong>哈密顿路径</strong>数量）。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250404202349226.png" alt="image-20250404202349226"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250404202520453.png" alt="image-20250404202520453"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250404202707153.png" alt="image-20250404202707153"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250404203707191.png" alt="image-20250404203707191"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250404203733735.png" alt="image-20250404203733735"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-寒假字节青训营" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/01/15/%E5%AF%92%E5%81%87%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/" class="article-date">
  	<time datetime="2025-01-15T02:07:18.000Z" itemprop="datePublished">2025-01-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/01/15/%E5%AF%92%E5%81%87%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/">
        寒假字节青训营
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SQL-Optimizer解析"><a href="#SQL-Optimizer解析" class="headerlink" title="SQL Optimizer解析"></a>SQL Optimizer解析</h1><p>optimizer是优化器。</p>
<h2 id="大数据体系与SQL处理流程"><a href="#大数据体系与SQL处理流程" class="headerlink" title="大数据体系与SQL处理流程"></a>大数据体系与SQL处理流程</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115102028282.png" alt="image-20250115102028282"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115102259290.png" alt="image-20250115102259290"></p>
<p><strong>Parser</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115102412176.png" alt="image-20250115102412176"></p>
<p><strong>Analyser和Logical Plan</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115103016868.png" alt="image-20250115103016868"></p>
<p>算子只是操作说明，没有具体的实现。</p>
<p>left-deep tree：每个JOIN的右边必须是scan（就是读取一张表）。</p>
<p><strong>查询优化</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115103508958.png" alt="image-20250115103508958"></p>
<p><strong>Physical Plan和Executor</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115104805690.png" alt="image-20250115104805690"></p>
<p>Plan Fragment只包含了完整执行计划的一部分，完整执行计划拆分成多个Plan Fragment。</p>
<p>拆分执行计划后，每个节点之间靠Shuffle算子来连接。（后面会介绍）</p>
<p>每个节点会增加一个Executor，似乎是提升运行速度。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115105032425.png" alt="image-20250115105032425"></p>
<h2 id="常见优化查询"><a href="#常见优化查询" class="headerlink" title="常见优化查询"></a>常见优化查询</h2><p><strong>分类</strong></p>
<p>第一种：按照遍历树的顺序</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115142531697.png" alt="image-20250115142531697"></p>
<p>第二种：根据优化的方法</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115142846898.png" alt="image-20250115142846898"></p>
<p>RBO根据规则优化，重写查询。</p>
<h3 id="RBO"><a href="#RBO" class="headerlink" title="RBO"></a>RBO</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115143329729.png" alt="image-20250115143329729"></p>
<p>R是一个表，p1,p2,p3……pn是条件</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115143541595.png" alt="image-20250115143541595"></p>
<p><strong>优化规则</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115143847372.png" alt="image-20250115143847372"></p>
<p>列裁剪（尽可能减少数据）：从上往下扫描，找出这个执行计划中需要的列（感觉就是元素），一直到最后的SCAN，就是只读取需要的列，其他的不要，减少IO交换。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115144217154.png" alt="image-20250115144217154"></p>
<p>WHERE里面的那些表达式就是谓词。</p>
<p>将谓词尽可能地往前推和往下推，尽早地过滤掉一些不必要的数据。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115144753427.png" alt="image-20250115144753427"></p>
<p>利用一些表达式的等价关系和过滤条件，可以推导出新的过滤条件。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115144939094.png" alt="image-20250115144939094"></p>
<p>16分钟，没听懂。</p>
<p>在运行的时候，从右边获取新的条件运用到左边进行读取。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115145612827.png" alt="image-20250115145612827"></p>
<h3 id="CBO"><a href="#CBO" class="headerlink" title="CBO"></a>CBO</h3><p>概念：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115145922720.png" alt="image-20250115145922720"></p>
<p>统计信息：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115150402853.png" alt="image-20250115150402853"></p>
<p>原始表统计信息可以SCAN出来，中间算子的统计信息需要进行推导，所以叫作推导统计信息。</p>
<p>统计信息的收集方式：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115150659676.png" alt="image-20250115150659676"></p>
<p>第一种在执行时如果遇到数据更新啥的，会导致速度较慢；第二种因为是手动执行的，所以收集到的数据可能会比较旧，因为需要手动执行后数据才会更新。</p>
<p>统计信息推导原则：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115152458806.png" alt="image-20250115152458806"></p>
<p>Filter Selectivity，选择率</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115152846180.png" alt="image-20250115152846180"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115153147035.png" alt="image-20250115153147035"></p>
<p>动态规划方法就是将寻找整体最优解问题分成寻找局部最优解问题，然后不断地通过局部的最优解得到全局的最优解。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250115154046701.png" alt="image-20250115154046701"></p>
<h1 id="流-批-OLAP一体的Flink引擎介绍"><a href="#流-批-OLAP一体的Flink引擎介绍" class="headerlink" title="流&#x2F;批&#x2F;OLAP一体的Flink引擎介绍"></a>流&#x2F;批&#x2F;OLAP一体的Flink引擎介绍</h1><h2 id="Apache-Flink概述"><a href="#Apache-Flink概述" class="headerlink" title="Apache Flink概述"></a>Apache Flink概述</h2><h3 id="诞生背景"><a href="#诞生背景" class="headerlink" title="诞生背景"></a>诞生背景</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116154146733.png" alt="image-20250116154146733"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116154325220.png" alt="image-20250116154325220"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116154630915.png" alt="image-20250116154630915"></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>Flink是流式计算的一个框架。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116155036161.png" alt="image-20250116155036161"></p>
<h3 id="开源生态"><a href="#开源生态" class="headerlink" title="开源生态"></a>开源生态</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116155710352.png" alt="image-20250116155710352"></p>
<h2 id="Flink整体架构"><a href="#Flink整体架构" class="headerlink" title="Flink整体架构"></a>Flink整体架构</h2><h3 id="Flink分层架构"><a href="#Flink分层架构" class="headerlink" title="Flink分层架构"></a>Flink分层架构</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116161504221.png" alt="image-20250116161504221"></p>
<p>不管是SQL描述还是DataStream还是pfFlink描述，在执行引擎层都会转化为一个统一的抽象的DAG图，它是一个逻辑的表达方式。</p>
<p>状态存储层：State Backend；然后上面的三层都是执行引擎层。</p>
<h3 id="Flink总体架构"><a href="#Flink总体架构" class="headerlink" title="Flink总体架构"></a>Flink总体架构</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116162054670.png" alt="image-20250116162054670"></p>
<p>DataFlowGraph就是DAG的一个图。</p>
<p>代码全部都是写在Program code那边，不管是java还是python 什么的，然后经过一些处理转化为DataFlow的一个graph，就是DAG的一张图。Client端会将用户数据处理逻辑转化为DAG的一张图，然后Client端会将这张图提交给JM。JM会将它简化为一个具体的物理执行图，并且JM根据物理执行图对应的任务将对应的Task调用到TM中。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116162959218.png" alt="image-20250116162959218"></p>
<p>JobMaster是申请资源(slot)的。</p>
<p>Client端提交作业，Dispatcher拉几个JobMaster，JobMaster向ResourceManager申请资源，上图中两个TM向ResourceManager申请注册，注册完毕后代表此时资源中有两个TM可以调用，那JM如果申请调用两个TM的话就可以调用了。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116164120781.png" alt="image-20250116164120781"></p>
<p>第一步是弄一个环境变量，要从哪里读入数据，addSource里面填的是地址，要从哪里读。</p>
<p>map就是一个一对一的解析处理，这边处理的是一行数据。一行语句中是有空格的，而这个parse语句就可以根据这个空格把这条语句拆开，这边就是拆成了一个Event的格式。</p>
<p>keyBy是将想同的数据弄到一块，将数据分发到Task上，apply是对数据做什么处理。</p>
<p>最后是将数据写到某个地方。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116165338291.png" alt="image-20250116165338291"></p>
<p>为什么map到keyBy会有那么多线，因为map处理后的数据会在keyBy中处理根据它处理的哈希值进行分配，所以map处理的数据可能会到keyBy1也有可能会到keyBy2。</p>
<p>这是逻辑执行图-&gt;可以执行并发的一个执行图。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116165724154.png" alt="image-20250116165724154"></p>
<p>source也叫operator或者task。</p>
<p>可以将source和map嵌在一起执行，因为不用经过keyBy分配，所以source读完一条数据后紧接着就可以调用map进行处理，可以在同一个线程中进行。什么算子可以嵌在一起是有判断条件的，可以去官网查看。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116170242230.png" alt="image-20250116170242230"></p>
<p>每个TM里面可以有多少个slot是用户自己定义的，每个slot在TM里面都是有一个单独的线程的。</p>
<h3 id="Flink如何做到流批一体化"><a href="#Flink如何做到流批一体化" class="headerlink" title="Flink如何做到流批一体化"></a>Flink如何做到流批一体化</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116171041384.png" alt="image-20250116171041384"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116171109384.png" alt="image-20250116171109384"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116171229762.png" alt="image-20250116171229762"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116171417857.png" alt="image-20250116171417857"></p>
<h4 id="流批一体的Scheduler层"><a href="#流批一体的Scheduler层" class="headerlink" title="流批一体的Scheduler层"></a>流批一体的Scheduler层</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116173517314.png" alt="image-20250116173517314"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116173716334.png" alt="image-20250116173716334"></p>
<p>LAZY等上游资源处理完之后可以用上游处理完的资源去处理下游。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116173939863.png" alt="image-20250116173939863"></p>
<p>12个task一起调度，不是16个。</p>
<p>A有两个并发，B有两个，C有四个，D有四个，B的要平均传输到两个C中，C要传输到4个D中。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116174147834.png" alt="image-20250116174147834"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116174340282.png" alt="image-20250116174340282"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116174817831.png" alt="image-20250116174817831"></p>
<p>BLOCKING：A产生的数据不会立马传给B，数据不是实时传输的，中间需要先落盘，就是存到磁盘中，这样子在A1执行完后B1可以从磁盘中读取数据，这样子A1可以先执行，执行完后释放资源，然后执行B1。</p>
<p>PLIPELINED：A产生的数据直接传给B，中间不落盘，直接走到内存，就是A1的数据可能先存到内存中，然后发给B1后内存就释放掉了。最后还是需要12个task的资源，这个作业才能整体运行起来。</p>
<h4 id="流批一体的Shuffle-Service层"><a href="#流批一体的Shuffle-Service层" class="headerlink" title="流批一体的Shuffle Service层"></a>流批一体的Shuffle Service层</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116192925311.png" alt="image-20250116192925311"></p>
<p>涉及到上下游的数据交换就是一个shuffle。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116193111934.png" alt="image-20250116193111934"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116193254190.png" alt="image-20250116193254190"></p>
<p>流作业中如果task销毁了，那么shuffle也没了，而批的不会。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116193747409.png" alt="image-20250116193747409"></p>
<h2 id="Flink架构优化"><a href="#Flink架构优化" class="headerlink" title="Flink架构优化"></a>Flink架构优化</h2><h3 id="流-批-OLAP业务场景概述"><a href="#流-批-OLAP业务场景概述" class="headerlink" title="流&#x2F;批&#x2F;OLAP业务场景概述"></a>流&#x2F;批&#x2F;OLAP业务场景概述</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116201644458.png" alt="image-20250116201644458"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116201701867.png" alt="image-20250116201701867"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250116201753632-1737029874253-1.png" alt="image-20250116201753632"></p>
<h3 id="Flink如何支持OLAP场景"><a href="#Flink如何支持OLAP场景" class="headerlink" title="Flink如何支持OLAP场景"></a>Flink如何支持OLAP场景</h3><p>需要有一定基础，建议之后再看。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-青训营" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/01/14/%E9%9D%92%E8%AE%AD%E8%90%A5/" class="article-date">
  	<time datetime="2025-01-14T12:09:43.078Z" itemprop="datePublished">2025-01-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、凯阳</p>
<p>2、<img src="D:\hexo\source\source\imgs${fiilname}\image-20250114190712259.png" alt="image-20250114190712259"></p>
<p><img src="D:\hexo\source\source\imgs${fiilname}\image-20250114190805319.png" alt="image-20250114190805319"></p>
<p>3、结营证书获取</p>
<p><img src="D:\hexo\source\source\imgs${fiilname}\image-20250114190842325.png" alt="image-20250114190842325"></p>
<p><img src="D:\hexo\source\source\imgs${fiilname}\image-20250114191128121.png" alt="image-20250114191128121"></p>
<p>4、大项目</p>
<p>（1）简易流计算系统设计</p>
<p>参考看3</p>
<p>（2）简易分布式爬虫系统实现	</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-蓝桥" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/01/07/%E8%93%9D%E6%A1%A5/" class="article-date">
  	<time datetime="2025-01-07T11:12:54.576Z" itemprop="datePublished">2025-01-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、刷历年真题</p>
<p>2、</p>
<p><img src="D:\hexo\source\source\imgs${fiilname}\image-20250107190352991.png" alt="image-20250107190352991"></p>
<p>学习路线，蓝桥官网上有</p>
<p>3、基础做对70%，一等奖水平</p>
<p>4、<img src="D:\hexo\source\source\imgs${fiilname}\image-20250107190621316.png" alt="image-20250107190621316"></p>
<p><img src="D:\hexo\source\source\imgs${fiilname}\image-20250107190643849.png" alt="image-20250107190643849"></p>
<p>后面数字代表难度，A组那边的都是比较难的。</p>
<p>5、计算题概率低，时间要放在基础上。</p>
<p>6、<img src="D:\hexo\source\source\imgs${fiilname}\image-20250107190915698.png" alt="image-20250107190915698"></p>
<p>7、<img src="D:\hexo\source\source\imgs${fiilname}\image-20250107190947161.png" alt="image-20250107190947161"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-数据清洗" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/08/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/" class="article-date">
  	<time datetime="2024-10-08T08:02:29.000Z" itemprop="datePublished">2024-10-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/08/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/">
        数据清洗
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是数据清洗"><a href="#什么是数据清洗" class="headerlink" title="什么是数据清洗"></a>什么是数据清洗</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241008161309399.png" alt="n"></p>
<p>数据清洗就是将“脏数据”变为“干净的数据”。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241008162030445.png" alt="image-20241008162030445"></p>
<p>清洗流程：</p>
<p>数据的读写-&gt;数据的探索与描述-&gt;数据简单处理-&gt;（重复值的处理-&gt;缺失值的处理-&gt;异常值的处理-&gt;文本字符串的处理-&gt;时间格式序列的处理）（后面这五个不是一定要按照这个顺序）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241008163005596.png" alt="image-20241008163005596"></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241008171558890.png" alt="image-20241008171558890"></p>
<p>markdown形式，写笔记就要遵循markdown的要求，不然不能实现。</p>
<p><strong>如果你在运行 Jupyter Notebook 的过程中重启或中断了内核，所有的导入和变量都会被清空。此时你需要重新运行导入语句。</strong></p>
<h1 id="numpy模块"><a href="#numpy模块" class="headerlink" title="numpy模块"></a>numpy模块</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="array"><a href="#array" class="headerlink" title="array()"></a>array()</h3><p>可以将numpy当作一维或多维的数组，重在于数值运算，多用于大型、多维数组上执行的数值运算。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241017153404872.png" alt="image-20241017153404872"></p>
<p><strong>Object</strong>代表的是数据源；<strong>dtype</strong>代表的是某种数据类型，代表的是数据源的数据的类型，如果不写的话，那数据源的数据的类型就默认为它传入是什么类型就是什么类型。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207163358898.png" alt="image-20250207163358898"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207163510509.png" alt="image-20250207163510509"></p>
<p>想要打印某个变量的值不需要写print，直接写变量名就好了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241017153931796.png" alt="image-20241017153931796"></p>
<p>创建数组用的是创建列表的语法，但是因为是数组，所以<strong>元素类型是相同的</strong>，不能像列表那样可以存放不同的数据类型。</p>
<p>优先级：字符串&gt;浮点型&gt;整数</p>
<h3 id="frombuffer-，可转化字符串"><a href="#frombuffer-，可转化字符串" class="headerlink" title="frombuffer()，可转化字符串"></a>frombuffer()，可转化字符串</h3><p>numpy.frombuffer 用于实现动态数组。</p>
<p>numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p>
<pre><code class="hljs plaintext">numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)
注意：buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。
buffer	可以是任意对象，会以流的形式读入。
dtype	返回数组的数据类型，可选
count	读取的数据数量，默认为-1，读取所有数据。
offset	读取的起始位置，默认为0。</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207171004355.png" alt="image-20250207171004355"></p>
<p><code>dtype=&#39;S1&#39;</code> 表示<strong>固定长度的字符串</strong>，其中 <code>S1</code> 代表<strong>每个元素是 1 字节的字符串</strong>（即单个字符）。</p>
<p><code>S1</code> → 每个元素是 1 字节（1 个字符），<code>Sx</code> → 其中 <code>x</code> 是字符串的最大长度</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207171100749.png" alt="image-20250207171100749"></p>
<h3 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207164553766.png" alt="image-20250207164553766"></p>
<h3 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241017160139601.png" alt="image-20241017160139601"></p>
<pre><code class="hljs plaintext">plt.read(&#x27;7.jpg&#x27;)</code></pre>

<p>读取图片数据后会将数据存储在一个numpy数组中，单引号里面填写图片路径。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241020165012942.png" alt="image-20241020165012942"></p>
<pre><code class="hljs plaintext">import matplotlib.pyplot as plt
img_arr = plt.imread(&#x27;./7.jpg&#x27;) #数组中装载的就是图片内容
plt.imshow(img_arr) #将numpy数组进行可视化展示</code></pre>

<p>这个图片展示单从内容上讲，不如前面那个方法。</p>
<pre><code class="hljs plaintext">img_arr = img_arr - 100 #数组名减去一个数代表这个数组里的全部数据都减去那个数</code></pre>

<h3 id="zero-ones-linspace-arange-random系列"><a href="#zero-ones-linspace-arange-random系列" class="headerlink" title="zero(),ones(),linspace(),arange(),random系列"></a>zero(),ones(),linspace(),arange(),random系列</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241020165857076.png" alt="image-20241020165857076"></p>
<p>以上几个方法都是创建数组的。</p>
<p>zero()代表初始数据为0，ones()代表初始数据为1；不是linespace，是linspace。</p>
<pre><code class="hljs plaintext">numpy.zeros(shape, dtype = float, order = &#x27;C&#x27;)
shape	数组形状
dtype	数据类型，可选，默认为浮点数
order	&#x27;C&#x27; 用于 C 的行数组，或者 &#x27;F&#x27; 用于 FORTRAN 的列数组</code></pre>

<pre><code class="hljs plaintext">np.zeros(shape = (3,4)) # shape代表的是要创建的数组大小，(3,4)就是三行四列</code></pre>

<pre><code class="hljs plaintext">numpy.ones(shape, dtype = None, order = &#x27;C&#x27;)默认为浮点数</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241020171120344.png" alt="image-20241020171120344"></p>
<p>“size&#x3D;”不一定要写。</p>
<pre><code class="hljs plaintext">np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)
start	序列的起始值
stop	序列的终止值，如果endpoint为true，该值包含于数列中
num		要生成的等步长的样本数量，默认为50
endpoint	该值为 true 时，数列中包含stop值，反之不包含，默认是True。
retstep	如果为 True 时，生成的数组中会显示间距，反之不显示。
dtype	ndarray 的数据类型</code></pre>

<p><code>np.linspace(start, stop, num)</code> 的作用是生成一个从 <code>start</code> 到 <code>stop</code>（包括 <code>start</code> 和 <code>stop</code>）的等差数列，包含 <code>num</code> 个元素。<code>np.linspace(0, 100, num=20)</code> 生成的是一个等差数列，从 <code>0</code> 到 <code>100</code> 之间均匀分布 <strong>20 个点</strong>，包括起点 <code>0</code> 和终点 <code>100</code>。在生成等差数列时，我们需要确定每两个相邻数之间的间隔。希望生成 20 个数，但实际上这个数列可以理解为有 <strong>19 个间隔</strong>，因为 20 个数之间只有 19 个间隔。间隔长度为(100 - 0) &#x2F; (20 - 1) ≈ 5.26315789。</p>
<p><code>np.arange(10,50,step)</code>，step，步长。<code>numpy.arange(start, stop, step, dtype)</code></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207214929078.png" alt="image-20250207214929078"></p>
<p><code>np.random.randint(start,end,size)</code>，产生一个size大小的DataFrame，元素是start到end的随机数。</p>
<p><code>np.random.random(size)</code>，生成的是size大小范围0-1的DataFrame，可以指定索引。</p>
<h3 id="logspace"><a href="#logspace" class="headerlink" title="logspace()"></a>logspace()</h3><pre><code class="hljs plaintext">np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)
base 参数意思是取对数的时候 log 的下标。
start	序列的起始值为：base ** start
stop	序列的终止值为：base ** stop。如果endpoint为true，该值包含于数列中
num		要生成的等步长的样本数量，默认为50
endpoint	该值为 true 时，数列中中包含stop值，反之不包含，默认是True。
base	对数 log 的底数。
dtype	ndarray 的数据类型</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207171943115.png" alt="image-20250207171943115"></p>
<h2 id="numpy数组的常用属性"><a href="#numpy数组的常用属性" class="headerlink" title="numpy数组的常用属性"></a>numpy数组的常用属性</h2><p>shape,ndim,size,dtype</p>
<p><code>数组名.shape</code>返回的是数组的形状。</p>
<p><code>数组名.ndim</code>返回的是数组的维度。</p>
<p><code>数组名.size</code>返回的是数组的元素个数。</p>
<p><code>数组名.dtype</code>返回的是数组的元素类型。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241020214914911.png" alt="image-20241020214914911"></p>
<p><code>dtype(变量)</code>返回的是变量的类型。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207163207446.png" alt="image-20250207163207446"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207163809862.png" alt="image-20250207163809862"></p>
<h2 id="numpy的索引和切片操作"><a href="#numpy的索引和切片操作" class="headerlink" title="numpy的索引和切片操作"></a>numpy的索引和切片操作</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引操作和列表的索引操作时一样的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241020215302927.png" alt="image-20241020215302927"></p>
<p><strong>整数数组索引</strong>：指使用一个数组来访问另一个数组的元素。这个数组中的每个元素都是目标数组中某个维度上的索引值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207221111954.png" alt="image-20250207221111954"></p>
<p>行索引和列索引是配对的。[0,1,2]用来选择行索引，[0,1,0]用来选择列索引。</p>
<pre><code class="hljs plaintext">x[[0,1,2],[0,1,0]]等于x[0,0],x[1,1],x[2,0]</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207221802238.png" alt="image-20250207221802238"></p>
<p>按照上面那样整数索引以二维数组的形式输入，最后输出结果也是二维数组。</p>
<p>但如果<code>y = x[[0,0,3,3],[0,2,0,2]]</code> ，最后就会输出一维数组<img src="/../source/imgs/$%7Bfiilname%7D/image-20250207222254474.png" alt="image-20250207222254474"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207222808964.png" alt="image-20250207222808964"></p>
<p><strong><code>a[1:3, [1,2]]</code></strong><br>先选择 <strong>行 1 到 2</strong>，再选 <strong>列 1、2</strong>，得到的是一个<strong>子矩阵</strong>。</p>
<p><strong><code>a[[1,2], [1,2]]</code></strong><br>选取的是 <strong>(1,1) 和 (2,2) 位置</strong> 的元素，得到的是一个<strong>一维数组</strong>。</p>
<p>那怎么取第1，3，5行的第2，4，6列的数据呢？</p>
<p>1、使用np.ix_()</p>
<pre><code class="hljs plaintext">import numpy as np

# 创建 8×8 的数组
a = np.arange(64).reshape(8, 8)

# 选取第 1、3、5 行 &amp; 第 2、4、6 列
rows = [1, 3, 5]   # 行索引
cols = [2, 4, 6]   # 列索引

result = a[np.ix_(rows, cols)]
print(result)</code></pre>

<p>2、直接使用 [:, :] 进行花式索引</p>
<pre><code class="hljs plaintext">result = a[[1, 3, 5], :][:, [2, 4, 6]]
print(result)</code></pre>

<p><code>a[[1, 3, 5], :]</code> → 先取出<strong>第 1、3、5 行</strong>，包含所有列。</p>
<p><code>[:, [2, 4, 6]]</code> → 再在选出的子矩阵中取出<strong>第 2、4、6 列</strong>。</p>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>一维数组：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207215349800.png" alt="image-20250207215349800"></p>
<p>冒号 <strong>:</strong> 的解释：如果只放置一个参数，如 **[2]**，将返回与该索引相对应的单个元素。如果为 **[2:]**，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 **[2:7]**，那么则提取两个索引(不包括停止索引)之间的项。</p>
<p>二维数组：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241020215504578.png" alt="image-20241020215504578"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207215727797.png" alt="image-20250207215727797"></p>
<p>[1:]从索引为1的切割到底。</p>
<p>切片还可以包括<strong>省略号 …</strong>，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p>
<p>在 NumPy 中，<code>...</code>（省略号）用于表示<strong>多个冒号（<code>:</code>）</strong>，它的作用是<strong>自动匹配剩余的维度</strong>，以便简化索引操作。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207220436562.png" alt="image-20250207220436562"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207220509824.png" alt="image-20250207220509824"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207220525783.png" alt="image-20250207220525783"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241020215706883.png" alt="image-20241020215706883"></p>
<p>将图片进行左右翻转，就是该图片的行不变，列倒置。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241020215928312.png" alt="image-20241020215928312"></p>
<p>图片上下翻转，就是图片的行倒置，列不变。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241020220104876.png" alt="image-20241020220104876"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241020220351225.png" alt="image-20241020220351225"></p>
<p>上述关于图片的各种操作就是关于图片的numpy数组的操作。</p>
<h2 id="广播（Broaddcast）"><a href="#广播（Broaddcast）" class="headerlink" title="广播（Broaddcast）"></a>广播（Broaddcast）</h2><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式。</p>
<p>如果两个数组 a 和 b 形状相同，即满足 <strong>a.shape &#x3D;&#x3D; b.shape</strong>，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208114331553.png" alt="image-20250208114331553"></p>
<p>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208114630902.png" alt="image-20250208114630902"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208115018470.png" alt="image-20250208115018470"></p>
<h2 id="迭代数组"><a href="#迭代数组" class="headerlink" title="迭代数组"></a>迭代数组</h2><p>NumPy 迭代器对象 <strong>numpy.nditer</strong> 提供了一种灵活访问一个或者多个数组元素的方式。</p>
<p><code>np.nditer(a)</code> 是 NumPy 提供的<strong>多维数组迭代器</strong>，可以逐元素访问 <code>a</code>。</p>
<p>适用于<strong>任何维度的数组</strong>，而不需要手动写多层 <code>for</code> 循环。</p>
<p><strong>按行优先（C 方式）依次访问数组中的元素</strong>。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208155819018.png" alt="image-20250208155819018"></p>
<p>**<code>print(x)</code>**：打印变量 <code>x</code>（这里是 NumPy 数组中的元素）。</p>
<p><strong><code>end=&quot;, &quot;</code><strong>：指定</strong>打印结尾的字符</strong>，原本print()默认是换行 <code>&quot;\n&quot;</code>，但这里改为 <code>&quot;, &quot;</code>（逗号+空格），所以输出在同一行，并且元素之间用 <code>&quot;, &quot;</code> 分隔。</p>
<p>控制遍历顺序：</p>
<ul>
<li><code>for x in np.nditer(a, order=&#39;F&#39;):</code>Fortran order，即是列序优先；</li>
<li><code>for x in np.nditer(a.T, order=&#39;C&#39;):</code>C order，即是行序优先；</li>
</ul>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208160527323.png" alt="image-20250208160527323"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208162240752.png" alt="image-20250208162240752"></p>
<p>将<code>x[...]=2*x</code> 修改为<code>x=2*x</code>就不能修改原数组了。</p>
<p><code>x[...]</code> 表示 <code>x</code> 仍然是 <code>a</code> 数组的<strong>视图</strong>（view）。</p>
<p><code>x[...] =</code> <strong>不会改变 <code>x</code> 本身的引用，而是修改它所指向的内存中的值</strong>。</p>
<p><code>x = 2 * x</code> 和 <code>x[...] = 2 * x</code> 的<strong>关键区别</strong>在于：</p>
<ul>
<li><code>x[...] =</code> <strong>操作的是 <code>x</code> 所指向的原数组</strong>。</li>
<li><code>x =</code> <strong>创建了一个新的 Python 变量，而不是修改原数组的内存</strong>。</li>
</ul>
<p>在 NumPy 中，<strong>视图（view）</strong> 是指<strong>共享相同数据但具有不同形状或表示方式的数组</strong>。<br><strong>视图不会创建新的数据副本，而是引用原始数组的内存</strong>，因此修改视图的数据会影响原数组，反之亦然。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208163444276.png" alt="image-20250208163444276"></p>
<p>如果两个数组是<strong>可广播</strong>的，nditer 组合对象能够<strong>同时迭代</strong>它们。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208163732611.png" alt="image-20250208163732611"></p>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="修改数组形状"><a href="#修改数组形状" class="headerlink" title="修改数组形状"></a>修改数组形状</h3><p>**数组名.reshape(行，列)**：重新制定形状。一维-&gt;多维；多维-&gt;一维。</p>
<p>reshape(12**,**)和reshape(12)都代表12个元素的一维数组；但是reshape(,12)会报错，不代表1列的数组。</p>
<p>变形前后的<strong>元素数量要一样</strong>。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250207163826087.png" alt="image-20250207163826087"></p>
<p><code>numpy.ndarray.flat</code> 是一个数组元素迭代器。不用使用迭代数组也可以一个一个输出元素。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208170733082.png" alt="image-20250208170733082"></p>
<p><code>numpy.ndarray.flatten</code> 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，<strong>返回的始终是一维数组</strong>。</p>
<p><code>ndarray.flatten(order=&#39;C&#39;)</code>，order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208171052827.png" alt="image-20250208171052827"></p>
<p><code>numpy.ravel()</code> 展平的数组元素，顺序通常是”C风格”，返回的是数组<strong>视图</strong>（view），修改会影响原始数组。</p>
<p><code>ndarray.ravel(order=&#39;C&#39;)</code>，用法和flatten一样，也是返回一维数组。</p>
<h3 id="翻转数组"><a href="#翻转数组" class="headerlink" title="翻转数组"></a>翻转数组</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208171758181.png" alt="image-20250208171758181"></p>
<p>后面两个想看自己去菜鸟看。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208171942673.png" alt="image-20250208171942673"></p>
<p><strong>numpy.ndarray.T 类似 numpy.transpose</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208172025127.png" alt="image-20250208172025127"></p>
<h3 id="级联操作（同一维度）"><a href="#级联操作（同一维度）" class="headerlink" title="级联操作（同一维度）"></a>级联操作（同一维度）</h3><p>将多个numpy数组进行横向或纵向的拼接。</p>
<pre><code class="hljs plaintext">import numpy as np
arr = np.array([1,2,3])
arr2 = np.array([4,5,6])
np.concatenate((arr,arr2),axis = 0)</code></pre>

<pre><code class="hljs plaintext">import numpy as np
arr3 = np.random.randint(0,10,size = [2,3])
arr4 = np.random.randint(0,10,size = [2,3])
arr5 = np.concatenate((arr3,arr4),axis = 0)
arr5</code></pre>

<p><code>np.concatenate((要拼接的数组),axis = 如何拼接)</code></p>
<p><code>numpy.concatenate((a1, a2, ...), axis)</code>，<code>a1, a2, ...</code>：相同类型的数组，axis默认为0</p>
<p>对<strong>一维数组</strong>来说，只有axis &#x3D; 0，代表横向拼接。对<strong>二维数组</strong>来说，axis &#x3D; 0 ：纵向(y轴)拼接；axis &#x3D; 1：横向(x轴)拼接。对<strong>三维数组</strong>来说，在承接二维的基础上，axis &#x3D; 2，就是z轴上的拼接。</p>
<p>级联的两个数组维度一样但行列不同怎么办？</p>
<p>在<strong>行相同列不同</strong>的情况上，可以<strong>横向拼接</strong>，不能纵向拼接；在<strong>行不同列相同</strong>的情况下，可以<strong>纵向拼接</strong>，不能横向拼接。</p>
<p>可以用于图片的拼接上。</p>
<h3 id="分割数组"><a href="#分割数组" class="headerlink" title="分割数组"></a>分割数组</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208205923418.png" alt="image-20250208205923418"></p>
<p><code>numpy.split(ary, indices_or_sections, axis)</code></p>
<ul>
<li><code>ary</code>：被分割的数组</li>
<li><code>indices_or_sections</code>：如果是一个整数，就用该数平均切分（需要刚好可以平分成这个数量），如果是一个数组，为沿轴切分的位置（左开右闭）</li>
<li><code>axis</code>：设置沿着哪个方向进行切分，默认为 0，横向切分，即水平方向。为 1 时，纵向切分，即竖直方向。</li>
</ul>
<p>横向分割的意思是假如用一把刀来切分，分割的时候刀是沿水平方向移动的，刀口和竖直方向平行。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208210135074-1739019695959-1.png" alt="image-20250208210135074"></p>
<p><strong>axis 为 0 时在水平方向分割，axis 为 1 时在垂直方向分割。</strong></p>
<p><code>numpy.hsplit</code> 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208210654313.png" alt="image-20250208210654313"></p>
<p><code>numpy.vsplit</code> 沿着垂直轴分割，其分割方式与hsplit用法相同。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208211721091.png" alt="image-20250208211721091"></p>
<h3 id="数组元素的添加和删除"><a href="#数组元素的添加和删除" class="headerlink" title="数组元素的添加和删除"></a>数组元素的添加和删除</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208211812393.png" alt="image-20250208211812393"></p>
<p><code>numpy.resize(arr, shape)</code>，如果新数组大小大于原始大小，则包含原始数组中的元素的副本。可以想象成原数组的元素一个一个循环填进新数组中。</p>
<pre><code class="hljs plaintext">import numpy as np
 
a = np.array([[1,2,3],[4,5,6]])
 
print (&#x27;第一个数组：&#x27;)
print (a)
print (&#x27;\n&#x27;)
 
print (&#x27;第一个数组的形状：&#x27;)
print (a.shape)
print (&#x27;\n&#x27;)
b = np.resize(a, (3,2))
 
print (&#x27;第二个数组：&#x27;)
print (b)
print (&#x27;\n&#x27;)
 
print (&#x27;第二个数组的形状：&#x27;)
print (b.shape)
print (&#x27;\n&#x27;)

# 要注意 a 的第一行在 b 中重复出现，因为尺寸变大了 
print (&#x27;修改第二个数组的大小：&#x27;)
b = np.resize(a,(3,3))
print (b)</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208212314743.png" alt="image-20250208212314743"></p>
<p>若是<code>b = np.resize(a,(2,2,2))</code>则输出<img src="/../source/imgs/$%7Bfiilname%7D/image-20250208212437833.png" alt="image-20250208212437833"></p>
<p><code>numpy.append</code> 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的<strong>维度必须匹配</strong>否则将生成ValueError。</p>
<pre><code class="hljs plaintext">numpy.append(arr, values, axis=None)</code></pre>

<ul>
<li><code>arr</code>：输入数组</li>
<li><code>values</code>：要向<code>arr</code>添加的值，需要和<code>arr</code>形状相同（除了要添加的轴）</li>
<li><code>axis</code>：默认为 None。当axis<strong>无定义</strong>时，是横向加成，返回总是为<strong>一维数组</strong>！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（<strong>列数要相同</strong>）。当axis为1时，数组是加在右边（<strong>行数要相同</strong>）。</li>
</ul>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208213035163.png" alt="image-20250208213035163"></p>
<p><code>numpy.insert</code> 函数<strong>在给定索引之前</strong>，沿给定轴在输入数组中插入值。</p>
<p>函数会在指定位置（或位置数组）插入给定的值或数组，然后<strong>返回新的数组</strong>。被插入的元素可以是标量值，也可以是数组。需要注意的是，插入操作会返回一个新的数组，而不会改变原始数组。</p>
<p><code>numpy.insert(arr, obj, values, axis)</code></p>
<ul>
<li><code>arr</code>：输入数组</li>
<li><code>obj</code>：在其之前插入值的索引</li>
<li><code>values</code>：要插入的值</li>
<li><code>axis</code>：沿着它插入的轴，如果未提供，则输入数组会被展开</li>
</ul>
<pre><code class="hljs plaintext">import numpy as np
 
a = np.array([[1,2],[3,4],[5,6]])
 
print (&#x27;第一个数组：&#x27;)
print (a)
print (&#x27;\n&#x27;)
 
print (&#x27;未传递 Axis 参数。 在删除之前输入数组会被展开。&#x27;)
print (np.insert(a,3,[11,12]))
print (&#x27;\n&#x27;)
print (&#x27;传递了 Axis 参数。 会广播值数组来配输入数组。&#x27;)
 
print (&#x27;沿轴 0 广播：&#x27;)
    print (np.insert(a,1,[11],axis = 0))
print (&#x27;\n&#x27;)
 
print (&#x27;沿轴 1 广播：&#x27;)
print (np.insert(a,1,11,axis = 1))</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208214031350.png" alt="image-20250208214031350"></p>
<p>当axis&#x3D;0时，以行为单位进行插入；当axis&#x3D;1是，以列为单位进行插入。</p>
<p>要实现广播数组进行插入的前提这个数组可以广播。</p>
<p><code>numpy.delete</code> 函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。</p>
<pre><code class="hljs plaintext">Numpy.delete(arr, obj, axis)</code></pre>

<ul>
<li><code>arr</code>：输入数组</li>
<li><code>obj</code>：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</li>
<li><code>axis</code>：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</li>
</ul>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208214751293.png" alt="image-20250208214751293"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250208214801277.png" alt="image-20250208214801277"></p>
<p><code>numpy.unique</code> 函数用于去除数组中的重复元素。</p>
<p><code>numpy.unique(arr, return_index, return_inverse, return_counts)</code></p>
<ul>
<li><code>arr</code>：输入数组，如果不是一维数组则会展开</li>
<li><code>return_index</code>：如果为<code>true</code>，返回新列表元素在旧列表中的位置（下标），并以列表形式储</li>
<li><code>return_inverse</code>：如果为<code>true</code>，返回旧列表元素在新列表中的位置（下标），并以列表形式储</li>
<li><code>return_counts</code>：如果为<code>true</code>，返回去重数组中的元素在原数组中的出现次数</li>
</ul>
<p>这个函数返回的去重后的数组同时也完成了排序。</p>
<pre><code class="hljs plaintext">import numpy as np
 
a = np.array([5,2,6,2,7,5,6,8,2,9])
 
print (&#x27;第一个数组：&#x27;)
print (a)
print (&#x27;\n&#x27;)
 
print (&#x27;第一个数组的去重值：&#x27;)
u = np.unique(a)
print (u)
print (&#x27;\n&#x27;)
 
print (&#x27;去重数组的索引数组：&#x27;)
u,indices = np.unique(a, return_index = True)
print (indices)
print (&#x27;\n&#x27;)
 
print (&#x27;我们可以看到每个和原数组下标对应的数值：&#x27;)
print (a)
print (&#x27;\n&#x27;)
 
print (&#x27;去重数组的下标：&#x27;)
u,indices = np.unique(a,return_inverse = True)
print (u)
print (&#x27;\n&#x27;)
 
print (&#x27;下标为：&#x27;)
print (indices)
print (&#x27;\n&#x27;)
 
print (&#x27;使用下标重构原数组：&#x27;)
print (u[indices])
print (&#x27;\n&#x27;)
 
print (&#x27;返回去重元素的重复数量：&#x27;)
u,indices = np.unique(a,return_counts = True)
print (u)
print (indices)</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209113611236.png" alt="image-20250209113611236"></p>
<p>为什么<code>u,indices = np.unique(a, return_index = True)</code>可以同时给两个赋值且值还不同？</p>
<p>因为此时这个函数会返回去重后的数组 <code>u</code>（按排序后的唯一值），返回 <code>indices</code>，它是原数组中每个唯一值第一次出现的索引。它会同时返回两个值，这是python函数中的多返回值机制，如<img src="/../source/imgs/$%7Bfiilname%7D/image-20250209113855801.png" alt="image-20250209113855801"></p>
<h2 id="常用的函数"><a href="#常用的函数" class="headerlink" title="常用的函数"></a>常用的函数</h2><h3 id="算术函数"><a href="#算术函数" class="headerlink" title="算术函数"></a>算术函数</h3><p><strong>sum,max,min,mean</strong></p>
<p><code>数组名.sum()</code>：求出该数组所有元素的和。<code>数组名.sum(axis = 0/1)</code>：每列或每行的和。</p>
<p><code>np.sum([数据源],axis = 0/1)</code></p>
<p>后面几个函数的用法和sum一样。</p>
<p>mean求的是算术平均值。</p>
<p>NumPy 算术函数包含简单的加减乘除: <strong>add()<strong>，</strong>subtract()<strong>，</strong>multiply()</strong> 和 **divide()**。</p>
<p>需要注意的是数组必须<strong>具有相同的形状或符合数组广播规则</strong>。</p>
<p><code>numpy.reciprocal()</code> 函数返回参数<strong>逐元素</strong>的<strong>倒数</strong>。如 <strong>1&#x2F;4</strong> 倒数为 <strong>4&#x2F;1</strong>。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209115805828.png" alt="image-20250209115805828"></p>
<p><code>numpy.power()</code> 函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中<strong>相应</strong>元素的幂。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209115907058.png" alt="image-20250209115907058"></p>
<p>如果第二个元素只有一个数的话，那第一个元素的全部数的幂就是第二个元素的值。</p>
<p><code>numpy.mod()</code> 计算输入数组中相应元素的相除后的<strong>余数</strong>。 函数 numpy.remainder() 也产生相同的结果。</p>
<pre><code class="hljs plaintext">numpy.mod(被除数，除数)</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209212406356.png" alt="image-20250209212406356"></p>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241023172507743.png" alt="image-20241023172507743"></p>
<p>sin，对数组的每个元素都求sin。()里面也可以直接指定一个数，如：<code>np.sin(2.5)</code></p>
<p>这些函数计算使用的都是弧度制，所以要将角度转化为弧度就要<strong>通过乘 pi&#x2F;180 转化为弧度</strong>。</p>
<pre><code class="hljs plaintext">import numpy as np
 
a = np.array([0,30,45,60,90])
print (&#x27;不同角度的正弦值：&#x27;)
# 通过乘 pi/180 转化为弧度  
print (np.sin(a*np.pi/180))
print (&#x27;\n&#x27;)</code></pre>

<p>​	<img src="/../source/imgs/$%7Bfiilname%7D/image-20250209114628152.png" alt="image-20250209114628152"></p>
<p>arcsin，arccos，和 arctan 函数返回给定角度的 sin，cos 和 tan 的反三角函数，但这三个函数返回的不是角度而是弧度。这些函数的结果可以通过 <code>numpy.degrees()</code> 函数将弧度转换为角度。</p>
<pre><code class="hljs plaintext">import numpy as np
 
a = np.array([0,30,45,60,90])  
print (&#x27;含有正弦值的数组：&#x27;)
sin = np.sin(a*np.pi/180)  
print (sin)
print (&#x27;\n&#x27;)
print (&#x27;计算角度的反正弦，返回值以弧度为单位：&#x27;)
inv = np.arcsin(sin)  
print (inv)
print (&#x27;\n&#x27;)
print (&#x27;通过转化为角度制来检查结果：&#x27;)
print (np.degrees(inv))
print (&#x27;\n&#x27;)</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209115237438.png" alt="image-20250209115237438"></p>
<p>当decimal为负数的时候，四舍五入的位置开始向左移动。</p>
<p><code>numpy.floor()</code> 返回小于或者等于指定表达式的最大整数，即向下取整。</p>
<p><code>numpy.ceil()</code> 返回大于或者等于指定表达式的最小整数，即向上取整。</p>
<p>这两个函数参数就是数组。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241023172851161.png" alt="image-20241023172851161"></p>
<p>amin和amax的操作和上面的min和max是一样的。</p>
<p>np,ptp(数组,axis)</p>
<pre><code class="hljs plaintext"># arr.std()
arr5 = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(arr5.std())
print(arr5[1].std())</code></pre>

<p>方差和标准差用法一样。</p>
<h3 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><p><code>numpy.amin()</code> 用于计算数组中的元素沿指定轴的最小值。</p>
<pre><code class="hljs plaintext">numpy.amin(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</code></pre>

<ul>
<li><code>a</code>: 输入的数组，可以是一个NumPy数组或类似数组的对象。</li>
<li><code>axis</code>: 可选参数，用于指定在哪个轴上计算最小值。如果不提供此参数，则返回整个数组的最小值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴。</li>
<li><code>out</code>: 可选参数，用于指定结果的存储位置。</li>
<li><code>keepdims</code>: 可选参数，如果为True，将保持结果数组的维度数目与输入数组相同。如果为False（默认值），则会去除计算后维度为1的轴。</li>
<li><code>initial</code>: 可选参数，用于指定一个初始值，然后在数组的元素上计算最小值。</li>
<li><code>where</code>: 可选参数，一个布尔数组，用于指定仅考虑满足条件的元素。</li>
</ul>
<p>initial部分是提供一个初始值，防止使用这个函数是遇到空数组导致报错，假如是空数组的话，那最后会返回initial的值。</p>
<p><code>numpy.amax()</code> 用于计算数组中的元素沿指定轴的最大值。</p>
<pre><code class="hljs plaintext">numpy.amax(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</code></pre>

<pre><code class="hljs plaintext">import numpy as np 
 
a = np.array([[3,7,5],[8,4,3],[2,4,9]])  
print (&#x27;我们的数组是：&#x27;)
print (a)
print (&#x27;\n&#x27;)
print (&#x27;调用 amin() 函数：&#x27;)
print (np.amin(a,1))
print (&#x27;\n&#x27;)
print (&#x27;再次调用 amin() 函数：&#x27;)
print (np.amin(a,0))
print (&#x27;\n&#x27;)
print (&#x27;调用 amax() 函数：&#x27;)
print (np.amax(a))
print (&#x27;\n&#x27;)
print (&#x27;再次调用 amax() 函数：&#x27;)
print (np.amax(a, axis =  0))</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209123026294.png" alt="image-20250209123026294"></p>
<p><strong>numpy.ptp()</strong> 函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p>
<pre><code class="hljs plaintext">numpy.ptp(a, axis=None, out=None, keepdims=&lt;no value&gt;, where=&lt;no value&gt;)</code></pre>

<ul>
<li><code>a</code>: 输入的数组，可以是一个 NumPy 数组或类似数组的对象。</li>
<li><code>axis</code>: 可选参数，用于指定在哪个轴上计算峰-峰值。如果不提供此参数，则返回整个数组的峰-峰值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴。</li>
<li><code>out</code>: 可选参数，用于指定结果的存储位置。</li>
<li><code>keepdims</code>: 可选参数，如果为 True，将保持结果数组的维度数目与输入数组相同。如果为 False（默认值），则会去除计算后维度为1的轴。</li>
<li><code>where</code>: 可选参数，一个布尔数组，用于指定仅考虑满足条件的元素。</li>
</ul>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209123846267.png" alt="image-20250209123846267"></p>
<p>百分位数是统计中使用的度量，表示<strong>小于这个值</strong>的观察值的百分比。</p>
<pre><code class="hljs plaintext">numpy.percentile(a, q, axis)</code></pre>

<ul>
<li>a: 输入数组</li>
<li>q: 要计算的百分位数，在 0 ~ 100 之间</li>
<li>axis: 沿着它计算百分位数的轴</li>
</ul>
<p>第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。</p>
<p>举个例子：高等院校的入学考试成绩经常以百分位数的形式报告。比如，假设某个考生在入学考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。</p>
<p>这里的 p &#x3D; 70。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209124221500.png" alt="image-20250209124221500"></p>
<p><code>numpy.median()</code> 函数用于计算数组 a 中元素的中位数（中值）。也可以使用percentile函数，当百分位数为50就可以。</p>
<pre><code class="hljs plaintext">numpy.median(a, axis=None, out=None, overwrite_input=False, keepdims=&lt;no value&gt;)</code></pre>

<ul>
<li><code>overwrite_input</code>: 可选参数，如果为True，则允许在计算中使用输入数组的内存。这可能会在某些情况下提高性能，但可能会修改输入数组的内容。</li>
</ul>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209124750016.png" alt="image-20250209124750016"></p>
<pre><code class="hljs plaintext">算术平均值：numpy.mean(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)
标准差：numpy.std(ndarry)
方差：numpy.var(ndarry)</code></pre>

<p><code>numpy.average()</code> 函数根据在另一个数组中给出的各自的权重计算数组中元素的<strong>加权平均值</strong>。</p>
<p>加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。</p>
<p>考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。</p>
<pre><code class="hljs plaintext">加权平均值 = (1*4+2*3+3*2+4*1)/(4+3+2+1)</code></pre>

<pre><code class="hljs plaintext">numpy.average(a, axis=None, weights=None, returned=False)</code></pre>

<ul>
<li><code>a</code>: 输入的数组，可以是一个 NumPy 数组或类似数组的对象。</li>
<li><code>axis</code>: 可选参数，用于指定在哪个轴上计算加权平均值。如果不提供此参数，则计算整个数组的加权平均值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴。</li>
<li><code>weights</code>: 可选参数，用于指定对应数据点的权重。如果不提供权重数组，则默认为等权重。</li>
<li><code>returned</code>: 可选参数，如果为True，将同时返回加权平均值和权重总和。</li>
</ul>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209185849829.png" alt="image-20250209185849829"></p>
<h3 id="排序，条件筛选函数"><a href="#排序，条件筛选函数" class="headerlink" title="排序，条件筛选函数"></a>排序，条件筛选函数</h3><p><code>numpy.sort()</code> 函数返回输入数组的排序副本。</p>
<pre><code class="hljs plaintext">numpy.sort(a, axis, kind, order)</code></pre>

<ul>
<li>a: 要排序的数组</li>
<li>axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis&#x3D;0 按列排序，axis&#x3D;1 按行排序</li>
<li>kind: 默认为’quicksort’（快速排序）</li>
<li>order: 如果数组包含字段，则是要排序的字段</li>
</ul>
<p>可以通过控制order的内容来控制排序。</p>
<pre><code class="hljs plaintext">import numpy as np  
 
a = np.array([[3,7],[9,1]])  
print (&#x27;我们的数组是：&#x27;)
print (a)
print (&#x27;\n&#x27;)
print (&#x27;调用 sort() 函数：&#x27;)
print (np.sort(a))
print (&#x27;\n&#x27;)
print (&#x27;按列排序：&#x27;)
print (np.sort(a, axis =  0))
print (&#x27;\n&#x27;)
# 在 sort 函数中排序字段 
dt = np.dtype([(&#x27;name&#x27;,  &#x27;S10&#x27;),(&#x27;age&#x27;,  int)]) 
a = np.array([(&quot;raju&quot;,21),(&quot;anil&quot;,25),(&quot;ravi&quot;,  17),  (&quot;amar&quot;,27)], dtype = dt)  
print (&#x27;我们的数组是：&#x27;)
print (a)
print (&#x27;\n&#x27;)
print (&#x27;按 name 排序：&#x27;)
print (np.sort(a, order =  &#x27;name&#x27;))</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209191202420.png" alt="image-20250209191202420"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209191219146.png" alt="image-20250209191219146"><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209191241694.png" alt="image-20250209191241694"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209191311103.png" alt="image-20250209191311103"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209191324958.png" alt="image-20250209191324958"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209191334485.png" alt="image-20250209191334485"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209191345976.png" alt="image-20250209191345976"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209191359329.png" alt="image-20250209191359329"></p>
<p><code>numpy.argsort()</code> 函数返回的是数组值从小到大的索引值。</p>
<pre><code class="hljs plaintext">import numpy as np 
 
x = np.array([3,  1,  2])  
print (&#x27;我们的数组是：&#x27;)
print (x)
print (&#x27;\n&#x27;)
print (&#x27;对 x 调用 argsort() 函数：&#x27;)
y = np.argsort(x)  
print (y)
print (&#x27;\n&#x27;)
print (&#x27;以排序后的顺序重构原数组：&#x27;)
print (x[y])</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209192006531.png" alt="image-20250209192006531"></p>
<p>argsort()函数也可以用于多维数组，假如用于二维数组的话，如下图：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250209211521281.png" alt="image-20250209211521281"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209211701662.png" alt="image-20250209211701662"></p>
<p>为什么是要在列方向上进行排序呢？因为<strong>返回的索引是每一行里各个元素的列索引</strong>，axis&#x3D;1就代表要按照 y 提供的列索引顺序对每一行进行重排。</p>
<p><code>numpy.lexsort()</code> 用于对多个序列进行排序。返回的也是索引。</p>
<p>把它想象成对电子表格进行排序，每一列代表一个序列，<strong>排序时优先照顾靠后的列</strong>。</p>
<p>这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209205456459.png" alt="image-20250209205456459"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209205553739.png" alt="image-20250209205553739"></p>
<p><code>nm[i] + &quot;, &quot; + dv[i]</code> 会拼接成字符串。</p>
<p>因为使用了列表推导式，所以print里面的方括号不能去掉。</p>
<p><code>numpy.argmax()</code> 和 <code>numpy.argmin()</code>函数分别沿给定轴返回最大和最小元素的索引，没给 axis 赋值的话返回的索引是原数组张开后的索引，想要直接用的话需要将原数组张开后(flatten)调用，这两个函数的参数是<code>(ndarry,axis)</code>。</p>
<p><code>numpy.nonzero()</code> 函数返回输入数组中非零元素的索引。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209210406521.png" alt="image-20250209210406521"></p>
<p><code>numpy.where()</code> 函数返回输入数组中满足给定条件的元素的索引。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209210450077.png" alt="image-20250209210450077"></p>
<p><code>numpy.extract()</code> 函数根据某个条件从数组中抽取元素，返回满条件的元素。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209212210522.png" alt="image-20250209212210522"></p>
<h2 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241023173758732.png" alt="image-20241023173758732"></p>
<p><code>np.matrixlib.identity(6)</code>没有这个功能了。</p>
<p>推荐直接用 <code>np.identity(6)</code>或者<code>np.eye(6)</code>来创建单位矩阵，6 代表矩阵大小，6行6列。</p>
<p><strong>转置矩阵</strong></p>
<p>T</p>
<pre><code class="hljs plaintext">arr.T
np.eye(3).T</code></pre>

<p><strong>矩阵相乘</strong></p>
<p>numpy.dot(a,b,out &#x3D; None)</p>
<p>a：ndarray数组；b：ndarray数组</p>
<h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><p>numpy处理数值型的数据，pandas处理数值型之外的数据。</p>
<h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241116211840457.png" alt="image-20241116211840457"> </p>
<p>Series(数据源，索引，数据类型)</p>
<pre><code class="hljs plaintext">from pandas import Series
a = Series(data = [1,2,3,&#x27;four&#x27;]) #a = Series([1,2,3,&#x27;four&#x27;])
a</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241116213754628.png" alt="image-20241116213754628"></p>
<p>没有写index的，序号就默认为“0，1，2，3……”</p>
<pre><code class="hljs plaintext">pandas.Series(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)</code></pre>

<ul>
<li><code>data</code>：Series 的数据部分，可以是列表、数组、字典、标量值等。如果不提供此参数，则创建一个空的 Series。</li>
<li><code>index</code>：Series 的索引部分，用于对数据进行标记。可以是列表、数组、索引对象等。如果不提供此参数，则创建一个默认的整数索引。</li>
<li><code>dtype</code>：指定 Series 的数据类型。可以是 NumPy 的数据类型，例如 <code>np.int64</code>、<code>np.float64</code> 等。如果不提供此参数，则根据数据自动推断数据类型。</li>
<li><code>name</code>：Series 的名称，用于标识 Series 对象。如果提供了此参数，则创建的 Series 对象将具有指定的名称。</li>
<li><code>copy</code>：是否复制数据。默认为 False，表示不复制数据。如果设置为 True，则复制输入的数据。</li>
<li><code>fastpath</code>：是否启用快速路径。默认为 False。启用快速路径可能会在某些情况下提高性能。</li>
</ul>
<p>通过Series对象建立Series：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250209220317686.png" alt="image-20250209220317686"></p>
<p>可以指定这个Series对象的名称。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209215347691.png" alt="image-20250209215347691"></p>
<p>括号里面只能写data，不能用其他的，或者直接不写，只需将数据传入就行。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241116214459360.png" alt="image-20241116214459360"></p>
<p><strong>定义索引后依旧可以使用默认索引。</strong></p>
<p>使用字典充当数据源</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241116214610438.png" alt="image-20241116214610438"></p>
<p>索引和切片的使用与前面的差不多。</p>
<p>不过切片会一起显示前面的序号，索引不会。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241116214857710.png" alt="image-20241116214857710"></p>
<p>shape和size和前面的一样，分别显示形状和个数。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241116215025869.png" alt="image-20241116215025869"></p>
<p>dtype返回的是数据类型，返回Object说明Series也只能存储同一种类型的数据。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241116215259800.png" alt="image-20241116215259800"></p>
<p>上面的后四个表示加减乘除，可以使用上面的方法来进行，也可以直接使用运算符。</p>
<p>head()显示前几个数据，默认是5，可以指定要显示的个数，如：s.head(3)，表示显示前三个数据。</p>
<p>tail()就是显示后几个数据。</p>
<p>s.unique()，输出去重后的数据，变成一维数组输出。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241116215650054.png" alt="image-20241116215650054"></p>
<p>notnull()就是判断不为空值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241116215852825.png" alt="image-20241116215852825"></p>
<p>NaN和null还是有区别的，后面会讲。</p>
<p><strong>Series的运算法则：索引一致的元素进行算术运算否则补空。</strong></p>
<pre><code class="hljs plaintext">import pandas as pd

# 创建 Series
data = [1, 2, 3, 4, 5, 6]
index = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]
s = pd.Series(data, index=index)</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209220732464.png" alt="image-20250209220732464"></p>
<p>输出：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209220752753.png" alt="image-20250209220752753"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209221148480.png" alt="image-20250209221148480"></p>
<p><code>del</code>是直接在Series里删除的，会修改原数据；drop则不会修改原数据。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209221526427.png" alt="image-20250209221526427"></p>
<p>可以使用numpy的函数。</p>
<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><h3 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h3><p>DataFrame是由多个Series组成的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241116220639074.png" alt="image-20241116220639074"></p>
<p><strong>创建：</strong><code>pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False)</code></p>
<ul>
<li><p><code>data</code>：DataFrame 的数据部分，可以是字典、二维数组、Series、DataFrame 或其他可转换为 DataFrame 的对象。如果不提供此参数，则创建一个空的 DataFrame。</p>
</li>
<li><p><code>copy</code>：是否复制数据。默认为 False，表示不复制数据。如果设置为 True，则复制输入的数据。</p>
</li>
</ul>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241116220819883.png" alt="image-20241116220819883"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250210105649202.png" alt="image-20250210105649202"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241116220907164.png" alt="image-20241116220907164"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250210105900866.png" alt="image-20250210105900866"></p>
<p>字典中的key变为列索引，既然已经有列索引了，那后面就只需要指定行索引（index）就可以了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241116221042780.png" alt="image-20241116221042780"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250210110640124.png" alt="image-20250210110640124"></p>
<p>​	<img src="/../source/imgs/$%7Bfiilname%7D/image-20241116221950940.png" alt="image-20241116221950940"></p>
<p>定义行号和列号的方法：字典定义列号，index定义行号</p>
<pre><code class="hljs plaintext">import pandas as pd

df = pd.DataFrame(&#123;&#x27;A&#x27;: [11, 21, 31],
                   &#x27;B&#x27;: [12, 22, 32],
                   &#x27;C&#x27;: [13, 23, 33]&#125;,
                  index=[&#x27;ONE&#x27;, &#x27;TWO&#x27;, &#x27;THREE&#x27;])

print(df)
#         A   B   C
# ONE    11  12  13
# TWO    21  22  23
# THREE  31  32  33</code></pre>

<p>或</p>
<pre><code class="hljs plaintext">from pandas import DataFrame
df = DataFrame(data = [[1,2,3],[1,2,3]],index = [&#x27;a&#x27;,&#x27;b&#x27;],columns = [&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;])
df</code></pre>

<p>index和columns的位置没规定。</p>
<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><p><strong>values，columns，index，shape</strong></p>
<p>values返回的是DataFrame里的数据（去除了行号和列号的表格）</p>
<p>index返回所有行号，colums返回的是所有列号。</p>
<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><pre><code class="hljs plaintext">df[&#x27;d&#x27;] # 取单列，中括号中的只能填列号，不能填行号
df[[&#x27;d&#x27;,&#x27;e&#x27;]] # 取多列</code></pre>

<p>注意取多列有俩中括号。</p>
<pre><code class="hljs plaintext"># iloc：用于取隐式索引（就是没有自己取规定行号是什么，是默认的行号），若是显式索引（不是默认的）用这个会报错
# loc：用于取显式索引，也可以用于隐式
df.loc[&#x27;a&#x27;] # 取单行
df.loc[[&#x27;a&#x27;,&#x27;b&#x27;]] # 取多行
# loc[行,列]</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117164941477.png" alt="image-20241117164941477"></p>
<h3 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117165149851.png" alt="image-20241117165149851"></p>
<p>切片操作中中括号里填的是行号，<strong>与索引操作相反</strong>，iloc和loc的限制与索引的一样，里面填的内容和numpy切片的一样，前面表示行，后面表示列。</p>
<pre><code class="hljs plaintext">df[:-1] # 表示的是删去最后一行
df.iloc[:-1] # 表示的也是删去最后一行</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117170002025.png" alt="image-20241117170002025"></p>
<p><strong>DataFrame的运算和Series的运算一样。</strong></p>
<p>关于运算操作如果不懂的话可以看<code>df大杀器之索引和切片</code>的17分钟左右。</p>
<h3 id="附加操作，时间类型的转化"><a href="#附加操作，时间类型的转化" class="headerlink" title="附加操作，时间类型的转化"></a>附加操作，时间类型的转化</h3><p><code>pd.to_datatime(数据源)</code></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117171137698.png" alt="image-20241117171137698"></p>
<p>将某一列设置为行索引：<code>df.set_index(该列的名字)</code>，<strong>不会改变原数据</strong>。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117171612645.png" alt="image-20241117171612645"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h4><p>还有好多在下面依次出现。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250210111308171.png" alt="image-20250210111308171"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250210111336169.png" alt="image-20250210111336169"></p>
<h4 id="取数据，存数据，csv文件"><a href="#取数据，存数据，csv文件" class="headerlink" title="取数据，存数据，csv文件"></a>取数据，存数据，csv文件</h4><p>原DataFrame不会改变，若是<code>pd.to_datatime(数据源,inplace = True)</code>原始数据就会改变。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117192232217.png" alt="image-20241117192232217"></p>
<h4 id="excel文件"><a href="#excel文件" class="headerlink" title="excel文件"></a>excel文件</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122172513586.png" alt="image-20250122172513586"></p>
<h4 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117192358861.png" alt="image-20241117192358861"></p>
<p>在drop()中，axis&#x3D;1代表列（特例，一般都表示行），和numpy里的相反。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117222704823.png" alt="image-20241117222704823"></p>
<h4 id="布尔值取数据"><a href="#布尔值取数据" class="headerlink" title="布尔值取数据"></a>布尔值取数据</h4><p>上面那个语句是个判断语句，最后输出布尔值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117223032337.png" alt="image-20241117223032337"></p>
<p>只会输出为True的那行，False的那行不会输出。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117223215097.png" alt="image-20241117223215097"></p>
<h4 id="shift，计算"><a href="#shift，计算" class="headerlink" title="shift，计算"></a>shift，计算</h4><p><code>df[&#39;close&#39;].shift(1)	</code>代表的是df的close这一列的数据集体下移一位，就是原本第一行的close的数据下移到第二行的close位置。</p>
<p><code>df[&#39;close&#39;].shift(-1)</code>是集体上移一位。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117223713222.png" alt="image-20241117223713222"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117223839106.png" alt="image-20241117223839106"></p>
<p><code>df[&#39;2010-01&#39;:&#39;2020-02&#39;]</code>只有时间索引才可以这么切。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117224856759.png" alt="image-20241117224856759"></p>
<h4 id="resample"><a href="#resample" class="headerlink" title="resample"></a>resample</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117224921880.png" alt="image-20241117224921880"></p>
<p>这里的数据没有错，只是前面的索引错了。</p>
<p>“M”代表的是月份，所以resample(‘M’)代表的就是根据月份进行重新取样，first就是第一行。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117225428585.png" alt="image-20241117225428585"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117230315354.png" alt="image-20241117230315354"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117230845024.png" alt="image-20241117230845024"></p>
<p>resv那边乘的应该是1000。</p>
<p>上面的<code>new_df[&#39;close&#39;][-1]</code>在现在这个版本已经不行了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117231532452.png" alt="image-20241117231532452"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241117231542220.png" alt="image-20241117231542220"></p>
<h2 id="Pandas-CSV"><a href="#Pandas-CSV" class="headerlink" title="Pandas CSV"></a>Pandas CSV</h2><p>CSV（Comma-Separated Values，逗号分隔值，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212145557040.png" alt="image-20250212145557040"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212145650419.png" alt="image-20250212145650419"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212145701853.png" alt="image-20250212145701853"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212145944079.png" alt="image-20250212145944079"></p>
<h2 id="Pandas-Excel"><a href="#Pandas-Excel" class="headerlink" title="Pandas Excel"></a>Pandas Excel</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212150138045.png" alt="image-20250212150138045"></p>
<p>语法中的参数非常多，需要的话自己去菜鸟查询。</p>
<p>read_excel 默认读取第一个表单（sheet_name&#x3D;0），假设 data.xlsx 文件中只有一个表单，读取后的数据会存储在一个 DataFrame 中。</p>
<p>如果 data.xlsx 文件中有<strong>多个表单</strong>，可以通过指定 <strong>sheet_name</strong> 来读取特定表单的数据，例如 <code>pd.read_excel(&#39;data.xlsx&#39;, sheet_name=&#39;Sheet1&#39;)。</code></p>
<p><code>ExcelFile</code> - 加载 Excel 文件。</p>
<p><code>ExcelFile</code> 是一个用于读取 Excel 文件的类，它可以处理多个表单，并在不重新打开文件的情况下访问其中的数据。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212150720143.png" alt="image-20250212150720143"></p>
<p>想要使用上述方法，需要先加载Excel文件，然后才能使用sheet_names等。</p>
<p><code>ExcelWriter</code> 是 pandas 提供的一个类，用于将 DataFrame 或 Series 对象写入 Excel 文件。使用 ExcelWriter，你可以在一个 Excel 文件中<strong>写入多个工作表</strong>，并且可以更灵活地控制写入过程。</p>
<pre><code class="hljs plaintext">pandas.ExcelWriter(path, engine=None, date_format=None, datetime_format=None, mode=&#x27;w&#x27;, storage_options=None, if_sheet_exists=None, engine_kwargs=None)</code></pre>

<ul>
<li><code>path</code>：这是必需的参数，指定了要写入的 Excel 文件的路径、URL 或文件对象。可以是本地文件路径、远程存储路径（如 S3）、URL 链接或已打开的文件对象。</li>
<li><code>engine</code>：这是一个可选参数，用于指定写入 Excel 文件的引擎。如果为 <code>None</code>，则 pandas 会自动选择一个可用的引擎（默认优先选择 <code>openpyxl</code>，如果不可用则选择其他可用引擎）。常见的引擎包括 <code>&#39;openpyxl&#39;</code>（用于 <code>.xlsx</code> 文件）、<code>&#39;xlsxwriter&#39;</code>（提供高级格式化和图表功能）、<code>&#39;odf&#39;</code>（用于 OpenDocument 格式如 <code>.ods</code>）等。</li>
<li><code>date_format</code>：这是一个可选参数，指定写入 Excel 文件中日期的格式字符串，例如 <code>&quot;YYYY-MM-DD&quot;</code>。</li>
<li><code>datetime_format</code>：这是一个可选参数，指定写入 Excel 文件中日期时间对象的格式字符串，例如 <code>&quot;YYYY-MM-DD HH:MM:SS&quot;</code>。</li>
<li><code>mode</code>：这是一个可选参数，默认为 <code>&#39;w&#39;</code>，表示写入模式。如果设置为 <code>&#39;a&#39;</code>，则表示追加模式，向现有文件中添加数据（仅支持部分引擎，如 <code>openpyxl</code>）。</li>
<li><code>storage_options</code>：这是一个可选参数，用于指定与存储后端连接的额外选项，例如认证信息、访问权限等，适用于写入远程存储（如 S3、GCS）。</li>
<li><code>if_sheet_exists</code>：这是一个可选参数，默认为 <code>&#39;error&#39;</code>，指定如果工作表已经存在时的行为。选项包括 <code>&#39;error&#39;</code>（抛出错误）、<code>&#39;new&#39;</code>（创建一个新工作表）、<code>&#39;replace&#39;</code>（替换现有工作表的内容）、<code>&#39;overlay&#39;</code>（在现有工作表上覆盖写入）。</li>
<li><code>engine_kwargs</code>：这是一个可选参数，用于传递给引擎的其他关键字参数。这些参数会传递给相应引擎的函数，例如 <code>xlsxwriter.Workbook(file, **engine_kwargs)</code> 或 <code>openpyxl.Workbook(**engine_kwargs)</code> 等。</li>
</ul>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212151857536.png" alt="image-20250212151857536"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212151928041.png" alt="image-20250212151928041"></p>
<h2 id="Pandas常用函数"><a href="#Pandas常用函数" class="headerlink" title="Pandas常用函数"></a>Pandas常用函数</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212154147108.png" alt="image-20250212154147108"></p>
<pre><code class="hljs plaintext"># 从 SQL 数据库中读取数据
import sqlite3
conn = sqlite3.connect(&#x27;database.db&#x27;)
df = pd.read_sql(&#x27;SELECT * FROM table_name&#x27;, conn)</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212154224406.png" alt="image-20250212154224406"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212154250653.png" alt="image-20250212154250653"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212154421471.png" alt="image-20250212154421471"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212154450902.png" alt="image-20250212154450902"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212154856502.png" alt="image-20250212154856502"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212154936428.png" alt="image-20250212154936428"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250212154956492.png" alt="image-20250212154956492"></p>
<h1 id="缺失值的清洗"><a href="#缺失值的清洗" class="headerlink" title="缺失值的清洗"></a>缺失值的清洗</h1><h2 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h2><p>原始数据中会存在缺失值（空值）</p>
<p>有两种丢失数据：None，np.nan(NaN)</p>
<p>两种丢失数据区别：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241118220138346.png" alt="image-20241118220138346"></p>
<p>浮点型的空加任意值都等于空，None加值会报错。</p>
<p>在pandas中如果遇到None形式的空值，pandas会将其强转为NaN类型的空值。</p>
<h2 id="pandas处理空值的操作"><a href="#pandas处理空值的操作" class="headerlink" title="pandas处理空值的操作"></a>pandas处理空值的操作</h2><pre><code class="hljs plaintext">判断空值：isnull,notnull，any,all
删除：dropna
覆盖：fillna</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241118220830353.png" alt="image-20241118220830353"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><strong>方式1：对空值进行过滤（删除空值所在的行数据）</strong></p>
<p>技术：isnull,notnull,any,all</p>
<p>一、</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241118221604872.png" alt="image-20241118221604872"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241118221746314.png" alt="image-20241118221746314"></p>
<p>要用true和false来显示筛选数据的时候记住使用的是loc而不是iloc。</p>
<pre><code class="hljs plaintext">all是用来监测false的，如果某一行中都是True则返回True，有一个False就返回False。
需要和notnull搭配</code></pre>

<p>二、</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241118222048105.png" alt="image-20241118222048105"></p>
<p>这个没有进行删除，只是显示出现了筛选，只显示True的。</p>
<p><strong>方式2：dropna：可以直接将缺失的行或列进行删除</strong></p>
<p><strong>下面这个最简单，但前面的也要会</strong></p>
<pre><code class="hljs plaintext">df.dropna(axis = 0) # 删除缺失值所在的行
df.dropna(axis = 1) # 删除缺失值所在的列</code></pre>

<h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241119163203471.png" alt="image-20241119163203471"></p>
<p>先向前填充再向后填充。</p>
<pre><code class="hljs plaintext">df.fillna(value = n) # 空值都被n覆盖</code></pre>

<p>一般情况都选择删除而不是覆盖，删除的成本高才选择覆盖。</p>
<pre><code class="hljs plaintext">df.fillna(method = &#x27;ffill&#x27;,axis) # 向前填充
df.fillna(method = &#x27;bfill&#x27;,axis) # 向后填充
# axis = 1,水平方向的填充
# axis = 0,竖直方向的填充</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250122205032999.png" alt="image-20250122205032999"></p>
<h1 id="重复值和异常值的清洗"><a href="#重复值和异常值的清洗" class="headerlink" title="重复值和异常值的清洗"></a>重复值和异常值的清洗</h1><h2 id="重复值"><a href="#重复值" class="headerlink" title="重复值"></a>重复值</h2><p>使用drop_duplicates</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110155355944.png" alt="image-20250110155355944"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110155949718.png" alt="image-20250110155949718"></p>
<p><code>keep=first</code>代表的是保留重复数据第一次出现的那行。<code>keep=last</code>保留最后一次出现的。<code>keep=false</code>代表把所有重复行数据删掉。</p>
<p>不写的话默认等于first。</p>
<h2 id="异常值"><a href="#异常值" class="headerlink" title="异常值"></a>异常值</h2><p>没有专用的函数就是用上面学到的方法，配合给的条件进行处理。</p>
<p>“**~**”：这个符号代表取反。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110162043014.png" alt="image-20250110162043014"></p>
<h1 id="DataFrame的级联操作和合并操作"><a href="#DataFrame的级联操作和合并操作" class="headerlink" title="DataFrame的级联操作和合并操作"></a>DataFrame的级联操作和合并操作</h1><p>这个级联操作行列不同也可以进行，就是补空值。</p>
<h2 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h2><p><strong>pd.concat</strong></p>
<p><strong>pd.append</strong>（不能用）</p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>进行横向或纵向的拼接</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110170836736.png" alt="image-20250110170836736"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110170907796.png" alt="image-20250110170907796"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250210111006315.png" alt="image-20250210111006315"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110170016708.png" alt="image-20250110170016708"></p>
<p>外连接：join&#x3D;’outer’，当没写的时候默认为外连接，就是普通连接，补空值。</p>
<p>内连接：join&#x3D;’inner’，只连接索引相同的。</p>
<p>想要保留输完整性则使用外连接。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110171148373.png" alt="image-20250110171148373"></p>
<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>版本2.0以上被废除</p>
<h2 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110211737460.png" alt="image-20250110211737460"></p>
<p>级联对应的是表格，对表格的拼接；合并对应的是数据，对数据的合并与整合。</p>
<p>合并一次只能合并两张表。</p>
<p>如果两张表大部分的索引都一样那就做级联；如果只有局部的索引一样或者都不一样就用合并。</p>
<p>下面说的几对几合并是一个表格里的数据对另一个表格里的数据是否一一对应。</p>
<h3 id="一对一合并"><a href="#一对一合并" class="headerlink" title="一对一合并"></a>一对一合并</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110214416753.png" alt="image-20250110214416753"></p>
<pre><code class="hljs plaintext">pd.merge(df3,df4,on = &#x27;employee&#x27;)</code></pre>

<p><strong>on</strong> 后面写的是合并条件，基于这个合并条件进行合并。如果不写的话，它就会将两张表中共有的列作为合并条件进行合并。</p>
<h3 id="一对多合并"><a href="#一对多合并" class="headerlink" title="一对多合并"></a>一对多合并</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110215438548.png" alt="image-20250110215438548"></p>
<h3 id="多对多合并"><a href="#多对多合并" class="headerlink" title="多对多合并"></a>多对多合并</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110215203510.png" alt="image-20250110215203510"></p>
<h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>merge方法里有个参数值叫作how，它默认为inner，也就是去除了空值所在的行，当赋值为outer时，空值所在的行就是出现，这里的空值出现是因为两个表中有不能对应的地方，这些地方就会为空值，而不是可以起到删除空值的作用。</p>
<p><strong>这个时候代表的时内连接和外连接。</strong></p>
<p>要保证合并数据的完整性的话就要使用outer。</p>
<p>默认为inner：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250110215832260.png" alt="image-20250110215832260"></p>
<p>赋值为outer：<img src="/../source/imgs/$%7Bfiilname%7D/image-20250110215907103.png" alt="image-20250110215907103"></p>
<p><strong>还有左连接和右连接。</strong></p>
<p>how &#x3D; ‘left’ 时代表的是左连接，就是保留左表的数据；how &#x3D; ‘right’ 时代表的是右连接，保留右表的数据。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110220248399.png" alt="image-20250110220248399"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110220301935.png" alt="image-20250110220301935"></p>
<h3 id="key的规范化"><a href="#key的规范化" class="headerlink" title="key的规范化"></a>key的规范化</h3><p><strong>当有多个列名称相同时</strong>，需要用on&#x3D; 来指定哪一个列作为key，配合suffixes指定冲突列名。</p>
<p><strong>on</strong></p>
<p>当有列冲突而不去管时，此时merge会将相同的列一起作为key来合并。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110221218568.png" alt="image-20250110221218568"></p>
<p>on 指定一列</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110221304576.png" alt="image-20250110221304576"></p>
<p><strong>当两张表没有可进行连接的列时</strong>，可使用left_on和right_on手动指定merge中的左右两边哪一列作为连接的列。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110222051157.png" alt="image-20250110222051157"></p>
<p>没有相同列的表。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250110222210619-1736518931502-1.png" alt="image-20250110222210619"></p>
<h1 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h1><h2 id="info-unique"><a href="#info-unique" class="headerlink" title="info,unique"></a>info,unique</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250111100931119.png" alt="image-20250111100931119"></p>
<p><code>info() </code>返回的是这组数据的原始信息。<img src="/../source/imgs/$%7Bfiilname%7D/image-20250210110742928.png" alt="image-20250210110742928"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250111101905682.png" alt="image-20250111101905682"></p>
<p>将布尔值作为行索引后取出对应的行数据，<code>abb_pop.loc[abb_pop[&#39;state&#39;].isnull()]</code> 这个在里面的输出是一个DataFrame，所以可以把这个整体看成是一个原始数据表，所以要取出这个表中的列数据是就可以直接 <code>[]</code> ，变为<code>abb_pop.loc[abb_pop[&#39;state&#39;].isnull()][&#39;state/region&#39;]</code>。</p>
<p><code>s.unique()</code>，输出去重后的数据，变成一维数组输出。</p>
<h2 id="query"><a href="#query" class="headerlink" title="query"></a>query</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250111103822853.png" alt="image-20250111103822853"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250111104120328.png" alt="image-20250111104120328"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250111104718652.png" alt="image-20250111104718652"></p>
<p><code>query()</code> 函数专门针对DataFrame做条件查询。不用这个函数的话也可以使用条件判断语句。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250111104952127.png" alt="image-20250111104952127"></p>
<p>原本数据里面没有’midu’这一列，但赋值一下就相当于是添加了。</p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250111105222702.png" alt="image-20250111105222702"></p>
<p>sort_values是对值进行排序，sort_index是对索引排序。</p>
<p>ascending默认为True，是升序；False是降序。</p>
<h1 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121170744385.png" alt="image-20250121170744385"></p>
<p>to_replace代表要替换的元素，value代表替换成的元素，第三个是inplace，用法和前面的一样。<code>replace(to_replace,value,inplace)</code></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121171035642.png" alt="image-20250121171035642"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121171256227.png" alt="image-20250121171256227"></p>
<h1 id="pandas高级操作"><a href="#pandas高级操作" class="headerlink" title="pandas高级操作"></a>pandas高级操作</h1><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>概念：创建一个映射关系列表，把values元素和一个特定的字符串或者标签绑定（给一个元素提供不同的表现形式）。</p>
<p>那接下来就可以使用这个标签来表示这元素了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121200256614.png" alt="image-20250121200256614"></p>
<p><strong>map是Series的方法，只能通过Series调用。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250209220540915.png" alt="image-20250209220540915"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121202816778.png" alt="image-20250121202816778"></p>
<p>def 关键字代表自定义一个函数。</p>
<h2 id="排序实现的随机抽样"><a href="#排序实现的随机抽样" class="headerlink" title="排序实现的随机抽样"></a>排序实现的随机抽样</h2><p>take() 和 np.random.permutation()</p>
<p><strong>take和drop一样，1表示列，0表示行</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121204449180.png" alt="image-20250121204449180"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121204907251.png" alt="image-20250121204907251"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121205044414.png" alt="image-20250121205044414"></p>
<p>上面这是打乱列。</p>
<p>在打乱列的基础上再打乱行，然后再取样，那就是随机取样了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121205317253.png" alt="image-20250121205317253"></p>
<h2 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h2><p>数据分类处理核心：</p>
<p>groupby()函数，groups属性查看分组情况。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121210735924.png" alt="image-20250121210735924"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121210924645.png" alt="image-20250121210924645"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121210600357.png" alt="image-20250121210600357"></p>
<p>mean()函数只能对数值型数据进行处理，所以没对颜色求均值，这个mean()因为没指定对象，所以同时对price和weight进行求平均值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121210650442.png" alt="image-20250121210650442"></p>
<p>只对价格求平均值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121211010285.png" alt="image-20250121211010285"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121211306799.png" alt="g"></p>
<p>想要将对应的平均重量赋给对应的颜色后面，直接添加添加不了，那就是给color分别绑定对应的重量，也就是<strong>映射</strong>。</p>
<p>map()里面放的是映射关系表，映射关系表就是字典。</p>
<p><code>to_dict()</code>：Series的方法，将Series转化为字典，而<code>df.groupby(by = &#39;color&#39;)[&#39;weight&#39;].mean()</code>返回的正好是Series。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121212510286.png" alt="image-20250121212510286"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20250121212827936.png" alt="image-20250121212827936"></p>
<p>没看懂那个函数是怎么用的。</p>
<p>transform()返回的是经过映射的结果，但apply()返回的不是经过映射的结果，经过映射的可以直接汇总到原本的数据中。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-实战题目" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/05/%E5%AE%9E%E6%88%98%E9%A2%98%E7%9B%AE/" class="article-date">
  	<time datetime="2024-10-05T09:54:39.000Z" itemprop="datePublished">2024-10-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/05/%E5%AE%9E%E6%88%98%E9%A2%98%E7%9B%AE/">
        实战题目
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="寻找两数之和（运用哈希表）"><a href="#寻找两数之和（运用哈希表）" class="headerlink" title="寻找两数之和（运用哈希表）"></a>寻找两数之和（运用哈希表）</h1><pre><code class="hljs plaintext">import java.util.HashMap;
import java.util.Map;

class Solution &#123;
    public int[] twoSum(int[] nums, int target) &#123;
        // 创建一个哈希表，用于存储数组中的值及其对应的索引
        Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;();

        // 遍历数组 nums
        for (int i = 0; i &lt; nums.length; ++i) &#123;
            // 检查哈希表中是否存在一个数，使其与当前数的和等于目标值
            if (hashtable.containsKey(target - nums[i])) &#123;
                // 如果存在，返回这个数的索引和当前数的索引
                return new int[]&#123;hashtable.get(target - nums[i]), i&#125;;
            &#125;
            // 如果不存在，将当前数及其索引存入哈希表
            hashtable.put(nums[i], i);
        &#125;

        // 如果没有找到满足条件的两个数，返回一个空数组
        return new int[0];
    &#125;
&#125;</code></pre>

<p>1、 <code>Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;();</code></p>
<p>声明了一个叫作<code>hashtable</code>的变量，它的类型是<code>Map&lt;Integer, Integer&gt;</code>。<code>Map</code>是一个接口，它定义了键值对的集合，其中每个键最多只能映射到一个值。这意味着<code>hashtable</code>将引用一个<code>Map</code>对象，并且这个<code>Map</code>键和值都是<code>Integer</code>类型（存储整数类型的键和值），同时创建了一个新的<code>HashMap</code>对象，并将其赋值给<code>hashtable</code>变量。<code>new HashMap&lt;Integer, Integer&gt;()</code>调用了<code>HashMap</code>类的无参数构造函数，创建了一个空的<code>HashMap</code>对象，其中<code>Integer</code>指定了键和值的类型。</p>
<p>2、<code>hashtable.containsKey(target - nums[i])</code>，检查哈希表中是否存在一个数（查找的是特征值）。</p>
<p>3、<code>hashtable.get(target - nums[i])</code>，返回这个数的索引（返回存储的内容）。</p>
<p>4、<code>hashtable.put(nums[i], i);</code>，将当前数及其索引存入哈希表，<code>nums[i]</code>应该是特征值，数据结构书里有讲，i 是存储的值。</p>
<h1 id="基本数据类型和String之间的转化"><a href="#基本数据类型和String之间的转化" class="headerlink" title="基本数据类型和String之间的转化"></a>基本数据类型和String之间的转化</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727111651630.png" alt="image-20240727111651630"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727111716345.png" alt="image-20240727111716345"></p>
<pre><code class="hljs plaintext">String string = &quot;faogaig&quot;;
string.length();</code></pre>

<p><code>string.length()</code>就是这个字符串的长度。</p>
<p>要提取这个字符串里的字符的话就用<code>string.charAt(int num)</code>。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727111753320.png" alt="image-20240727111753320"></p>
<h1 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240819211720021-1728122090345-711.png" alt="image-20240819211720021"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240819211739407-1728122090345-712.png" alt="image-20240819211739407"></p>
<p>方法三：递归</p>
<p><strong>将String类型的数（比如说二进制，四进制等）转化为Long类型的数怎么转化</strong></p>
<pre><code class="hljs plaintext">long decimalValue = Long.parseLong(aStr, base);//base代表的是此时atr的进制，aStr是要转化的字符串，如10111001011</code></pre>

<p><img src="../source/imgs/${fiilname}/image-20250610104456586.png" alt="image-20250610104456586" style="zoom:50%;" /><img src="../source/imgs/${fiilname}/image-20250610104602438.png" alt="image-20250610104602438" style="zoom:50%;" /></p>
<pre><code class="hljs plaintext">import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main1 &#123;
    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt(); // n &lt;= 1000

        int[] bases = &#123;2, 4, 8, 16&#125;;

        for (int i = 0; i &lt; n; i++) &#123;
            // A_i 的长度可能达到 30
            String aStr = scanner.next();
            // B_i &lt;= 10^9, 使用 long 是一种安全的做法
            long bVal = scanner.nextLong();

            List&lt;Long&gt; solutions = new ArrayList&lt;&gt;();

            for (int base : bases) &#123;
                try &#123;
                    // 关键点：
                    // 1. Long.parseLong 可以处理长达63位的二进制数，对于本题足够。
                    // 2. 如果 aStr 包含对当前 base 无效的字符 (如 &quot;A&quot; in base 8), 会抛出 NumberFormatException。
                    // 3. 如果转换后的数值超过 Long.MAX_VALUE (约 9*10^18), 也会抛出 NumberFormatException。
                    //    由于任何解都必须 &lt;= 10^9, 这种溢出的情况自然被排除，正是我们想要的。
                    long decimalValue = Long.parseLong(aStr, base);

                    // 检查转换后的值是否满足 &lt;= B_i 的约束
                    if (decimalValue &lt;= bVal) &#123;
                        solutions.add(decimalValue);
                    &#125;
                &#125; catch (NumberFormatException e) &#123;
                    // 捕捉所有转换异常，静默处理，继续尝试下一个进制。
                &#125;
            &#125;

            // 根据解的数量进行判断
            if (solutions.size() == 1) &#123;
                System.out.println(solutions.get(0));
            &#125; else &#123;
                // 0个解或多于1个解，都输出-1
                System.out.println(-1);
            &#125;
        &#125;

        scanner.close();
    &#125;
&#125;</code></pre>



<h1 id="随机数（seed）"><a href="#随机数（seed）" class="headerlink" title="随机数（seed）"></a>随机数（seed）</h1><pre><code class="hljs plaintext">题目的主要信息：
每次运行程序时，输入一个随机种子，产生一个[1,6]之间的随机整数
具体做法：
输入的随机种子不是随机数，但是会用该随机种子进行算法。因此在Random类中seed是一个参数，用于生成伪随机数，因为范围是1-6，但是伪随机数生成是0~n-1，因此末尾需要再加1.</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240819212557410.png" alt="image-20240819212557410"></p>
<pre><code class="hljs plaintext">import java.util.Random;
import java.util.Scanner;
 
public class Main &#123;
 
    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNextInt()) &#123;
            int seed = scanner.nextInt(); //输入随机数种子
            Random random = new Random(seed); //用随机种子进行随机算法
            System.out.println(random.nextInt(6) + 1); //随机生成1-6地数字
        &#125;
    &#125;
 
&#125;</code></pre>

<h1 id="最短路径，dijkstra-优先队列"><a href="#最短路径，dijkstra-优先队列" class="headerlink" title="最短路径，dijkstra+优先队列"></a>最短路径，dijkstra+优先队列</h1><pre><code class="hljs plaintext">import java.util.*;

public class c &#123;

    static class Edge &#123;
        int to; // 目标城市
        int length; // 路径长度

        Edge(int to, int length) &#123;
            this.to = to;
            this.length = length;
        &#125;
    &#125;

    static class State &#123;
        int city; // 当前城市
        int totalRescue; // 当前能召集的救援队数量
        int pathLength; // 当前路径长度

        State(int city, int totalRescue, int pathLength) &#123;
            this.city = city;
            this.totalRescue = totalRescue;
            this.pathLength = pathLength;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);

        // 读取输入
        int N = scanner.nextInt(); // 城市个数
        int M = scanner.nextInt(); // 快速道路的条数
        int S = scanner.nextInt(); // 出发地
        int D = scanner.nextInt(); // 目的地

        int[] rescueTeams = new int[N]; // 各城市的救援队数
        for (int i = 0; i &lt; N; i++) &#123;
            rescueTeams[i] = scanner.nextInt();
        &#125;

        // 构建图
        List&lt;List&lt;Edge&gt;&gt; graph = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; N; i++) &#123;
            graph.add(new ArrayList&lt;&gt;());
        &#125;

        for (int i = 0; i &lt; M; i++) &#123;
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            int length = scanner.nextInt();
            graph.get(u).add(new Edge(v, length));
            graph.get(v).add(new Edge(u, length)); // 因为是双向道路
        &#125;

        // 调用 Dijkstra 算法
        dijkstra(S, D, rescueTeams, graph);

        scanner.close();
    &#125;

    private static void dijkstra(int start, int end, int[] rescueTeams, List&lt;List&lt;Edge&gt;&gt; graph) &#123;
        int N = graph.size();
        int[] minDist = new int[N]; // 记录到各城市的最短路径长度
        Arrays.fill(minDist, Integer.MAX_VALUE);
        minDist[start] = 0;

        // 记录从起点到各点的救援队数量
        int[] maxRescue = new int[N];
        maxRescue[start] = rescueTeams[start];

        // 记录路径
        int[] previous = new int[N];
        Arrays.fill(previous, -1);

        // 使用优先队列
        PriorityQueue&lt;State&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a.pathLength));
        pq.add(new State(start, rescueTeams[start], 0));

        while (!pq.isEmpty()) &#123;
            State current = pq.poll();

            // 如果当前城市是目的地，结束
            if (current.city == end) &#123;
                break;
            &#125;

            for (Edge edge : graph.get(current.city)) &#123;
                int nextCity = edge.to;
                int newDist = current.pathLength + edge.length;
                int newRescue = current.totalRescue + rescueTeams[nextCity];

                // 更新最短路径和救援队数量
                if (newDist &lt; minDist[nextCity] || (newDist == minDist[nextCity] &amp;&amp; newRescue &gt; maxRescue[nextCity])) &#123;
                    minDist[nextCity] = newDist;
                    maxRescue[nextCity] = newRescue;
                    previous[nextCity] = current.city;
                    pq.add(new State(nextCity, newRescue, newDist));
                &#125;
            &#125;
        &#125;

        // 输出结果
        System.out.println(minDist[end] + &quot; &quot; + maxRescue[end]);

        // 输出路径
        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();
        for (int at = end; at != -1; at = previous[at]) &#123;
            path.add(at);
        &#125;
        Collections.reverse(path); // 反转路径

        // 打印路径
        for (int city : path) &#123;
            System.out.print(city + &quot; &quot;);
        &#125;
    &#125;
&#125;</code></pre>

<hr>
<p><code>PriorityQueue&lt;State&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a.pathLength));</code>这句话什么意思</p>
<p>这句话的意思是创建一个优先队列 <code>pq</code>，该队列将按照元素的路径长度进行排序。以下是详细解释：</p>
<p><strong>具体含义</strong></p>
<ol>
<li>**<code>PriorityQueue&lt;State&gt;</code>**：这部分表示我们在创建一个优先队列，队列中的元素类型是 <code>State</code>。<code>State</code> 是一个自定义的类，通常包含一些信息，比如当前城市、可召集的救援队数量和当前路径长度。</li>
<li>**<code>new PriorityQueue&lt;&gt;(...)</code>**：这是 Java 中用于创建一个优先队列的构造函数。</li>
<li>**<code>Comparator.comparingInt(a -&gt; a.pathLength)</code>**：<ul>
<li><strong><code>Comparator.comparingInt(...)</code></strong> 是一个静态方法，用于生成一个比较器，这个比较器用于比较两个整数值。</li>
<li><strong><code>a -&gt; a.pathLength</code></strong> 是一个 lambda 表达式，它表示从 <code>State</code> 对象 <code>a</code> 中提取 <code>pathLength</code> 属性进行比较。</li>
</ul>
</li>
</ol>
<p><strong>整体作用</strong></p>
<p>结合起来，这行代码的作用是创建一个优先队列 <code>pq</code>，并定义了该队列的排序规则为：当我们从队列中取出元素时，优先取出路径长度最短的 <code>State</code> 对象。</p>
<p><strong>例子</strong></p>
<p>假设有多个 <code>State</code> 对象，它们的 <code>pathLength</code> 分别是 5、3 和 8。当我们将这些对象加入优先队列后，优先队列将会保证在取出元素时，首先取出的将是 <code>pathLength</code> 最小的对象（即 <code>pathLength</code> 为 3 的对象）。</p>
<hr>
<p>pq.poll()有什么用</p>
<p><code>pq.poll()</code> 的作用是从优先队列 <code>pq</code> 中获取并移除优先级最高的元素（在这里是路径长度最短的 <code>State</code> 对象）。具体来说：</p>
<p><strong>详细说明</strong></p>
<ol>
<li><strong>获取元素</strong>：<code>poll()</code> 方法返回队列中优先级最高的元素。如果队列为空，则返回 <code>null</code>。</li>
<li><strong>移除元素</strong>：与 <code>peek()</code> 方法不同，<code>poll()</code> 不仅返回这个元素，还会将其从队列中移除。这意味着之后再调用 <code>poll()</code> 时，将不会再得到这个元素。</li>
<li><strong>优先队列的特点</strong>：在优先队列中，元素的顺序是根据它们的优先级来决定的。在 Dijkstra 算法中，优先级通常是路径长度，路径长度越短的元素优先级越高。</li>
</ol>
<p><strong>应用场景</strong></p>
<p>在 Dijkstra 算法中，使用 <code>pq.poll()</code> 来获取当前已知的最短路径的节点（即离起点最近的节点），并继续探索从这个节点出发的其他可能的路径。通过这种方式，算法能逐步找到从起点到各个节点的最短路径。</p>
<p><strong>示例</strong></p>
<p>假设优先队列中有以下 <code>State</code> 对象：</p>
<ul>
<li>State(城市 1, 路径长度 3)</li>
<li>State(城市 2, 路径长度 1)</li>
<li>State(城市 3, 路径长度 5)</li>
</ul>
<p>调用 <code>pq.poll()</code> 将返回路径长度为 1 的对象（城市 2），同时将其从队列中移除。下次调用 <code>poll()</code> 时，将返回路径长度为 3 的对象（城市 1）。</p>
<p>容易理解的：</p>
<pre><code class="hljs plaintext">import java.util.Scanner;

public class Main&#123;
    private static int[] dis,w,pre,num,weight;
    private static boolean[] vis;
    private static int n,m,s,d;
    private static int[][] G;
    public static void main(String[] args) &#123;
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();m = sc.nextInt();
        s = sc.nextInt();d = sc.nextInt();
        dis = new int[n];vis = new boolean[n];w=new int[n];pre=new int[n];num=new int[n];
        weight = new int[n];
        G = new int[n][n];//邻接矩阵
        for(int i = 0; i&lt;n; i++)&#123;
            weight[i] = sc.nextInt();
            dis[i] = 1000;//设起点到达各点的最短距离
        &#125;
        for(int i = 0; i&lt;n; i++)&#123;
            for(int j = 0; j&lt;n; j++)&#123;
                if(i != j)
                    G[i][j] = 1000;
            &#125;
        &#125;
        for(int i = 0; i&lt;m; i++)&#123;
            int a = sc.nextInt();int b = sc.nextInt();int c = sc.nextInt();
            G[a][b] = c;
            G[b][a] = c;
        &#125;
        Dijkstra(s);
        System.out.println( num[d]+&quot; &quot;+w[d]);
        dfs(s,d);
        System.out.println();
 
    &#125;
    private static void dfs(int s,int v)&#123;
        if(s == v)&#123;
            System.out.print(s);
            return;
        &#125;
        dfs(s,pre[v]);
        System.out.print(&quot; &quot;+v);
    &#125;
 
    private static void Dijkstra(int s) &#123;
        dis[s] = 0;//将起点到达自身的距离修改为0；
        num[s] = 1;//最短路径条数初始化为1；
        w[s] = weight[s];//救援队数目修改为起点城市的救援队数目
        for (int i = 0; i&lt;n; i++)&#123;
            int u = -1,min = 1000;
            for(int j = 0; j&lt;n; j++)&#123;
                if(!vis[j] &amp;&amp; dis[j] &lt; min)&#123;
                    min = dis[j];
                    u = j;
                &#125;
            &#125;
            if(u == -1)return;
            vis[u] = true;
            for(int v = 0; v&lt;n; v++)&#123;
                if(!vis[v] &amp;&amp; G[u][v] != 1000 &amp;&amp; dis[u] + G[u][v] &lt; dis[v])&#123;
                    dis[v] = dis[u] + G[u][v];
                    w[v] = w[u]+weight[v];
                    num[v] = num[u];
                    pre[v] = u;
                &#125;else if(!vis[v] &amp;&amp; G[u][v] != 1000 &amp;&amp;dis[u] + G[u][v] == dis[v])&#123;
                    num[v] += num[u];//最短距离相同时路径条数累加
                    if(w[v] &lt; w[u]+weight[v])&#123;
                        w[v] = w[u]+weight[v];
                        pre[v] = u;
                    &#125;
                &#125;
            &#125;
        &#125;
 
    &#125;
&#125;</code></pre>

<p>上面两种方法结合起来的答案，通过的测试最多：</p>
<pre><code class="hljs plaintext">import java.util.*;

public class Main &#123;

    static class Edge &#123;
        int now; // 目前所在的城市
        int length; // 路径长度

        Edge(int now, int length) &#123;
            this.now = now;
            this.length = length;
        &#125;
    &#125;

    private static int[] previous ;
    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);

        // 读取输入
        int N = scanner.nextInt(); // 城市个数
        int M = scanner.nextInt(); // 快速道路的条数
        int S = scanner.nextInt(); // 出发地
        int D = scanner.nextInt(); // 目的地

        int[] rescueTeams = new int[N]; // 各城市的救援队数
        // 记录路径
        previous = new int[N];
        Arrays.fill(previous, -1);

        for (int i = 0; i &lt; N; i++) &#123;
            rescueTeams[i] = scanner.nextInt();
        &#125;

        // 构建图
        int[][] graph = new int[N][N];
        for(int i = 0;i &lt; N;i ++)
            Arrays.fill(graph[i],Integer.MAX_VALUE);

        for (int i = 0; i &lt; M; i++) &#123;
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            int length = scanner.nextInt();
            graph[u][v] = length;
            graph[v][u] = length; // 因为是双向道路
        &#125;

        // 调用 Dijkstra 算法
        dijkstra(S, D, rescueTeams, graph);
        dfs(S,D);
    &#125;
    private static void dfs(int s,int v)&#123;
        if(s == v)&#123;
            System.out.print(s);
            return;
        &#125;
        dfs(s,previous[v]);
        System.out.print(&quot; &quot;+v);
    &#125;
    private static void dijkstra(int start, int end, int[] rescueTeams, int[][] graph) &#123;
        int N = graph.length;
        int[] min = new int[N]; // 记录到各城市的最短路径长度
        int[] nums = new int[N];//记录最短路径数量，初始值设为1
        Arrays.fill(nums,1);
        boolean[] visit = new boolean[N];

        Arrays.fill(min, Integer.MAX_VALUE);
        min[start] = 0;

        // 记录从起点到各点的救援队数量
        int[] maxRescue = new int[N];
        maxRescue[start] = rescueTeams[start];

        // 使用优先队列
        PriorityQueue&lt;Edge&gt; minDist = new PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a.length));
        minDist.add(new Edge(start,0));

        while (!minDist.isEmpty()) &#123;
            Edge current = minDist.poll();

            // 如果当前城市是目的地，结束
            if (current.now == end) &#123;
                break;
            &#125;
            int now = current.now;
            visit[now] = true;
            for (int v = 0;v &lt; N;v ++) &#123;

                // 更新最短路径和救援队数量
                if(!visit[v] &amp;&amp; graph[now][v] != Integer.MAX_VALUE &amp;&amp; graph[now][v] + min[now] &lt; min[v])&#123;
                    min[v] = graph[now][v] + min[now];
                    maxRescue[v] = maxRescue[now] + rescueTeams[v];
                    previous[v] = now;
                    minDist.add(new Edge(v,min[v]));
                    nums[v] = nums[now];
                &#125;else if(!visit[v] &amp;&amp; graph[now][v] != Integer.MAX_VALUE &amp;&amp; graph[now][v] + min[now] == min[v])&#123;
                    nums[v] += nums[now];
                    if(maxRescue[now] + rescueTeams[v] &gt; maxRescue[v])&#123;
                        maxRescue[v] = maxRescue[now] + rescueTeams[v];
                        previous[v] = now;
                    &#125;
                &#125;
            &#125;
        &#125;

        // 输出结果
        System.out.println(nums[end] + &quot; &quot; + maxRescue[end]);

    &#125;
&#125;</code></pre>

<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><h2 id="1、范围"><a href="#1、范围" class="headerlink" title="1、范围"></a>1、范围</h2><p>小明正在设计一台打点计数器，该计数器可以接受多个递增的数字范围，并对这些范围内的每个唯一数字打点。如果多个范围之间有重叠，计数器将合并这些范围并只对每个唯一数字打一次点。小明需要你帮助他计算，在给定的多组数字范围内，计数器会打多少个点。 例如，给定三个数字范围 [1, 4], [7, 10], 和 [3, 5]，计数器首先将这些范围合并，变成 [1, 5] 和 [7, 10]，然后计算这两个范围内共有多少个唯一数字，即从 1 到 5 有 5 个数字，从 7 到 10 有 4 个数字，共打 9 个点。</p>
<pre><code class="hljs plaintext">import java.util.*;

public class Main &#123;
    public static int solution(int[][] inputArray) &#123;
        // Step 1: 按范围起点排序
        Arrays.sort(inputArray, Comparator.comparingInt(a -&gt; a[0]));

        // Step 2: 合并范围
        List&lt;int[]&gt; mergedRanges = new ArrayList&lt;&gt;();
        int[] currentRange = inputArray[0];
    
        for (int i = 1; i &lt; inputArray.length; i++) &#123;
            int[] nextRange = inputArray[i];
            // 如果当前范围与下一个范围有重叠或相邻
            if (currentRange[1] &gt;= nextRange[0] - 1) &#123;
                // 更新当前范围的终点为两者较大的终点
                currentRange[1] = Math.max(currentRange[1], nextRange[1]);
            &#125; else &#123;
                // 否则，当前范围结束，加入结果
                mergedRanges.add(currentRange);
                currentRange = nextRange;
            &#125;
        &#125;
        // 添加最后一个范围
        mergedRanges.add(currentRange);
    
        // Step 3: 计算合并后范围内的总数字数量
        int totalPoints = 0;
        for (int[] range : mergedRanges) &#123;
            totalPoints += range[1] - range[0] + 1;
        &#125;
    
        return totalPoints;
    &#125;
    
    public static void main(String[] args) &#123;
        // 测试用例
        int[][] testArray1 = &#123;&#123;1, 4&#125;, &#123;7, 10&#125;, &#123;3, 5&#125;&#125;;
        int[][] testArray2 = &#123;&#123;1, 2&#125;, &#123;6, 10&#125;, &#123;11, 15&#125;&#125;;
        int[][] testArray3 = &#123;&#123;1, 3&#125;, &#123;2, 5&#125;, &#123;4, 8&#125;&#125;;
        
        System.out.println(solution(testArray1) == 9); // [1, 5], [7, 10] =&gt; 5 + 4 = 9
        System.out.println(solution(testArray2) == 12); // [1, 2], [6, 10], [11, 15] =&gt; 2 + 5 + 5 = 12
        System.out.println(solution(testArray3) == 8); // [1, 8] =&gt; 8
    &#125;

&#125;</code></pre>

<p>里面的<code>Comparator.comparingInt(a -&gt; a[0])</code> 是 Java 中用于创建比较器的一种简洁方式，用于比较对象（如数组、对象等）的某个整数字段或属性。</p>
<ul>
<li><code>Comparator.comparingInt()</code> 是 Java 8 引入的一种简洁创建比较器的方式，用于比较整数值。</li>
<li><code>a -&gt; a[0]</code> 是一个 <strong>Lambda 表达式</strong>，表示取 <code>a</code> 的第一个元素（索引为 <code>0</code>）作为比较的依据。</li>
</ul>
<p>完整功能是：<strong>按数组的第一个元素升序排序</strong>。</p>
<p><code>Comparator.comparingInt(a -&gt; a[0])</code> 的功能等价于：</p>
<pre><code class="hljs plaintext">list.sort(new Comparator&lt;int[]&gt;() &#123;
    @Override
    public int compare(int[] o1, int[] o2) &#123;
        return Integer.compare(o1[0], o2[0]);
    &#125;
&#125;);</code></pre>

<h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><ul>
<li><em><strong>*一个元素有多个属性就想到构造类*</strong></em></li>
<li><em><strong>*构造类用来存相应的属性可以重新定义一下排序的方法即compareTo()方法*</strong></em></li>
</ul>
<h2 id="3、StringBuilder"><a href="#3、StringBuilder" class="headerlink" title="3、StringBuilder"></a>3、StringBuilder</h2><p>当 <code>List</code> 或其他集合（如 <code>Set</code>）中存储的是 <code>StringBuilder</code> 对象时，可能会出现错误判断，这是因为 <code>StringBuilder</code> 的 <strong>默认比较机制</strong> 并不基于内容，而是基于对象引用。</p>
<p><strong><code>StringBuilder</code> 的比较机制</strong></p>
<ul>
<li><code>StringBuilder</code> 类没有重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li>
<li>其默认实现继承自 <code>Object</code>，比较的是对象的内存地址，而不是内容。</li>
</ul>
<p><strong>错误场景</strong></p>
<p>当你将 <code>StringBuilder</code> 添加到集合（如 <code>List</code> 或 <code>Set</code>）中，集合内部会使用 <code>equals()</code> 方法来判断元素是否相等。如果两个 <code>StringBuilder</code> 的内容相同，但它们是不同的对象引用，则会被认为是不同的元素。</p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><h2 id="StreamTokenizer"><a href="#StreamTokenizer" class="headerlink" title="StreamTokenizer"></a>StreamTokenizer</h2><p><strong>不能和Scanner混合使用。</strong></p>
<p><code>StreamTokenizer</code> 是 Java 中的一个类，专门用于解析输入流，将其分割为“标记”（<code>token</code>）。这些标记可以是数字、单词（字符串）或单个字符。<code>StreamTokenizer</code> 将空白字符（如空格、制表符、换行符）作为分隔符，不会返回它们。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>1、创建 <code>StreamTokenizer</code> 对象，传入 <code>Reader</code> 类型的输入源（通常使用 <code>BufferedReader</code>）。</p>
<p>2、使用 <code>StreamTokenizer.nextToken()</code> 来获取下一个标记（<code>token</code>）。</p>
<p>3、根据标记类型（数字、字符串或其他）处理数据。</p>
<h3 id="主要方法和字段"><a href="#主要方法和字段" class="headerlink" title="主要方法和字段"></a><strong>主要方法和字段</strong></h3><p><strong>方法</strong></p>
<ol>
<li><pre><code>nextToken()
<pre><code class="hljs plaintext">
   - 解析输入流中的下一个标记。
   - 返回标记的类型，并将其存储在 `ttype` 字段中。

2. ```
   pushBack()</code></pre>

- 将最近解析的标记退回到流中，供后续重新处理。
</code></pre>
</li>
</ol>
<p><strong>字段</strong></p>
<ol>
<li><pre><code>ttype
<pre><code class="hljs plaintext">
   - 表示当前标记的类型：
     - `StreamTokenizer.TT_NUMBER`：标记是数字。
     - `StreamTokenizer.TT_WORD`：标记是单词（字符串）。
     - 单个字符的 ASCII 值：标记是符号或单字符。
     - `StreamTokenizer.TT_EOF`：到达输入流的末尾。

2. ```
   nval</code></pre>

- 当 `ttype` 为 `TT_NUMBER` 时，`nval` 保存解析的数字值（`double` 类型）。
</code></pre>
</li>
<li><pre><code>sval
<pre><code class="hljs plaintext">
   - 当 `ttype` 为 `TT_WORD` 时，`sval` 保存解析的字符串。

**数据得先解析，才能取出来，就是得先nextToken()，才能通过nval和sval取出。**
</code></pre>
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
StreamTokenizer tokenizer = new StreamTokenizer(reader);
tokenizer.nextToken();
int n = tokenizer.nval; # 假设输入的是数字
<pre><code class="hljs plaintext">
**记得`throws IOException`**

### 示例

1、简单的数字和单词解析
</code></pre>
import java.io.*;
</code></pre>
</li>
</ol>
<p>public class Main {<br>    public static void main(String[] args) throws IOException {<br>        BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(System.in));<br>        StreamTokenizer tokenizer &#x3D; new StreamTokenizer(reader);</p>
<pre><code>    System.out.println(&quot;请输入内容（例如：123 Hello 456）：&quot;);

    while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;
        if (tokenizer.ttype == StreamTokenizer.TT_NUMBER) &#123;
            System.out.println(&quot;数字: &quot; + tokenizer.nval);
        &#125; else if (tokenizer.ttype == StreamTokenizer.TT_WORD) &#123;
            System.out.println(&quot;单词: &quot; + tokenizer.sval);
        &#125; else &#123;
            System.out.println(&quot;字符: &quot; + (char) tokenizer.ttype);
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre><code class="hljs plaintext">
2：解析一组整数和操作符
</code></pre>
<p>import java.io.*;</p>
<p>public class Main {<br>    public static void main(String[] args) throws IOException {<br>        BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(System.in));<br>        StreamTokenizer tokenizer &#x3D; new StreamTokenizer(reader);</p>
<pre><code>    System.out.println(&quot;请输入表达式（例如：1 + 2 - 3）：&quot;);

    while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;
        if (tokenizer.ttype == StreamTokenizer.TT_NUMBER) &#123;
            System.out.print((int) tokenizer.nval + &quot; &quot;);
        &#125; else if (tokenizer.ttype == &#39;+&#39; || tokenizer.ttype == &#39;-&#39;) &#123;
            System.out.print((char) tokenizer.ttype + &quot; &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre><code class="hljs plaintext">
3：解析带换行符的多行输入
</code></pre>
<p>import java.io.*;</p>
<p>public class Main {<br>    public static void main(String[] args) throws IOException {<br>        BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(System.in));<br>        StreamTokenizer tokenizer &#x3D; new StreamTokenizer(reader);</p>
<pre><code>    System.out.println(&quot;请输入多行内容（输入END结束）：&quot;);

    while (true) &#123;
        tokenizer.nextToken();
        if (tokenizer.ttype == StreamTokenizer.TT_WORD &amp;&amp; &quot;END&quot;.equals(tokenizer.sval)) &#123;
            break;
        &#125; else if (tokenizer.ttype == StreamTokenizer.TT_NUMBER) &#123;
            System.out.println(&quot;数字: &quot; + tokenizer.nval);
        &#125; else if (tokenizer.ttype == StreamTokenizer.TT_WORD) &#123;
            System.out.println(&quot;单词: &quot; + tokenizer.sval);
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre><code class="hljs plaintext">
## BufferedReader

`BufferedReader.readLine()` 会直接读取一整行**字符串**，直到遇到换行符 (`\n`) 或回车换行符 (`\r\n`)。

换行符本身不会包含在读取的结果中，因此返回的字符串已经是干净的数据。

换行符自动被跳过，不需要显式处理，不像**nextLine()**方法。
</code></pre>
<p>BufferedReader ins &#x3D; new BufferedReader(new InputStreamReader(System.in));<br>String str &#x3D; ins.readLine();</p>
<pre><code class="hljs plaintext">
# 建立二叉树

根据中序遍历（b）和后序遍历（f）建立二叉树。
</code></pre>
<p>import java.io.*;<br>import java.util.HashMap;</p>
<p>public class Main{<br>    public static class Node{<br>        int value;<br>        Node left;<br>        Node right;<br>        public Node(int value){<br>            this.value &#x3D; value;<br>        }<br>    }<br>    public static Node buildTree(int[] f,int[] b,int fStart,int fEnd,int bStart,int bEnd,HashMap&lt;Integer,Integer&gt; hm){<br>        if(fStart &gt; fEnd || bStart &gt; bEnd) return null;<br>        int num &#x3D; f[fEnd];<br>        Node root &#x3D; new Node(num);<br>        int bIndex &#x3D; hm.get(num);<br>        int left &#x3D; bIndex - bStart;<br>        root.left &#x3D; buildTree(f,b,fStart,fStart + left - 1,bStart,bIndex - 1,hm);<br>        root.right &#x3D; buildTree(f,b,fStart + left, fEnd - 1,bIndex + 1,bEnd,hm);<br>        return root;<br>    }<br>    public static void main(String[] args) throws IOException{<br>        BufferedReader bfr &#x3D; new BufferedReader(new InputStreamReader(System.in));<br>        StreamTokenizer st &#x3D; new StreamTokenizer(bfr);<br>        st.nextToken();<br>        int n &#x3D; (int)st.nval;<br>        int[] f &#x3D; new int[n];<br>        int[] b &#x3D; new int[n];<br>        for(int i &#x3D; 0;i &lt; n;i ++) {<br>            st.nextToken();<br>            f[i] &#x3D; (int) st.nval;<br>        }<br>        for(int i &#x3D; 0;i &lt; n;i ++) {<br>            st.nextToken();<br>            b[i] &#x3D; (int) st.nval;<br>        }<br>        HashMap&lt;Integer,Integer&gt; hm &#x3D; new HashMap&lt;&gt;();<br>        int order &#x3D; 0;<br>        for(int i : b) {<br>            hm.put(i, order);<br>            order ++;<br>        }<br>        Node root &#x3D; buildTree(f,b,0,f.length - 1,0,b.length - 1,hm);<br>    }<br>}</p>
<pre><code class="hljs plaintext">
# 中心扩展法查找最长对称子串长度

对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定`Is PAT&amp;TAP symmetric?`，最长对称子串为`s PAT&amp;TAP s`，于是你应该输出11。
</code></pre>
<p>import java.util.Scanner;</p>
<p>public class Main {<br>    &#x2F;&#x2F; 中心扩展法查找最长对称子串长度<br>    public static int longestSymmetricSubstring(char[] chars) {<br>        int maxLength &#x3D; 0;<br>        for (int i &#x3D; 0; i &lt; chars.length; i++) {<br>            &#x2F;&#x2F; 以单个字符为中心扩展<br>            maxLength &#x3D; Math.max(maxLength, expandAroundCenter(chars, i, i));<br>            &#x2F;&#x2F; 以两个相邻字符为中心扩展<br>            maxLength &#x3D; Math.max(maxLength, expandAroundCenter(chars, i, i + 1));<br>        }<br>        return maxLength;<br>    }</p>
<pre><code>// 中心扩展方法
private static int expandAroundCenter(char[] chars, int left, int right) &#123;
    while (left &gt;= 0 &amp;&amp; right &lt; chars.length &amp;&amp; chars[left] == chars[right]) &#123;
        left--;
        right++;
    &#125;
    // 返回扩展后的回文子串长度
    return right - left - 1;
&#125;

public static void main(String[] args) &#123;
    Scanner input = new Scanner(System.in);
    String str = input.nextLine();
    char[] chars = str.toCharArray();
    int maxLength = longestSymmetricSubstring(chars);
    System.out.println(maxLength);
&#125;
</code></pre>
<p>}</p>
<pre><code class="hljs plaintext">
# 判断两个字符串（可以循环比对）的最大公共子串的长度
</code></pre>
<p>public class Main {<br>    public static int maxPublic(StringBuilder sb1,StringBuilder sb2,int m) {<br>        int maxL &#x3D; 0;<br>        int[][] lens &#x3D; new int[m + 1][m + 1];<br>        for(int i &#x3D; 1;i &lt;&#x3D; m;i ++) {<br>            for(int j &#x3D; 1;j &lt;&#x3D; m;j ++) {<br>                if(sb1.charAt(i - 1) &#x3D;&#x3D; sb2.charAt(j - 1)) lens[i][j] &#x3D; lens[i - 1][j - 1] + 1;<br>                &#x2F;&#x2F;lens[i][j] 表示：sb1 前 i 个字符 和 sb2 前 j 个字符 所能形成的最长公共子串的长度。<br>                &#x2F;&#x2F;如果 sb1[i-1] &#x3D;&#x3D; sb2[j-1]（即当前字符匹配）：lens[i][j]&#x3D;lens[i−1][j−1]+1<br>                &#x2F;&#x2F;继承前一个位置的状态 lens[i-1][j-1]，然后 +1。<br>                else lens[i][j] &#x3D; 0;<br>                maxL &#x3D; Math.max(maxL,lens[i][j]);<br>                if(maxL &gt;&#x3D; m &#x2F; 2) return m &#x2F; 2;<br>            }<br>        }<br>        return maxL;<br>    }<br>    public static void main(String[] args) {<br>         Scanner input &#x3D; new Scanner(System.in);<br>         int n &#x3D; input.nextInt();&#x2F;&#x2F;字符串数量<br>         int m &#x3D; input.nextInt();&#x2F;&#x2F;每个字符串的长度<br>         input.nextLine();&#x2F;&#x2F;消除换行符<br>         String[] strs &#x3D; new String[n];<br>         for(int i &#x3D; 0;i &lt; n;i ++)<br>        	 strs[i] &#x3D; input.nextLine();<br>         for(int i &#x3D; 0;i &lt; n;i ++) {<br>        	 StringBuilder sb1 &#x3D; new StringBuilder(strs[i]);<br>        	 sb1.append(sb1);<br>        	 for(int j &#x3D; i + 1;j &lt; n;j ++) {<br>        		 StringBuilder sb2 &#x3D; new StringBuilder(strs[j]);<br>        		 sb2.append(sb2);<br>        		 &#x2F;&#x2F;maxPublic(sb1, sb2, 2 * m)<br>        	 }<br>         }<br>    }<br>}</p>
<pre><code class="hljs plaintext">


# 在java中如何快速判断两个List集合中是否有相同的元素

速度上并没有提升多少，只是写的简单。

**方法 1：使用 `retainAll` 方法**

`retainAll` 是 `Collection` 接口中的方法，它会保留集合中与另一个集合相同的元素。
</code></pre>
<p>import java.util.ArrayList;<br>import java.util.List;</p>
<p>public class Main {<br>    public static void main(String[] args) {<br>        List<String> list1 &#x3D; new ArrayList&lt;&gt;();<br>        list1.add(“A”);<br>        list1.add(“B”);<br>        list1.add(“C”);</p>
<pre><code>    List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
    list2.add(&quot;C&quot;);
    list2.add(&quot;D&quot;);
    list2.add(&quot;E&quot;);

    // 复制 list1，避免修改原始数据
    List&lt;String&gt; tempList = new ArrayList&lt;&gt;(list1);
    tempList.retainAll(list2);

    if (!tempList.isEmpty()) &#123;
        System.out.println(&quot;两个 List 有相同的元素&quot;);
    &#125; else &#123;
        System.out.println(&quot;两个 List 没有相同的元素&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre><code class="hljs plaintext">
**方法 2：使用 `Collections.disjoint` 方法**

`Collections.disjoint` 方法直接判断两个集合是否没有共同的元素。如果返回 `true`，表示没有共同元素；否则有。
</code></pre>
<p>import java.util.*;</p>
<p>public class Main {<br>    public static void main(String[] args) {<br>        List<String> list1 &#x3D; Arrays.asList(“A”, “B”, “C”);<br>        List<String> list2 &#x3D; Arrays.asList(“C”, “D”, “E”);</p>
<pre><code>    if (!Collections.disjoint(list1, list2)) &#123;
        System.out.println(&quot;两个 List 有相同的元素&quot;);
    &#125; else &#123;
        System.out.println(&quot;两个 List 没有相同的元素&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre><code class="hljs plaintext">
# 图，割点

战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。 输入格式： 输入在第一行给出两个整数N（0 &lt; N ≤ 500）和M（≤ 5000），分别为城市个数（于是默认城市从0到N-1编号）和连接两城市的通路条数。随后M行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数K和随后的K个被攻占的城市的编号。 注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。 输出格式： 对每个被攻占的城市，如果它会改变整个国家的连通性，则输出Red Alert: City k is lost!，其中k是该城市的编号；否则只输出City k is lost.即可。如果该国失去了最后一个城市，则增加一行输出Game Over.。
</code></pre>
<p>import java.util.Scanner;</p>
<p>public class Main {<br>    static int N,M,K ;<br>    static int[][] Maps;&#x2F;&#x2F;统计初始联通数量<br>    static int[] f;&#x2F;&#x2F;重置根节点数组<br>    static int[] falg;&#x2F;&#x2F;判断城市是否被攻占<br>    public static void init() {<br>        for (int i &#x3D; 0; i &lt; f.length; i++) {<br>            f[i] &#x3D; i;<br>        }<br>    }</p>
<pre><code>public static int find(int x) &#123;
    if(x!=f[x]) &#123;
        f[x] = find(f[x]);
    &#125;
    return f[x];
&#125;

public static void unite(int a,int b) &#123;
    int x = find(a);
    int y = find(b);
    if(x!=y) f[x] = y;
&#125;

public static void main(String[] args) &#123;
    // TODO Auto-generated method stub
    Scanner scan = new Scanner(System.in);
    int N = scan.nextInt();
    int M = scan.nextInt();
    Maps = new int[M][2];
    f = new int[N];
    falg = new int[N];
    init();
    for (int i = 0; i &lt; M; i++) &#123;
        Maps[i][0] = scan.nextInt();
        Maps[i][1] = scan.nextInt();
        unite(Maps[i][0],Maps[i][1]);
    &#125;
    int count = 0;//统计攻占前的联通城市数量
    for (int i = 0; i &lt; f.length; i++) &#123;
        if(f[i]==i) &#123;
            count++;
        &#125;
    &#125;
    K = scan.nextInt();
    int n = K;
    while(K--&gt;0) &#123;
        init();
        int k = scan.nextInt();
        falg[k] = 1;
        for (int i = 0; i &lt; M; i++) &#123;
            int a = Maps[i][0];
            int b = Maps[i][1];
            if(falg[a]==1 || falg[b]==1)continue;
            if(k!=a&amp;&amp;k!=b)unite(a, b);
        &#125;
        int sum = 0;
        for (int i = 0; i &lt; N; i++) &#123;
            if(f[i]==i)sum++;
        &#125;

        //因为删掉该城市 这个城市也是一个单独的连通块 所以当前连通块&gt;之前连通块+这个城市 说明删掉该城市 会改变图的连通性
        if(sum&gt;count+1) System.out.printf(&quot;Red Alert: City %d is lost!\n&quot;,k);
        else System.out.printf(&quot;City %d is lost.\n&quot;,k);
        count=sum;//更新连通块
    &#125;
    if(N==n)System.out.printf(&quot;Game Over.&quot;);

&#125;
</code></pre>
<p>}</p>
<pre><code class="hljs plaintext">
# 阶乘

&lt;img src=&quot;../source/imgs/$&#123;fiilname&#125;/image-20250323154250243.png&quot; alt=&quot;image-20250323154250243&quot; style=&quot;zoom:50%;&quot; /&gt;
</code></pre>
<p>import java.util.Scanner;</p>
<p>public class Main {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F; 下面举例说明为什么要将nums[]中最小的元素作为因子初始值<br>        &#x2F;&#x2F; 3！ 6<br>        &#x2F;&#x2F; 4！ 24<br>        &#x2F;&#x2F; 5！ 120<br>        &#x2F;&#x2F; 和为150 必是 3！的倍数！ 因为 4！5！都是3！的倍数，所以加起来肯定也是 (min) 3！的倍数<br>        &#x2F;&#x2F; 所以应该找出数组最小值作为初始的sum，再一个一个往上找<br>        &#x2F;&#x2F; 比如上面这个例子，需要有 4个3！才能进化为 4！，由于只有一个 3！所以不能往上找了，break退出，答案就是3<br>        Scanner sc &#x3D; new Scanner(System.in);<br>        int n &#x3D; sc.nextInt();<br>        long[] nums &#x3D; new long[n];<br>        long min &#x3D; Long.MAX_VALUE;<br>        for (int i &#x3D; 0; i &lt; nums.length; i++) {<br>            nums[i] &#x3D; sc.nextLong();<br>            min &#x3D; Math.min(min, nums[i]);<br>        }<br>        long sum &#x3D; min;  &#x2F;&#x2F; sum为nums[]中的最小值<br>        long num &#x3D; 0;    &#x2F;&#x2F; num为nums[]中值为sum的数量<br>        while (true) {<br>            &#x2F;&#x2F; 如下文注释：num在上个循环中是18，sum 在上个循环中 8更新为9<br>            &#x2F;&#x2F; 根据 18 * 8！ &#x3D; 2 * 9 * 8！ &#x3D; 2 * 9！可知此次循环的 num 要更新为 18 &#x2F; 9 &#x3D; 2<br>            num &#x3D; num &#x2F; sum;<br>            for (int i &#x3D; 0; i &lt; nums.length; i++) {<br>                if (nums[i] &#x3D;&#x3D; sum) {<br>                    num++;<br>                }<br>            }<br>            &#x2F;&#x2F; 如果sum的数量（num）等于sum+1的倍数，则可以将其逻辑上将这num个sum合成为（sum+1）的阶乘。<br>            &#x2F;&#x2F; 形象化： sum &#x3D; 2  num &#x3D; 3  3个2 &#x3D; 2+2+2    sum+1 &#x3D; 3  3 &#x3D; 3的倍数， 3个2合成为3的阶乘<br>            &#x2F;&#x2F; 18(num)个8！(sum) &#x3D; 18 * 8！ &#x3D; 2 * 9 * 8！ &#x3D; 2 * 9！  sum的数量18 &#x3D; sum+1&#x3D;9 的倍数<br>            if (num % (sum + 1) &#x3D;&#x3D; 0 &amp;&amp; num !&#x3D; 0) {<br>                sum++;<br>            } else break;<br>        }<br>        System.out.println(sum);<br>    }<br>}</p>
<pre><code class="hljs plaintext">
# 数学

![image-20250404103236386](../source/imgs/$&#123;fiilname&#125;/image-20250404103236386.png)

用这种方式求斜率k和截距b可以避免小数精度的影响，特别是截距b，如果就直接用k来求的话，会因为精度问题导致原本应该相同的b而不同。这种求b的方式叫做点斜式。

![image-20250406213554281](../source/imgs/$&#123;fiilname&#125;/image-20250406213554281.png)

&lt;img src=&quot;../source/imgs/$&#123;fiilname&#125;/uid1525433-20240412-1712919046696.png&quot; alt=&quot;图片描述&quot; style=&quot;zoom:67%;&quot; /&gt;

![image-20250406214405360](../source/imgs/$&#123;fiilname&#125;/image-20250406214405360.png)

寻找条件减少暴力的数量。

![image-20250406215602462](../source/imgs/$&#123;fiilname&#125;/image-20250406215602462.png)

------

有一个 *n*×*m* 方格的棋盘，矩形的总数量为&lt;img src=&quot;../source/imgs/$&#123;fiilname&#125;/image-20250904172413877.png&quot; alt=&quot;image-20250904172413877&quot; style=&quot;zoom:20%;&quot; /&gt;.

原因：

- 棋盘有 n 行，因此有 n+1 条水平线（包括上边界和下边界）。选择两条不同的水平线的方式是组合数&lt;img src=&quot;../source/imgs/$&#123;fiilname&#125;/image-20250904172510512.png&quot; alt=&quot;image-20250904172510512&quot; style=&quot;zoom:50%;&quot; /&gt;
- 棋盘有 m 列，因此有 m+1 条垂直线（包括左边界和右边界）。选择两条不同的垂直线的方式是组合数&lt;img src=&quot;../source/imgs/$&#123;fiilname&#125;/image-20250904172545506.png&quot; alt=&quot;image-20250904172545506&quot; style=&quot;zoom:50%;&quot; /&gt;
- 每个矩形由一对水平线和一对垂直线唯一确定，因此总矩形个数是水平线选择数和垂直线选择数的乘积：&lt;img src=&quot;../source/imgs/$&#123;fiilname&#125;/image-20250904172609188.png&quot; alt=&quot;image-20250904172609188&quot; style=&quot;zoom:50%;&quot; /&gt;

**矩形数**=**正方形数**+**长方形数**

# 快速幂和高精度乘法
</code></pre>
<h1 id="初始化全局变量，Python中不需要固定大小的数组，列表可以动态扩展"><a href="#初始化全局变量，Python中不需要固定大小的数组，列表可以动态扩展" class="headerlink" title="初始化全局变量，Python中不需要固定大小的数组，列表可以动态扩展"></a>初始化全局变量，Python中不需要固定大小的数组，列表可以动态扩展</h1><p>n &#x3D; 0<br>a &#x3D; [0] * 1010  # 模拟数组，存储每个位上的数字<br>res &#x3D; [0] * 1010 # 模拟数组，存储每个位上的数字<br>cnt &#x3D; 0 # Python中不常用这种方式来记录长度，通常直接用 len() 或保持一个实际的长度变量</p>
<h1 id="设置一个最大处理的位数，Python实际上可以处理任意长度"><a href="#设置一个最大处理的位数，Python实际上可以处理任意长度" class="headerlink" title="设置一个最大处理的位数，Python实际上可以处理任意长度"></a>设置一个最大处理的位数，Python实际上可以处理任意长度</h1><p>MAX_DIGITS &#x3D; 500</p>
<p>def multiply1(): # 高精度乘法模板1 (res &#x3D; res * a)<br>    “””<br>    实现高精度乘法 res &#x3D; res * a。<br>    res 存储第一个乘数，a 存储第二个乘数。结果存储回 res。<br>    “””<br>    tmp &#x3D; [0] * (MAX_DIGITS * 2) # 乘积的位数可能翻倍，所以需要更大的临时空间</p>
<pre><code># 执行小学乘法，每一位与每一位相乘
for i in range(MAX_DIGITS):
    if res[i] == 0 and i &gt; 0 and all(x == 0 for x in res[i:]):
        # 优化：如果res的当前位及其之后都是0，则不再需要计算
        break
    for j in range(MAX_DIGITS):
        if a[j] == 0 and j &gt; 0 and all(x == 0 for x in a[j:]):
            # 优化：如果a的当前位及其之后都是0，则不再需要计算
            break
        tmp[i + j] += res[i] * a[j]

# 处理进位
t = 0
for i in range(len(tmp)): # 遍历tmp的有效长度
    tmp[i] += t
    res[i] = tmp[i] % 10 # 当前位取余
    t = tmp[i] // 10    # 进位

# 更新 res 的实际长度，如果需要的话
# Python中通常不需要手动管理长度，因为可以动态获取 len()
</code></pre>
<p>def multiply2(): # 高精度乘法模板2 (a &#x3D; a * a)<br>    “””<br>    实现高精度乘法 a &#x3D; a * a。<br>    a 存储第一个乘数和第二个乘数。结果存储回 a。<br>    “””<br>    tmp &#x3D; [0] * (MAX_DIGITS * 2) # 乘积的位数可能翻倍，所以需要更大的临时空间</p>
<pre><code># 执行小学乘法，每一位与每一位相乘
for i in range(MAX_DIGITS):
    if a[i] == 0 and i &gt; 0 and all(x == 0 for x in a[i:]):
        break
    for j in range(MAX_DIGITS):
        if a[j] == 0 and j &gt; 0 and all(x == 0 for x in a[j:]):
            break
        tmp[i + j] += a[i] * a[j]

# 处理进位
t = 0
for i in range(len(tmp)): # 遍历tmp的有效长度
    tmp[i] += t
    a[i] = tmp[i] % 10 # 当前位取余
    t = tmp[i] // 10    # 进位

# 更新 a 的实际长度，如果需要的话
</code></pre>
<p>def quick_pow(p): # 快速幂<br>    “””<br>    实现快速幂算法，计算 2^p。<br>    结果存储在全局变量 res 中。<br>    “””<br>    global res, a # 声明将修改全局变量</p>
<pre><code># 初始化：res = 1 (最终结果)，a = 2 (底数)
# Python中列表的反转，res[0]是最低位
res = [0] * (MAX_DIGITS + 1) # 增加一位以防溢出
a = [0] * (MAX_DIGITS + 1)  # 增加一位以防溢出
res[0] = 1
a[0] = 2

# 快速幂主循环
while p &gt; 0:
    if p &amp; 1: # 如果 p 的当前最低位是 1 (p % 2 == 1)
        multiply1() # res = res * a (将当前的 a 乘到结果中)
    multiply2() # a = a * a (a 自乘，准备下一轮迭代)
    p &gt;&gt;= 1     # p 右移一位 (p = p // 2)

# 调整 res 的长度，去掉高位的0
global cnt
cnt = len(res) - 1
while cnt &gt;= 0 and res[cnt] == 0:
    cnt -= 1
cnt += 1 # 实际的位数

# 打印结果 (逆序打印，因为最低位在前面)
# print(&quot;2^&quot;, original_p, &quot; = &quot;, end=&quot;&quot;)
# if cnt == 0: # 如果结果是0，例如 2^负数 这种情况，虽然快速幂没有考虑负数
#     print(&quot;0&quot;)
# else:
#     for i in range(cnt - 1, -1, -1):
#         print(res[i], end=&quot;&quot;)
# print()
</code></pre>
<h1 id="示例调用"><a href="#示例调用" class="headerlink" title="示例调用"></a>示例调用</h1><h1 id="quick-pow-10-计算-2-10"><a href="#quick-pow-10-计算-2-10" class="headerlink" title="quick_pow(10) # 计算 2^10"></a>quick_pow(10) # 计算 2^10</h1><pre><code class="hljs plaintext">
**高精度乘法解释**

**什么是高精度乘法？**
高精度乘法是指当两个数字非常大，以至于它们的乘积超出了标准数据类型（如 int, long long 等）所能表示的范围时，我们需要一种方法来精确计算它们的乘积。通常，我们会将大数存储在数组或列表中，每个元素代表大数的一个位。

**实现原理 (以 multiply1 为例，res = res \* a)：**

1. **存储方式：** 在C++和Python代码中，大数被存储在数组（或列表）中。res[0] 和 a[0] 存储的是个位，res[1] 和 a[1] 存储的是十位，以此类推。这种“低位在前”的存储方式方便进行乘法计算和进位处理。
   - 例如，数字 123 存储为 [3, 2, 1]。
2. **初始化临时结果：** 创建一个足够大的临时数组 tmp（乘积的位数最多是两个乘数位数之和），并初始化为0。
3. **逐位相乘 (模拟小学乘法)：**
   - 我们遍历 res 的每一位 res[i] 和 a 的每一位 a[j]。
   - 将 res[i] * a[j] 的结果加到 tmp[i + j] 上。
   - **为什么是 tmp[i + j]？** 因为当个位 res[0] 乘以个位 a[0] 时，结果是 tmp[0]（个位）；当 res[1]（十位）乘以 a[0]（个位）时，结果是 tmp[1]（十位）；当 res[1]（十位）乘以 a[1]（十位）时，结果是 tmp[2]（百位）。这与我们手算乘法时错位相加的原理是完全一致的。
4. **处理进位：**
   - 在完成所有逐位相乘后，tmp 数组的每个位置上可能存储了不止一位的数字（例如，3 * 4 = 12，tmp[0] 可能是 12）。
   - 从 tmp[0] 开始遍历，将当前位 tmp[i] 加上前一位的进位 t。
   - res[i] = (tmp[i] + t) % 10：当前位的结果是 tmp[i] 和进位之和的个位。
   - t = (tmp[i] + t) // 10：计算新的进位，用于下一位的处理。
   - 这个过程确保了每一位都只存储一个数字，并将多余的进位传递给下一位。

**优化：** 在Python代码中，我增加了一些 if res[i] == 0 ... 的判断。如果一个数的当前位以及所有更高位都是0，那么再往后乘就没有意义了，可以提前退出循环，提高效率。这在C++的数组操作中也常见，但Python列表的 all() 操作可能会有额外的开销，主要为了语义上的清晰。

**快速幂解释**

**什么是快速幂？**
快速幂是一种在 O(log n) 时间复杂度内计算 a^b 的算法，而不是传统的 O(n) 时间复杂度。它利用了指数的二进制表示来显著减少乘法操作的次数。

**实现原理 (以计算 2^p 为例)：**

1. **二进制分解：** 任何一个正整数 p 都可以被表示成二进制形式。例如，p = 10（十进制）是 1010（二进制）。
   这意味着 10 = 8 + 2。
   所以 2^10 = 2^(8 + 2) = 2^8 * 2^2。
2. **迭代过程：**
   - **初始化：**
     - res (result) 初始化为 1 (任何数的 0 次方都是 1)。
     - a (base) 初始化为我们要计算的底数，这里是 2。
     - p 是指数。
   - **循环判断 p 的最低位：**
     - while p &gt; 0:：循环直到指数 p 变为 0。
     - if p &amp; 1:：这是一个位运算，等价于 if p % 2 == 1，判断 p 的当前最低位是否为 1。
       - 如果为 1，说明当前这一项 a^(2^k) 存在于 2^p 的分解中，所以我们需要将当前的 a 乘到结果 res 中。在代码中就是 multiply1() (即 res = res * a)。
     - multiply2()：无论 p 的最低位是 0 还是 1，我们都需要将底数 a 自乘（即 a = a * a）。这是因为在下一次循环中，a 将代表 a 的平方（如果当前 a 是 2^1，下次就是 2^2；如果当前 a 是 2^2，下次就是 2^4，以此类推）。
     - p &gt;&gt;= 1:：这是一个位运算，等价于 p = p // 2，将 p 右移一位，相当于除以 2，以便检查下一位。



快速幂思想运用在矩阵乘法上：可以看《真题技巧》的“斐波那契套路”。上面的高精度乘法有两个模板是给下面的快速幂服务的，其实思路都一样。

&lt;img src=&quot;../source/imgs/$&#123;fiilname&#125;/image-20250903190737136.png&quot; alt=&quot;image-20250903190737136&quot; style=&quot;zoom:50%;&quot; /&gt;
</code></pre>
<p>import math</p>
<p>def multiply1(res, a):<br>    temp &#x3D; [0] * 1010<br>    for i in range(500):<br>        for j in range(500):<br>            temp[i + j] +&#x3D; res[i] * a[j]<br>    t &#x3D; 0<br>    for i in range(500):<br>        temp[i] +&#x3D; t<br>        res[i] &#x3D; temp[i] % 10<br>        t &#x3D; temp[i] &#x2F;&#x2F; 10<br>    return res</p>
<p>def multiply2(a):<br>    temp &#x3D; [0] * 1010<br>    for i in range(500):<br>        for j in range(500):<br>            temp[i + j] +&#x3D; a[i] * a[j]<br>    t &#x3D; 0<br>    for i in range(500):<br>        temp[i] +&#x3D; t<br>        a[i] &#x3D; temp[i] % 10<br>        t &#x3D; temp[i] &#x2F;&#x2F; 10<br>    return a</p>
<p>def quick_pow(p):<br>    res &#x3D; [0] * 501<br>    a &#x3D; [0] * 501<br>    res[0] &#x3D; 1<br>    a[0] &#x3D; 2<br>    while p !&#x3D; 0:<br>        if p &amp; 1:<br>            res &#x3D; multiply1(res, a)<br>        a &#x3D; multiply2(a)<br>        p &gt;&gt;&#x3D; 1<br>    return res</p>
<p>n &#x3D; int(input())<br>length &#x3D; int(n * math.log10(2) + 1)<br>print(length)</p>
<p>result_array &#x3D; quick_pow(n)</p>
<p>result_array[0] -&#x3D; 1</p>
<p>cnt &#x3D; 0<br>for i in range(499, -1, -1):<br>    if cnt &#x3D;&#x3D; 50:<br>        print()<br>        cnt &#x3D; 0<br>    print(result_array[i], end&#x3D;””)<br>    cnt +&#x3D; 1<br>print()</p>
<pre><code>
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2025 Odegaard
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>