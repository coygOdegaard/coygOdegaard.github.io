<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>数据清洗 | coygOdegaard</title><meta name="keywords" content="大数据"><meta name="author" content="Odegaard"><meta name="copyright" content="Odegaard"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="数据清洗"><meta name="application-name" content="数据清洗"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="数据清洗"><meta property="og:url" content="http://example.com/2024/10/08/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/index.html"><meta property="og:site_name" content="coygOdegaard"><meta property="og:description" content="什么是数据清洗 数据清洗就是将“脏数据”变为“干净的数据”。  清洗流程： 数据的读写-&amp;gt;数据的探索与描述-&amp;gt;数据简单处理-&amp;gt;（重复值的处理-&amp;gt;缺失值的处理-&amp;gt;异常值的处理-&amp;gt;文本字符串的处理-&amp;gt;时间格式序列的处理）（后面这五个不是一定要按照这个顺序）  环"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="Odegaard"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="什么是数据清洗 数据清洗就是将“脏数据”变为“干净的数据”。  清洗流程： 数据的读写-&amp;gt;数据的探索与描述-&amp;gt;数据简单处理-&amp;gt;（重复值的处理-&amp;gt;缺失值的处理-&amp;gt;异常值的处理-&amp;gt;文本字符串的处理-&amp;gt;时间格式序列的处理）（后面这五个不是一定要按照这个顺序）  环"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2024/10/08/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Odegaard","link":"链接: ","source":"来源: coygOdegaard","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'coygOdegaard',
  title: '数据清洗',
  postAI: '',
  pageFillDescription: '什么是数据清洗, 环境搭建, numpy模块, 创建数组, array(), frombuffer()可转化字符串, empty(), 存储图片, zero()ones()linspace()arange()random系列, logspace(), numpy数组的常用属性, numpy的索引和切片操作, 索引, 切片, 广播（Broaddcast）, 迭代数组, 数组操作, 修改数组形状, 翻转数组, 级联操作（同一维度）, 分割数组, 数组元素的添加和删除, 常用的函数, 算术函数, 数学函数, 统计函数, 排序条件筛选函数, 矩阵操作, Pandas, Series, 基本, 常用方法, DataFrame, 基本, 基本属性, 索引操作, 切片操作, 附加操作时间类型的转化, 应用, 部分方法, 取数据存数据csv文件, excel文件, drop, 布尔值取数据, shift计算, resample, Pandas CSV, Pandas Excel, Pandas常用函数, 缺失值的清洗, 缺失值, pandas处理空值的操作, 删除, 覆盖, 重复值和异常值的清洗, 重复值, 异常值, DataFrame的级联操作和合并操作, 级联操作, concat, append, 合并操作, 一对一合并, 一对多合并, 多对多合并, how, key的规范化, 应用, infounique, query, sort, 替换操作, pandas高级操作, 映射, 排序实现的随机抽样, 分组聚合什么是数据清洗数据清洗就是将脏数据变为干净的数据清洗流程数据的读写数据的探索与描述数据简单处理重复值的处理缺失值的处理异常值的处理文本字符串的处理时间格式序列的处理后面这五个不是一定要按照这个顺序环境搭建形式写笔记就要遵循的要求不然不能实现如果你在运行的过程中重启或中断了内核所有的导入和变量都会被清空此时你需要重新运行导入语句模块创建数组可以将当作一维或多维的数组重在于数值运算多用于大型多维数组上执行的数值运算代表的是数据源代表的是某种数据类型代表的是数据源的数据的类型如果不写的话那数据源的数据的类型就默认为它传入是什么类型就是什么类型想要打印某个变量的值不需要写直接写变量名就好了创建数组用的是创建列表的语法但是因为是数组所以元素类型是相同的不能像列表那样可以存放不同的数据类型优先级字符串浮点型整数可转化字符串用于实现动态数组接受输入参数以流的形式读入转化成对象注意是字符串的时候默认是类型所以要转成在原前加上可以是任意对象会以流的形式读入返回数组的数据类型可选读取的数据数量默认为读取所有数据读取的起始位置默认为表示固定长度的字符串其中代表每个元素是字节的字符串即单个字符每个元素是字节个字符其中是字符串的最大长度存储图片读取图片数据后会将数据存储在一个数组中单引号里面填写图片路径数组中装载的就是图片内容将数组进行可视化展示这个图片展示单从内容上讲不如前面那个方法数组名减去一个数代表这个数组里的全部数据都减去那个数系列以上几个方法都是创建数组的代表初始数据为代表初始数据为不是是数组形状数据类型可选默认为浮点数用于的行数组或者用于的列数组代表的是要创建的数组大小就是三行四列默认为浮点数不一定要写序列的起始值序列的终止值如果为该值包含于数列中要生成的等步长的样本数量默认为该值为时数列中包含值反之不包含默认是如果为时生成的数组中会显示间距反之不显示的数据类型的作用是生成一个从到包括和的等差数列包含个元素生成的是一个等差数列从到之间均匀分布个点包括起点和终点在生成等差数列时我们需要确定每两个相邻数之间的间隔希望生成个数但实际上这个数列可以理解为有个间隔因为个数之间只有个间隔间隔长度为步长产生一个大小的元素是到的随机数生成的是大小范围的可以指定索引参数意思是取对数的时候的下标序列的起始值为序列的终止值为如果为该值包含于数列中要生成的等步长的样本数量默认为该值为时数列中中包含值反之不包含默认是对数的底数的数据类型数组的常用属性数组名返回的是数组的形状数组名返回的是数组的维度数组名返回的是数组的元素个数数组名返回的是数组的元素类型变量返回的是变量的类型的索引和切片操作索引索引操作和列表的索引操作时一样的整数数组索引指使用一个数组来访问另一个数组的元素这个数组中的每个元素都是目标数组中某个维度上的索引值行索引和列索引是配对的用来选择行索引用来选择列索引等于按照上面那样整数索引以二维数组的形式输入最后输出结果也是二维数组但如果最后就会输出一维数组先选择行到再选列得到的是一个子矩阵选取的是和位置的元素得到的是一个一维数组那怎么取第行的第列的数据呢使用创建的数组选取第行第列行索引列索引直接使用进行花式索引先取出第行包含所有列再在选出的子矩阵中取出第列切片一维数组冒号的解释如果只放置一个参数如将返回与该索引相对应的单个元素如果为表示从该索引开始以后的所有项都将被提取如果使用了两个参数如那么则提取两个索引不包括停止索引之间的项二维数组从索引为的切割到底切片还可以包括省略号来使选择元组的长度与数组的维度相同如果在行位置使用省略号它将返回包含行中元素的在中省略号用于表示多个冒号它的作用是自动匹配剩余的维度以便简化索引操作将图片进行左右翻转就是该图片的行不变列倒置图片上下翻转就是图片的行倒置列不变上述关于图片的各种操作就是关于图片的数组的操作广播广播是对不同形状的数组进行数值计算的方式如果两个数组和形状相同即满足那么的结果就是与数组对应位相乘这要求维数相同且各维度的长度相同当运算中的个数组的形状不同时将自动触发广播机制迭代数组迭代器对象提供了一种灵活访问一个或者多个数组元素的方式是提供的多维数组迭代器可以逐元素访问适用于任何维度的数组而不需要手动写多层循环按行优先方式依次访问数组中的元素打印变量这里是数组中的元素指定打印结尾的字符原本默认是换行但这里改为逗号空格所以输出在同一行并且元素之间用分隔控制遍历顺序即是列序优先即是行序优先将修改为就不能修改原数组了表示仍然是数组的视图不会改变本身的引用而是修改它所指向的内存中的值和的关键区别在于操作的是所指向的原数组创建了一个新的变量而不是修改原数组的内存在中视图是指共享相同数据但具有不同形状或表示方式的数组视图不会创建新的数据副本而是引用原始数组的内存因此修改视图的数据会影响原数组反之亦然如果两个数组是可广播的组合对象能够同时迭代它们假设数组的维度为数组的维度为则使用以下迭代器数组被广播到的大小数组操作修改数组形状数组名行列重新制定形状一维多维多维一维和都代表个元素的一维数组但是会报错不代表列的数组变形前后的元素数量要一样是一个数组元素迭代器不用使用迭代数组也可以一个一个输出元素返回一份数组拷贝对拷贝所做的修改不会影响原始数组返回的始终是一维数组按行按列原顺序元素在内存中的出现顺序展平的数组元素顺序通常是风格返回的是数组视图修改会影响原始数组用法和一样也是返回一维数组翻转数组后面两个想看自己去菜鸟看类似级联操作同一维度将多个数组进行横向或纵向的拼接要拼接的数组如何拼接相同类型的数组默认为对一维数组来说只有代表横向拼接对二维数组来说纵向轴拼接横向轴拼接对三维数组来说在承接二维的基础上就是轴上的拼接级联的两个数组维度一样但行列不同怎么办在行相同列不同的情况上可以横向拼接不能纵向拼接在行不同列相同的情况下可以纵向拼接不能横向拼接可以用于图片的拼接上分割数组被分割的数组如果是一个整数就用该数平均切分需要刚好可以平分成这个数量如果是一个数组为沿轴切分的位置左开右闭设置沿着哪个方向进行切分默认为横向切分即水平方向为时纵向切分即竖直方向横向分割的意思是假如用一把刀来切分分割的时候刀是沿水平方向移动的刀口和竖直方向平行为时在水平方向分割为时在垂直方向分割函数用于水平分割数组通过指定要返回的相同形状的数组数量来拆分原数组沿着垂直轴分割其分割方式与用法相同数组元素的添加和删除如果新数组大小大于原始大小则包含原始数组中的元素的副本可以想象成原数组的元素一个一个循环填进新数组中第一个数组第一个数组的形状第二个数组第二个数组的形状要注意的第一行在中重复出现因为尺寸变大了修改第二个数组的大小若是则输出函数在数组的末尾添加值追加操作会分配整个数组并把原来的数组复制到新数组中此外输入数组的维度必须匹配否则将生成输入数组要向添加的值需要和形状相同除了要添加的轴默认为当无定义时是横向加成返回总是为一维数组当有定义的时候分别为和的时候当有定义的时候分别为和的时候列数要相同当为时数组是加在右边行数要相同函数在给定索引之前沿给定轴在输入数组中插入值函数会在指定位置或位置数组插入给定的值或数组然后返回新的数组被插入的元素可以是标量值也可以是数组需要注意的是插入操作会返回一个新的数组而不会改变原始数组输入数组在其之前插入值的索引要插入的值沿着它插入的轴如果未提供则输入数组会被展开第一个数组未传递参数在删除之前输入数组会被展开传递了参数会广播值数组来配输入数组沿轴广播沿轴广播当时以行为单位进行插入当是以列为单位进行插入要实现广播数组进行插入的前提这个数组可以广播函数返回从输入数组中删除指定子数组的新数组与函数的情况一样如果未提供轴参数则输入数组将展开输入数组可以被切片整数或者整数数组表明要从输入数组删除的子数组沿着它删除给定子数组的轴如果未提供则输入数组会被展开函数用于去除数组中的重复元素输入数组如果不是一维数组则会展开如果为返回新列表元素在旧列表中的位置下标并以列表形式储如果为返回旧列表元素在新列表中的位置下标并以列表形式储如果为返回去重数组中的元素在原数组中的出现次数这个函数返回的去重后的数组同时也完成了排序第一个数组第一个数组的去重值去重数组的索引数组我们可以看到每个和原数组下标对应的数值去重数组的下标下标为使用下标重构原数组返回去重元素的重复数量为什么可以同时给两个赋值且值还不同因为此时这个函数会返回去重后的数组按排序后的唯一值返回它是原数组中每个唯一值第一次出现的索引它会同时返回两个值这是函数中的多返回值机制如常用的函数算术函数数组名求出该数组所有元素的和数组名每列或每行的和数据源后面几个函数的用法和一样求的是算术平均值算术函数包含简单的加减乘除和需要注意的是数组必须具有相同的形状或符合数组广播规则函数返回参数逐元素的倒数如倒数为函数将第一个输入数组中的元素作为底数计算它与第二个输入数组中相应元素的幂如果第二个元素只有一个数的话那第一个元素的全部数的幂就是第二个元素的值计算输入数组中相应元素的相除后的余数函数也产生相同的结果被除数除数数学函数对数组的每个元素都求里面也可以直接指定一个数如这些函数计算使用的都是弧度制所以要将角度转化为弧度就要通过乘转化为弧度不同角度的正弦值通过乘转化为弧度和函数返回给定角度的和的反三角函数但这三个函数返回的不是角度而是弧度这些函数的结果可以通过函数将弧度转换为角度含有正弦值的数组计算角度的反正弦返回值以弧度为单位通过转化为角度制来检查结果当为负数的时候四舍五入的位置开始向左移动返回小于或者等于指定表达式的最大整数即向下取整返回大于或者等于指定表达式的最小整数即向上取整这两个函数参数就是数组和的操作和上面的和是一样的数组方差和标准差用法一样统计函数用于计算数组中的元素沿指定轴的最小值输入的数组可以是一个数组或类似数组的对象可选参数用于指定在哪个轴上计算最小值如果不提供此参数则返回整个数组的最小值可以是一个整数表示轴的索引也可以是一个元组表示多个轴可选参数用于指定结果的存储位置可选参数如果为将保持结果数组的维度数目与输入数组相同如果为默认值则会去除计算后维度为的轴可选参数用于指定一个初始值然后在数组的元素上计算最小值可选参数一个布尔数组用于指定仅考虑满足条件的元素部分是提供一个初始值防止使用这个函数是遇到空数组导致报错假如是空数组的话那最后会返回的值用于计算数组中的元素沿指定轴的最大值我们的数组是调用函数再次调用函数调用函数再次调用函数函数计算数组中元素最大值与最小值的差最大值最小值输入的数组可以是一个数组或类似数组的对象可选参数用于指定在哪个轴上计算峰峰值如果不提供此参数则返回整个数组的峰峰值可以是一个整数表示轴的索引也可以是一个元组表示多个轴可选参数用于指定结果的存储位置可选参数如果为将保持结果数组的维度数目与输入数组相同如果为默认值则会去除计算后维度为的轴可选参数一个布尔数组用于指定仅考虑满足条件的元素百分位数是统计中使用的度量表示小于这个值的观察值的百分比输入数组要计算的百分位数在之间沿着它计算百分位数的轴第个百分位数是这样一个值它使得至少有的数据项小于或等于这个值且至少有的数据项大于或等于这个值举个例子高等院校的入学考试成绩经常以百分位数的形式报告比如假设某个考生在入学考试中的语文部分的原始分数为分相对于参加同一考试的其他学生来说他的成绩如何并不容易知道但是如果原始分数分恰好对应的是第百分位数我们就能知道大约的学生的考分比他低而约的学生考分比他高这里的函数用于计算数组中元素的中位数中值也可以使用函数当百分位数为就可以可选参数如果为则允许在计算中使用输入数组的内存这可能会在某些情况下提高性能但可能会修改输入数组的内容算术平均值标准差方差函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值加权平均值即将各数值乘以相应的权数然后加总求和得到总体值再除以总的单位数考虑数组和相应的权重通过将相应元素的乘积相加并将和除以权重的和来计算加权平均值加权平均值输入的数组可以是一个数组或类似数组的对象可选参数用于指定在哪个轴上计算加权平均值如果不提供此参数则计算整个数组的加权平均值可以是一个整数表示轴的索引也可以是一个元组表示多个轴可选参数用于指定对应数据点的权重如果不提供权重数组则默认为等权重可选参数如果为将同时返回加权平均值和权重总和排序条件筛选函数函数返回输入数组的排序副本要排序的数组沿着它排序数组的轴如果没有数组会被展开沿着最后的轴排序按列排序按行排序默认为快速排序如果数组包含字段则是要排序的字段可以通过控制的内容来控制排序我们的数组是调用函数按列排序在函数中排序字段我们的数组是按排序函数返回的是数组值从小到大的索引值我们的数组是对调用函数以排序后的顺序重构原数组函数也可以用于多维数组假如用于二维数组的话如下图为什么是要在列方向上进行排序呢因为返回的索引是每一行里各个元素的列索引就代表要按照提供的列索引顺序对每一行进行重排用于对多个序列进行排序返回的也是索引把它想象成对电子表格进行排序每一列代表一个序列排序时优先照顾靠后的列这里举一个应用场景小升初考试重点班录取学生按照总成绩录取在总成绩相同时数学成绩高的优先录取在总成绩和数学成绩都相同时按照英语成绩录取这里总成绩排在电子表格的最后一列数学成绩在倒数第二列英语成绩在倒数第三列会拼接成字符串因为使用了列表推导式所以里面的方括号不能去掉和函数分别沿给定轴返回最大和最小元素的索引没给赋值的话返回的索引是原数组张开后的索引想要直接用的话需要将原数组张开后调用这两个函数的参数是函数返回输入数组中非零元素的索引函数返回输入数组中满足给定条件的元素的索引函数根据某个条件从数组中抽取元素返回满条件的元素矩阵操作没有这个功能了推荐直接用或者来创建单位矩阵代表矩阵大小行列转置矩阵矩阵相乘数组数组处理数值型的数据处理数值型之外的数据基本数据源索引数据类型没有写的序号就默认为的数据部分可以是列表数组字典标量值等如果不提供此参数则创建一个空的的索引部分用于对数据进行标记可以是列表数组索引对象等如果不提供此参数则创建一个默认的整数索引指定的数据类型可以是的数据类型例如等如果不提供此参数则根据数据自动推断数据类型的名称用于标识对象如果提供了此参数则创建的对象将具有指定的名称是否复制数据默认为表示不复制数据如果设置为则复制输入的数据是否启用快速路径默认为启用快速路径可能会在某些情况下提高性能通过对象建立可以指定这个对象的名称括号里面只能写不能用其他的或者直接不写只需将数据传入就行定义索引后依旧可以使用默认索引使用字典充当数据源索引和切片的使用与前面的差不多不过切片会一起显示前面的序号索引不会和和前面的一样分别显示形状和个数返回的是数据类型返回说明也只能存储同一种类型的数据常用方法上面的后四个表示加减乘除可以使用上面的方法来进行也可以直接使用运算符显示前几个数据默认是可以指定要显示的个数如表示显示前三个数据就是显示后几个数据输出去重后的数据变成一维数组输出就是判断不为空值和还是有区别的后面会讲的运算法则索引一致的元素进行算术运算否则补空创建输出是直接在里删除的会修改原数据则不会修改原数据可以使用的函数基本是由多个组成的创建的数据部分可以是字典二维数组或其他可转换为的对象如果不提供此参数则创建一个空的是否复制数据默认为表示不复制数据如果设置为则复制输入的数据字典中的变为列索引既然已经有列索引了那后面就只需要指定行索引就可以了定义行号和列号的方法字典定义列号定义行号或和的位置没规定基本属性返回的是里的数据去除了行号和列号的表格返回所有行号返回的是所有列号索引操作取单列中括号中的只能填列号不能填行号取多列注意取多列有俩中括号用于取隐式索引就是没有自己取规定行号是什么是默认的行号若是显式索引不是默认的用这个会报错用于取显式索引也可以用于隐式取单行取多行行列切片操作切片操作中中括号里填的是行号与索引操作相反和的限制与索引的一样里面填的内容和切片的一样前面表示行后面表示列表示的是删去最后一行表示的也是删去最后一行的运算和的运算一样关于运算操作如果不懂的话可以看大杀器之索引和切片的分钟左右附加操作时间类型的转化数据源将某一列设置为行索引该列的名字不会改变原数据应用部分方法还有好多在下面依次出现取数据存数据文件原不会改变若是数据源原始数据就会改变文件在中代表列特例一般都表示行和里的相反布尔值取数据上面那个语句是个判断语句最后输出布尔值只会输出为的那行的那行不会输出计算代表的是的这一列的数据集体下移一位就是原本第一行的的数据下移到第二行的位置是集体上移一位只有时间索引才可以这么切这里的数据没有错只是前面的索引错了代表的是月份所以代表的就是根据月份进行重新取样就是第一行那边乘的应该是上面的在现在这个版本已经不行了逗号分隔值有时也称为字符分隔值因为分隔字符也可以不是逗号其文件以纯文本形式存储表格数据数字和文本语法中的参数非常多需要的话自己去菜鸟查询默认读取第一个表单假设文件中只有一个表单读取后的数据会存储在一个中如果文件中有多个表单可以通过指定来读取特定表单的数据例如加载文件是一个用于读取文件的类它可以处理多个表单并在不重新打开文件的情况下访问其中的数据想要使用上述方法需要先加载文件然后才能使用等是提供的一个类用于将或对象写入文件使用你可以在一个文件中写入多个工作表并且可以更灵活地控制写入过程这是必需的参数指定了要写入的文件的路径或文件对象可以是本地文件路径远程存储路径如链接或已打开的文件对象这是一个可选参数用于指定写入文件的引擎如果为则会自动选择一个可用的引擎默认优先选择如果不可用则选择其他可用引擎常见的引擎包括用于文件提供高级格式化和图表功能用于格式如等这是一个可选参数指定写入文件中日期的格式字符串例如这是一个可选参数指定写入文件中日期时间对象的格式字符串例如这是一个可选参数默认为表示写入模式如果设置为则表示追加模式向现有文件中添加数据仅支持部分引擎如这是一个可选参数用于指定与存储后端连接的额外选项例如认证信息访问权限等适用于写入远程存储如这是一个可选参数默认为指定如果工作表已经存在时的行为选项包括抛出错误创建一个新工作表替换现有工作表的内容在现有工作表上覆盖写入这是一个可选参数用于传递给引擎的其他关键字参数这些参数会传递给相应引擎的函数例如或等常用函数从数据库中读取数据缺失值的清洗缺失值原始数据中会存在缺失值空值有两种丢失数据两种丢失数据区别浮点型的空加任意值都等于空加值会报错在中如果遇到形式的空值会将其强转为类型的空值处理空值的操作判断空值删除覆盖删除方式对空值进行过滤删除空值所在的行数据技术一要用和来显示筛选数据的时候记住使用的是而不是是用来监测的如果某一行中都是则返回有一个就返回需要和搭配二这个没有进行删除只是显示出现了筛选只显示的方式可以直接将缺失的行或列进行删除下面这个最简单但前面的也要会删除缺失值所在的行删除缺失值所在的列覆盖先向前填充再向后填充空值都被覆盖一般情况都选择删除而不是覆盖删除的成本高才选择覆盖向前填充向后填充水平方向的填充竖直方向的填充重复值和异常值的清洗重复值使用代表的是保留重复数据第一次出现的那行保留最后一次出现的代表把所有重复行数据删掉不写的话默认等于异常值没有专用的函数就是用上面学到的方法配合给的条件进行处理这个符号代表取反的级联操作和合并操作这个级联操作行列不同也可以进行就是补空值级联操作不能用进行横向或纵向的拼接外连接当没写的时候默认为外连接就是普通连接补空值内连接只连接索引相同的想要保留输完整性则使用外连接版本以上被废除合并操作级联对应的是表格对表格的拼接合并对应的是数据对数据的合并与整合合并一次只能合并两张表如果两张表大部分的索引都一样那就做级联如果只有局部的索引一样或者都不一样就用合并下面说的几对几合并是一个表格里的数据对另一个表格里的数据是否一一对应一对一合并后面写的是合并条件基于这个合并条件进行合并如果不写的话它就会将两张表中共有的列作为合并条件进行合并一对多合并多对多合并方法里有个参数值叫作它默认为也就是去除了空值所在的行当赋值为时空值所在的行就是出现这里的空值出现是因为两个表中有不能对应的地方这些地方就会为空值而不是可以起到删除空值的作用这个时候代表的时内连接和外连接要保证合并数据的完整性的话就要使用默认为赋值为还有左连接和右连接时代表的是左连接就是保留左表的数据时代表的是右连接保留右表的数据的规范化当有多个列名称相同时需要用来指定哪一个列作为配合指定冲突列名当有列冲突而不去管时此时会将相同的列一起作为来合并指定一列当两张表没有可进行连接的列时可使用和手动指定中的左右两边哪一列作为连接的列没有相同列的表应用返回的是这组数据的原始信息将布尔值作为行索引后取出对应的行数据这个在里面的输出是一个所以可以把这个整体看成是一个原始数据表所以要取出这个表中的列数据是就可以直接变为输出去重后的数据变成一维数组输出函数专门针对做条件查询不用这个函数的话也可以使用条件判断语句原本数据里面没有这一列但赋值一下就相当于是添加了是对值进行排序是对索引排序默认为是升序是降序替换操作代表要替换的元素代表替换成的元素第三个是用法和前面的一样高级操作映射概念创建一个映射关系列表把元素和一个特定的字符串或者标签绑定给一个元素提供不同的表现形式那接下来就可以使用这个标签来表示这元素了是的方法只能通过调用关键字代表自定义一个函数排序实现的随机抽样和和一样表示列表示行上面这是打乱列在打乱列的基础上再打乱行然后再取样那就是随机取样了分组聚合数据分类处理核心函数属性查看分组情况函数只能对数值型数据进行处理所以没对颜色求均值这个因为没指定对象所以同时对和进行求平均值只对价格求平均值想要将对应的平均重量赋给对应的颜色后面直接添加添加不了那就是给分别绑定对应的重量也就是映射里面放的是映射关系表映射关系表就是字典的方法将转化为字典而返回的正好是没看懂那个函数是怎么用的返回的是经过映射的结果但返回的不是经过映射的结果经过映射的可以直接汇总到原本的数据中',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-23 22:38:06',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">coygOdegaard</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 1.05rem;">大数据<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>4</sup></a><a href="/tags/%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">语言<sup>3</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">11</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>大数据</span></a></span></div></div><h1 class="post-title" itemprop="name headline">数据清洗</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-10-08T08:02:29.000Z" title="发表于 2024-10-08 16:02:29">2024-10-08</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-06-23T14:38:06.982Z" title="更新于 2025-06-23 22:38:06">2025-06-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/10/08/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"><header><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" tabindex="-1" itemprop="url">大数据</a><h1 id="CrawlerTitle" itemprop="name headline">数据清洗</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Odegaard</span><time itemprop="dateCreated datePublished" datetime="2024-10-08T08:02:29.000Z" title="发表于 2024-10-08 16:02:29">2024-10-08</time><time itemprop="dateCreated datePublished" datetime="2025-06-23T14:38:06.982Z" title="更新于 2025-06-23 22:38:06">2025-06-23</time></header><h1 id="什么是数据清洗"><a href="#什么是数据清洗" class="headerlink" title="什么是数据清洗"></a>什么是数据清洗</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241008161309399.png" alt="n"></p>
<p>数据清洗就是将“脏数据”变为“干净的数据”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241008162030445.png" alt="image-20241008162030445"></p>
<p>清洗流程：</p>
<p>数据的读写-&gt;数据的探索与描述-&gt;数据简单处理-&gt;（重复值的处理-&gt;缺失值的处理-&gt;异常值的处理-&gt;文本字符串的处理-&gt;时间格式序列的处理）（后面这五个不是一定要按照这个顺序）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241008163005596.png" alt="image-20241008163005596"></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241008171558890.png" alt="image-20241008171558890"></p>
<p>markdown形式，写笔记就要遵循markdown的要求，不然不能实现。</p>
<p><strong>如果你在运行 Jupyter Notebook 的过程中重启或中断了内核，所有的导入和变量都会被清空。此时你需要重新运行导入语句。</strong></p>
<h1 id="numpy模块"><a href="#numpy模块" class="headerlink" title="numpy模块"></a>numpy模块</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="array"><a href="#array" class="headerlink" title="array()"></a>array()</h3><p>可以将numpy当作一维或多维的数组，重在于数值运算，多用于大型、多维数组上执行的数值运算。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241017153404872.png" alt="image-20241017153404872"></p>
<p><strong>Object</strong>代表的是数据源；<strong>dtype</strong>代表的是某种数据类型，代表的是数据源的数据的类型，如果不写的话，那数据源的数据的类型就默认为它传入是什么类型就是什么类型。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207163358898.png" alt="image-20250207163358898"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207163510509.png" alt="image-20250207163510509"></p>
<p>想要打印某个变量的值不需要写print，直接写变量名就好了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241017153931796.png" alt="image-20241017153931796"></p>
<p>创建数组用的是创建列表的语法，但是因为是数组，所以<strong>元素类型是相同的</strong>，不能像列表那样可以存放不同的数据类型。</p>
<p>优先级：字符串&gt;浮点型&gt;整数</p>
<h3 id="frombuffer-，可转化字符串"><a href="#frombuffer-，可转化字符串" class="headerlink" title="frombuffer()，可转化字符串"></a>frombuffer()，可转化字符串</h3><p>numpy.frombuffer 用于实现动态数组。</p>
<p>numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p>
<pre><code class="hljs plaintext">numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)
注意：buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。
buffer	可以是任意对象，会以流的形式读入。
dtype	返回数组的数据类型，可选
count	读取的数据数量，默认为-1，读取所有数据。
offset	读取的起始位置，默认为0。</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207171004355.png" alt="image-20250207171004355"></p>
<p><code>dtype=&#39;S1&#39;</code> 表示<strong>固定长度的字符串</strong>，其中 <code>S1</code> 代表<strong>每个元素是 1 字节的字符串</strong>（即单个字符）。</p>
<p><code>S1</code> → 每个元素是 1 字节（1 个字符），<code>Sx</code> → 其中 <code>x</code> 是字符串的最大长度</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207171100749.png" alt="image-20250207171100749"></p>
<h3 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207164553766.png" alt="image-20250207164553766"></p>
<h3 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241017160139601.png" alt="image-20241017160139601"></p>
<pre><code class="hljs plaintext">plt.read(&#x27;7.jpg&#x27;)</code></pre>

<p>读取图片数据后会将数据存储在一个numpy数组中，单引号里面填写图片路径。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241020165012942.png" alt="image-20241020165012942"></p>
<pre><code class="hljs plaintext">import matplotlib.pyplot as plt
img_arr = plt.imread(&#x27;./7.jpg&#x27;) #数组中装载的就是图片内容
plt.imshow(img_arr) #将numpy数组进行可视化展示</code></pre>

<p>这个图片展示单从内容上讲，不如前面那个方法。</p>
<pre><code class="hljs plaintext">img_arr = img_arr - 100 #数组名减去一个数代表这个数组里的全部数据都减去那个数</code></pre>

<h3 id="zero-ones-linspace-arange-random系列"><a href="#zero-ones-linspace-arange-random系列" class="headerlink" title="zero(),ones(),linspace(),arange(),random系列"></a>zero(),ones(),linspace(),arange(),random系列</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241020165857076.png" alt="image-20241020165857076"></p>
<p>以上几个方法都是创建数组的。</p>
<p>zero()代表初始数据为0，ones()代表初始数据为1；不是linespace，是linspace。</p>
<pre><code class="hljs plaintext">numpy.zeros(shape, dtype = float, order = &#x27;C&#x27;)
shape	数组形状
dtype	数据类型，可选，默认为浮点数
order	&#x27;C&#x27; 用于 C 的行数组，或者 &#x27;F&#x27; 用于 FORTRAN 的列数组</code></pre>

<pre><code class="hljs plaintext">np.zeros(shape = (3,4)) # shape代表的是要创建的数组大小，(3,4)就是三行四列</code></pre>

<pre><code class="hljs plaintext">numpy.ones(shape, dtype = None, order = &#x27;C&#x27;)默认为浮点数</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241020171120344.png" alt="image-20241020171120344"></p>
<p>“size&#x3D;”不一定要写。</p>
<pre><code class="hljs plaintext">np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)
start	序列的起始值
stop	序列的终止值，如果endpoint为true，该值包含于数列中
num		要生成的等步长的样本数量，默认为50
endpoint	该值为 true 时，数列中包含stop值，反之不包含，默认是True。
retstep	如果为 True 时，生成的数组中会显示间距，反之不显示。
dtype	ndarray 的数据类型</code></pre>

<p><code>np.linspace(start, stop, num)</code> 的作用是生成一个从 <code>start</code> 到 <code>stop</code>（包括 <code>start</code> 和 <code>stop</code>）的等差数列，包含 <code>num</code> 个元素。<code>np.linspace(0, 100, num=20)</code> 生成的是一个等差数列，从 <code>0</code> 到 <code>100</code> 之间均匀分布 <strong>20 个点</strong>，包括起点 <code>0</code> 和终点 <code>100</code>。在生成等差数列时，我们需要确定每两个相邻数之间的间隔。希望生成 20 个数，但实际上这个数列可以理解为有 <strong>19 个间隔</strong>，因为 20 个数之间只有 19 个间隔。间隔长度为(100 - 0) &#x2F; (20 - 1) ≈ 5.26315789。</p>
<p><code>np.arange(10,50,step)</code>，step，步长。<code>numpy.arange(start, stop, step, dtype)</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207214929078.png" alt="image-20250207214929078"></p>
<p><code>np.random.randint(start,end,size)</code>，产生一个size大小的DataFrame，元素是start到end的随机数。</p>
<p><code>np.random.random(size)</code>，生成的是size大小范围0-1的DataFrame，可以指定索引。</p>
<h3 id="logspace"><a href="#logspace" class="headerlink" title="logspace()"></a>logspace()</h3><pre><code class="hljs plaintext">np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)
base 参数意思是取对数的时候 log 的下标。
start	序列的起始值为：base ** start
stop	序列的终止值为：base ** stop。如果endpoint为true，该值包含于数列中
num		要生成的等步长的样本数量，默认为50
endpoint	该值为 true 时，数列中中包含stop值，反之不包含，默认是True。
base	对数 log 的底数。
dtype	ndarray 的数据类型</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207171943115.png" alt="image-20250207171943115"></p>
<h2 id="numpy数组的常用属性"><a href="#numpy数组的常用属性" class="headerlink" title="numpy数组的常用属性"></a>numpy数组的常用属性</h2><p>shape,ndim,size,dtype</p>
<p><code>数组名.shape</code>返回的是数组的形状。</p>
<p><code>数组名.ndim</code>返回的是数组的维度。</p>
<p><code>数组名.size</code>返回的是数组的元素个数。</p>
<p><code>数组名.dtype</code>返回的是数组的元素类型。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241020214914911.png" alt="image-20241020214914911"></p>
<p><code>dtype(变量)</code>返回的是变量的类型。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207163207446.png" alt="image-20250207163207446"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207163809862.png" alt="image-20250207163809862"></p>
<h2 id="numpy的索引和切片操作"><a href="#numpy的索引和切片操作" class="headerlink" title="numpy的索引和切片操作"></a>numpy的索引和切片操作</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引操作和列表的索引操作时一样的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241020215302927.png" alt="image-20241020215302927"></p>
<p><strong>整数数组索引</strong>：指使用一个数组来访问另一个数组的元素。这个数组中的每个元素都是目标数组中某个维度上的索引值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207221111954.png" alt="image-20250207221111954"></p>
<p>行索引和列索引是配对的。[0,1,2]用来选择行索引，[0,1,0]用来选择列索引。</p>
<pre><code class="hljs plaintext">x[[0,1,2],[0,1,0]]等于x[0,0],x[1,1],x[2,0]</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207221802238.png" alt="image-20250207221802238"></p>
<p>按照上面那样整数索引以二维数组的形式输入，最后输出结果也是二维数组。</p>
<p>但如果<code>y = x[[0,0,3,3],[0,2,0,2]]</code> ，最后就会输出一维数组<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207222254474.png" alt="image-20250207222254474"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207222808964.png" alt="image-20250207222808964"></p>
<p><strong><code>a[1:3, [1,2]]</code></strong><br>先选择 <strong>行 1 到 2</strong>，再选 <strong>列 1、2</strong>，得到的是一个<strong>子矩阵</strong>。</p>
<p><strong><code>a[[1,2], [1,2]]</code></strong><br>选取的是 <strong>(1,1) 和 (2,2) 位置</strong> 的元素，得到的是一个<strong>一维数组</strong>。</p>
<p>那怎么取第1，3，5行的第2，4，6列的数据呢？</p>
<p>1、使用np.ix_()</p>
<pre><code class="hljs plaintext">import numpy as np

# 创建 8×8 的数组
a = np.arange(64).reshape(8, 8)

# 选取第 1、3、5 行 &amp; 第 2、4、6 列
rows = [1, 3, 5]   # 行索引
cols = [2, 4, 6]   # 列索引

result = a[np.ix_(rows, cols)]
print(result)</code></pre>

<p>2、直接使用 [:, :] 进行花式索引</p>
<pre><code class="hljs plaintext">result = a[[1, 3, 5], :][:, [2, 4, 6]]
print(result)</code></pre>

<p><code>a[[1, 3, 5], :]</code> → 先取出<strong>第 1、3、5 行</strong>，包含所有列。</p>
<p><code>[:, [2, 4, 6]]</code> → 再在选出的子矩阵中取出<strong>第 2、4、6 列</strong>。</p>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>一维数组：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207215349800.png" alt="image-20250207215349800"></p>
<p>冒号 <strong>:</strong> 的解释：如果只放置一个参数，如 **[2]**，将返回与该索引相对应的单个元素。如果为 **[2:]**，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 **[2:7]**，那么则提取两个索引(不包括停止索引)之间的项。</p>
<p>二维数组：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241020215504578.png" alt="image-20241020215504578"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207215727797.png" alt="image-20250207215727797"></p>
<p>[1:]从索引为1的切割到底。</p>
<p>切片还可以包括<strong>省略号 …</strong>，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p>
<p>在 NumPy 中，<code>...</code>（省略号）用于表示<strong>多个冒号（<code>:</code>）</strong>，它的作用是<strong>自动匹配剩余的维度</strong>，以便简化索引操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207220436562.png" alt="image-20250207220436562"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207220509824.png" alt="image-20250207220509824"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207220525783.png" alt="image-20250207220525783"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241020215706883.png" alt="image-20241020215706883"></p>
<p>将图片进行左右翻转，就是该图片的行不变，列倒置。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241020215928312.png" alt="image-20241020215928312"></p>
<p>图片上下翻转，就是图片的行倒置，列不变。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241020220104876.png" alt="image-20241020220104876"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241020220351225.png" alt="image-20241020220351225"></p>
<p>上述关于图片的各种操作就是关于图片的numpy数组的操作。</p>
<h2 id="广播（Broaddcast）"><a href="#广播（Broaddcast）" class="headerlink" title="广播（Broaddcast）"></a>广播（Broaddcast）</h2><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式。</p>
<p>如果两个数组 a 和 b 形状相同，即满足 <strong>a.shape &#x3D;&#x3D; b.shape</strong>，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208114331553.png" alt="image-20250208114331553"></p>
<p>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208114630902.png" alt="image-20250208114630902"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208115018470.png" alt="image-20250208115018470"></p>
<h2 id="迭代数组"><a href="#迭代数组" class="headerlink" title="迭代数组"></a>迭代数组</h2><p>NumPy 迭代器对象 <strong>numpy.nditer</strong> 提供了一种灵活访问一个或者多个数组元素的方式。</p>
<p><code>np.nditer(a)</code> 是 NumPy 提供的<strong>多维数组迭代器</strong>，可以逐元素访问 <code>a</code>。</p>
<p>适用于<strong>任何维度的数组</strong>，而不需要手动写多层 <code>for</code> 循环。</p>
<p><strong>按行优先（C 方式）依次访问数组中的元素</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208155819018.png" alt="image-20250208155819018"></p>
<p>**<code>print(x)</code>**：打印变量 <code>x</code>（这里是 NumPy 数组中的元素）。</p>
<p><strong><code>end=&quot;, &quot;</code><strong>：指定</strong>打印结尾的字符</strong>，原本print()默认是换行 <code>&quot;\n&quot;</code>，但这里改为 <code>&quot;, &quot;</code>（逗号+空格），所以输出在同一行，并且元素之间用 <code>&quot;, &quot;</code> 分隔。</p>
<p>控制遍历顺序：</p>
<ul>
<li><code>for x in np.nditer(a, order=&#39;F&#39;):</code>Fortran order，即是列序优先；</li>
<li><code>for x in np.nditer(a.T, order=&#39;C&#39;):</code>C order，即是行序优先；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208160527323.png" alt="image-20250208160527323"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208162240752.png" alt="image-20250208162240752"></p>
<p>将<code>x[...]=2*x</code> 修改为<code>x=2*x</code>就不能修改原数组了。</p>
<p><code>x[...]</code> 表示 <code>x</code> 仍然是 <code>a</code> 数组的<strong>视图</strong>（view）。</p>
<p><code>x[...] =</code> <strong>不会改变 <code>x</code> 本身的引用，而是修改它所指向的内存中的值</strong>。</p>
<p><code>x = 2 * x</code> 和 <code>x[...] = 2 * x</code> 的<strong>关键区别</strong>在于：</p>
<ul>
<li><code>x[...] =</code> <strong>操作的是 <code>x</code> 所指向的原数组</strong>。</li>
<li><code>x =</code> <strong>创建了一个新的 Python 变量，而不是修改原数组的内存</strong>。</li>
</ul>
<p>在 NumPy 中，<strong>视图（view）</strong> 是指<strong>共享相同数据但具有不同形状或表示方式的数组</strong>。<br><strong>视图不会创建新的数据副本，而是引用原始数组的内存</strong>，因此修改视图的数据会影响原数组，反之亦然。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208163444276.png" alt="image-20250208163444276"></p>
<p>如果两个数组是<strong>可广播</strong>的，nditer 组合对象能够<strong>同时迭代</strong>它们。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208163732611.png" alt="image-20250208163732611"></p>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="修改数组形状"><a href="#修改数组形状" class="headerlink" title="修改数组形状"></a>修改数组形状</h3><p>**数组名.reshape(行，列)**：重新制定形状。一维-&gt;多维；多维-&gt;一维。</p>
<p>reshape(12**,**)和reshape(12)都代表12个元素的一维数组；但是reshape(,12)会报错，不代表1列的数组。</p>
<p>变形前后的<strong>元素数量要一样</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250207163826087.png" alt="image-20250207163826087"></p>
<p><code>numpy.ndarray.flat</code> 是一个数组元素迭代器。不用使用迭代数组也可以一个一个输出元素。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208170733082.png" alt="image-20250208170733082"></p>
<p><code>numpy.ndarray.flatten</code> 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，<strong>返回的始终是一维数组</strong>。</p>
<p><code>ndarray.flatten(order=&#39;C&#39;)</code>，order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208171052827.png" alt="image-20250208171052827"></p>
<p><code>numpy.ravel()</code> 展平的数组元素，顺序通常是”C风格”，返回的是数组<strong>视图</strong>（view），修改会影响原始数组。</p>
<p><code>ndarray.ravel(order=&#39;C&#39;)</code>，用法和flatten一样，也是返回一维数组。</p>
<h3 id="翻转数组"><a href="#翻转数组" class="headerlink" title="翻转数组"></a>翻转数组</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208171758181.png" alt="image-20250208171758181"></p>
<p>后面两个想看自己去菜鸟看。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208171942673.png" alt="image-20250208171942673"></p>
<p><strong>numpy.ndarray.T 类似 numpy.transpose</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208172025127.png" alt="image-20250208172025127"></p>
<h3 id="级联操作（同一维度）"><a href="#级联操作（同一维度）" class="headerlink" title="级联操作（同一维度）"></a>级联操作（同一维度）</h3><p>将多个numpy数组进行横向或纵向的拼接。</p>
<pre><code class="hljs plaintext">import numpy as np
arr = np.array([1,2,3])
arr2 = np.array([4,5,6])
np.concatenate((arr,arr2),axis = 0)</code></pre>

<pre><code class="hljs plaintext">import numpy as np
arr3 = np.random.randint(0,10,size = [2,3])
arr4 = np.random.randint(0,10,size = [2,3])
arr5 = np.concatenate((arr3,arr4),axis = 0)
arr5</code></pre>

<p><code>np.concatenate((要拼接的数组),axis = 如何拼接)</code></p>
<p><code>numpy.concatenate((a1, a2, ...), axis)</code>，<code>a1, a2, ...</code>：相同类型的数组，axis默认为0</p>
<p>对<strong>一维数组</strong>来说，只有axis &#x3D; 0，代表横向拼接。对<strong>二维数组</strong>来说，axis &#x3D; 0 ：纵向(y轴)拼接；axis &#x3D; 1：横向(x轴)拼接。对<strong>三维数组</strong>来说，在承接二维的基础上，axis &#x3D; 2，就是z轴上的拼接。</p>
<p>级联的两个数组维度一样但行列不同怎么办？</p>
<p>在<strong>行相同列不同</strong>的情况上，可以<strong>横向拼接</strong>，不能纵向拼接；在<strong>行不同列相同</strong>的情况下，可以<strong>纵向拼接</strong>，不能横向拼接。</p>
<p>可以用于图片的拼接上。</p>
<h3 id="分割数组"><a href="#分割数组" class="headerlink" title="分割数组"></a>分割数组</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208205923418.png" alt="image-20250208205923418"></p>
<p><code>numpy.split(ary, indices_or_sections, axis)</code></p>
<ul>
<li><code>ary</code>：被分割的数组</li>
<li><code>indices_or_sections</code>：如果是一个整数，就用该数平均切分（需要刚好可以平分成这个数量），如果是一个数组，为沿轴切分的位置（左开右闭）</li>
<li><code>axis</code>：设置沿着哪个方向进行切分，默认为 0，横向切分，即水平方向。为 1 时，纵向切分，即竖直方向。</li>
</ul>
<p>横向分割的意思是假如用一把刀来切分，分割的时候刀是沿水平方向移动的，刀口和竖直方向平行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208210135074-1739019695959-1.png" alt="image-20250208210135074"></p>
<p><strong>axis 为 0 时在水平方向分割，axis 为 1 时在垂直方向分割。</strong></p>
<p><code>numpy.hsplit</code> 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208210654313.png" alt="image-20250208210654313"></p>
<p><code>numpy.vsplit</code> 沿着垂直轴分割，其分割方式与hsplit用法相同。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208211721091.png" alt="image-20250208211721091"></p>
<h3 id="数组元素的添加和删除"><a href="#数组元素的添加和删除" class="headerlink" title="数组元素的添加和删除"></a>数组元素的添加和删除</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208211812393.png" alt="image-20250208211812393"></p>
<p><code>numpy.resize(arr, shape)</code>，如果新数组大小大于原始大小，则包含原始数组中的元素的副本。可以想象成原数组的元素一个一个循环填进新数组中。</p>
<pre><code class="hljs plaintext">import numpy as np
 
a = np.array([[1,2,3],[4,5,6]])
 
print (&#x27;第一个数组：&#x27;)
print (a)
print (&#x27;\n&#x27;)
 
print (&#x27;第一个数组的形状：&#x27;)
print (a.shape)
print (&#x27;\n&#x27;)
b = np.resize(a, (3,2))
 
print (&#x27;第二个数组：&#x27;)
print (b)
print (&#x27;\n&#x27;)
 
print (&#x27;第二个数组的形状：&#x27;)
print (b.shape)
print (&#x27;\n&#x27;)

# 要注意 a 的第一行在 b 中重复出现，因为尺寸变大了 
print (&#x27;修改第二个数组的大小：&#x27;)
b = np.resize(a,(3,3))
print (b)</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208212314743.png" alt="image-20250208212314743"></p>
<p>若是<code>b = np.resize(a,(2,2,2))</code>则输出<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208212437833.png" alt="image-20250208212437833"></p>
<p><code>numpy.append</code> 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的<strong>维度必须匹配</strong>否则将生成ValueError。</p>
<pre><code class="hljs plaintext">numpy.append(arr, values, axis=None)</code></pre>

<ul>
<li><code>arr</code>：输入数组</li>
<li><code>values</code>：要向<code>arr</code>添加的值，需要和<code>arr</code>形状相同（除了要添加的轴）</li>
<li><code>axis</code>：默认为 None。当axis<strong>无定义</strong>时，是横向加成，返回总是为<strong>一维数组</strong>！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（<strong>列数要相同</strong>）。当axis为1时，数组是加在右边（<strong>行数要相同</strong>）。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208213035163.png" alt="image-20250208213035163"></p>
<p><code>numpy.insert</code> 函数<strong>在给定索引之前</strong>，沿给定轴在输入数组中插入值。</p>
<p>函数会在指定位置（或位置数组）插入给定的值或数组，然后<strong>返回新的数组</strong>。被插入的元素可以是标量值，也可以是数组。需要注意的是，插入操作会返回一个新的数组，而不会改变原始数组。</p>
<p><code>numpy.insert(arr, obj, values, axis)</code></p>
<ul>
<li><code>arr</code>：输入数组</li>
<li><code>obj</code>：在其之前插入值的索引</li>
<li><code>values</code>：要插入的值</li>
<li><code>axis</code>：沿着它插入的轴，如果未提供，则输入数组会被展开</li>
</ul>
<pre><code class="hljs plaintext">import numpy as np
 
a = np.array([[1,2],[3,4],[5,6]])
 
print (&#x27;第一个数组：&#x27;)
print (a)
print (&#x27;\n&#x27;)
 
print (&#x27;未传递 Axis 参数。 在删除之前输入数组会被展开。&#x27;)
print (np.insert(a,3,[11,12]))
print (&#x27;\n&#x27;)
print (&#x27;传递了 Axis 参数。 会广播值数组来配输入数组。&#x27;)
 
print (&#x27;沿轴 0 广播：&#x27;)
    print (np.insert(a,1,[11],axis = 0))
print (&#x27;\n&#x27;)
 
print (&#x27;沿轴 1 广播：&#x27;)
print (np.insert(a,1,11,axis = 1))</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208214031350.png" alt="image-20250208214031350"></p>
<p>当axis&#x3D;0时，以行为单位进行插入；当axis&#x3D;1是，以列为单位进行插入。</p>
<p>要实现广播数组进行插入的前提这个数组可以广播。</p>
<p><code>numpy.delete</code> 函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。</p>
<pre><code class="hljs plaintext">Numpy.delete(arr, obj, axis)</code></pre>

<ul>
<li><code>arr</code>：输入数组</li>
<li><code>obj</code>：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</li>
<li><code>axis</code>：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208214751293.png" alt="image-20250208214751293"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250208214801277.png" alt="image-20250208214801277"></p>
<p><code>numpy.unique</code> 函数用于去除数组中的重复元素。</p>
<p><code>numpy.unique(arr, return_index, return_inverse, return_counts)</code></p>
<ul>
<li><code>arr</code>：输入数组，如果不是一维数组则会展开</li>
<li><code>return_index</code>：如果为<code>true</code>，返回新列表元素在旧列表中的位置（下标），并以列表形式储</li>
<li><code>return_inverse</code>：如果为<code>true</code>，返回旧列表元素在新列表中的位置（下标），并以列表形式储</li>
<li><code>return_counts</code>：如果为<code>true</code>，返回去重数组中的元素在原数组中的出现次数</li>
</ul>
<p>这个函数返回的去重后的数组同时也完成了排序。</p>
<pre><code class="hljs plaintext">import numpy as np
 
a = np.array([5,2,6,2,7,5,6,8,2,9])
 
print (&#x27;第一个数组：&#x27;)
print (a)
print (&#x27;\n&#x27;)
 
print (&#x27;第一个数组的去重值：&#x27;)
u = np.unique(a)
print (u)
print (&#x27;\n&#x27;)
 
print (&#x27;去重数组的索引数组：&#x27;)
u,indices = np.unique(a, return_index = True)
print (indices)
print (&#x27;\n&#x27;)
 
print (&#x27;我们可以看到每个和原数组下标对应的数值：&#x27;)
print (a)
print (&#x27;\n&#x27;)
 
print (&#x27;去重数组的下标：&#x27;)
u,indices = np.unique(a,return_inverse = True)
print (u)
print (&#x27;\n&#x27;)
 
print (&#x27;下标为：&#x27;)
print (indices)
print (&#x27;\n&#x27;)
 
print (&#x27;使用下标重构原数组：&#x27;)
print (u[indices])
print (&#x27;\n&#x27;)
 
print (&#x27;返回去重元素的重复数量：&#x27;)
u,indices = np.unique(a,return_counts = True)
print (u)
print (indices)</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209113611236.png" alt="image-20250209113611236"></p>
<p>为什么<code>u,indices = np.unique(a, return_index = True)</code>可以同时给两个赋值且值还不同？</p>
<p>因为此时这个函数会返回去重后的数组 <code>u</code>（按排序后的唯一值），返回 <code>indices</code>，它是原数组中每个唯一值第一次出现的索引。它会同时返回两个值，这是python函数中的多返回值机制，如<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209113855801.png" alt="image-20250209113855801"></p>
<h2 id="常用的函数"><a href="#常用的函数" class="headerlink" title="常用的函数"></a>常用的函数</h2><h3 id="算术函数"><a href="#算术函数" class="headerlink" title="算术函数"></a>算术函数</h3><p><strong>sum,max,min,mean</strong></p>
<p><code>数组名.sum()</code>：求出该数组所有元素的和。<code>数组名.sum(axis = 0/1)</code>：每列或每行的和。</p>
<p><code>np.sum([数据源],axis = 0/1)</code></p>
<p>后面几个函数的用法和sum一样。</p>
<p>mean求的是算术平均值。</p>
<p>NumPy 算术函数包含简单的加减乘除: <strong>add()<strong>，</strong>subtract()<strong>，</strong>multiply()</strong> 和 **divide()**。</p>
<p>需要注意的是数组必须<strong>具有相同的形状或符合数组广播规则</strong>。</p>
<p><code>numpy.reciprocal()</code> 函数返回参数<strong>逐元素</strong>的<strong>倒数</strong>。如 <strong>1&#x2F;4</strong> 倒数为 <strong>4&#x2F;1</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209115805828.png" alt="image-20250209115805828"></p>
<p><code>numpy.power()</code> 函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中<strong>相应</strong>元素的幂。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209115907058.png" alt="image-20250209115907058"></p>
<p>如果第二个元素只有一个数的话，那第一个元素的全部数的幂就是第二个元素的值。</p>
<p><code>numpy.mod()</code> 计算输入数组中相应元素的相除后的<strong>余数</strong>。 函数 numpy.remainder() 也产生相同的结果。</p>
<pre><code class="hljs plaintext">numpy.mod(被除数，除数)</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209212406356.png" alt="image-20250209212406356"></p>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241023172507743.png" alt="image-20241023172507743"></p>
<p>sin，对数组的每个元素都求sin。()里面也可以直接指定一个数，如：<code>np.sin(2.5)</code></p>
<p>这些函数计算使用的都是弧度制，所以要将角度转化为弧度就要<strong>通过乘 pi&#x2F;180 转化为弧度</strong>。</p>
<pre><code class="hljs plaintext">import numpy as np
 
a = np.array([0,30,45,60,90])
print (&#x27;不同角度的正弦值：&#x27;)
# 通过乘 pi/180 转化为弧度  
print (np.sin(a*np.pi/180))
print (&#x27;\n&#x27;)</code></pre>

<p>​	<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209114628152.png" alt="image-20250209114628152"></p>
<p>arcsin，arccos，和 arctan 函数返回给定角度的 sin，cos 和 tan 的反三角函数，但这三个函数返回的不是角度而是弧度。这些函数的结果可以通过 <code>numpy.degrees()</code> 函数将弧度转换为角度。</p>
<pre><code class="hljs plaintext">import numpy as np
 
a = np.array([0,30,45,60,90])  
print (&#x27;含有正弦值的数组：&#x27;)
sin = np.sin(a*np.pi/180)  
print (sin)
print (&#x27;\n&#x27;)
print (&#x27;计算角度的反正弦，返回值以弧度为单位：&#x27;)
inv = np.arcsin(sin)  
print (inv)
print (&#x27;\n&#x27;)
print (&#x27;通过转化为角度制来检查结果：&#x27;)
print (np.degrees(inv))
print (&#x27;\n&#x27;)</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209115237438.png" alt="image-20250209115237438"></p>
<p>当decimal为负数的时候，四舍五入的位置开始向左移动。</p>
<p><code>numpy.floor()</code> 返回小于或者等于指定表达式的最大整数，即向下取整。</p>
<p><code>numpy.ceil()</code> 返回大于或者等于指定表达式的最小整数，即向上取整。</p>
<p>这两个函数参数就是数组。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241023172851161.png" alt="image-20241023172851161"></p>
<p>amin和amax的操作和上面的min和max是一样的。</p>
<p>np,ptp(数组,axis)</p>
<pre><code class="hljs plaintext"># arr.std()
arr5 = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(arr5.std())
print(arr5[1].std())</code></pre>

<p>方差和标准差用法一样。</p>
<h3 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><p><code>numpy.amin()</code> 用于计算数组中的元素沿指定轴的最小值。</p>
<pre><code class="hljs plaintext">numpy.amin(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</code></pre>

<ul>
<li><code>a</code>: 输入的数组，可以是一个NumPy数组或类似数组的对象。</li>
<li><code>axis</code>: 可选参数，用于指定在哪个轴上计算最小值。如果不提供此参数，则返回整个数组的最小值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴。</li>
<li><code>out</code>: 可选参数，用于指定结果的存储位置。</li>
<li><code>keepdims</code>: 可选参数，如果为True，将保持结果数组的维度数目与输入数组相同。如果为False（默认值），则会去除计算后维度为1的轴。</li>
<li><code>initial</code>: 可选参数，用于指定一个初始值，然后在数组的元素上计算最小值。</li>
<li><code>where</code>: 可选参数，一个布尔数组，用于指定仅考虑满足条件的元素。</li>
</ul>
<p>initial部分是提供一个初始值，防止使用这个函数是遇到空数组导致报错，假如是空数组的话，那最后会返回initial的值。</p>
<p><code>numpy.amax()</code> 用于计算数组中的元素沿指定轴的最大值。</p>
<pre><code class="hljs plaintext">numpy.amax(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</code></pre>

<pre><code class="hljs plaintext">import numpy as np 
 
a = np.array([[3,7,5],[8,4,3],[2,4,9]])  
print (&#x27;我们的数组是：&#x27;)
print (a)
print (&#x27;\n&#x27;)
print (&#x27;调用 amin() 函数：&#x27;)
print (np.amin(a,1))
print (&#x27;\n&#x27;)
print (&#x27;再次调用 amin() 函数：&#x27;)
print (np.amin(a,0))
print (&#x27;\n&#x27;)
print (&#x27;调用 amax() 函数：&#x27;)
print (np.amax(a))
print (&#x27;\n&#x27;)
print (&#x27;再次调用 amax() 函数：&#x27;)
print (np.amax(a, axis =  0))</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209123026294.png" alt="image-20250209123026294"></p>
<p><strong>numpy.ptp()</strong> 函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p>
<pre><code class="hljs plaintext">numpy.ptp(a, axis=None, out=None, keepdims=&lt;no value&gt;, where=&lt;no value&gt;)</code></pre>

<ul>
<li><code>a</code>: 输入的数组，可以是一个 NumPy 数组或类似数组的对象。</li>
<li><code>axis</code>: 可选参数，用于指定在哪个轴上计算峰-峰值。如果不提供此参数，则返回整个数组的峰-峰值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴。</li>
<li><code>out</code>: 可选参数，用于指定结果的存储位置。</li>
<li><code>keepdims</code>: 可选参数，如果为 True，将保持结果数组的维度数目与输入数组相同。如果为 False（默认值），则会去除计算后维度为1的轴。</li>
<li><code>where</code>: 可选参数，一个布尔数组，用于指定仅考虑满足条件的元素。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209123846267.png" alt="image-20250209123846267"></p>
<p>百分位数是统计中使用的度量，表示<strong>小于这个值</strong>的观察值的百分比。</p>
<pre><code class="hljs plaintext">numpy.percentile(a, q, axis)</code></pre>

<ul>
<li>a: 输入数组</li>
<li>q: 要计算的百分位数，在 0 ~ 100 之间</li>
<li>axis: 沿着它计算百分位数的轴</li>
</ul>
<p>第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。</p>
<p>举个例子：高等院校的入学考试成绩经常以百分位数的形式报告。比如，假设某个考生在入学考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。</p>
<p>这里的 p &#x3D; 70。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209124221500.png" alt="image-20250209124221500"></p>
<p><code>numpy.median()</code> 函数用于计算数组 a 中元素的中位数（中值）。也可以使用percentile函数，当百分位数为50就可以。</p>
<pre><code class="hljs plaintext">numpy.median(a, axis=None, out=None, overwrite_input=False, keepdims=&lt;no value&gt;)</code></pre>

<ul>
<li><code>overwrite_input</code>: 可选参数，如果为True，则允许在计算中使用输入数组的内存。这可能会在某些情况下提高性能，但可能会修改输入数组的内容。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209124750016.png" alt="image-20250209124750016"></p>
<pre><code class="hljs plaintext">算术平均值：numpy.mean(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)
标准差：numpy.std(ndarry)
方差：numpy.var(ndarry)</code></pre>

<p><code>numpy.average()</code> 函数根据在另一个数组中给出的各自的权重计算数组中元素的<strong>加权平均值</strong>。</p>
<p>加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。</p>
<p>考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。</p>
<pre><code class="hljs plaintext">加权平均值 = (1*4+2*3+3*2+4*1)/(4+3+2+1)</code></pre>

<pre><code class="hljs plaintext">numpy.average(a, axis=None, weights=None, returned=False)</code></pre>

<ul>
<li><code>a</code>: 输入的数组，可以是一个 NumPy 数组或类似数组的对象。</li>
<li><code>axis</code>: 可选参数，用于指定在哪个轴上计算加权平均值。如果不提供此参数，则计算整个数组的加权平均值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴。</li>
<li><code>weights</code>: 可选参数，用于指定对应数据点的权重。如果不提供权重数组，则默认为等权重。</li>
<li><code>returned</code>: 可选参数，如果为True，将同时返回加权平均值和权重总和。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209185849829.png" alt="image-20250209185849829"></p>
<h3 id="排序，条件筛选函数"><a href="#排序，条件筛选函数" class="headerlink" title="排序，条件筛选函数"></a>排序，条件筛选函数</h3><p><code>numpy.sort()</code> 函数返回输入数组的排序副本。</p>
<pre><code class="hljs plaintext">numpy.sort(a, axis, kind, order)</code></pre>

<ul>
<li>a: 要排序的数组</li>
<li>axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis&#x3D;0 按列排序，axis&#x3D;1 按行排序</li>
<li>kind: 默认为’quicksort’（快速排序）</li>
<li>order: 如果数组包含字段，则是要排序的字段</li>
</ul>
<p>可以通过控制order的内容来控制排序。</p>
<pre><code class="hljs plaintext">import numpy as np  
 
a = np.array([[3,7],[9,1]])  
print (&#x27;我们的数组是：&#x27;)
print (a)
print (&#x27;\n&#x27;)
print (&#x27;调用 sort() 函数：&#x27;)
print (np.sort(a))
print (&#x27;\n&#x27;)
print (&#x27;按列排序：&#x27;)
print (np.sort(a, axis =  0))
print (&#x27;\n&#x27;)
# 在 sort 函数中排序字段 
dt = np.dtype([(&#x27;name&#x27;,  &#x27;S10&#x27;),(&#x27;age&#x27;,  int)]) 
a = np.array([(&quot;raju&quot;,21),(&quot;anil&quot;,25),(&quot;ravi&quot;,  17),  (&quot;amar&quot;,27)], dtype = dt)  
print (&#x27;我们的数组是：&#x27;)
print (a)
print (&#x27;\n&#x27;)
print (&#x27;按 name 排序：&#x27;)
print (np.sort(a, order =  &#x27;name&#x27;))</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209191202420.png" alt="image-20250209191202420"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209191219146.png" alt="image-20250209191219146"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209191241694.png" alt="image-20250209191241694"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209191311103.png" alt="image-20250209191311103"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209191324958.png" alt="image-20250209191324958"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209191334485.png" alt="image-20250209191334485"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209191345976.png" alt="image-20250209191345976"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209191359329.png" alt="image-20250209191359329"></p>
<p><code>numpy.argsort()</code> 函数返回的是数组值从小到大的索引值。</p>
<pre><code class="hljs plaintext">import numpy as np 
 
x = np.array([3,  1,  2])  
print (&#x27;我们的数组是：&#x27;)
print (x)
print (&#x27;\n&#x27;)
print (&#x27;对 x 调用 argsort() 函数：&#x27;)
y = np.argsort(x)  
print (y)
print (&#x27;\n&#x27;)
print (&#x27;以排序后的顺序重构原数组：&#x27;)
print (x[y])</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209192006531.png" alt="image-20250209192006531"></p>
<p>argsort()函数也可以用于多维数组，假如用于二维数组的话，如下图：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209211521281.png" alt="image-20250209211521281"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209211701662.png" alt="image-20250209211701662"></p>
<p>为什么是要在列方向上进行排序呢？因为<strong>返回的索引是每一行里各个元素的列索引</strong>，axis&#x3D;1就代表要按照 y 提供的列索引顺序对每一行进行重排。</p>
<p><code>numpy.lexsort()</code> 用于对多个序列进行排序。返回的也是索引。</p>
<p>把它想象成对电子表格进行排序，每一列代表一个序列，<strong>排序时优先照顾靠后的列</strong>。</p>
<p>这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209205456459.png" alt="image-20250209205456459"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209205553739.png" alt="image-20250209205553739"></p>
<p><code>nm[i] + &quot;, &quot; + dv[i]</code> 会拼接成字符串。</p>
<p>因为使用了列表推导式，所以print里面的方括号不能去掉。</p>
<p><code>numpy.argmax()</code> 和 <code>numpy.argmin()</code>函数分别沿给定轴返回最大和最小元素的索引，没给 axis 赋值的话返回的索引是原数组张开后的索引，想要直接用的话需要将原数组张开后(flatten)调用，这两个函数的参数是<code>(ndarry,axis)</code>。</p>
<p><code>numpy.nonzero()</code> 函数返回输入数组中非零元素的索引。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209210406521.png" alt="image-20250209210406521"></p>
<p><code>numpy.where()</code> 函数返回输入数组中满足给定条件的元素的索引。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209210450077.png" alt="image-20250209210450077"></p>
<p><code>numpy.extract()</code> 函数根据某个条件从数组中抽取元素，返回满条件的元素。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209212210522.png" alt="image-20250209212210522"></p>
<h2 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241023173758732.png" alt="image-20241023173758732"></p>
<p><code>np.matrixlib.identity(6)</code>没有这个功能了。</p>
<p>推荐直接用 <code>np.identity(6)</code>或者<code>np.eye(6)</code>来创建单位矩阵，6 代表矩阵大小，6行6列。</p>
<p><strong>转置矩阵</strong></p>
<p>T</p>
<pre><code class="hljs plaintext">arr.T
np.eye(3).T</code></pre>

<p><strong>矩阵相乘</strong></p>
<p>numpy.dot(a,b,out &#x3D; None)</p>
<p>a：ndarray数组；b：ndarray数组</p>
<h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><p>numpy处理数值型的数据，pandas处理数值型之外的数据。</p>
<h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116211840457.png" alt="image-20241116211840457"> </p>
<p>Series(数据源，索引，数据类型)</p>
<pre><code class="hljs plaintext">from pandas import Series
a = Series(data = [1,2,3,&#x27;four&#x27;]) #a = Series([1,2,3,&#x27;four&#x27;])
a</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116213754628.png" alt="image-20241116213754628"></p>
<p>没有写index的，序号就默认为“0，1，2，3……”</p>
<pre><code class="hljs plaintext">pandas.Series(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)</code></pre>

<ul>
<li><code>data</code>：Series 的数据部分，可以是列表、数组、字典、标量值等。如果不提供此参数，则创建一个空的 Series。</li>
<li><code>index</code>：Series 的索引部分，用于对数据进行标记。可以是列表、数组、索引对象等。如果不提供此参数，则创建一个默认的整数索引。</li>
<li><code>dtype</code>：指定 Series 的数据类型。可以是 NumPy 的数据类型，例如 <code>np.int64</code>、<code>np.float64</code> 等。如果不提供此参数，则根据数据自动推断数据类型。</li>
<li><code>name</code>：Series 的名称，用于标识 Series 对象。如果提供了此参数，则创建的 Series 对象将具有指定的名称。</li>
<li><code>copy</code>：是否复制数据。默认为 False，表示不复制数据。如果设置为 True，则复制输入的数据。</li>
<li><code>fastpath</code>：是否启用快速路径。默认为 False。启用快速路径可能会在某些情况下提高性能。</li>
</ul>
<p>通过Series对象建立Series：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209220317686.png" alt="image-20250209220317686"></p>
<p>可以指定这个Series对象的名称。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209215347691.png" alt="image-20250209215347691"></p>
<p>括号里面只能写data，不能用其他的，或者直接不写，只需将数据传入就行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116214459360.png" alt="image-20241116214459360"></p>
<p><strong>定义索引后依旧可以使用默认索引。</strong></p>
<p>使用字典充当数据源</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116214610438.png" alt="image-20241116214610438"></p>
<p>索引和切片的使用与前面的差不多。</p>
<p>不过切片会一起显示前面的序号，索引不会。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116214857710.png" alt="image-20241116214857710"></p>
<p>shape和size和前面的一样，分别显示形状和个数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116215025869.png" alt="image-20241116215025869"></p>
<p>dtype返回的是数据类型，返回Object说明Series也只能存储同一种类型的数据。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116215259800.png" alt="image-20241116215259800"></p>
<p>上面的后四个表示加减乘除，可以使用上面的方法来进行，也可以直接使用运算符。</p>
<p>head()显示前几个数据，默认是5，可以指定要显示的个数，如：s.head(3)，表示显示前三个数据。</p>
<p>tail()就是显示后几个数据。</p>
<p>s.unique()，输出去重后的数据，变成一维数组输出。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116215650054.png" alt="image-20241116215650054"></p>
<p>notnull()就是判断不为空值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116215852825.png" alt="image-20241116215852825"></p>
<p>NaN和null还是有区别的，后面会讲。</p>
<p><strong>Series的运算法则：索引一致的元素进行算术运算否则补空。</strong></p>
<pre><code class="hljs plaintext">import pandas as pd

# 创建 Series
data = [1, 2, 3, 4, 5, 6]
index = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]
s = pd.Series(data, index=index)</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209220732464.png" alt="image-20250209220732464"></p>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209220752753.png" alt="image-20250209220752753"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209221148480.png" alt="image-20250209221148480"></p>
<p><code>del</code>是直接在Series里删除的，会修改原数据；drop则不会修改原数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209221526427.png" alt="image-20250209221526427"></p>
<p>可以使用numpy的函数。</p>
<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><h3 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h3><p>DataFrame是由多个Series组成的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116220639074.png" alt="image-20241116220639074"></p>
<p><strong>创建：</strong><code>pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False)</code></p>
<ul>
<li><p><code>data</code>：DataFrame 的数据部分，可以是字典、二维数组、Series、DataFrame 或其他可转换为 DataFrame 的对象。如果不提供此参数，则创建一个空的 DataFrame。</p>
</li>
<li><p><code>copy</code>：是否复制数据。默认为 False，表示不复制数据。如果设置为 True，则复制输入的数据。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116220819883.png" alt="image-20241116220819883"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250210105649202.png" alt="image-20250210105649202"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116220907164.png" alt="image-20241116220907164"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250210105900866.png" alt="image-20250210105900866"></p>
<p>字典中的key变为列索引，既然已经有列索引了，那后面就只需要指定行索引（index）就可以了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116221042780.png" alt="image-20241116221042780"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250210110640124.png" alt="image-20250210110640124"></p>
<p>​	<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241116221950940.png" alt="image-20241116221950940"></p>
<p>定义行号和列号的方法：字典定义列号，index定义行号</p>
<pre><code class="hljs plaintext">import pandas as pd

df = pd.DataFrame(&#123;&#x27;A&#x27;: [11, 21, 31],
                   &#x27;B&#x27;: [12, 22, 32],
                   &#x27;C&#x27;: [13, 23, 33]&#125;,
                  index=[&#x27;ONE&#x27;, &#x27;TWO&#x27;, &#x27;THREE&#x27;])

print(df)
#         A   B   C
# ONE    11  12  13
# TWO    21  22  23
# THREE  31  32  33</code></pre>

<p>或</p>
<pre><code class="hljs plaintext">from pandas import DataFrame
df = DataFrame(data = [[1,2,3],[1,2,3]],index = [&#x27;a&#x27;,&#x27;b&#x27;],columns = [&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;])
df</code></pre>

<p>index和columns的位置没规定。</p>
<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><p><strong>values，columns，index，shape</strong></p>
<p>values返回的是DataFrame里的数据（去除了行号和列号的表格）</p>
<p>index返回所有行号，colums返回的是所有列号。</p>
<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><pre><code class="hljs plaintext">df[&#x27;d&#x27;] # 取单列，中括号中的只能填列号，不能填行号
df[[&#x27;d&#x27;,&#x27;e&#x27;]] # 取多列</code></pre>

<p>注意取多列有俩中括号。</p>
<pre><code class="hljs plaintext"># iloc：用于取隐式索引（就是没有自己取规定行号是什么，是默认的行号），若是显式索引（不是默认的）用这个会报错
# loc：用于取显式索引，也可以用于隐式
df.loc[&#x27;a&#x27;] # 取单行
df.loc[[&#x27;a&#x27;,&#x27;b&#x27;]] # 取多行
# loc[行,列]</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117164941477.png" alt="image-20241117164941477"></p>
<h3 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117165149851.png" alt="image-20241117165149851"></p>
<p>切片操作中中括号里填的是行号，<strong>与索引操作相反</strong>，iloc和loc的限制与索引的一样，里面填的内容和numpy切片的一样，前面表示行，后面表示列。</p>
<pre><code class="hljs plaintext">df[:-1] # 表示的是删去最后一行
df.iloc[:-1] # 表示的也是删去最后一行</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117170002025.png" alt="image-20241117170002025"></p>
<p><strong>DataFrame的运算和Series的运算一样。</strong></p>
<p>关于运算操作如果不懂的话可以看<code>df大杀器之索引和切片</code>的17分钟左右。</p>
<h3 id="附加操作，时间类型的转化"><a href="#附加操作，时间类型的转化" class="headerlink" title="附加操作，时间类型的转化"></a>附加操作，时间类型的转化</h3><p><code>pd.to_datatime(数据源)</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117171137698.png" alt="image-20241117171137698"></p>
<p>将某一列设置为行索引：<code>df.set_index(该列的名字)</code>，<strong>不会改变原数据</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117171612645.png" alt="image-20241117171612645"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h4><p>还有好多在下面依次出现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250210111308171.png" alt="image-20250210111308171"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250210111336169.png" alt="image-20250210111336169"></p>
<h4 id="取数据，存数据，csv文件"><a href="#取数据，存数据，csv文件" class="headerlink" title="取数据，存数据，csv文件"></a>取数据，存数据，csv文件</h4><p>原DataFrame不会改变，若是<code>pd.to_datatime(数据源,inplace = True)</code>原始数据就会改变。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117192232217.png" alt="image-20241117192232217"></p>
<h4 id="excel文件"><a href="#excel文件" class="headerlink" title="excel文件"></a>excel文件</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250122172513586.png" alt="image-20250122172513586"></p>
<h4 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117192358861.png" alt="image-20241117192358861"></p>
<p>在drop()中，axis&#x3D;1代表列（特例，一般都表示行），和numpy里的相反。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117222704823.png" alt="image-20241117222704823"></p>
<h4 id="布尔值取数据"><a href="#布尔值取数据" class="headerlink" title="布尔值取数据"></a>布尔值取数据</h4><p>上面那个语句是个判断语句，最后输出布尔值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117223032337.png" alt="image-20241117223032337"></p>
<p>只会输出为True的那行，False的那行不会输出。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117223215097.png" alt="image-20241117223215097"></p>
<h4 id="shift，计算"><a href="#shift，计算" class="headerlink" title="shift，计算"></a>shift，计算</h4><p><code>df[&#39;close&#39;].shift(1)	</code>代表的是df的close这一列的数据集体下移一位，就是原本第一行的close的数据下移到第二行的close位置。</p>
<p><code>df[&#39;close&#39;].shift(-1)</code>是集体上移一位。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117223713222.png" alt="image-20241117223713222"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117223839106.png" alt="image-20241117223839106"></p>
<p><code>df[&#39;2010-01&#39;:&#39;2020-02&#39;]</code>只有时间索引才可以这么切。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117224856759.png" alt="image-20241117224856759"></p>
<h4 id="resample"><a href="#resample" class="headerlink" title="resample"></a>resample</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117224921880.png" alt="image-20241117224921880"></p>
<p>这里的数据没有错，只是前面的索引错了。</p>
<p>“M”代表的是月份，所以resample(‘M’)代表的就是根据月份进行重新取样，first就是第一行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117225428585.png" alt="image-20241117225428585"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117230315354.png" alt="image-20241117230315354"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117230845024.png" alt="image-20241117230845024"></p>
<p>resv那边乘的应该是1000。</p>
<p>上面的<code>new_df[&#39;close&#39;][-1]</code>在现在这个版本已经不行了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117231532452.png" alt="image-20241117231532452"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241117231542220.png" alt="image-20241117231542220"></p>
<h2 id="Pandas-CSV"><a href="#Pandas-CSV" class="headerlink" title="Pandas CSV"></a>Pandas CSV</h2><p>CSV（Comma-Separated Values，逗号分隔值，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212145557040.png" alt="image-20250212145557040"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212145650419.png" alt="image-20250212145650419"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212145701853.png" alt="image-20250212145701853"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212145944079.png" alt="image-20250212145944079"></p>
<h2 id="Pandas-Excel"><a href="#Pandas-Excel" class="headerlink" title="Pandas Excel"></a>Pandas Excel</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212150138045.png" alt="image-20250212150138045"></p>
<p>语法中的参数非常多，需要的话自己去菜鸟查询。</p>
<p>read_excel 默认读取第一个表单（sheet_name&#x3D;0），假设 data.xlsx 文件中只有一个表单，读取后的数据会存储在一个 DataFrame 中。</p>
<p>如果 data.xlsx 文件中有<strong>多个表单</strong>，可以通过指定 <strong>sheet_name</strong> 来读取特定表单的数据，例如 <code>pd.read_excel(&#39;data.xlsx&#39;, sheet_name=&#39;Sheet1&#39;)。</code></p>
<p><code>ExcelFile</code> - 加载 Excel 文件。</p>
<p><code>ExcelFile</code> 是一个用于读取 Excel 文件的类，它可以处理多个表单，并在不重新打开文件的情况下访问其中的数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212150720143.png" alt="image-20250212150720143"></p>
<p>想要使用上述方法，需要先加载Excel文件，然后才能使用sheet_names等。</p>
<p><code>ExcelWriter</code> 是 pandas 提供的一个类，用于将 DataFrame 或 Series 对象写入 Excel 文件。使用 ExcelWriter，你可以在一个 Excel 文件中<strong>写入多个工作表</strong>，并且可以更灵活地控制写入过程。</p>
<pre><code class="hljs plaintext">pandas.ExcelWriter(path, engine=None, date_format=None, datetime_format=None, mode=&#x27;w&#x27;, storage_options=None, if_sheet_exists=None, engine_kwargs=None)</code></pre>

<ul>
<li><code>path</code>：这是必需的参数，指定了要写入的 Excel 文件的路径、URL 或文件对象。可以是本地文件路径、远程存储路径（如 S3）、URL 链接或已打开的文件对象。</li>
<li><code>engine</code>：这是一个可选参数，用于指定写入 Excel 文件的引擎。如果为 <code>None</code>，则 pandas 会自动选择一个可用的引擎（默认优先选择 <code>openpyxl</code>，如果不可用则选择其他可用引擎）。常见的引擎包括 <code>&#39;openpyxl&#39;</code>（用于 <code>.xlsx</code> 文件）、<code>&#39;xlsxwriter&#39;</code>（提供高级格式化和图表功能）、<code>&#39;odf&#39;</code>（用于 OpenDocument 格式如 <code>.ods</code>）等。</li>
<li><code>date_format</code>：这是一个可选参数，指定写入 Excel 文件中日期的格式字符串，例如 <code>&quot;YYYY-MM-DD&quot;</code>。</li>
<li><code>datetime_format</code>：这是一个可选参数，指定写入 Excel 文件中日期时间对象的格式字符串，例如 <code>&quot;YYYY-MM-DD HH:MM:SS&quot;</code>。</li>
<li><code>mode</code>：这是一个可选参数，默认为 <code>&#39;w&#39;</code>，表示写入模式。如果设置为 <code>&#39;a&#39;</code>，则表示追加模式，向现有文件中添加数据（仅支持部分引擎，如 <code>openpyxl</code>）。</li>
<li><code>storage_options</code>：这是一个可选参数，用于指定与存储后端连接的额外选项，例如认证信息、访问权限等，适用于写入远程存储（如 S3、GCS）。</li>
<li><code>if_sheet_exists</code>：这是一个可选参数，默认为 <code>&#39;error&#39;</code>，指定如果工作表已经存在时的行为。选项包括 <code>&#39;error&#39;</code>（抛出错误）、<code>&#39;new&#39;</code>（创建一个新工作表）、<code>&#39;replace&#39;</code>（替换现有工作表的内容）、<code>&#39;overlay&#39;</code>（在现有工作表上覆盖写入）。</li>
<li><code>engine_kwargs</code>：这是一个可选参数，用于传递给引擎的其他关键字参数。这些参数会传递给相应引擎的函数，例如 <code>xlsxwriter.Workbook(file, **engine_kwargs)</code> 或 <code>openpyxl.Workbook(**engine_kwargs)</code> 等。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212151857536.png" alt="image-20250212151857536"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212151928041.png" alt="image-20250212151928041"></p>
<h2 id="Pandas常用函数"><a href="#Pandas常用函数" class="headerlink" title="Pandas常用函数"></a>Pandas常用函数</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212154147108.png" alt="image-20250212154147108"></p>
<pre><code class="hljs plaintext"># 从 SQL 数据库中读取数据
import sqlite3
conn = sqlite3.connect(&#x27;database.db&#x27;)
df = pd.read_sql(&#x27;SELECT * FROM table_name&#x27;, conn)</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212154224406.png" alt="image-20250212154224406"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212154250653.png" alt="image-20250212154250653"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212154421471.png" alt="image-20250212154421471"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212154450902.png" alt="image-20250212154450902"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212154856502.png" alt="image-20250212154856502"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212154936428.png" alt="image-20250212154936428"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250212154956492.png" alt="image-20250212154956492"></p>
<h1 id="缺失值的清洗"><a href="#缺失值的清洗" class="headerlink" title="缺失值的清洗"></a>缺失值的清洗</h1><h2 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h2><p>原始数据中会存在缺失值（空值）</p>
<p>有两种丢失数据：None，np.nan(NaN)</p>
<p>两种丢失数据区别：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241118220138346.png" alt="image-20241118220138346"></p>
<p>浮点型的空加任意值都等于空，None加值会报错。</p>
<p>在pandas中如果遇到None形式的空值，pandas会将其强转为NaN类型的空值。</p>
<h2 id="pandas处理空值的操作"><a href="#pandas处理空值的操作" class="headerlink" title="pandas处理空值的操作"></a>pandas处理空值的操作</h2><pre><code class="hljs plaintext">判断空值：isnull,notnull，any,all
删除：dropna
覆盖：fillna</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241118220830353.png" alt="image-20241118220830353"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><strong>方式1：对空值进行过滤（删除空值所在的行数据）</strong></p>
<p>技术：isnull,notnull,any,all</p>
<p>一、</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241118221604872.png" alt="image-20241118221604872"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241118221746314.png" alt="image-20241118221746314"></p>
<p>要用true和false来显示筛选数据的时候记住使用的是loc而不是iloc。</p>
<pre><code class="hljs plaintext">all是用来监测false的，如果某一行中都是True则返回True，有一个False就返回False。
需要和notnull搭配</code></pre>

<p>二、</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241118222048105.png" alt="image-20241118222048105"></p>
<p>这个没有进行删除，只是显示出现了筛选，只显示True的。</p>
<p><strong>方式2：dropna：可以直接将缺失的行或列进行删除</strong></p>
<p><strong>下面这个最简单，但前面的也要会</strong></p>
<pre><code class="hljs plaintext">df.dropna(axis = 0) # 删除缺失值所在的行
df.dropna(axis = 1) # 删除缺失值所在的列</code></pre>

<h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20241119163203471.png" alt="image-20241119163203471"></p>
<p>先向前填充再向后填充。</p>
<pre><code class="hljs plaintext">df.fillna(value = n) # 空值都被n覆盖</code></pre>

<p>一般情况都选择删除而不是覆盖，删除的成本高才选择覆盖。</p>
<pre><code class="hljs plaintext">df.fillna(method = &#x27;ffill&#x27;,axis) # 向前填充
df.fillna(method = &#x27;bfill&#x27;,axis) # 向后填充
# axis = 1,水平方向的填充
# axis = 0,竖直方向的填充</code></pre>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250122205032999.png" alt="image-20250122205032999"></p>
<h1 id="重复值和异常值的清洗"><a href="#重复值和异常值的清洗" class="headerlink" title="重复值和异常值的清洗"></a>重复值和异常值的清洗</h1><h2 id="重复值"><a href="#重复值" class="headerlink" title="重复值"></a>重复值</h2><p>使用drop_duplicates</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110155355944.png" alt="image-20250110155355944"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110155949718.png" alt="image-20250110155949718"></p>
<p><code>keep=first</code>代表的是保留重复数据第一次出现的那行。<code>keep=last</code>保留最后一次出现的。<code>keep=false</code>代表把所有重复行数据删掉。</p>
<p>不写的话默认等于first。</p>
<h2 id="异常值"><a href="#异常值" class="headerlink" title="异常值"></a>异常值</h2><p>没有专用的函数就是用上面学到的方法，配合给的条件进行处理。</p>
<p>“**~**”：这个符号代表取反。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110162043014.png" alt="image-20250110162043014"></p>
<h1 id="DataFrame的级联操作和合并操作"><a href="#DataFrame的级联操作和合并操作" class="headerlink" title="DataFrame的级联操作和合并操作"></a>DataFrame的级联操作和合并操作</h1><p>这个级联操作行列不同也可以进行，就是补空值。</p>
<h2 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h2><p><strong>pd.concat</strong></p>
<p><strong>pd.append</strong>（不能用）</p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>进行横向或纵向的拼接</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110170836736.png" alt="image-20250110170836736"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110170907796.png" alt="image-20250110170907796"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250210111006315.png" alt="image-20250210111006315"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110170016708.png" alt="image-20250110170016708"></p>
<p>外连接：join&#x3D;’outer’，当没写的时候默认为外连接，就是普通连接，补空值。</p>
<p>内连接：join&#x3D;’inner’，只连接索引相同的。</p>
<p>想要保留输完整性则使用外连接。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110171148373.png" alt="image-20250110171148373"></p>
<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>版本2.0以上被废除</p>
<h2 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110211737460.png" alt="image-20250110211737460"></p>
<p>级联对应的是表格，对表格的拼接；合并对应的是数据，对数据的合并与整合。</p>
<p>合并一次只能合并两张表。</p>
<p>如果两张表大部分的索引都一样那就做级联；如果只有局部的索引一样或者都不一样就用合并。</p>
<p>下面说的几对几合并是一个表格里的数据对另一个表格里的数据是否一一对应。</p>
<h3 id="一对一合并"><a href="#一对一合并" class="headerlink" title="一对一合并"></a>一对一合并</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110214416753.png" alt="image-20250110214416753"></p>
<pre><code class="hljs plaintext">pd.merge(df3,df4,on = &#x27;employee&#x27;)</code></pre>

<p><strong>on</strong> 后面写的是合并条件，基于这个合并条件进行合并。如果不写的话，它就会将两张表中共有的列作为合并条件进行合并。</p>
<h3 id="一对多合并"><a href="#一对多合并" class="headerlink" title="一对多合并"></a>一对多合并</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110215438548.png" alt="image-20250110215438548"></p>
<h3 id="多对多合并"><a href="#多对多合并" class="headerlink" title="多对多合并"></a>多对多合并</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110215203510.png" alt="image-20250110215203510"></p>
<h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>merge方法里有个参数值叫作how，它默认为inner，也就是去除了空值所在的行，当赋值为outer时，空值所在的行就是出现，这里的空值出现是因为两个表中有不能对应的地方，这些地方就会为空值，而不是可以起到删除空值的作用。</p>
<p><strong>这个时候代表的时内连接和外连接。</strong></p>
<p>要保证合并数据的完整性的话就要使用outer。</p>
<p>默认为inner：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110215832260.png" alt="image-20250110215832260"></p>
<p>赋值为outer：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110215907103.png" alt="image-20250110215907103"></p>
<p><strong>还有左连接和右连接。</strong></p>
<p>how &#x3D; ‘left’ 时代表的是左连接，就是保留左表的数据；how &#x3D; ‘right’ 时代表的是右连接，保留右表的数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110220248399.png" alt="image-20250110220248399"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110220301935.png" alt="image-20250110220301935"></p>
<h3 id="key的规范化"><a href="#key的规范化" class="headerlink" title="key的规范化"></a>key的规范化</h3><p><strong>当有多个列名称相同时</strong>，需要用on&#x3D; 来指定哪一个列作为key，配合suffixes指定冲突列名。</p>
<p><strong>on</strong></p>
<p>当有列冲突而不去管时，此时merge会将相同的列一起作为key来合并。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110221218568.png" alt="image-20250110221218568"></p>
<p>on 指定一列</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110221304576.png" alt="image-20250110221304576"></p>
<p><strong>当两张表没有可进行连接的列时</strong>，可使用left_on和right_on手动指定merge中的左右两边哪一列作为连接的列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110222051157.png" alt="image-20250110222051157"></p>
<p>没有相同列的表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250110222210619-1736518931502-1.png" alt="image-20250110222210619"></p>
<h1 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h1><h2 id="info-unique"><a href="#info-unique" class="headerlink" title="info,unique"></a>info,unique</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250111100931119.png" alt="image-20250111100931119"></p>
<p><code>info() </code>返回的是这组数据的原始信息。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250210110742928.png" alt="image-20250210110742928"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250111101905682.png" alt="image-20250111101905682"></p>
<p>将布尔值作为行索引后取出对应的行数据，<code>abb_pop.loc[abb_pop[&#39;state&#39;].isnull()]</code> 这个在里面的输出是一个DataFrame，所以可以把这个整体看成是一个原始数据表，所以要取出这个表中的列数据是就可以直接 <code>[]</code> ，变为<code>abb_pop.loc[abb_pop[&#39;state&#39;].isnull()][&#39;state/region&#39;]</code>。</p>
<p><code>s.unique()</code>，输出去重后的数据，变成一维数组输出。</p>
<h2 id="query"><a href="#query" class="headerlink" title="query"></a>query</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250111103822853.png" alt="image-20250111103822853"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250111104120328.png" alt="image-20250111104120328"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250111104718652.png" alt="image-20250111104718652"></p>
<p><code>query()</code> 函数专门针对DataFrame做条件查询。不用这个函数的话也可以使用条件判断语句。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250111104952127.png" alt="image-20250111104952127"></p>
<p>原本数据里面没有’midu’这一列，但赋值一下就相当于是添加了。</p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250111105222702.png" alt="image-20250111105222702"></p>
<p>sort_values是对值进行排序，sort_index是对索引排序。</p>
<p>ascending默认为True，是升序；False是降序。</p>
<h1 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121170744385.png" alt="image-20250121170744385"></p>
<p>to_replace代表要替换的元素，value代表替换成的元素，第三个是inplace，用法和前面的一样。<code>replace(to_replace,value,inplace)</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121171035642.png" alt="image-20250121171035642"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121171256227.png" alt="image-20250121171256227"></p>
<h1 id="pandas高级操作"><a href="#pandas高级操作" class="headerlink" title="pandas高级操作"></a>pandas高级操作</h1><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>概念：创建一个映射关系列表，把values元素和一个特定的字符串或者标签绑定（给一个元素提供不同的表现形式）。</p>
<p>那接下来就可以使用这个标签来表示这元素了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121200256614.png" alt="image-20250121200256614"></p>
<p><strong>map是Series的方法，只能通过Series调用。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250209220540915.png" alt="image-20250209220540915"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121202816778.png" alt="image-20250121202816778"></p>
<p>def 关键字代表自定义一个函数。</p>
<h2 id="排序实现的随机抽样"><a href="#排序实现的随机抽样" class="headerlink" title="排序实现的随机抽样"></a>排序实现的随机抽样</h2><p>take() 和 np.random.permutation()</p>
<p><strong>take和drop一样，1表示列，0表示行</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121204449180.png" alt="image-20250121204449180"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121204907251.png" alt="image-20250121204907251"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121205044414.png" alt="image-20250121205044414"></p>
<p>上面这是打乱列。</p>
<p>在打乱列的基础上再打乱行，然后再取样，那就是随机取样了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121205317253.png" alt="image-20250121205317253"></p>
<h2 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h2><p>数据分类处理核心：</p>
<p>groupby()函数，groups属性查看分组情况。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121210735924.png" alt="image-20250121210735924"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121210924645.png" alt="image-20250121210924645"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121210600357.png" alt="image-20250121210600357"></p>
<p>mean()函数只能对数值型数据进行处理，所以没对颜色求均值，这个mean()因为没指定对象，所以同时对price和weight进行求平均值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121210650442.png" alt="image-20250121210650442"></p>
<p>只对价格求平均值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121211010285.png" alt="image-20250121211010285"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121211306799.png" alt="g"></p>
<p>想要将对应的平均重量赋给对应的颜色后面，直接添加添加不了，那就是给color分别绑定对应的重量，也就是<strong>映射</strong>。</p>
<p>map()里面放的是映射关系表，映射关系表就是字典。</p>
<p><code>to_dict()</code>：Series的方法，将Series转化为字典，而<code>df.groupby(by = &#39;color&#39;)[&#39;weight&#39;].mean()</code>返回的正好是Series。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121212510286.png" alt="image-20250121212510286"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../source/imgs/$%7Bfiilname%7D/image-20250121212827936.png" alt="image-20250121212827936"></p>
<p>没看懂那个函数是怎么用的。</p>
<p>transform()返回的是经过映射的结果，但apply()返回的不是经过映射的结果，经过映射的可以直接汇总到原本的数据中。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Odegaard</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/10/08/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/10/08/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/')">数据清洗</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/10/08/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=数据清洗&amp;url=http://example.com/2024/10/08/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">coygOdegaard</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>大数据<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/05/%E5%AE%9E%E6%88%98%E9%A2%98%E7%9B%AE/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">实战题目</div></div></a></div><div class="next-post pull-right"><a href="/2025/01/07/%E8%93%9D%E6%A1%A5/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97"><span class="toc-number">1.</span> <span class="toc-text">什么是数据清洗</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">2.</span> <span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#numpy%E6%A8%A1%E5%9D%97"><span class="toc-number">3.</span> <span class="toc-text">numpy模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">3.1.</span> <span class="toc-text">创建数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#array"><span class="toc-number">3.1.1.</span> <span class="toc-text">array()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#frombuffer-%EF%BC%8C%E5%8F%AF%E8%BD%AC%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.1.2.</span> <span class="toc-text">frombuffer()，可转化字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#empty"><span class="toc-number">3.1.3.</span> <span class="toc-text">empty()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%9B%BE%E7%89%87"><span class="toc-number">3.1.4.</span> <span class="toc-text">存储图片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zero-ones-linspace-arange-random%E7%B3%BB%E5%88%97"><span class="toc-number">3.1.5.</span> <span class="toc-text">zero(),ones(),linspace(),arange(),random系列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#logspace"><span class="toc-number">3.1.6.</span> <span class="toc-text">logspace()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#numpy%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">3.2.</span> <span class="toc-text">numpy数组的常用属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#numpy%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text">numpy的索引和切片操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">3.3.2.</span> <span class="toc-text">切片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%EF%BC%88Broaddcast%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">广播（Broaddcast）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%95%B0%E7%BB%84"><span class="toc-number">3.5.</span> <span class="toc-text">迭代数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-number">3.6.</span> <span class="toc-text">数组操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E5%BD%A2%E7%8A%B6"><span class="toc-number">3.6.1.</span> <span class="toc-text">修改数组形状</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">3.6.2.</span> <span class="toc-text">翻转数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C%EF%BC%88%E5%90%8C%E4%B8%80%E7%BB%B4%E5%BA%A6%EF%BC%89"><span class="toc-number">3.6.3.</span> <span class="toc-text">级联操作（同一维度）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84"><span class="toc-number">3.6.4.</span> <span class="toc-text">分割数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">3.6.5.</span> <span class="toc-text">数组元素的添加和删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.</span> <span class="toc-text">常用的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.1.</span> <span class="toc-text">算术函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.2.</span> <span class="toc-text">数学函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.3.</span> <span class="toc-text">统计函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.4.</span> <span class="toc-text">排序，条件筛选函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C"><span class="toc-number">3.8.</span> <span class="toc-text">矩阵操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pandas"><span class="toc-number">4.</span> <span class="toc-text">Pandas</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Series"><span class="toc-number">4.1.</span> <span class="toc-text">Series</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC"><span class="toc-number">4.1.1.</span> <span class="toc-text">基本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DataFrame"><span class="toc-number">4.2.</span> <span class="toc-text">DataFrame</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">基本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.2.</span> <span class="toc-text">基本属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.3.</span> <span class="toc-text">索引操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.4.</span> <span class="toc-text">切片操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E5%8C%96"><span class="toc-number">4.2.5.</span> <span class="toc-text">附加操作，时间类型的转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">4.2.6.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">部分方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AD%98%E6%95%B0%E6%8D%AE%EF%BC%8Ccsv%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.6.2.</span> <span class="toc-text">取数据，存数据，csv文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#excel%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.6.3.</span> <span class="toc-text">excel文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#drop"><span class="toc-number">4.2.6.4.</span> <span class="toc-text">drop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%80%BC%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">4.2.6.5.</span> <span class="toc-text">布尔值取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shift%EF%BC%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">4.2.6.6.</span> <span class="toc-text">shift，计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resample"><span class="toc-number">4.2.6.7.</span> <span class="toc-text">resample</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pandas-CSV"><span class="toc-number">4.3.</span> <span class="toc-text">Pandas CSV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pandas-Excel"><span class="toc-number">4.4.</span> <span class="toc-text">Pandas Excel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pandas%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">Pandas常用函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%BA%E5%A4%B1%E5%80%BC%E7%9A%84%E6%B8%85%E6%B4%97"><span class="toc-number">5.</span> <span class="toc-text">缺失值的清洗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E5%A4%B1%E5%80%BC"><span class="toc-number">5.1.</span> <span class="toc-text">缺失值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pandas%E5%A4%84%E7%90%86%E7%A9%BA%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.</span> <span class="toc-text">pandas处理空值的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">5.2.1.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96"><span class="toc-number">5.2.2.</span> <span class="toc-text">覆盖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%80%BC%E5%92%8C%E5%BC%82%E5%B8%B8%E5%80%BC%E7%9A%84%E6%B8%85%E6%B4%97"><span class="toc-number">6.</span> <span class="toc-text">重复值和异常值的清洗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%80%BC"><span class="toc-number">6.1.</span> <span class="toc-text">重复值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%80%BC"><span class="toc-number">6.2.</span> <span class="toc-text">异常值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DataFrame%E7%9A%84%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C%E5%92%8C%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">7.</span> <span class="toc-text">DataFrame的级联操作和合并操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C"><span class="toc-number">7.1.</span> <span class="toc-text">级联操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#concat"><span class="toc-number">7.1.1.</span> <span class="toc-text">concat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#append"><span class="toc-number">7.1.2.</span> <span class="toc-text">append</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">7.2.</span> <span class="toc-text">合并操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E5%90%88%E5%B9%B6"><span class="toc-number">7.2.1.</span> <span class="toc-text">一对一合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%90%88%E5%B9%B6"><span class="toc-number">7.2.2.</span> <span class="toc-text">一对多合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%90%88%E5%B9%B6"><span class="toc-number">7.2.3.</span> <span class="toc-text">多对多合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#how"><span class="toc-number">7.2.4.</span> <span class="toc-text">how</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96"><span class="toc-number">7.2.5.</span> <span class="toc-text">key的规范化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-number">8.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#info-unique"><span class="toc-number">8.1.</span> <span class="toc-text">info,unique</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#query"><span class="toc-number">8.2.</span> <span class="toc-text">query</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sort"><span class="toc-number">8.3.</span> <span class="toc-text">sort</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">9.</span> <span class="toc-text">替换操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pandas%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">10.</span> <span class="toc-text">pandas高级操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84"><span class="toc-number">10.1.</span> <span class="toc-text">映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7"><span class="toc-number">10.2.</span> <span class="toc-text">排序实现的随机抽样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88"><span class="toc-number">10.3.</span> <span class="toc-text">分组聚合</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/" title="深度学习入门">深度学习入门</a><time datetime="2025-09-11T02:01:58.000Z" title="发表于 2025-09-11 10:01:58">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/python%E6%9A%91%E5%81%87/" title="python暑假">python暑假</a><time datetime="2025-07-08T01:52:38.000Z" title="发表于 2025-07-08 09:52:38">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="机器学习">机器学习</a><time datetime="2025-05-08T12:23:38.000Z" title="发表于 2025-05-08 20:23:38">2025-05-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/05/%E7%9C%9F%E9%A2%98%E6%8A%80%E5%B7%A7/" title="真题技巧">真题技巧</a><time datetime="2025-05-05T11:30:32.000Z" title="发表于 2025-05-05 19:30:32">2025-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/21/%E7%AE%97%E6%B3%95/" title="算法">算法</a><time datetime="2025-01-21T02:01:50.000Z" title="发表于 2025-01-21 10:01:50">2025-01-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Odegaard" target="_blank">Odegaard</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 0.88rem;">大数据<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>4</sup></a><a href="/tags/%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">语言<sup>3</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Odegaard 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>