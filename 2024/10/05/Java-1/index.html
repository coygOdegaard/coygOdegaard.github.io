
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1">
  
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>Java - coygOdegaard</title>

  
    <meta name="description" content="输出一个源文件中最多只能有一个 public 类，其它类的个数不限。 创建类就是class 后加 “类名字 {} ; ” 就可以了。 public class Hello &#123; 	&#x2F;&#x2F;编写一个 main 方法 	public static void main(String[] args) &#123;  		System.out.println(&quot;韩顺平教育 hello&amp;quot">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="http://example.com/2024/10/05/Java-1/">
<meta property="og:site_name" content="coygOdegaard">
<meta property="og:description" content="输出一个源文件中最多只能有一个 public 类，其它类的个数不限。 创建类就是class 后加 “类名字 {} ; ” 就可以了。 public class Hello &#123; 	&#x2F;&#x2F;编写一个 main 方法 	public static void main(String[] args) &#123;  		System.out.println(&quot;韩顺平教育 hello&amp;quot">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240331162808560.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240331162911540.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240331170957715.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240331171207534.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240331171313736.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240331171422444.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240331172107978.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240331172159351.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240331172343300.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240331174353745.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240331173809136.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240406104725188.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240331173512452.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240406105123566.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240406110811133.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240406111009378.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240406111320032.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240406145737348.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240406153915032.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240406154707308.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240406154757093.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240406160744093.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240414162104595.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240727215532534.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240727215556763.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240414160742794.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240414160800080.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240414172133782.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240414173149611.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240414173354781.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240414174808879.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240414174130949.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240414223450716.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240414223508413.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240414223520994.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240416215806747.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240416220623063.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240416225740440.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240416221229472.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240416221318669.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240416221835840.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240416230046791.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240416231516983.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240416231543717.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240416231606165.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240421100232412.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240421100247672.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240421100300205.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240421101136977.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240421152812000.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240421154101920.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240421155237284.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240421155435513.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240421160114725.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240421161008041.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240421161024081.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240422104711717.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240422110254831.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240422110428982.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240512102858424.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240512105648039.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240512110945870.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240512111357129.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240526095634527.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240526095701954.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240526104012922.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240526231659923.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240526231714044.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240715200948826.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716104558577.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716105559989.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716105745510.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716111438635.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716111525542.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716113303141.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716113759767.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716113811536.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716113833142.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716113915583.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716114938961.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716152930438.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716155111996.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716163920548.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716163953842.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716204256473.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716204345054.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716204400577.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716210400850.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240716210424127.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240717154518155.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240717161053557.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240717171108655.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240717171138906.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240717171312869.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240717171717547.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240717171807403.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240717200449840.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240717200458838.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240717202046849.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240717202102384.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240720155227537.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240719165409567.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240719192856826.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240720151522693.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240720151528940.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240720162846185.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240722171151062.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240722171101245.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240722171203350.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240722171235698.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723110944904.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723104249407.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723104256939.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723110339250.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723110401077.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723110406016.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723115424926.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723154528512.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723154851742.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723154929380.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723155619628.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723160923814.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723162241156.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723163738843.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723164003159.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723173519242.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723173836145.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723173846457.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240723194324191.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725094033403.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725095011997.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725101855889.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725155654016.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725160337428.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725160623681.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725160911284.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725160917675.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725162340448.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725174711688.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725192856145.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725194357733.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725194954602.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725213723566.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725213754328.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725213940513.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725214604330.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725214609681.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240725220102012.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240726194749047.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240726195140571.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240726195227118.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240726214516539.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240726214606711.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240726214615158.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240727102408708.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240727102414626.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240727102419556.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240727102424525.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240730103701253.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731104137732.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731153546504.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731153824416.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731154135263.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731161904912.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731162157449.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731164151694.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731162633775.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731162648857.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731162833533.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731162906866.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731163027886.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731163110864.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731163332984.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731164241784.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731164845230.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731173758424.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240731174140998.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240801110702617.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240801110714899.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240801111139204.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240801111510841.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802102316270.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802102713074.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802104712915.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802112155115.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802112932591.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802112946033.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802112952647.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802113113614.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802152635252.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802152156272.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802152322585.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802152329006.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802153728020.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802154437791.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240819211720021.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240819211739407.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802162302892.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240802163521972.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240824154300761.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240803152208071-1722669728912-1.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240803153113712.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240803153150977.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240803154943978.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240803160114605.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240803160118325.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240803164210193.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240804155633708.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240804161408893.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240804161509764.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240804162504069.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240804165247557.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240804175601112.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240804175615009.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240804180459515.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240804200138404.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805113308968.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805113551076.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805113556309.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805153109897.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805160915142.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805160927232.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805160957407.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805161907452.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805165417212.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240823223412800.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805170327199.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805171457469.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805171512437.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805193045404.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805193215719.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805193504840.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805193519644.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240805194122247.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240806103202514.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240806103231006.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240806103343391.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240806112731405.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240806112707254.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240806112715287.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240806113412779.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240806154342854.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240806154547157.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240806201214488.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240806204935015.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240806204948094.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240806203631348.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240808110338660.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240808110429658.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240808110554802.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240808110724566.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240808110754123.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240808111227573.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240808111527052.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240808153830100.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240808154056938.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240808154617956.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240809110141506.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240809111102632.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240809111218256-1723173139016-1.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240809112640233.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240809112658580.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20240809112743876.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240809113352685.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240809165532655.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240809170146345.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240809171004302.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240810105516928.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240810112032671.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240811165750263.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240811165842195.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240812170556243.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240813110428523.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240813110530651.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240813110536404.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240813110635780.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240813110653713.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240813173129946.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240813173513118.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240813173546876.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240813223615180.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240813223620304.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240813223704614.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240814111046367.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240814111410113-1723605250860-1.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240814171441700.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240814171506503.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240814214504483.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240814214703422.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240814220715469.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240814221818587.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240815104404950.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240815104422172.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240815105730149.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240815110054951.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240815112143826.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240816110944717.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240816111311259.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240816111320424.png">
<meta property="article:published_time" content="2024-10-05T09:51:15.000Z">
<meta property="article:modified_time" content="2025-06-13T08:11:22.929Z">
<meta property="article:author" content="Odegaard">
<meta property="article:tag" content="语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240331162808560.png">
  
  
  
  <meta name="keywords" content="语言">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.1">


  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Odegaard","sameAs":[]},"dateCreated":"2024-10-05T17:51:15+08:00","dateModified":"2025-06-13T16:11:22+08:00","datePublished":"2024-10-05T17:51:15+08:00","description":"","headline":"Java","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2024/10/05/Java-1/"},"publisher":{"@type":"Organization","name":"Odegaard","sameAs":[]},"url":"http://example.com/2024/10/05/Java-1/","keywords":"语言","image":[]}</script>
  
</head>
<body>

<div class="l_body content" id="start" layout="post" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="undefined" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main">coygOdegaard</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>



<widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2025/09/29/test-p/"><span class="title">test p</span></a><a class="item title" href="/2025/09/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"><span class="title">深度学习入门</span></a><a class="item title" href="/2025/01/21/%E7%AE%97%E6%B3%95/"><span class="title">算法</span></a><a class="item title" href="/2024/10/05/%E5%AE%9E%E6%88%98%E9%A2%98%E7%9B%AE/"><span class="title">实战题目</span></a><a class="item title" href="/2025/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="title">机器学习</span></a><a class="item title" href="/2025/07/08/python%E6%9A%91%E5%81%87/"><span class="title">python暑假</span></a><a class="item title" href="/2025/05/05/%E7%9C%9F%E9%A2%98%E6%8A%80%E5%B7%A7/"><span class="title">真题技巧</span></a><a class="item title" href="/2024/10/05/python2/"><span class="title">python2</span></a><a class="item title" href="/2024/10/08/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"><span class="title">数据清洗</span></a><a class="item title" href="/2024/10/05/Java-1/"><span class="title">Java</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-10-05T09:51:15.000Z">2024-10-05</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-06-13T08:11:22.929Z">2025-06-13</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Java</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>一个源文件中最多只能有一个 public 类，其它类的个数不限。</p>
<p>创建类就是class 后加 “类名字 {} ; ” 就可以了。</p>
<pre><code class="hljs plaintext">public class Hello &#123;
	//编写一个 main 方法
	public static void main(String[] args) &#123; 
		System.out.println(&quot;韩顺平教育 hello&quot;); 
	&#125; 
&#125;</code></pre>

<p>两个println之间会自动跳行，如果输出用的是print则和c语言中的printf一样。</p>
<p>&#x2F;&#x2F;对代码的相关说明<br>&#x2F;&#x2F;1. public class Hello 表示 Hello 是一个类,是一个 public 公有的类<br>&#x2F;&#x2F;2. Hello{ } 表示一个类的开始和结束<br>&#x2F;&#x2F;3. public static void main(String[] args) 表示一个主方法,即我们程序的入口<br>&#x2F;&#x2F;4. main() {} 表示方法的开始和结束<br>&#x2F;&#x2F;5. System.out.println(“hello,world<del>“); 表示输出”hello,world</del>“到屏幕</p>
<p>&#x2F;&#x2F;6. ;表示语句结束</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331162808560.png" alt="image-20240331162808560"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331162911540.png" alt="image-20240331162911540"></p>
<p>public static void main(String[] args)相当于int main()。</p>
<pre><code class="hljs plaintext">public class Dog &#123;
    //一个源文件中最多只能有一个 public 类。其它类的个数不限，也可以将 main 方法写在非 public 类中，
//然后指定运行非 public 类，这样入口方法就是非 public 的 main 方法
    public static void main(String[] args) &#123;
        System.out.println(&quot;hello, 小狗狗~&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">public class ChangeChar &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
        int n=2;
        int m=5;
        int sum = n + m;
        System.out.println(sum);
    &#125;
&#125;</code></pre>

<p>输出变量不用双引号，然后就跟c语言里一样，不能一次性输出两个变量。</p>
<p>里面定义sum，它的第一轮运算（不包括赋值）必须在定义后面接着，像上面那样，但之后的运算就和以前一样了。</p>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><pre><code class="hljs plaintext">在控制台，输入 tab 键，可以实现命令补全
\t ：一个制表位，实现对齐的功能
\n ：换行符
\\ ：一个\
\&quot; :一个&quot;
\&#x27; ：一个&#x27; 
\r :一个回车 (r前面的好像输不出来)</code></pre>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><pre><code class="hljs plaintext">public class Var02 &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//记录人的信息
        int age = 30;
        double score = 88.9;
        char gender = &#x27;男&#x27;;
        String name = &quot;king&quot;;
//输出信息, 快捷键
        System.out.println(&quot;人的信息如下:&quot;);
        System.out.println(name);
        System.out.println(age);
        System.out.println(score);
        System.out.println(gender);
    &#125;
&#125;</code></pre>

<p>输出变量不用加双引号，且两句println中自带换行；另外，可以直接命名字符串为一个变量了，string 变量名&#x3D;”字符串”。</p>
<p>String类型的变量可以直接这样赋值：s1&#x3D;new String(“abc”)，数组的赋值用法。</p>
<p>char后面可以加汉字了。</p>
<p>变量在同一个作用域中不能重名，但不同的可以。</p>
<h2 id="“-”的使用"><a href="#“-”的使用" class="headerlink" title="“+”的使用"></a>“+”的使用</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331170957715.png" alt="image-20240331170957715"></p>
<p>注意是左右两项，然后<strong>从左到右</strong>，但是加括号可以改变运算顺序。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331171207534.png" alt="image-20240331171207534"></p>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331171313736.png" alt="image-20240331171313736"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331171422444.png" alt="image-20240331171422444"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331172107978.png" alt="image-20240331172107978"></p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331172159351.png" alt="image-20240331172159351"></p>
<p><strong>细节:如果是直接查询得的的小数或者直接赋值，是可以判断相等</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331172343300.png" alt="image-20240331172343300"></p>
<pre><code class="hljs plaintext">public class FloatDetail &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//Java 的浮点型常量(具体值)默认为 double 型，声明 float 型常量，须后加‘f’或‘F&#x27; //float num1 = 1.1; //对不对?错误
        float num2 = 1.1F; //对的
        double num3 = 1.1; //对
        double num4 = 1.1f; //对
//十进制数形式：如：5.12 512.0f .512 (必须有小数点）
        double num5 = .123; //等价 0.123
        System.out.println(num5);
        //科学计数法形式:如：5.12e2 [5.12 * 10 的 2 次方 ] 5.12E-2 []
        System.out.println(5.12e2);//512.0
        System.out.println(5.12E-2);//0.0512
//通常情况下，应该使用 double 型，因为它比 float 型更精确。
//[举例说明]double num9 = 2.1234567851;float num10 = 2.1234567851F;
        double num9 = 2.1234567851;
        float num10 = 2.1234567851F;
        System.out.println(num9);
        System.out.println(num10);
//浮点数使用陷阱: 2.7 和 8.1 / 3 比较
//看看一段代码
        double num11 = 2.7;
        double num12 = 2.7; //8.1 / 3; //2.7
        System.out.println(num11);//2.7
        System.out.println(num12);//接近 2.7 的一个小数，而不是 2.7
//得到一个重要的使用点: 当我们对运算结果是小数的进行相等判断是，要小心
//应该是以两个数的差值的绝对值，在某个精度范围类判断
        if( num11 == num12) &#123;
            System.out.println(&quot;num11 == num12 相等&quot;);
        &#125;
//正确的写法 , ctrl + / 注释快捷键, 再次输入就取消注释
        if(Math.abs(num11 - num12) &lt; 0.000001 ) &#123;
            System.out.println(&quot;差值非常小，到我的规定精度，认为相等...&quot;);
        &#125;
//细节:如果是直接查询得的的小数或者直接赋值，是可以判断相等
    &#125;
&#125;</code></pre>

<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符我们用字符串 String。</p>
<p>Java里的字符对应的是 Unicode 码。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331174353745.png" alt="image-20240331174353745"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331173809136.png" alt="image-20240331173809136"></p>
<pre><code class="hljs plaintext">public class CharDetail &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//在 java 中，char 的本质是一个整数，在默认输出时，是 unicode 码对应的字符
//要输出对应的数字，可以(int)字符
        char c1 = 97;
        System.out.println(c1); // a
        char c2 = &#x27;a&#x27;; //输出&#x27;a&#x27; 对应的 数字
        System.out.println((int)c2);
        char c3 = &#x27;韩&#x27;;
        System.out.println((int)c3);//38889
        char c4 = 38889;
        System.out.println(c4);//韩
//char 类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码.
		System.out.println(&#x27;a&#x27; + 10);//107
//课堂小测试
        char c5 = &#x27;b&#x27; + 1;//98+1==&gt; 99
        System.out.println((int)c5); //99
        System.out.println(c5); //99-&gt;对应的字符-&gt;编码表 ASCII(规定好的)=&gt;c
    &#125;
&#125;</code></pre>

<h3 id="布尔类型-boolean"><a href="#布尔类型-boolean" class="headerlink" title="布尔类型 boolean"></a>布尔类型 boolean</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406104725188.png" alt="image-20240406104725188"></p>
<h2 id="查看类的使用方法"><a href="#查看类的使用方法" class="headerlink" title="查看类的使用方法"></a>查看类的使用方法</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331173512452.png" alt="image-20240331173512452"></p>
<h2 id="基本数据类型转化"><a href="#基本数据类型转化" class="headerlink" title="基本数据类型转化"></a>基本数据类型转化</h2><h3 id="自动类型转化"><a href="#自动类型转化" class="headerlink" title="自动类型转化"></a>自动类型转化</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406105123566.png" alt="image-20240406105123566"></p>
<pre><code class="hljs plaintext">public class AutoConvertDetail &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//细节 1： 有多种类型的数据混合运算时，
//系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算
        int n1 = 10; //ok
//float d1 = n1 + 1.1;//错误 n1 + 1.1 =&gt; 结果类型是 double
//double d1 = n1 + 1.1;//对 n1 + 1.1 =&gt; 结果类型是 double
        float d1 = n1 + 1.1F;//对 n1 + 1.1 =&gt; 结果类型是 float
//细节 2: 当我们把精度(容量)大 的数据类型赋值给精度(容量)小 的数据类型时，
//就会报错，反之就会进行自动类型转换。
//
//int n2 = 1.1;//错误 double -&gt; int
//细节 3: (byte, short) 和 char 之间不会相互自动转换
//当把具体数赋给 byte 时，(1)先判断该数是否在 byte 范围内，如果是就可以
        byte b1 = 10; //对 , -128-127
// int n2 = 1; //n2 是 int
// byte b2 = n2; //错误，原因： 如果是变量赋值，判断类型
//
// char c1 = b1; //错误， 原因 byte 不能自动转成 char
//
//
//细节 4: byte，short，char 他们三者可以计算，在计算时首先转换为 int 类型
        byte b2 = 1;
        byte b3 = 2;
        short s1 = 1;
//short s2 = b2 + s1;//错, b2 + s1 =&gt; int
        int s2 = b2 + s1;//对, b2 + s1 =&gt; int
//byte b4 = b2 + b3; //错误: b2 + b3 =&gt; int
//
//boolean 不参与转换
        boolean pass = true;
//int num100 = pass;// boolean 不参与类型的自动转换
//自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型
//看一道题
        byte b4 = 1;
        short s3 = 100;
        int num200 = 1;
        float num300 = 1.1F;
        double num500 = b4 + s3 + num200 + num300; //float -&gt; double
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">int n1 = 10; //ok
//float d1 = n1 + 1.1;//错误 n1 + 1.1 =&gt; 结果类型是 double</code></pre>

<p>因为数字1.1没有定义数据类型，所以默认为double型。</p>
<h3 id="强制类型转化"><a href="#强制类型转化" class="headerlink" title="强制类型转化"></a>强制类型转化</h3><p>在将容量大的数据类型转化为容量小的数据类型时需要用到，可能会造成精度降低或溢出，和c语言中一样。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406110811133.png" alt="image-20240406110811133"></p>
<p>第4点在上面自动类型转化有提到。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406111009378.png" alt="image-20240406111009378"></p>
<h2 id="基本数据类型和String类型的转化"><a href="#基本数据类型和String类型的转化" class="headerlink" title="基本数据类型和String类型的转化"></a>基本数据类型和String类型的转化</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406111320032.png" alt="image-20240406111320032"></p>
<pre><code class="hljs plaintext">public class StringToBasic &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//基本数据类型-&gt;String
        int n1 = 100;
        float f1 = 1.1F;
        double d1 = 4.5;
        boolean b1 = true;
        String s1 = n1 + &quot;&quot;;
        String s2 = f1 + &quot;&quot;;
        String s3 = d1 + &quot;&quot;;
        String s4 = b1 + &quot;&quot;;
        System.out.println(s1 + &quot; &quot; + s2 + &quot; &quot; + s3 + &quot; &quot; + s4);
        //System.out.println(s1  + s2  + s3  + s4);这样输出字符串之间没有空格
//String-&gt;对应的基本数据类型
        String s5 = &quot;123&quot;;
//会在 OOP 讲对象和方法的时候回详细
//解读 使用 基本数据类型对应的包装类，的相应方法，得到基本数据类型
        int num1 = Integer.parseInt(s5);
        double num2 = Double.parseDouble(s5);
        float num3 = Float.parseFloat(s5);
        long num4 = Long.parseLong(s5);
        byte num5 = Byte.parseByte(s5);
        boolean b = Boolean.parseBoolean(&quot;true&quot;);
        short num6 = Short.parseShort(s5);
        System.out.println(&quot;===================&quot;);
        System.out.println(num1);//123
        System.out.println(num2);//123.0
        System.out.println(num3);//123.0
        System.out.println(num4);//123
        System.out.println(num5);//123
        System.out.println(num6);//123
        System.out.println(b);//true
//怎么把字符串转成字符 char -&gt; 含义是指 把字符串的第一个字符得到
//解读 s5.charAt(0) 得到 s5 字符串的第一个字符 &#x27;1&#x27; System.out.println(s5.charAt(0));
    &#125;
&#125;</code></pre>

<p>数据类型转化完后直接输出也可以。</p>
<pre><code class="hljs plaintext">System.out.println(s1);</code></pre>

<p>在将 String 类型转成基本数据类型时，<strong>要确保String类型可以转化为有效的数据</strong>，比如 我们可以把 “123” , 转成一 个整数，但是不能把 “hello” 转成一个整数。</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406145737348.png" alt="image-20240406145737348"></p>
<p>“&#x2F;”也有点不同，相除的数中要有小数结果才会是小数，其他与c语言一样。</p>
<pre><code class="hljs plaintext">class ArithmeticOperator &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
// /使用
        System.out.println(10 / 4); //从数学来看是 2.5, java 中 2
        System.out.println(10.0 / 4); //java 是 2.5
// 注释快捷键 ctrl + /, 再次输入 ctrl + / 取消注释
        double d = 10 / 4;//java 中 10 / 4 = 2, 2=&gt;2.0
        System.out.println(d);// 是 2.0
// % 取模 ,取余
// 在 % 的本质 看一个公式!!!! a % b = a - a / b * b
// -10 % 3 =&gt; -10 - (-10) / 3 * 3 = -10 + 9 = -1
// 10 % -3 = 10 - 10 / (-3) * (-3) = 10 - 9 = 1
// -10 % -3 = (-10) - (-10) / (-3) * (-3) = -10 + 9 = -1
        System.out.println(10 % 3); //1
        System.out.println(-10 % 3); // -1
        System.out.println(10 % -3); //1
        System.out.println(-10 % -3);//-1
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">double d = 10 / 4;//java 中 10 / 4 = 2, 2=&gt;2.0</code></pre>

<p><strong>% 的本质看一个公式!!!! a % b &#x3D; a - a &#x2F; b * b</strong></p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406153915032.png" alt="image-20240406153915032"></p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406154707308.png" alt="image-20240406154707308"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406154757093.png" alt="image-20240406154757093"></p>
<p>（1）对于**&amp;&amp;短路与**而言，如果第一个条件为 false ,<strong>后面的条件不再判断</strong> ，效率高。</p>
<p>​		对于**&amp;逻辑与**而言，如果第一个条件为 false ,<strong>后面的条件仍然会判断</strong>，效率低。</p>
<p>（2）||短路或：如果第一个条件为 true， &#x2F;&#x2F;则第二个条件不会判断，最终结果为 true，效率高。</p>
<p>​		| 逻辑或：不管第一个条件是否为 true，<strong>第二个条件都要判断</strong>，效率低。</p>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>条件表达式 <strong>?</strong> 表达式 1**:** 表达式 2**;**<br>运算规则：</p>
<pre><code>       1. 如果条件表达式为 true，运算后的结果是表达式 1；
       2. 如果条件表达式为 false，运算后的结果是表达式 2；
</code></pre>
<pre><code class="hljs plaintext">//三元运算符细节
public class TernaryOperatorDetail &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//表达式 1 和表达式 2 要为可以赋给接收变量的类型
//(或可以自动转换/或者强制转换)
        int a = 3;
        int b = 8;
        int c = a &gt; b ? (int)1.1 : (int)3.4;//可以的
        double d = a &gt; b ? a : b + 3;//可以的，满足 int -&gt; double
    &#125;
&#125;</code></pre>

<p><strong>double d &#x3D; a &gt; b ? a : b + 3;&#x2F;&#x2F;可以的，满足 int -&gt; double</strong></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406160744093.png" alt="image-20240406160744093"></p>
<pre><code class="hljs plaintext">标识符命名规范
1) 包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm
2) 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰]
比如： TankShotGame
3) 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小
驼峰， 简称 驼峰法]
比如： tankShotGame
4) 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ
比如 ：定义一个所得税率 TAX_RATE</code></pre>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><h2 id="if-普通输入变量"><a href="#if-普通输入变量" class="headerlink" title="if+普通输入变量"></a>if+普通输入变量</h2><pre><code class="hljs plaintext">import java.util.Scanner;//导入
//if 的快速入门
public class If01 &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//编写一个程序,可以输入人的年龄,如果该同志的年龄大于 18 岁, //则输出 &quot;你年龄大于 18,要对自己的行为负责,送入监狱&quot;
//
//思路分析
//1. 接收输入的年龄, 应该定义一个 Scanner 对象
//2. 把年龄保存到一个变量 int age
//3. 使用 if 判断，输出对应信息
//应该定义一个 Scanner 对象
        Scanner myScanner = new Scanner(System.in);
        System.out.println(&quot;请输入年龄&quot;);
//把年龄保存到一个变量 int age
        int age = myScanner.nextInt();
//使用 if 判断，输出对应信息
        if(age &gt; 18) &#123;
            System.out.println(&quot;你年龄大于 18,要对自己的行为负责,送入监狱&quot;);
        &#125;
        System.out.println(&quot;程序继续...&quot;);
    &#125;
&#125;</code></pre>

<p><strong>导入语句需要放在开头。</strong></p>
<pre><code class="hljs plaintext">Scanner myScanner = new Scanner(System.in);</code></pre>

<p>myScanner可以替换成别的对象名字，然后下面的也要一起替换。</p>
<p>例：</p>
<pre><code class="hljs plaintext">import java.util.Scanner;
public class test &#123;
    public static void main(String[] args)&#123;
        Scanner two = new Scanner(System.in);
        int age =two.nextInt();
        System.out.println(age);
    &#125;
&#125;</code></pre>

<h2 id="switch-输入字符"><a href="#switch-输入字符" class="headerlink" title="switch+输入字符"></a>switch+输入字符</h2><p>第一种：switch用法和c 语言一样。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414162104595.png" alt="image-20240414162104595"></p>
<p><strong>返回值不包括小数，但包括字符串。</strong></p>
<p>第二种：</p>
<pre><code class="hljs plaintext">switch(num)&#123;
    case 1 -&gt; System.out.println(&quot;春暖花开&quot;);
    case 2 -&gt; System.out.println(&quot;夏日凉风&quot;);
    case 3 -&gt; System.out.println(&quot;秋月盈盈&quot;);
    case 4 -&gt; System.out.println(&quot;冬雪皑皑&quot;);
    default -&gt; System.out.println(&quot;季节输入非法.&quot;);
    &#125;</code></pre>

<p>第三种：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727215532534.png" alt="image-20240727215532534"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727215556763.png" alt="image-20240727215556763"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414160742794.png" alt="image-20240414160742794"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414160800080.png" alt="image-20240414160800080"></p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>和c 一样</p>
<h2 id="while和do-while"><a href="#while和do-while" class="headerlink" title="while和do while"></a>while和do while</h2><p>一样</p>
<h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><pre><code class="hljs plaintext">public class ForExercise &#123;
   public static void main(String[] args)&#123;
       Scanner myScanner = new Scanner(System.in);
       String name;
       String passwd;
       int chance = 3; //登录一次 ，就减少一次
       for( int i = 1; i &lt;= 3; i++) &#123;//3 次登录机会
           System.out.println(&quot;请输入名字&quot;);
           name = myScanner.next();
           System.out.println(&quot;请输入密码&quot;);
           passwd = myScanner.next();
//比较输入的名字和密码是否正确
//补充说明字符串 的内容 比较 使用的 方法 equals
           if(&quot;丁真&quot;.equals(name) &amp;&amp; &quot;666&quot;.equals(passwd)) &#123;
               System.out.println(&quot;恭喜你，登录成功~&quot;);
               break;
           &#125;
//登录的机会就减少一次
           chance--;
           System.out.println(&quot;你还有&quot; + chance + &quot;次登录机会&quot;);
       &#125;
   &#125;
&#125;</code></pre>

<h3 id="equal方法"><a href="#equal方法" class="headerlink" title="equal方法"></a>equal方法</h3><p>目前只知道用来比较字符串。</p>
<p><strong>格式：a字符串.equals(b字符串)</strong></p>
<p>equals()不能用于判断基本数据类型的变量。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414172133782.png" alt="image-20240414172133782"></p>
<p>x变量为基本数据类型，不能使用equals，比较的是引用类型的对象。</p>
<p>引用类型是 Java 语言中用户自定义的类型，包括类、接口、数组等。引用类型的对象是可变的，可以被修改。</p>
<p>equals针对的比较对象是引用类型， 在Java中Object对象是所有对象的父类，所以每个类都会有个equals的方法。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414173149611.png" alt="image-20240414173149611"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414173354781.png" alt="image-20240414173354781"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414174808879.png" alt="image-20240414174808879"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414174130949.png" alt="image-20240414174130949"></p>
<h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><pre><code class="hljs plaintext">(1) continue 语句用于结束本次循环，继续执行下一次循环。
(2) continue 语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 , 这个和前面的标签的
使用的规则一样.</code></pre>

<p>标签的使用</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414223450716.png" alt="image-20240414223450716"></p>
<p>break label1   跳出label1。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414223508413.png" alt="image-20240414223508413"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414223520994.png" alt="image-20240414223520994"></p>
<p>若continue后面不加标签则和c 语言中的用法一样。</p>
<h1 id="数组，排序，查找"><a href="#数组，排序，查找" class="headerlink" title="数组，排序，查找"></a>数组，排序，查找</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><pre><code class="hljs plaintext">class ForExercise &#123;
   public static void main(String[] args)&#123;
       double[] hens = &#123;3, 5, 1, 3.4, 2, 50, 7.8, 88.8,1.1,5.6,100&#125;;
       System.out.println(&quot;===使用数组解决===&quot;);
       double totalWeight = 0;
       for( int i = 0; i &lt; hens.length; i++) &#123;
//System.out.println(&quot;第&quot; + (i+1) + &quot;个元素的值=&quot; + hens[i]);
           totalWeight += hens[i];
       &#125;
       System.out.println(&quot;总体重=&quot; + totalWeight
               + &quot;平均体重=&quot; + (totalWeight / hens.length) );
   &#125;
&#125;</code></pre>

<p><strong>一、</strong></p>
<p>直接给一个数组赋值</p>
<pre><code class="hljs plaintext">double[] hens = &#123;3, 5, 1, 3.4, 2, 50, 7.8, 88.8,1.1,5.6,100&#125;;</code></pre>

<pre><code class="hljs plaintext">double hens[] = &#123;3, 5, 1, 3.4, 2, 50, 7.8, 88.8,1.1,5.6,100&#125;;</code></pre>

<p>第二个也可以但会发出警报，不规范，最好用第一个。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416215806747.png" alt="image-20240416215806747"></p>
<p><strong>二、</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416220623063.png" alt="image-20240416220623063"></p>
<p>第四种不一定要给数组赋初值，只要规定它的大小就可以了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416225740440.png" alt="image-20240416225740440"></p>
<p>使用方法和c语言一样。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416221229472.png" alt="image-20240416221229472"></p>
<p>最好用int[] a</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416221318669.png" alt="image-20240416221318669"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416221835840.png" alt="image-20240416221835840"></p>
<p>int数组里面不能赋值字符串，所以第一行不行。</p>
<pre><code class="hljs plaintext">public class ArrayExercise01 &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
/*
创建一个 char 类型的 26 个元素的数组，分别 放置&#x27;A&#x27;-&#x27;Z&#x27;。
使用 for 循环访问所有元素并打印出来。
提示：char 类型数据运算 &#x27;A&#x27;+1 -&gt; &#x27;B&#x27; 思路分析
1. 定义一个 数组 char[] chars = new char[26]
2. 因为 &#x27;A&#x27; + 1 = &#x27;B&#x27; 类推，所以老师使用 for 来赋值
3. 使用 for 循环访问所有元素
*/
        char[] chars = new char[26];
        for( int i = 0; i &lt; chars.length; i++) &#123;//循环 26 次
//chars 是 char[]
//chars[i] 是 char
            chars[i] = (char)(&#x27;A&#x27; + i); //&#x27;A&#x27; + i 是 int , 需要强制转换
        &#125;
//循环输出
        System.out.println(&quot;===chars 数组===&quot;);
        for( int i = 0; i &lt; chars.length; i++) &#123;//循环 26 次
            System.out.print(chars[i] + &quot; &quot;);
        &#125;
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">chars[i] = (char)(&#x27;A&#x27; + i); //&#x27;A&#x27; + i 是 int , 需要强制转换</code></pre>

<p>这步和c语言中的不一样，需要强制转化，不然会出问题。char可以自动转化为int，但是int 不能自动转化char。但是如果是chars[i]&#x3D;97+i；就不需要强制转化，输出也是字符。</p>
<p>里面定义了数组chars，而chars.length就表示这个数组的长度，不用赋值。</p>
<hr>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416230046791.png" alt="image-20240416230046791"></p>
<pre><code class="hljs plaintext">class ForExercise &#123;
   public static void main(String[] args)&#123;
       int[] scores = &#123;88,99,100,92&#125;;
       int i;
       int[] number;
       number = scores;
       for(i=0;i&lt;4;i++)&#123;
           System.out.println(number[i]);
       &#125;
   &#125;
&#125;</code></pre>

<p>两个数组名可以直接相等，赋的值是地址，也就是number现在指向的就是scores数组，所以<strong>修改number数组里的值，scores数组里的值也会发生变化</strong>。<code>number = scores;</code>这句话的意思是让number指向scores的数据空间。</p>
<h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><h4 id="arraycopy"><a href="#arraycopy" class="headerlink" title="arraycopy ()"></a>arraycopy ()</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416231516983.png" alt="image-20240416231516983"></p>
<p>原数组的起始索引代表开始复制的地方，目标数组的起始索引代表开始替代的地方，<strong>起始索引是数组中的下标值</strong>。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416231543717.png" alt="image-20240416231543717"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416231606165.png" alt="image-20240416231606165"></p>
<h4 id="copyOfRange"><a href="#copyOfRange" class="headerlink" title="copyOfRange"></a>copyOfRange</h4><p>需要引入，import java.util.Arrays;</p>
<p>Arrays.copyOfRange(int[] original, int from, int to)方法 ——-&gt;  拷贝从from(包括)到to(不包括)位置的数组</p>
<p>target &#x3D; Arrays.copyOfRange(source2,0,source2.length); target——目标数组，source2——要复制的数组。</p>
<h4 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h4><p>需要引入，import java.util.Arrays;</p>
<p>Arrays.copyOf(int[] original, int newLength)方法 ——-&gt;  截断或扩充数组（补0）</p>
<p>target &#x3D; Arrays.copyOf(source2, source2.length); target——目标数组，source2——要复制的数组。</p>
<h3 id="添加-扩容"><a href="#添加-扩容" class="headerlink" title="添加&#x2F;扩容"></a>添加&#x2F;扩容</h3><pre><code class="hljs plaintext">do &#123;
	int[] arrNew = new int[arr.length + 1];
	for(int i = 0; i &lt; arr.length; i++) &#123;
	arrNew[i] = arr[i];
    &#125;
    System.out.println(&quot;请输入你要添加的元素&quot;);
	int addNum = myScanner.nextInt();
	//把 addNum 赋给 arrNew 最后一个元素
	arrNew[arrNew.length - 1] = addNum;
	//让 arr 指向 arrNew
    arr = arrNew;
	//输出 arr 看看效果
	System.out.println(&quot;====arr 扩容后元素情况====&quot;);
	for(int i = 0; i &lt; arr.length; i++) &#123;
        System.out.print(arr[i] + &quot;\t&quot;);
	&#125;
	//问用户是否继续
    System.out.println(&quot;是否继续添加 y/n&quot;);
	char key = myScanner.next().charAt(0);
	if( key == &#x27;n&#x27;) &#123; //如果输入 n ,就结束
        break;
    &#125;
&#125;while(true);</code></pre>

<p><code>int[] arrNew = new int[arr.length + 1];</code>这句话虽然在循环当中数组名不变，但是会给它赋予新的空间，应该会导致这个数组变成一个新的数组，可参考数据结构里的赋值情况。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><pre><code class="hljs plaintext">String[] names = &#123;&quot;白眉鹰王&quot;, &quot;金毛狮王&quot;, &quot;紫衫龙王&quot;, &quot;青翼蝠王&quot;&#125;;
Scanner myScanner = new Scanner(System.in);
System.out.println(&quot;请输入名字&quot;);
String findName = myScanner.next();
//遍历数组，逐一比较，如果有，则提示信息，并退出
//这里老师给大家一个编程思想/技巧, 一个经典的方法
int index = -1;
for(int i = 0; i &lt; names.length; i++) &#123;
//比较 字符串比较 equals, 如果要找到名字就是当前元素
        if(findName.equals(names[i])) &#123;
        System.out.println(&quot;恭喜你找到 &quot; + findName);
System.out.println(&quot;下标为= &quot; + i);
//把 i 保存到 index
index = i;
break;//退出
        &#125;
	&#125;
        if(index == -1) &#123; //没有找到
        System.out.println(&quot;sorry ,没有找到 &quot; + findName);
&#125;</code></pre>

<p>这边比较字符串可直接使用equals。</p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><pre><code class="hljs plaintext">int[][] arr = &#123; 
        &#123;0, 0, 0, 0, 0, 0&#125;,
        &#123;0, 0, 1, 0, 0, 0&#125;, 
        &#123;0, 2, 0, 3, 0, 0&#125;, 
        &#123;0, 0, 0, 0, 0, 0&#125; 
&#125;;
System.out.println(&quot;二维数组的元素个数=&quot; + arr.length);
//(2) 二维数组的每个元素是一维数组, 所以如果需要得到每个一维数组的值
// 还需要再次遍历
//(3) 如果我们要访问第 (i+1)个一维数组的第 j+1 个值 arr[i][j];
// 举例 访问 3, =》 他是第 3 个一维数组的第 4 个值 arr[2][3]
System.out.println(&quot;第 3 个一维数组的第 4 个值=&quot; + arr[2][3]); //3
//输出二维图形
for(int i = 0; i &lt; arr.length; i++) &#123;//遍历二维数组的每个元素
//遍历二维数组的每个元素(数组)
//老韩解读
//1. arr[i] 表示 二维数组的第 i+1 个元素 比如 arr[0]：二维数组的第一个元素
//2. arr[i].length 得到 对应的 每个一维数组的长度
        for(int j = 0; j &lt; arr[i].length; j++) &#123;
        System.out.print(arr[i][j] + &quot; &quot;); //输出了一维数组
&#125;
        System.out.println();//换行
&#125;</code></pre>

<pre><code class="hljs plaintext">System.out.println();//换行</code></pre>

<pre><code class="hljs plaintext">System.out.println(&quot;二维数组的元素个数=&quot; + arr.length);
//(2) 二维数组的每个元素是一维数组, 所以如果需要得到每个一维数组的值
// 还需要再次遍历</code></pre>

<p><code>arr.length</code>代表的是二维数组中第一层的元素个数，也就是里面一维数组的个数。</p>
<p><code>arr[i].length</code>代表的是二维数组中的第 i+1 个一维数组中的元素个数。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421100232412.png" alt="image-20240421100232412"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421100247672.png" alt="image-20240421100247672"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421100300205.png" alt="image-20240421100300205"></p>
<p>第二种相当于是二维数组里的每个元素单独赋值，不过这边用的是“（）”而不是“{}”。</p>
<p><strong>动态初始化，当列数不确定时</strong></p>
<pre><code class="hljs plaintext">public class ForExercise &#123;
   public static void main(String[] args)&#123;
       int[][] arr = new int[3][];
       for(int i = 0; i &lt; arr.length; i++) &#123;//遍历 arr 每个一维数组
//给每个一维数组开空间 new
//如果没有给一维数组 new ,那么 arr[i]就是 null
           arr[i] = new int[i + 1];
//遍历一维数组，并给一维数组的每个元素赋值
           for(int j = 0; j &lt; arr[i].length; j++) &#123;
               arr[i][j] = i + 1;//赋值
           &#125;
       &#125;
       System.out.println(&quot;=====arr 元素=====&quot;);
//遍历 arr 输出
       for(int i = 0; i &lt; arr.length; i++) &#123;
//输出 arr 的每个一维数组
           for(int j = 0; j &lt; arr[i].length; j++) &#123;
               System.out.print(arr[i][j] + &quot; &quot;);
           &#125;
           System.out.println();//换行
       &#125;
   &#125;
&#125;</code></pre>

<p>二维数组的行数必须确认，列数可暂时不规定。</p>
<p><strong>二维数组中的每个一维数组的空间大小可以不相同。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421101136977.png" alt="image-20240421101136977"></p>
<h1 id="面向对象编程（基础）"><a href="#面向对象编程（基础）" class="headerlink" title="面向对象编程（基础）"></a>面向对象编程（基础）</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><pre><code class="hljs plaintext">class ForExercise &#123;
   public static void main(String[] args)&#123;
       Cat cat1 = new Cat();
       cat1.name = &quot;小白&quot;;
       cat1.age = 3;
       cat1.color = &quot;白色&quot;;
       cat1.weight = 10;
//创建了第二只猫，并赋给 cat2
//cat2 也是一个对象(猫对象)
       Cat cat2 = new Cat();
       cat2.name = &quot;小花&quot;;
       cat2.age = 100;
       cat2.color = &quot;花色&quot;;
       cat2.weight = 20;
//怎么访问对象的属性呢
       System.out.println(&quot;第 1 只猫信息&quot; + cat1.name
               + &quot; &quot; + cat1.age + &quot; &quot; + cat1.color + &quot; &quot; + cat1.weight);
       System.out.println(&quot;第 2 只猫信息&quot; + cat2.name
               + &quot; &quot; + cat2.age + &quot; &quot; + cat2.color + &quot; &quot; + cat2.weight);
   &#125;
&#125;
class Cat &#123;
    //属性/成员变量
    String name; //名字
    int age; //年龄
    String color; //颜色
    double weight; //体重
//行为
&#125;</code></pre>

<pre><code class="hljs plaintext">//1. new Cat() 创建一只猫(猫对象)
//2. Cat cat1 = new Cat(); 把创建的猫赋给 cat1
//cat1就是一个对象</code></pre>

<p>对于Cat这个类的定义在程序的前面或者后面都可以，位置没有规定，只要有定义就可以。</p>
<p><strong>cat1只是对象名，new Cat()创建的对象空间（数据）才是真正的对象。</strong></p>
<h3 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421152812000.png" alt="image-20240421152812000"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421154101920.png" alt="image-20240421154101920"></p>
<h3 id="属性-成员变量-字段"><a href="#属性-成员变量-字段" class="headerlink" title="属性&#x2F;成员变量&#x2F;字段"></a>属性&#x2F;成员变量&#x2F;字段</h3><p>（1）从概念或叫法上看： 成员变量 &#x3D; 属性 &#x3D; field(字段) （即 成员变量是用来表示属性的，授课中，统一叫 属性)。</p>
<p>（2）属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)。</p>
<p>就是类的定义里的那些量。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421155237284.png" alt="image-20240421155237284"></p>
<p>有默认值，public啥的参考c++（我觉得）。</p>
<pre><code class="hljs plaintext">class Person &#123;
    //四个属性
    int age;
    String name;
    double sal;
    boolean isPass;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421155435513.png" alt="image-20240421155435513"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421160114725.png" alt="image-20240421160114725"></p>
<p>这个赋值跟数组那边的指向那个数组类似，这边<strong>修改p2里的值，p1里的值也会发生变化</strong>。</p>
<p>即<code>p2.age=12</code>这句话可以改变p2里的age但不能改变p1里的age。</p>
<h3 id="类和对象的内存分配"><a href="#类和对象的内存分配" class="headerlink" title="类和对象的内存分配"></a>类和对象的内存分配</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421161008041.png" alt="image-20240421161008041"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421161024081.png" alt="image-20240421161024081"></p>
<p><strong>字符串属于常量</strong></p>
<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><p>即函数</p>
<pre><code class="hljs plaintext">class ForExercise &#123;
   public static void main(String[] args)&#123;
       //方法使用
//1. 方法写好后，如果不去调用(使用)，不会输出
//2. 先创建对象 ,然后调用方法即可
       Person p1 = new Person();
       p1.speak(); //调用方法
       p1.cal01(); //调用 cal01 方法
       p1.cal02(5); //调用 cal02 方法，同时给 n = 5
       p1.cal02(10); //调用 cal02 方法，同时给 n = 10
//调用 getSum 方法，同时 num1=10, num2=20
       //把 方法 getSum 返回的值，赋给 变量 returnRes
       int returnRes = p1.getSum(10, 20);
       System.out.println(&quot;getSum 方法返回的值=&quot; + returnRes);
   &#125;
&#125;
class Person &#123;
    String name;
    int age;
    //方法(成员方法)
//添加 speak 成员方法,输出 “我是一个好人”
//老韩解读
//1. public 表示方法是公开
//2. void ： 表示方法没有返回值
//3. speak() : speak 是方法名， () 形参列表
//4. &#123;&#125; 方法体，可以写我们要执行的代码
//5. System.out.println(&quot;我是一个好人&quot;); 表示我们的方法就是输出一句话
    public void speak() &#123;
        System.out.println(&quot;我是一个好人&quot;);
    &#125;
    //添加 cal01 成员方法,可以计算从 1+..+1000 的结果
    public void cal01() &#123;
//循环完成
        int res = 0;
        for(int i = 1; i &lt;= 1000; i++) &#123;
            res += i;
        &#125;
        System.out.println(&quot;cal01 方法 计算结果=&quot; + res);
    &#125;
    //添加 cal02 成员方法,该方法可以接收一个数 n，计算从 1+..+n 的结果
//老韩解读
//1. (int n) 形参列表， 表示当前有一个形参 n, 可以接收用户输入
    public void cal02(int n) &#123;
//循环完成
        int res = 0;
        for(int i = 1; i &lt;= n; i++) &#123;
            res += i;
        &#125;
        System.out.println(&quot;cal02 方法 计算结果=&quot; + res);
    &#125;
    //添加 getSum 成员方法,可以计算两个数的和
//老韩解读
//1. public 表示方法是公开的
//2. int :表示方法执行后，返回一个 int 值
//3. getSum 方法名
//4. (int num1, int num2) 形参列表，2 个形参，可以接收用户传入的两个数
//5. return res; 表示把 res 的值， 返回
    public int getSum(int num1, int num2) &#123;
        int res = num1 + num2;
        return res;
    &#125;
&#125;</code></pre>

<p>类里面的函数和c++里的一样要加上public啥的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240422104711717.png" alt="image-20240422104711717"></p>
<p>方法，接收一个二维数组</p>
<pre><code class="hljs plaintext">//方法，接收一个二维数组
public void printArr(int[][] map) &#123;
    System.out.println(&quot;=======&quot;);
//对传入的 map 数组进行遍历输出
    for(int i = 0; i &lt; map.length; i++) &#123;
        for(int j = 0; j &lt; map[i].length; j++) &#123;
            System.out.print(map[i][j] + &quot;_&quot;);
        &#125;
        System.out.println();
    &#125;
&#125;</code></pre>

<p>方法，返回一个数组</p>
<p>想要同时返回多个值，那就选择返回数组。返回的应该是数组地址。</p>
<pre><code class="hljs plaintext">int[] res = a.getSumAndSub(1, 4);
public int[] getSumAndSub(int n1, int n2) &#123;
    int[] resArr = new int[2]; //
    resArr[0] = n1 + n2;
    resArr[1] = n1 - n2;
    return resArr;
&#125;
//2. 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)</code></pre>

<pre><code class="hljs plaintext">//细节: 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型 的参数
byte b1 = 1;
byte b2 = 2;
a.getSumAndSub(b1, b2);//byte -&gt; int
//a.getSumAndSub(1.1, 1.8);//double -&gt;int(×)</code></pre>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>参数列表中的数，如果输入的数和定义的类型不同，但是可以自动转化也可以。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240422110254831.png" alt="image-20240422110254831"></p>
<pre><code class="hljs plaintext">//细节: 方法不能嵌套定义
public void f4() &#123;
//错误
// public void f5() &#123;
// &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240422110428982.png" alt="image-20240422110428982"></p>
<pre><code class="hljs plaintext">class A &#123;
    //同一个类中的方法调用：直接调用即可
//
    public void print(int n) &#123;
        System.out.println(&quot;print()方法被调用 n=&quot; + n);
    &#125;
    public void sayOk() &#123; //sayOk 调用 print(直接调用即可)
        print(10);
        System.out.println(&quot;继续执行 sayOK()~~~&quot;);
    &#125;
    //跨类中的方法 A 类调用 B 类方法：需要通过对象名调用
    public void m1() &#123;
//创建 B 对象, 然后在调用方法即可
        System.out.println(&quot;m1() 方法被调用&quot;);
        B b = new B();
        b.hi();
        System.out.println(&quot;m1() 继续执行:)&quot;);
    &#125;
&#125;
class B &#123;
    public void hi() &#123;
        System.out.println(&quot;B 类中的 hi()被执行&quot;);
    &#125;
&#125;</code></pre>

<p>跨类中的方法 A 类调用 B 类方法要先在A类中创建B对象，然后通过”对象名.方法名“调用。</p>
<h3 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h3><p>大部分和c语言中的形参，实参关系一样。</p>
<p>B 类中编写一个方法 test200，可以<strong>接收</strong>一个 Person(age,sal)<strong>对象</strong>，在方法中修改该对象属性，看看原来的对象是否变化？会变化.</p>
<pre><code class="hljs plaintext">class ForExercise &#123;
   public static void main(String[] args)&#123;
       B b=new B();
       Person p = new Person();
       p.name = &quot;jack&quot;;
       p.age = 10;
       b.test200(p);
//测试题, 如果 test200 执行的是 p = null ,下面的结果是 10
//测试题, 如果 test200 执行的是 p = new Person();..., 下面输出的是 10
       System.out.println(&quot;main 的 p.age=&quot; + p.age);//10000
   &#125;
&#125;
class Person &#123;
    String name;
    int age;
&#125;
class B &#123;
    public void test200(Person p) &#123;
		p.age = 10000; //修改对象属性
//思考
        //p = new Person();
        //p.name = &quot;tom&quot;;
        //p.age = 99;
//思考
//p = null;
    &#125;
&#125;</code></pre>

<p>在成员方法中直接修改传进来的对象属性，则外面的对象属性也会一起变化；</p>
<p>第二个是建立一个新的对象，相当于给p赋一个新的地址而不是通过p去修改属性，所以外面的p不会变化，就像c语言中想要修改传进函数中的地址时，需要双指针<code>int** a</code>这时候<code>*a</code>代表的时地址，通过修改*a才能改变外面的int *a；</p>
<p>第三个给p赋null原理和第二个一样。</p>
<pre><code class="hljs plaintext">public void test200(Person p) &#123;
   Person p2 = new Person();
   p2 = p;
   p2.age = 10000;
  &#125;</code></pre>

<p>这种方法（地址的传递）也会改变p中的值。</p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>java 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致！</p>
<p>形参列表不一致的意思是形参数量不一样或者是数量一样的情况下形参类型不一样。</p>
<p><strong>案例：</strong></p>
<p>类：MyCalculator 方法：calculate</p>
<ol>
<li>calculate(int n1, int n2) &#x2F;&#x2F;两个整数的和</li>
<li>calculate(int n1, double n2) &#x2F;&#x2F;一个整数，一个 double 的和</li>
<li>calculate(double n2, int n1)&#x2F;&#x2F;一个 double ,一个 Int 和</li>
<li>calculate(int n1, int n2,int n3)&#x2F;&#x2F;三个 int 的和</li>
</ol>
<p>若只是一个方法的访问修饰符不同，则第二个方法相当于是第一个方法的重复而不是重载。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240512102858424.png" alt="image-20240512102858424"></p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法，就可以通过可变参数实现。</p>
<p>语法：访问修饰符 返回类型 方法名(数据类型… 形参名) { }</p>
<p>例子：</p>
<p>类 HspMethod，方法 sum 【可以计算 2 个数的和，3 个数的和 ， 4. 5， 。。】</p>
<p>这题可以一个个利用方法重载写方法，或者利用可变参数。</p>
<p>方法名称相同，功能相同, 参数个数不同-&gt; 使用可变参数优化</p>
<pre><code class="hljs plaintext">class B &#123;
    //可以计算 2 个数的和，3 个数的和 ， 4. 5， 。。
    //1. int... 表示接受的是可变参数，类型是 int ,即可以接收多个 int(0-多)
//2. 使用可变参数时，可以当做数组来使用 即 nums 可以当做数组
//3. 遍历 nums 求和即可
    public int sum(int... nums) &#123;
//System.out.println(&quot;接收的参数个数=&quot; + nums.length);
        int res = 0;
        for(int i = 0; i &lt; nums.length; i++) &#123;
            res += nums[i];
        &#125;
        return res;
    &#125;
&#125;</code></pre>

<p> <code>nums.length</code>代表的是可变参数的个数；</p>
<pre><code class="hljs plaintext">HspMethod m = new HspMethod();
System.out.println(m.sum(1, 5, 100)); //106
System.out.println(m.sum(1,19)); //20</code></pre>

<p>调用还是像之前一样，方法里的nums并不需要出现在调用时的参数列表中。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240512105648039.png" alt="image-20240512105648039"></p>
<pre><code class="hljs plaintext">class VarParameterDetail &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
        //细节: 可变参数的实参可以为数组
        int[] arr = &#123;1, 2, 3&#125;;
        T t1 = new T();
        t1.f1(arr);
    &#125;
&#125;
class T &#123;
    public void f1(int... nums) &#123;
        System.out.println(&quot;长度=&quot; + nums.length);
    &#125;
    //细节: 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
    public void f2(String str, double... nums) &#123;
    &#125;
//细节: 一个形参列表中只能出现一个可变参数
//下面的写法是错的.
// public void f3(int... nums1, double... nums2) &#123;
// &#125;
&#125;</code></pre>

<p><strong>使用可变参数时，可以当做数组来使用——scores[i]</strong></p>
<pre><code class="hljs plaintext">class VarParameterExercise &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
        HspMethod hm = new HspMethod();
        System.out.println(hm.showScore(&quot;milan&quot; , 90.1, 80.0 ));
        System.out.println(hm.showScore(&quot;terry&quot; , 90.1, 80.0,10,30.5,70 ));
    &#125;
&#125;
class HspMethod &#123;
    /*
    有三个方法，分别实现返回姓名和两门课成绩(总分)，
    返回姓名和三门课成绩(总分)，返回姓名和五门课成绩（总分）。
    封装成一个可变参数的方法
    */
//分析 1. 方法名 showScore 2. 形参(String ,double... ) 3. 返回 String
//听课小伙伴，老师要求必须自己动手写
    public String showScore(String name ,double... scores ) &#123;
        double totalScore = 0;
        for(int i = 0; i &lt; scores.length; i++) &#123;
            totalScore += scores[i];
        &#125;
        return name + &quot; 有 &quot; +scores.length + &quot;门课的成绩总分为=&quot; + totalScore;
    &#125;
&#125;</code></pre>

<p><code>return name + &quot; 有 &quot; +scores.length + &quot;门课的成绩总分为=&quot; + totalScore;</code></p>
<p>返回一个字符串。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240512110945870.png" alt="image-20240512110945870"></p>
<p>这边的全局变量指的是在一个类中可以随便用的变量，而局部变量指的是在这个类中的方法中定义的变量，出了这个方法就不能使用。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240512111357129.png" alt="image-20240512111357129"></p>
<p>修饰符就是public啥的</p>
<h2 id="构造方法-构造器"><a href="#构造方法-构造器" class="headerlink" title="构造方法&#x2F;构造器"></a>构造方法&#x2F;构造器</h2><p>前面我们在创建人类的对象时，是先把一个对象创建好后，再给他的年龄和姓名属性赋值，如 果现在我要求，在创建人类的对象时，就直接指定这个对象的年龄和姓名，该怎么做? 这时就可以使用构造器。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240526095634527.png" alt="image-20240526095634527"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240526095701954.png" alt="image-20240526095701954"></p>
<pre><code class="hljs plaintext">class VarParameterExercise &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//当我们 new 一个对象时，直接通过构造器指定名字和年龄
        Person p1 = new Person(&quot;smith&quot;, 80);
        System.out.println(&quot;p1 的信息如下&quot;);
        System.out.println(&quot;p1 对象 name=&quot; + p1.name);//smith
        System.out.println(&quot;p1 对象 age=&quot; + p1.age);//80
    &#125;
&#125;
//在创建人类的对象时，就直接指定这个对象的年龄和姓名
//
class Person &#123;
    String name;
    int age;

    //构造器
//老韩解读
//1. 构造器没有返回值, 也不能写 void
//2. 构造器的名称和类 Person 一样
//3. (String pName, int pAge) 是构造器形参列表，规则和成员方法一样
    public Person(String pName, int pAge) &#123;
        System.out.println(&quot;构造器被调用~~ 完成对象的属性初始化&quot;);
        name = pName;
        age = pAge;
    &#125;
&#125;</code></pre>

<p><strong>构造器没有返回值, 也不能写 void</strong></p>
<p><strong>Person p1 &#x3D; new Person(“smith”, 80);</strong></p>
<p><code>Person p1 = new Person();</code>这种形式现在就会报错了，除非显式表达一下，在下面。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240526104012922.png" alt="image-20240526104012922"></p>
<p>构造器也可以重载</p>
<pre><code class="hljs plaintext">class Dog &#123;
    //如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器(也叫默认构造器)
//使用 javap 指令 反编译看看
/*
默认构造器
Dog() &#123;
&#125;
*/
//一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，
//除非显式的定义一下,即: Dog()&#123;&#125; 写 (这点很重要)
//
    public Dog(String dName) &#123;
//... &#125;
        Dog() &#123; //显式的定义一下 无参构造器
        &#125;
    &#125;
&#125;</code></pre>

<p>无参构造器的结构体可以添加程序，如age&#x3D;3;</p>
<h2 id="对象创建的流程分析"><a href="#对象创建的流程分析" class="headerlink" title="对象创建的流程分析"></a>对象创建的流程分析</h2><p>看不懂，基础不牢，等老师讲吧</p>
<p>就是后台程序的运行顺序</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h3 id="初始理解-hashcode"><a href="#初始理解-hashcode" class="headerlink" title="初始理解+hashcode"></a>初始理解+hashcode</h3><pre><code class="hljs plaintext">class VarParameterExercise &#123;
    public static void main(String[] args) &#123;
        Dog dog1 = new Dog(&quot;大壮&quot;, 3);
        System.out.println(&quot;dog1 的 hashcode=&quot; + dog1.hashCode());
//dog1 调用了 info()方法
        dog1.info();
        System.out.println(&quot;============&quot;);
        Dog dog2 = new Dog(&quot;大黄&quot;, 2);
        System.out.println(&quot;dog2 的 hashcode=&quot; + dog2.hashCode());
        dog2.info();
    &#125;
&#125;
class Dog&#123; //类
    String name;
    int age;
// public Dog(String dName, int dAge)&#123;//构造器
// name = dName;
// age = dAge;
// &#125;
//如果我们构造器的形参，能够直接写成属性名，就更好了
//但是出现了一个问题，根据变量的作用域原则
//构造器的 name 是局部变量，而不是属性
//构造器的 age 是局部变量，而不是属性
//==&gt; 引出 this 关键字来解决
public Dog(String name, int age)&#123;//构造器
//this.name 就是当前对象的属性 name
    this.name = name;
//this.age 就是当前对象的属性 age
    this.age = age;
    System.out.println(&quot;this.hashCode=&quot; + this.hashCode());
&#125;
    public void info()&#123;//成员方法,输出属性 x 信息
        System.out.println(&quot;this.hashCode=&quot; + this.hashCode());
        System.out.println(name + &quot;\t&quot; + age + &quot;\t&quot;);
    &#125;
&#125;</code></pre>

<p>据我的理解，构造器里的name是局部变量，而this.name是属性的name。</p>
<p>this后面加的应该是属性，因为<code>this.dName</code>是错误的</p>
<p><code>dog1.info()</code> 方法和 <code>dog1.hashCode()</code> 中两者返回的哈希码是一样的，而哈希码表示的是这个东西的存储位置，因此这里的调用都针对同一个 <code>Dog</code> 对象 <code>dog1</code>。</p>
<p>this.name.hashCode输出的是属性中name的哈希码；不同对象里的name的哈希码是不同的；name是String类的，所以有哈希码。</p>
<ul>
<li>在构造器中，<code>name</code> 被赋值为 <code>dName</code>，即 <code>name = dName;</code>。</li>
<li>然后，<code>this.name</code> 和 <code>dName</code> 都引用同一个字符串对象，因为在 Java 中字符串是不可变的，并且字符串的 <code>hashCode()</code> 方法是基于字符串内容计算的。</li>
<li><code>String</code> 类的 <code>hashCode()</code> 方法返回的是<strong>基于字符串内容计算出的哈希码，而不是对象的内存地址</strong>。</li>
<li>因此，如果两个字符串对象的内容相同（如 <code>this.name</code> 和 <code>dName</code> 在这个上下文中），它们的 <code>hashCode()</code> 返回值也是相同的。</li>
<li><code>System.out.println(&quot;this.hashCode=&quot; + this.age.hashCode());</code> 这句话是错误的，因为 <code>this.age</code> 是一个基本数据类型 <code>int</code>，而基本数据类型 <code>int</code> 没有 <code>hashCode()</code> 方法。<code>hashCode()</code> 是 <code>Object</code> 类的方法，只有<strong>对象类型才有这个方法，而基本数据类型是没有的。</strong></li>
</ul>
<pre><code class="hljs plaintext">在这个 Dog 类的代码示例中，System.out.println(&quot;this.hashCode=&quot; + this.hashCode()); 被用来输出当前 Dog 对象的哈希码。哈希码是一个整数，用于唯一标识对象的引用，在某种程度上表示对象在内存中的位置。</code></pre>

<p>要理解 <code>System.out.println(&quot;this.hashCode=&quot; + this.hashCode());</code> 的作用以及输出什么，我们可以分几个部分来分析：</p>
<ol>
<li><strong><code>this.hashCode()</code> 的作用</strong>:<ul>
<li><code>this</code> 关键字指的是当前对象的引用。</li>
<li><code>hashCode()</code> 是 <code>Object</code> 类的一个方法，返回一个哈希码值，通常不同对象的哈希码值是不同的，除非 <code>hashCode()</code> 方法被重写。</li>
</ul>
</li>
<li><strong>在构造器中的 <code>System.out.println(&quot;this.hashCode=&quot; + this.hashCode());</code></strong>:<ul>
<li>当创建一个新的 <code>Dog</code> 对象时，这个构造器会被调用。</li>
<li><code>this.hashCode()</code> 会输出当前 <code>Dog</code> 对象的哈希码，帮助我们确认当前对象的内存地址（可以理解为对象的唯一标识）。</li>
</ul>
</li>
<li><strong>在 <code>info</code> 方法中的 <code>System.out.println(&quot;this.hashCode=&quot; + this.hashCode());</code></strong>:<ul>
<li>当调用 <code>info</code> 方法时，<code>this.hashCode()</code> 会再次输出当前对象的哈希码。</li>
<li>这样可以确认调用 <code>info</code> 方法的对象是哪个，验证 <code>Dog</code> 对象的哈希码。</li>
</ul>
</li>
</ol>
<h3 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h3><p>this小结：简单的说就是哪个对象被调用，this就代表哪个对象。</p>
<pre><code class="hljs plaintext">switch (key)&#123;
    case &quot;1&quot;:
        this.detail();
        break;
    case &quot;2&quot;:
        this.income();
        break;
    case &quot;3&quot;:
        this.pay();
        break;
    case &quot;4&quot;:
        this.exit();
        break;
    default:
        System.out.println(&quot;输入有误，请重新选择！&quot;);
    &#125;</code></pre>

<p>通过这样用this，可以调用这个类中的方法。</p>
<h3 id="注意和细节"><a href="#注意和细节" class="headerlink" title="注意和细节"></a>注意和细节</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240526231659923.png" alt="image-20240526231659923"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240526231714044.png" alt="image-20240526231714044"></p>
<pre><code class="hljs plaintext">class VarParameterExercise &#123;
    public static void main(String[] args) &#123;
        Person p1 = new Person(&quot;mary&quot;, 20);
        Person p2 = new Person(&quot;mary&quot;, 20);
        System.out.println(&quot;p1 和 p2 比较的结果=&quot; + p1.compareTo(p2));
    &#125;
&#125;
/*
定义 Person 类，里面有 name、age 属性，并提供 compareTo 比较方法，
用于判断是否和另一个人相等，提供测试类 TestPerson 用于测试, 名字和年龄完全一样，就返回 true, 否则返回 false
 */
class Person &#123;
    String name;
    int age;
    //构造器
    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    //compareTo 比较方法
    public boolean compareTo(Person p) &#123;
//名字和年龄完全一样
// if(this.name.equals(p.name) &amp;&amp; this.age == p.age) &#123;
// return true;
// &#125; else &#123;
// return false;
// &#125;
        return this.name.equals(p.name) &amp;&amp; this.age == p.age;
    &#125;
&#125;</code></pre>

<p><code>return this.name.equals(p.name) &amp;&amp; this.age == p.age;</code>里面的this指的是调用这个函数的对象。</p>
<p>上面第四点：例子：</p>
<p>为 Rectangle 类编写一个带参数的构造方法，通过用户给出的长、宽创建矩形对象，再 编写一个默认的构造方法，在该方法中调用有参数的构造方法</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240715200948826.png" alt="image-20240715200948826"></p>
<h1 id="面向对象编程（中级）"><a href="#面向对象编程（中级）" class="headerlink" title="面向对象编程（中级）"></a>面向对象编程（中级）</h1><h2 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h2><ol>
<li>删除当前行, 默认是 ctrl + Y 自己配置 ctrl + d</li>
<li>复制当前行, 自己配置 ctrl + alt + 向下光标</li>
<li>补全代码 alt + &#x2F;</li>
<li>添加注释和取消注释 ctrl + &#x2F; 【第一次是添加注释，第二次是取消注释】</li>
<li>导入该行需要的类 先配置 auto import , 然后使用 alt+enter 即可</li>
<li>快速格式化代码 ctrl + alt + L</li>
<li>快速运行程序 自己定义 alt + R</li>
<li>生成构造器等 alt + insert [提高开发效率]</li>
<li>查看一个类的层级关系 ctrl + H [学习继承后，非常有用]</li>
<li>将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用]</li>
<li>自动的分配变量名 , 通过 在后面加 .var [老师最喜欢的]</li>
<li>还有很多其它的快捷键…</li>
</ol>
<p>control + O 在子类中重写方法。</p>
<p>一个普通类实现接口,就必须将该接口的所有方法都实现,可以使用 alt+enter （得先将光标放于该类上）来解决。</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716104558577.png" alt="image-20240716104558577"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716105559989.png" alt="image-20240716105559989"></p>
<h3 id="引入包"><a href="#引入包" class="headerlink" title="引入包"></a>引入包</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716105745510.png" alt="image-20240716105745510"></p>
<pre><code class="hljs plaintext">package com.hspedu.pkg;
import java.util.Arrays;
//注意:
//老韩建议：我们需要使用到哪个类，就导入哪个类即可，不建议使用 *导入
//import java.util.Scanner; 表示只会引入 java.util 包下的 Scanner
//import java.util.*;//表示将 java.util 包下的所有类都引入(导入)
public class Import &#123;
    public static void main(String[] args) &#123;
//使用系统提供 Arrays 完成 数组排序
        int[] arr = &#123;-1, 20, 2, 13, 3&#125;;
//比如对其进行排序
//传统方法是，自己编写排序(冒泡)
//系统是提供了相关的类，可以方便完成 Arrays
        Arrays.sort(arr);
//输出排序结果
        for (int i = 0; i &lt; arr.length; i++) &#123;
            System.out.print(arr[i] + &quot;\t&quot;);
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="sort排序、collections、Integer"><a href="#sort排序、collections、Integer" class="headerlink" title="sort排序、collections、Integer"></a>sort排序、collections、Integer</h4><p>升序排序：首先要引入Arrays包，<code>import java.util.Arrays;</code></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716111438635.png" alt="image-20240716111438635"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716111525542.png" alt="image-20240716111525542"></p>
<p>输出应该是[5,2,9,1,3]</p>
<p>降序排序：在引入Arrays包的基础上，再引入Collections,<code>import java.util.Collections;</code></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716113303141.png" alt="image-20240716113303141"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716113759767.png" alt="image-20240716113759767"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716113811536.png" alt="image-20240716113811536"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716113833142.png" alt="image-20240716113833142"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716113915583.png" alt="image-20240716113915583"></p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716114938961.png" alt="image-20240716114938961"></p>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716152930438.png" alt="image-20240716152930438"></p>
<p>由继承得到的类叫作子类。</p>
<pre><code class="hljs plaintext">package com.hspedu.modifier;
public class A &#123;
    //四个属性,分别使用不同的访问修饰符来修饰
    public int n1 = 100;
    protected int n2 = 200;
    int n3 = 300;
    private int n4 = 400;
    public void m1() &#123;
//在同一类中，可以访问 public protected 默认 private 修饰属性和方法
        System.out.println(&quot;n1=&quot; + n1 + &quot; n2=&quot; + n2 + &quot; n3=&quot; + n3 + &quot; n4=&quot; + n4);
    &#125;
    protected void m2() &#123; &#125;
    void m3() &#123; &#125;
    private void m4() &#123; &#125;
    public void hi() &#123;
//在同一类中，可以访问 public protected 默认 private 修饰属性和方法
        m1();
        m2();
        m3();
        m4();
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.modifier;
public class B &#123;
    public void say() &#123;
        A a = new A();
//在同一个包下，可以访问 public , protected 和 默认修饰属性或方法,不能访问 private 属性或方法
        System.out.println(&quot;n1=&quot; + a.n1 + &quot; n2=&quot; + a.n2 + &quot; n3=&quot; + a.n3 );
        a.m1();
        a.m2();
        a.m3();
//a.m4(); 错误的
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.modifier;
public class Test &#123;
    public static void main(String[] args) &#123;
        A a = new A ();
        a.m1();
        B b = new B();
        b.say();
    &#125;
&#125;
//只有 默认和 public 可以修饰类
class Tiger&#123; &#125;</code></pre>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>面向对象编程有三大特征：封装、继承和多态。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716155111996.png" alt="image-20240716155111996"></p>
<pre><code class="hljs plaintext">package com.hspedu.encap;
public class a&#123;
    public static void main(String[] args)&#123;
        Person person = new Person();
        person.setName(&quot;韩顺平&quot;);
        person.setAge(30);
        person.setSalary(30000);
        System.out.println(person.info());
        System.out.println(person.getSalary());
//如果我们自己使用构造器指定属性
        Person smith = new Person(&quot;smith&quot;, 80, 50000);
        System.out.println(&quot;====smith 的信息======&quot;);
        
        System.out.println(smith.info());
    &#125;
&#125;
/*
那么在 java 中如何实现这种类似的控制呢?
请大家看一个小程序(com.hspedu.encap: Encapsulation01.java), 不能随便查看人的年龄,工资等隐私，并对设置的年龄进行合理的验证。年龄合理就设置，否则给默认
年龄, 必须在 1-120, 年龄， 工资不能直接查看 ， name 的长度在 2-6 字符 之间
*/
class Person &#123;
    public String name; //名字公开
    private int age; //age 私有化
    private double salary; //..
     public void say(int n,String name) &#123;
&#125;
//构造器 alt+insert
public Person() &#123;
&#125;
//有三个属性的构造器
public Person(String name, int age, double salary) &#123;
// this.name = name;
// this.age = age;
// this.salary = salary;
//我们可以将 set 方法写在构造器中，这样仍然可以验证
    setName(name);
    setAge(age);
    setSalary(salary);
&#125;
//自己写 setXxx 和 getXxx 太慢，我们使用快捷键
//然后根据要求来完善我们的代码.
 public String getName() &#123;
         return name;
&#125;
public void setName(String name) &#123;
//加入对数据的校验,相当于增加了业务逻辑
    if(name.length() &gt;= 2 &amp;&amp; name.length() &lt;=6 ) &#123;
        this.name = name;
    &#125;else &#123;
        System.out.println(&quot;名字的长度不对，需要(2-6)个字符，默认名字&quot;);
        this.name = &quot;无名人&quot;;
    &#125;
&#125;
public int getAge() &#123;
    return age;
&#125;
public void setAge(int age) &#123;
    //判断
    if(age &gt;= 1 &amp;&amp; age &lt;= 120) &#123;//如果是合理范围
        this.age = age;
    &#125; else &#123;
        System.out.println(&quot;你设置年龄不对，需要在 (1-120), 给默认年龄 18 &quot;);
        this.age = 18;//给一个默认年龄
    &#125;
&#125;
public double getSalary() &#123;
//可以这里增加对当前对象的权限判断
    return salary;
&#125;
public void setSalary(double salary) &#123;
    this.salary = salary;
&#125;
//写一个方法，返回属性信息
public String info() &#123;
    return &quot;信息为 name=&quot; + name + &quot; age=&quot; + age + &quot; 薪水=&quot; + salary;
&#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">smith.age = 70;//错误，因为是private,所以得用特定的方法去访问或者修改这个属性，即setName</code></pre>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716163920548.png" alt="image-20240716163920548"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716163953842.png" alt="image-20240716163953842"></p>
<p>​	继承可以跨包进行。</p>
<p>父类中private的属性子类不能直接使用。</p>
<pre><code class="hljs plaintext">package com.hspedu.extend_.improve_;
//父类,是 Pupil 和 Graduate 的父类
public class Student &#123;
    //共有属性
    public String name;
    public int age;
    private double score;//成绩
    //共有的方法
    public void setScore(double score) &#123;
        this.score = score;
    &#125;
    public void showInfo() &#123;
        System.out.println(&quot;学生名 &quot; + name + &quot; 年龄 &quot; + age + &quot; 成绩 &quot; + score);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.extend_.improve_;
//让 Pupil 继承 Student 类
public class Pupil extends Student &#123;
    public void testing() &#123;
        System.out.println(&quot;小学生 &quot; + name + &quot; 正在考小学数学..&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.extend_.improve_;

public class Graduate extends Student &#123;
    public void testing() &#123;//和 Pupil 不一样
        System.out.println(&quot;大学生 &quot; + name + &quot; 正在考大学数学..&quot;);
    &#125;
&#125;</code></pre>

<p>若和上面三个处于同一个包中，以下两句可以省略</p>
<pre><code class="hljs plaintext">import com.hspedu.extend_.improve_.Graduate;
import com.hspedu.extend_.improve_.Pupil;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.extend_.improve_;

import com.hspedu.extend_.improve_.Graduate;
import com.hspedu.extend_.improve_.Pupil;

public class Extends01 &#123;
    public static void main(String[] args) &#123;
        com.hspedu.extend_.improve_.Pupil pupil = new Pupil();
        pupil.name = &quot;银角大王~&quot;;
        pupil.age = 11;
        pupil.testing();
        pupil.setScore(50);
        pupil.showInfo();
        System.out.println(&quot;=======&quot;);
        com.hspedu.extend_.improve_.Graduate graduate = new Graduate();
        graduate.name = &quot;金角大王~&quot;;
        graduate.age = 23;
        graduate.testing();
        graduate.setScore(80);
        graduate.showInfo();
    &#125;
&#125;</code></pre>

<p>已经引进了Pupil包，<code>import com.hspedu.extend_.improve_.Pupil;</code>，那下面的<code>com.hspedu.extend_.improve_.Pupil pupil = new Pupil();</code>可以变成<code>Pupil pupil = new Pupil();</code>，Graduate那个也是一样的道理。</p>
<p>像之前的Scanner，原本的<code>Scanner input = new Scanner(System.in)</code>也可以写作<code>java.util.Scanner input = new Scanner(System.in)</code>。</p>
<p>由于上面的类定义都是public，所以也可以在别的包中使用：</p>
<pre><code class="hljs plaintext">这个所处的包

import com.hspedu.extend_.improve_.Graduate;
import com.hspedu.extend_.improve_.Pupil;

public class a &#123;
    public static void main(String[] args) &#123;
        com.hspedu.extend_.improve_.Pupil pupil = new Pupil();
        pupil.name = &quot;银角大王~&quot;;
        pupil.age = 11;
        pupil.testing();
        pupil.setScore(50);
        pupil.showInfo();
        System.out.println(&quot;=======&quot;);
        com.hspedu.extend_.improve_.Graduate graduate = new Graduate();
        graduate.name = &quot;金角大王~&quot;;
        graduate.age = 23;
        graduate.testing();
        graduate.setScore(80);
        graduate.showInfo();
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">import com.hspedu.extend_.improve_.Graduate;
import com.hspedu.extend_.improve_.Pupil;</code></pre>

<p>这两句不可以省略了，但下面的<code>com.hspedu.extend_.improve_.Pupil pupil = new Pupil();</code>在引入类后就可以变成<code>Pupil pupil = new Pupil();</code>了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716204256473.png" alt="image-20240716204256473"></p>
<h3 id="深入讨论"><a href="#深入讨论" class="headerlink" title="深入讨论"></a>深入讨论</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716204345054.png" alt="image-20240716204345054"></p>
<p>父类没有提供无参构造器但也没提供有参构造器的时候，仍然是默认调用父类的无参构造器。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716204400577.png" alt="image-20240716204400577"></p>
<p>上面的看下面的例子都能懂，调用子类构造器，会从最顶级的父类一直往下调用，直到你调用的这个子类的构造器为止。不懂可运行下面程序。</p>
<pre><code class="hljs plaintext">package com.hspedu.extend_;

public class TopBase &#123; //父类是 Object
    public TopBase() &#123;
//super(); Object 的无参构造器
        System.out.println(&quot;构造器 TopBase() 被调用...&quot;);//1
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.extend_;

public class Base extends TopBase &#123; //父类
    //4 个属性
    public int n1 = 100;
    protected int n2 = 200;
    int n3 = 300;
    private int n4 = 400;
    public Base() &#123; //无参构造器
        System.out.println(&quot;父类 Base()构造器被调用....&quot;);
    &#125;
    public Base(String name, int age) &#123;//有参构造器
//默认 super()
        System.out.println(&quot;父类 Base(String name, int age)构造器被调用....&quot;);
    &#125;
    public Base(String name) &#123;//有参构造器
        System.out.println(&quot;父类 Base(String name)构造器被调用....&quot;);
    &#125;
    //父类提供一个 public 的方法,返回了 n4
    public int getN4() &#123;
        return n4;
    &#125;
    public void test100() &#123;
        System.out.println(&quot;test100&quot;);
    &#125;
    protected void test200() &#123;
        System.out.println(&quot;test200&quot;);
    &#125;
    void test300() &#123;
        System.out.println(&quot;test300&quot;);
    &#125;
    private void test400() &#123;
        System.out.println(&quot;test400&quot;);
    &#125;
    //call
    public void callTest400() &#123;
        test400();
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.extend_;

<span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-comment">//输入 ctrl + H 可以看到类的继承关系</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-comment">//子类</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sub</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;
<span class="hljs-comment">//1. 老师要调用父类的无参构造器, 如下或者 什么都不写,默认就是调用 super()</span>
<span class="hljs-comment">//super();//父类的无参构造器</span>
<span class="hljs-comment">//2. 老师要调用父类的 Base(String name) 构造器</span>
<span class="hljs-comment">//super(&quot;hsp&quot;);</span>
<span class="hljs-comment">//3. 老师要调用父类的 Base(String name, int age) 构造器</span>
        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;king&quot;</span>, <span class="hljs-number">20</span>);
<span class="hljs-comment">//细节： super 在使用时，必须放在构造器第一行</span>
<span class="hljs-comment">//细节: super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</span>
<span class="hljs-comment">//this() 不能再使用了</span>
        System.out.println(<span class="hljs-string">&quot;子类 Sub(String name, int age)构造器被调用....&quot;</span>);
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sub</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//无参构造器</span>
<span class="hljs-comment">//super(); //默认调用父类的无参构造器</span>
        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;smith&quot;</span>, <span class="hljs-number">10</span>);
        System.out.println(<span class="hljs-string">&quot;子类 Sub()构造器被调用....&quot;</span>);
    &#125;
    <span class="hljs-comment">//当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sub</span><span class="hljs-params">(String name)</span> &#123;
        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">30</span>);
<span class="hljs-comment">//do nothing... </span>
        System.out.println(<span class="hljs-string">&quot;子类 Sub(String name)构造器被调用....&quot;</span>);
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayOk</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//子类方法</span>
<span class="hljs-comment">//非私有的属性和方法可以在子类直接访问</span>
<span class="hljs-comment">//但是私有属性和方法不能在子类直接访问</span>
        System.out.println(n1 + <span class="hljs-string">&quot; &quot;</span> + n2 + <span class="hljs-string">&quot; &quot;</span> + n3);
        test100();
        test200();
        test300();
<span class="hljs-comment">//test400();错误</span>
<span class="hljs-comment">//要通过父类提供公共的方法去访问</span>
        System.out.println(<span class="hljs-string">&quot;n4=&quot;</span> + getN4());
        callTest400();<span class="hljs-comment">//</span>
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.extend_;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendsDetail</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
<span class="hljs-comment">// System.out.println(&quot;===第 1 个对象====&quot;);</span>
<span class="hljs-comment">// Sub sub = new Sub(); //创建了子类对象 sub</span>
<span class="hljs-comment">// System.out.println(&quot;===第 2 个对象====&quot;);</span>
<span class="hljs-comment">// Sub sub2 = new Sub(&quot;jack&quot;); //创建了子类对象 sub2</span>
        System.out.println(<span class="hljs-string">&quot;===第 3 对象====&quot;</span>);
        <span class="hljs-type">Sub</span> <span class="hljs-variable">sub3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>(<span class="hljs-string">&quot;king&quot;</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">//创建了子类对象 sub3</span>
        sub3.sayOk();
<span class="hljs-comment">//sub.sayOk();</span>
    &#125;
&#125;</code></pre>

<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716210400850.png" alt="image-20240716210400850"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716210424127.png" alt="image-20240716210424127"></p>
<h3 id="本质分析"><a href="#本质分析" class="headerlink" title="本质分析"></a>本质分析</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717154518155.png" alt="image-20240717154518155"></p>
<pre><code class="hljs plaintext">/**
 * 讲解继承的本质
 */
public class a &#123;
    public static void main(String[] args) &#123;
        Son son = new Son();//内存的布局
//?-&gt; 这时请大家注意，要按照查找关系来返回信息
//(1) 首先看子类是否有该属性
//(2) 如果子类有这个属性，并且可以访问，则返回信息
//(3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)
//(4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object... 
        System.out.println(son.name);//返回就是大头儿子
//System.out.println(son.getAge());//返回的就是 39
        System.out.println(son.hobby);//返回的就是旅游
    &#125;
&#125;
class GrandPa &#123; //爷类
    String name = &quot;大头爷爷&quot;;
    String hobby = &quot;旅游&quot;;
&#125;
class Father extends GrandPa &#123;//父类
    String name = &quot;大头爸爸&quot;;
    private int age = 39;
    public int getAge() &#123;
        return age;
    &#125;
&#125;
class Son extends Father &#123; //子类
    String name = &quot;大头儿子&quot;;
&#125;</code></pre>

<p>看起来应该是从小到大，或者说遵循就近原则。</p>
<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>super 代表父类的引用，用于<strong>访问父类的属性、方法、构造器</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717161053557.png" alt="image-20240717161053557"></p>
<p>有的知识看前面的super。</p>
<pre><code class="hljs plaintext">super 的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用 super 去访问爷爷类的成员；
如果多个基类(上级类)中都有同名的成员，使用 super 访问遵循就近原则。A-&gt;B-&gt;C</code></pre>

<p>cal方法就是该子类或其父类中的一个方法。</p>
<pre><code class="hljs plaintext">找 cal 方法时(cal() 和 this.cal())，顺序是:
(1)先找本类，如果有，则调用
(2)如果没有，则找父类(如果有，并可以调用，则调用)
(3)如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类
提示：如果查找方法的过程中，找到了，但是不能访问， 则报错, cannot access；父类和爷类都有但是父类的不能访问，也会报错，因为遵循就近原则。
如果查找方法的过程中，没有找到，则提示方法不存在
        this.cal(); //等价 cal</code></pre>

<pre><code class="hljs plaintext">找 cal 方法(super.call()) 的顺序是直接查找父类，其他的规则一样</code></pre>

<p>n1是该子类或其父类的一个属性。</p>
<pre><code class="hljs plaintext">n1 和 this.n1 查找的规则是
(1) 先找本类，如果有，则调用
(2) 如果没有，则找父类(如果有，并可以调用，则调用)
(3) 如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类
 提示：如果查找属性的过程中，找到了，但是不能访问， 则报错, cannot access
 如果查找属性的过程中，没有找到，则提示属性不存在</code></pre>

<pre><code class="hljs plaintext">找 n1 (super.n1) 的顺序是直接查找父类属性，其他的规则一样</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717171108655.png" alt="image-20240717171108655"></p>
<p>super和this的区别</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717171138906.png" alt="image-20240717171138906"></p>
<h2 id="方法重写-覆盖"><a href="#方法重写-覆盖" class="headerlink" title="方法重写&#x2F;覆盖"></a>方法重写&#x2F;覆盖</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717171312869.png" alt="image-20240717171312869"></p>
<p>细节: 子类方法的返回类型和父类方法返回类型一样，  或者是父类返回类型的子类</p>
<p><strong>注意事项和细节</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717171717547.png" alt="image-20240717171717547"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717171807403.png" alt="image-20240717171807403"></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>介绍：方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。</p>
<p>具体表现：</p>
<p>（1）方法的多态：重写和重载</p>
<p>（2）对象的多态：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717200449840.png" alt="image-20240717200449840"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717200458838.png" alt="image-20240717200458838"></p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.poly_.objectpoly_;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;
        System.out.println(<span class="hljs-string">&quot;Animal cry() 动物在叫....&quot;</span>);
    &#125;
&#125;
<span class="hljs-keyword">package</span> com.hspedu.poly_.objectpoly_;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;
        System.out.println(<span class="hljs-string">&quot;Cat cry() 小猫喵喵叫...&quot;</span>);
    &#125;
&#125;
<span class="hljs-keyword">package</span> com.hspedu.poly_.objectpoly_;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;
        System.out.println(<span class="hljs-string">&quot;Dog cry() 小狗汪汪叫...&quot;</span>);
    &#125;
&#125;
<span class="hljs-keyword">package</span> com.hspedu.poly_.objectpoly_;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyObject</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
<span class="hljs-comment">//体验对象多态特点</span>
<span class="hljs-comment">//animal 编译类型就是 Animal , 运行类型 Dog</span>
        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();
<span class="hljs-comment">//因为运行时 , 执行到改行时，animal 运行类型是 Dog,所以 cry 就是 Dog 的 cry</span>
        animal.cry(); <span class="hljs-comment">//小狗汪汪叫</span>
<span class="hljs-comment">//animal 编译类型 Animal,运行类型就是 Cat</span>
        animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();
        animal.cry(); <span class="hljs-comment">//小猫喵喵叫</span>
    &#125;
&#125;</code></pre>

<p>多态的<strong>前提是</strong>：两个对象(类)存在继承关系。</p>
<h3 id="向上和向下转型"><a href="#向上和向下转型" class="headerlink" title="向上和向下转型"></a>向上和向下转型</h3><p>多态的向上转型</p>
<p>不能调用子类中的特有成员就是说明调用的是对父类中的方法进行重写的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717202046849.png" alt="image-20240717202046849"></p>
<p>向上转型也可以这么写：</p>
<pre><code class="hljs plaintext">Cat cat = new Cat();

Animal animal = cat;</code></pre>

<p>多态向下转型</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717202102384.png" alt="image-20240717202102384"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240720155227537.png" alt="image-20240720155227537"></p>
<p>也可以  父类类型  引用名 &#x3D; （父类类型）父类引用，不过这样没啥用，使用方式还是和没转化前的一样，只能调用父类的东西。</p>
<pre><code class="hljs plaintext">package com.hspedu.poly_.detail_;
public class Animal &#123;
    String name = &quot;动物&quot;;
    int age = 10;
    public void sleep()&#123;
        System.out.println(&quot;睡&quot;);
    &#125;
    public void run()&#123;
        System.out.println(&quot;跑&quot;);
    &#125;
    public void eat()&#123;
        System.out.println(&quot;吃&quot;);
    &#125;
    public void show()&#123;
        System.out.println(&quot;hello,你好&quot;);
    &#125;
&#125;
package com.hspedu.poly_.detail_;
public class Cat extends Animal &#123;
    public void eat()&#123;//方法重写
        System.out.println(&quot;猫吃鱼&quot;);
    &#125;
    public void catchMouse()&#123;//Cat 特有方法
        System.out.println(&quot;猫抓老鼠&quot;);
    &#125;
&#125;
package com.hspedu.poly_.detail_;
public class Dog extends Animal &#123;//Dog 是 Animal 的子类
&#125;
package com.hspedu.poly_.detail_;
public class PolyDetail &#123;
    public static void main(String[] args) &#123;
//向上转型: 父类的引用指向了子类的对象
//语法：父类类型引用名 = new 子类类型();
    Animal animal = new Cat();
    Object obj = new Cat();//可以吗? 可以 Object 也是 Cat 的父类
//向上转型调用方法的规则如下:
//(1)可以调用父类中的所有成员(需遵守访问权限)
//(2)但是不能调用子类的特有的成员
//(#)因为在编译阶段，能调用哪些成员,是由编译类型来决定的
//animal.catchMouse();错误
//(4)最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法
//，然后调用，规则我前面我们讲的方法调用规则一致。
    animal.eat();//猫吃鱼.. animal.run();//跑
    animal.show();//hello,你好
    animal.sleep();//睡
//老师希望，可以调用 Cat 的 catchMouse 方法
//多态的向下转型
//(1)语法：子类类型 引用名 =（子类类型）父类引用;
//问一个问题? cat 的编译类型 Cat,运行类型是 Cat
    Cat cat = (Cat) animal;
    cat.catchMouse();//猫抓老鼠
//(2)要求父类的引用必须指向的是当前目标类型的对象
        Dog dog = (Dog) animal; //可以吗？不可以
        System.out.println(&quot;ok~~&quot;);
    &#125;
&#125;</code></pre>

<p><strong>属性没有重写之说,属性的值看编译类型</strong></p>
<pre><code class="hljs plaintext">package com.hspedu.poly_.detail_;
public class PolyDetail02 &#123;
    public static void main(String[] args) &#123;
//属性没有重写之说！属性的值看编译类型
        Base base = new Sub();//向上转型
        System.out.println(base.count);// ？ 看编译类型 10
        Sub sub = new Sub();
        System.out.println(sub.count);//? 20
    &#125;
&#125;
class Base &#123; //父类
    int count = 10;//属性
&#125;
class Sub extends Base &#123;//子类
    int count = 20;//属性
&#125;</code></pre>

<p><strong>instanceof 比较操作符</strong>，用于判断对象的<strong>运行类型</strong>是否为 XX 类型（后面的那个类型）或 XX 类型的子类型，</p>
<p>对象名  instanceof  类型名。</p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
        BB bb = new BB();
        System.out.println(bb instanceof BB);// true
        System.out.println(bb instanceof AA);// true
//aa 编译类型 AA, 运行类型是 BB
//BB 是 AA 子类
        AA aa = new BB();
        System.out.println(aa instanceof AA);//true
        System.out.println(aa instanceof BB);//true
        Object obj = new Object();
        System.out.println(obj instanceof AA);//false
        String str = &quot;hello&quot;;
//System.out.println(str instanceof AA);这句是错的,AA是一个类，str只是一个属性
        System.out.println(str instanceof Object);//true
    &#125;
&#125;
class AA &#123;&#125; //父类
class BB extends AA &#123;&#125;//子类</code></pre>

<h3 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240719165409567.png" alt="image-20240719165409567"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h4><p>多态数组 ： 数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。</p>
<p>应用实例:现有一个继承结构如下：要求创建 1 个 Person 对象、2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组 中，并调用每个对象 say 方法.</p>
<pre><code class="hljs plaintext">package com.hspedu.pkg;

public class Person &#123;//父类
    private String name;
    private int age;
    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    public String getName() &#123;return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public String say() &#123;//返回名字和年龄
        return name + &quot;\t&quot; + age;
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.pkg;

public class Student extends Person &#123;
    private double score;
    public Student(String name, int age, double score) &#123;
    	super(name, age);
        this.score = score;
    &#125;
    public double getScore() &#123;
        return score;
    &#125;
    public void setScore(double score) &#123;
        this.score = score;
    &#125;
    //重写父类 say
    @Override
    public String say() &#123;
        return &quot;学生 &quot; + super.say() + &quot; score=&quot; + score;
    &#125;
    //特有的方法
    public void study() &#123;
        System.out.println(&quot;学生 &quot; + getName() + &quot; 正在学 java...&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.pkg;

public class Teacher extends Person &#123;
    private double salary;
    public Teacher(String name, int age, double salary) &#123;
        super(name,age);
        this.salary = salary;
    &#125;
    public double getSalary() &#123;
        return salary;
    &#125;
    public void setSalary(double salary) &#123;
        this.salary = salary;
    &#125;
    //写重写父类的 say 方法
    @Override
    public String say() &#123;
        return &quot;老师 &quot; + super.say() + &quot; salary=&quot; + salary;
    &#125;
    //特有方法
    public void teach() &#123;
        System.out.println(&quot;老师 &quot; + getName() + &quot; 正在讲 java 课程...&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.pkg;

public class PloyArray &#123;
    public static void main(String[] args) &#123;
//应用实例:现有一个继承结构如下：要求创建 1 个 Person 对象、
// 2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组中，并调用每个对象 say 方法
        Person[] persons = new Person[5];
        persons[0] = new Person(&quot;jack&quot;, 20);
        persons[1] = new Student(&quot;mary&quot;, 18, 100);
        persons[2] = new Student(&quot;smith&quot;, 19, 30.1);
        persons[3] = new Teacher(&quot;scott&quot;, 30, 20000);
        persons[4] = new Teacher(&quot;king&quot;, 50, 25000);
//循环遍历多态数组，调用 say
        for (int i = 0; i &lt; persons.length; i++) &#123;
//老师提示: person[i] 编译类型是 Person ,运行类型是是根据实际情况由 JVM 来判断
            System.out.println(persons[i].say());//动态绑定机制
//这里大家聪明. 使用 类型判断 + 向下转型.
            if (persons[i] instanceof Student) &#123;//判断 person[i] 的运行类型是不是 Student
                Student student = (Student) persons[i];//向下转型
                student.study();
                //小伙伴也可以使用一条语句 ((Student)persons[i]).study();
            &#125; else if (persons[i] instanceof Teacher) &#123;
                Teacher teacher = (Teacher) persons[i];
                teacher.teach();
            &#125; else if (persons[i] instanceof Person) &#123;
                //System.out.println(&quot;你的类型有误, 请自己检查...&quot;);
            &#125; else &#123;
                System.out.println(&quot;你的类型有误, 请自己检查...&quot;);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>@Override：是一个伪代码，表示重写父类的方法，可以当作注释使用。</p>
<p>为什么要先判断Student：因为Student最小，<strong>先判断Teacher的话，运行类型是Student也可以通过</strong>。</p>
<pre><code class="hljs plaintext">Student student = (Student) persons[i];//向下转型
student.study();
                //小伙伴也可以使用一条语句 ((Student)persons[i]).study();</code></pre>

<h4 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240719192856826.png" alt="image-20240719192856826"></p>
<pre><code class="hljs plaintext">package com.hspedu.poly_.polyparameter_;
public class Employee &#123;
    private String name;
    private double salary;
    public Employee(String name, double salary) &#123;
        this.name = name;
        this.salary = salary;
    &#125;
    //得到年工资的方法
    public double getAnnual() &#123;
        return 12 * salary;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public double getSalary() &#123;
        return salary;
    &#125;
    public void setSalary(double salary) &#123;
        this.salary = salary;\
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.poly_.polyparameter_;
public class Manager extends Employee&#123;
    private double bonus;
    public Manager(String name, double salary, double bonus) &#123;
        super(name, salary);
        this.bonus = bonus;
    &#125;
    public double getBonus() &#123;
        return bonus;
    &#125;
    public void setBonus(double bonus) &#123;
        this.bonus = bonus;
    &#125;
    public void manage() &#123;
        System.out.println(&quot;经理 &quot; + getName() + &quot; is managing&quot;);
    &#125;
//重写获取年薪方法
    @Override
    public double getAnnual() &#123;
        return super.getAnnual() + bonus;
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.poly_.polyparameter_;
public class Worker extends Employee &#123;
    public Worker(String name, double salary) &#123;
        super(name, salary);
    &#125;
    public void work() &#123;
        System.out.println(&quot;普通员工 &quot; + getName() + &quot; is working&quot;);
    &#125;
    @Override
    public double getAnnual() &#123; //因为普通员工没有其它收入，则直接调用父类方法
        return super.getAnnual();
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.poly_.polyparameter_;
public class PloyParameter &#123;
    public static void main(String[] args) &#123;
        Worker tom = new Worker(&quot;tom&quot;, 2500);
        Manager milan = new Manager(&quot;milan&quot;, 5000, 200000);
        PloyParameter ployParameter = new PloyParameter();
        ployParameter.showEmpAnnual(tom);
        ployParameter.showEmpAnnual(milan);
        ployParameter.testWork(tom);
        ployParameter.testWork(milan);
    &#125;
    //showEmpAnnual(Employee e)
//实现获取任何员工对象的年工资,并在 main 方法中调用该方法 [e.getAnnual()]
    public void showEmpAnnual(Employee e) &#123;
        System.out.println(e.getAnnual());//动态绑定机制. &#125;
//添加一个方法，testWork,如果是普通员工，则调用 work 方法，如果是经理，则调用 manage 方法
        public void testWork(Employee e) &#123;
            if(e instanceof Worker) &#123;
                ((Worker) e).work();//有向下转型操作
            &#125; else if(e instanceof Manager) &#123;
                ((Manager) e).manage();//有向下转型操作
            &#125; else &#123;
                System.out.println(&quot;不做处理...&quot;);
            &#125;
        &#125;
    &#125;</code></pre>

<p>在主类中创建方法，然后要调用的话，需要先创建一个主类的对象，再通过这个对象进行调用。如果创建的是静态方法就不用先创建对象了，可以直接调用。</p>
<pre><code class="hljs plaintext">PloyParameter ployParameter = new PloyParameter();
        ployParameter.showEmpAnnual(tom);</code></pre>

<h2 id="Object类详解"><a href="#Object类详解" class="headerlink" title="Object类详解"></a>Object类详解</h2><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240720151522693.png" alt="image-20240720151522693"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240720151528940.png" alt="image-20240720151528940"></p>
<p>若是 对象1 equals 对象2，则是判断这两个对象的地址是否一样。</p>
<p>重写equals方法，就是直接在自己定义的类里面直接写就好了。</p>
<pre><code class="hljs plaintext">Person_ p1 = new Person_();
p1.name = &quot;hspedu&quot;;
Person_ p2 = new Person_();
p2.name = &quot;hspedu&quot;;
        System.out.println(p1==p2); //False
System.out.println(p1.name .equals( p2.name));//T
System.out.println(p1.equals(p2));//False</code></pre>

<h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode 方法"></a>hashCode 方法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240720162846185.png" alt="image-20240720162846185"></p>
<pre><code class="hljs plaintext">5 个小结:
        1) 提高具有哈希结构的容器的效率！
        2) 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！
        3) 两个引用，如果指向的是不同对象，则哈希值是不一样的
		4) 哈希值主要根据地址号来的！， 不能完全将哈希值等价于地址。
        5) 后面在集合，中 hashCode 如果需要的话，也会重写, 在讲解集合时，老韩在说如何重写 hashCode()</code></pre>

<p>对象名.hashCode()，输出该对象的哈希码。</p>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h3><p>感觉没啥大用。</p>
<pre><code class="hljs plaintext">1) 基本介绍
默认返回：全类名+@+哈希值的十六进制，【查看 Object 的 toString 方法】
子类往往重写 toString 方法，用于返回对象的属性信息
2) 重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式.
3) 当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用monster.toString()</code></pre>

<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
/*
Object 的 toString() 源码
(1)getClass().getName() 类的全类名(包名+类名 )
(2)Integer.toHexString(hashCode()) 将对象的 hashCode 值转成 16 进制字符串
public String toString() &#123;
return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
&#125;
*/
        Monster monster = new Monster(&quot;小妖怪&quot;, &quot;巡山的&quot;, 1000);
        System.out.println(monster.toString() + &quot; hashcode=&quot; + monster.hashCode());
        System.out.println(&quot;==当直接输出一个对象时，toString 方法会被默认的调用==&quot;);
        System.out.println(monster); //等价 monster.toString()
    &#125;
&#125;
class Monster &#123;
    private String name;
    private String job;
    private double sal;

    public Monster(String name, String job, double sal) &#123;
        this.name = name;
        this.job = job;
        this.sal = sal;
    &#125;

    //重写 toString 方法, 输出对象的属性
//使用快捷键即可 alt+insert -&gt; toString
    @Override
    public String toString() &#123; //重写后，一般是把对象的属性值输出，当然程序员也可以自己定制
        return &quot;Monster&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, job=&#x27;&quot; + job + &#x27;\&#x27;&#x27; +
                &quot;, sal=&quot; + sal +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用monster.toString()</code></pre>

<p><code>System.out.println(monster.toString() + &quot; hashcode=&quot; + monster.hashCode());</code>    </p>
<p>相当于   <code>System.out.println(monster + &quot; hashcode=&quot; + monster.hashCode());</code></p>
<h1 id="面向对象编程（高级）"><a href="#面向对象编程（高级）" class="headerlink" title="面向对象编程（高级）"></a>面向对象编程（高级）</h1><h2 id="类变量和类方法"><a href="#类变量和类方法" class="headerlink" title="类变量和类方法"></a>类变量和类方法</h2><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240722171151062.png" alt="image-20240722171151062"></p>
<p>就是静态变量&#x2F;全局变量，不过它是在类里面定义的。</p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
        Child child1 = new Child(&quot;白骨精&quot;);
        child1.join();
//count++;
        child1.count++;
        Child child2 = new Child(&quot;狐狸精&quot;);
        child2.join();
//count++;
        child2.count++;
        Child child3 = new Child(&quot;老鼠精&quot;);
        child3.join();
//count++;
        child3.count++;
//===========
//类变量，可以通过类名来访问
        System.out.println(&quot;共有&quot; + Child.count + &quot; 小孩加入了游戏...&quot;);
//下面的代码输出什么?
        System.out.println(&quot;child1.count=&quot; + child1.count);//3
        System.out.println(&quot;child2.count=&quot; + child2.count);//3
        System.out.println(&quot;child3.count=&quot; + child3.count);//3
    &#125;
&#125;
class Child &#123; //类
    private String name;
    //定义一个变量 count ,是一个类变量(静态变量) static 静态
//该变量最大的特点就是会被 Child 类的所有的对象实例共享
    public static int count = 0;
    public Child(String name) &#123;
        this.name = name;
    &#125;
    public void join() &#123;
        System.out.println(name + &quot; 加入了游戏..&quot;);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240722171101245.png" alt="image-20240722171101245"></p>
<p>说明：类变量是随着类的加载而创建，所以即使<strong>没有创建对象</strong>实例<strong>也可以访问</strong>。</p>
<pre><code class="hljs plaintext">public class VisitStatic &#123;
    public static void main(String[] args) &#123;
//类名.类变量名
//说明：类变量是随着类的加载而创建，所以即使没有创建对象实例也可以访问
        System.out.println(A.name);
        A a = new A();
//通过对象名.类变量名
        System.out.println(&quot;a.name=&quot; + a.name);
    &#125;
&#125;
class A &#123;
    //类变量
//类变量的访问，必须遵守 相关的访问权限. 
	public static String name = &quot;韩顺平教育&quot;;
//普通属性/普通成员变量/非静态属性/非静态成员变量/实例变量
    private int num = 10;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240722171203350.png" alt="image-20240722171203350"></p>
<p><strong>访问类变量</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240722171235698.png" alt="image-20240722171235698"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723110944904.png" alt="image-20240723110944904"></p>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723104249407.png" alt="image-20240723104249407"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723104256939.png" alt="image-20240723104256939"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723110339250.png" alt="image-20240723110339250"></p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
//创建 2 个学生对象，叫学费
        Stu tom = new Stu(&quot;tom&quot;);
//tom.payFee(100);
        Stu.payFee(100);//对不对?对
        Stu mary = new Stu(&quot;mary&quot;);
//mary.payFee(200);
        Stu.payFee(200);//对
//输出当前收到的总学费
        Stu.showFee();//300
//如果我们希望不创建实例，也可以调用某个方法(即当做工具来使用)
//这时，把方法做成静态方法时非常合适
        System.out.println(&quot;9 开平方的结果是=&quot; + Math.sqrt(9));
        System.out.println(MyTools.calSum(10, 30));
    &#125;
&#125;
//开发自己的工具类时，可以将方法做成静态的，方便调用
class MyTools &#123;
    //求出两个数的和
    public static double calSum(double n1, double n2) &#123;
        return n1 + n2;
    &#125;

    //可以写出很多这样的工具方法...
&#125;
class Stu &#123;
    private String name;//普通成员
    //定义一个静态变量，来累积学生的学费
    private static double fee = 0;

    public Stu(String name) &#123;
        this.name = name;
    &#125;

    //说明
//1. 当方法使用了 static 修饰后，该方法就是静态方法
//2. 静态方法就可以访问静态属性/变量
    public static void payFee(double fee) &#123;
        Stu.fee += fee;//累积到
    &#125;

    public static void showFee() &#123;
        System.out.println(&quot;总学费有:&quot; + Stu.fee);
    &#125;
&#125;</code></pre>

<p><code>System.out.println(&quot;9 开平方的结果是=&quot; + Math.sqrt(9));</code></p>
<pre><code class="hljs plaintext">Math.pow(double a,double b)；Math.sqrt(double a)</code></pre>

<p>上面都不需要引入类，可以直接使用。</p>
<p><strong>注意事项和细节</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723110401077.png" alt="image-20240723110401077"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723110406016.png" alt="image-20240723110406016"></p>
<p><strong>小结：记住两句话 (1) 静态方法，只能访问静态成员 (2) 非静态方法，可以访问所有的成员 (3) 在编写代码时，仍然要遵守访问权限规则。</strong></p>
<h2 id="理解main方法语法"><a href="#理解main方法语法" class="headerlink" title="理解main方法语法"></a>理解main方法语法</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723115424926.png" alt="image-20240723115424926"></p>
<ol>
<li>在 main()方法中，我们可以<strong>直接调用</strong> main 方法所在类的<strong>静态方法或静态属性</strong>； </li>
<li>但是，<strong>不能</strong>直接访问该类中的<strong>非静态成员</strong>，必须创建该类的一个实例对象后，才能<strong>通过这个对象</strong>去访问类中的非静态成员。</li>
</ol>
<pre><code class="hljs plaintext">public class Main01 &#123;
    //静态的变量/属性
    private static String name = &quot;韩顺平教育&quot;;
    //非静态的变量/属性
    private int n1 = 10000;
    //静态方法
    public static void hi() &#123;
        System.out.println(&quot;Main01 的 hi 方法&quot;);
    &#125;
    //非静态方法
    public void cry() &#123;
        System.out.println(&quot;Main01 的 cry 方法&quot;);
    &#125;
    public static void main(String[] args) &#123;
//可以直接使用 name
//1. 静态方法 main 可以访问本类的静态成员
        System.out.println(&quot;name=&quot; + name);
        hi();
//2. 静态方法 main 不可以访问本类的非静态成员
//System.out.println(&quot;n1=&quot; + n1);//错误
//cry();
//3. 静态方法 main 要访问本类的非静态成员，需要先创建对象 , 再调用即可
        Main01 main01 = new Main01();
        System.out.println(main01.n1);//ok
        main01.cry();
    &#125;
&#125;</code></pre>

<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723154528512.png" alt="image-20240723154528512"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723154851742.png" alt="image-20240723154851742"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723154929380.png" alt="image-20240723154929380"></p>
<p><strong>代码块调用的顺序优先于构造器</strong>，这样当我们不管调用哪个构造器，创建对象，都会先调用代码块的内容。</p>
<pre><code class="hljs plaintext">&#123;
    System.out.println(&quot;电影屏幕打开...&quot;);
    System.out.println(&quot;广告开始...&quot;);
    System.out.println(&quot;电影正是开始...&quot;);
&#125;;</code></pre>

<p>细节：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723155619628.png" alt="image-20240723155619628"></p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
//类被加载的情况举例
//1. 创建对象实例时(new)
// AA aa = new AA();
//2. 创建子类对象实例，父类也会被加载, 而且，父类先被加载，子类后被加载
// AA aa2 = new AA();
//3. 使用类的静态成员时(静态属性，静态方法)
// System.out.println(Cat.n1);
//static 代码块，是在类加载时，执行的，而且只会执行一次.
// DD dd = new DD();
// DD dd1 = new DD();
//普通的代码块，在创建对象实例时，会被隐式的调用。
// 被创建一次，就会调用一次。
// 如果只是使用类的静态成员时，普通代码块并不会执行
        System.out.println(DD.n1);//8888, 静态模块块一定会执行
    &#125;
&#125;
class DD &#123;
    public static int n1 = 8888;//静态属性
    //静态代码块
    static &#123;
        System.out.println(&quot;DD 的静态代码 1 被执行...&quot;);//
    &#125;
//普通代码块, 在 new 对象时，被调用，而且是每创建一个对象，就调用一次
//可以这样简单的，理解 普通代码块是构造器的补充
    &#123;
        System.out.println(&quot;DD 的普通代码块...&quot;);
    &#125;
&#125;
class Animal &#123;
    //静态代码块
    static &#123;
        System.out.println(&quot;Animal 的静态代码 1 被执行...&quot;);//
    &#125;
&#125;
class Cat extends Animal &#123;
    public static int n1 = 999;//静态属性
    //静态代码块
    static &#123;
        System.out.println(&quot;Cat 的静态代码 1 被执行...&quot;);//
    &#125;
&#125;
class BB &#123;
    //静态代码块
    static &#123;
        System.out.println(&quot;BB 的静态代码 1 被执行...&quot;);//1
    &#125;
&#125;
class AA extends BB &#123;
//静态代码块
    static &#123;
        System.out.println(&quot;AA 的静态代码 1 被执行...&quot;);//2
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">如果只是使用类的静态成员时，普通代码块并不会执行，但是静态模块会执行。

创建子类对象实例，父类也会被加载, 而且，父类先被加载，子类后被加载。</code></pre>

<p>为什么父类会先被加载，因为子类需要父类先创立子类才是完整的，是继承父类的，所以也是先调用父类的静态代码块、静态属性初始化，再调用子类的静态代码块、静态属性初始化。（下面有说明）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723160923814.png" alt="image-20240723160923814"></p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
        A a = new A();// (1) A 静态代码块 01 (2) getN1 被调用...(3)A 普通代码块 01(4)getN2 被调用...(5)A() 构造器被调用
    &#125;
&#125;
class A &#123;
    &#123; //普通代码块
        System.out.println(&quot;A 普通代码块 01&quot;);
    &#125;
    private int n2 = getN2();//普通属性的初始化
    static &#123; //静态代码块
        System.out.println(&quot;A 静态代码块 01&quot;);
    &#125;
    //静态属性的初始化
    private static int n1 = getN1();
    public static int getN1() &#123;
        System.out.println(&quot;getN1 被调用...&quot;);
        return 100;
    &#125;
    public int getN2() &#123; //普通方法/非静态方法
        System.out.println(&quot;getN2 被调用...&quot;);
        return 200;
    &#125;
    //无参构造器
    public A() &#123;
        System.out.println(&quot;A() 构造器被调用&quot;);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723162241156.png" alt="image-20240723162241156"></p>
<p>静态相关的代码块，属性初始化，在类加载的时候就执行完毕了，是早于构造器和普通代码块的。</p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
        new BBB();//(1)AAA 的普通代码块(2)AAA() 构造器被调用(3)BBB 的普通代码块(4)BBB() 构造器被调用
    &#125;
&#125;
class AAA &#123; //父类 Object
    static&#123;
        System.out.println(&quot;AAA的静态代码块...&quot;);
    &#125;
    &#123;
        System.out.println(&quot;AAA 的普通代码块&quot;);
    &#125;
    public AAA() &#123;
//(1)super()
//(2)调用本类的普通代码块
        System.out.println(&quot;AAA() 构造器被调用....&quot;);
    &#125;
&#125;
class BBB extends AAA &#123;
    static&#123;
        System.out.println(&quot;BBB的静态代码块...&quot;);
    &#125;
    &#123;
        System.out.println(&quot;BBB 的普通代码块...&quot;);
    &#125;
    public BBB() &#123;
//(1)super()
//(2)调用本类的普通代码块
        System.out.println(&quot;BBB() 构造器被调用....&quot;);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723163738843.png" alt="image-20240723163738843"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723164003159.png" alt="image-20240723164003159"></p>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>什么是设计模式：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723173519242.png" alt="image-20240723173519242"></p>
<p>什么是单例模式：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723173836145.png" alt="image-20240723173836145"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723173846457.png" alt="image-20240723173846457"></p>
<p><strong>饿汉式</strong>单例模式：</p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
// GirlFriend xh = new GirlFriend(&quot;小红&quot;);
// GirlFriend xb = new GirlFriend(&quot;小白&quot;);
//通过方法可以获取对象
        GirlFriend instance = GirlFriend.getInstance();
        System.out.println(instance);
        GirlFriend instance2 = GirlFriend.getInstance();
        System.out.println(instance2);
        System.out.println(instance == instance2);//T
//System.out.println(GirlFriend.n1);
//...
    &#125;
&#125;
//有一个类， GirlFriend
//只能有一个女朋友
        class GirlFriend &#123;
            private String name;

            //public static int n1 = 100;
//为了能够在静态方法中，返回 gf 对象，需要将其修饰为 static
//對象，通常是重量級的對象, 餓漢式可能造成創建了對象，但是沒有使用.
            private static GirlFriend gf = new GirlFriend(&quot;小红红&quot;);
//如何保障我们只能创建一个 GirlFriend 对象
//步骤[单例模式-饿汉式]
//1. 将构造器私有化
//2. 在类的内部直接创建对象(该对象是 static)
//3. 提供一个公共的 static 方法，返回 gf 对象
            private GirlFriend(String name) &#123;
                System.out.println(&quot;構造器被調用.&quot;);
                this.name = name;
            &#125;

            public static GirlFriend getInstance() &#123;
                return gf;
            &#125;

            @Override
            public String toString() &#123;
                return &quot;GirlFriend&#123;&quot; +
                        &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                        &#x27;&#125;&#x27;;
            &#125;
        &#125;</code></pre>

<p>当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用monster.toString()。</p>
<p> <code>System.out.println(instance == instance2);//T</code>    这句说明第二次返回的gf和第一次返回的是同一个，说明了是单例。</p>
<p><strong>懒汉式</strong>单例模式：</p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
//new Cat(&quot;大黃&quot;);
//System.out.println(Cat.n1);
        Cat instance = Cat.getInstance();
        System.out.println(instance);
//再次調用 getInstance
        Cat instance2 = Cat.getInstance();
        System.out.println(instance2);
        System.out.println(instance == instance2);//T
    &#125;
&#125;
//希望在程序運行過程中，只能創建一個 Cat 對象
//使用單例模式
class Cat &#123;
    private String name;
    public static int n1 = 999;
    private static Cat cat ; //默認是 null
    //步驟
//1.仍然構造器私有化
//2.定義一個 static 靜態屬性對象
//3.提供一個 public 的 static 方法，可以返回一個 Cat 對象
//4.懶漢式，只有當用戶使用 getInstance 時，才返回 cat 對象, 後面再次調用時，會返回上次創建的 cat 對象
// 從而保證了單例
    private Cat(String name) &#123;
        System.out.println(&quot;構造器調用...&quot;);
        this.name = name;
    &#125;
    public static Cat getInstance() &#123;
        if(cat == null) &#123;//如果還沒有創建 cat 對象
            cat = new Cat(&quot;小可愛&quot;);
        &#125;
        return cat;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Cat&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p>饿汉式和懒汉式的区别：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723194324191.png" alt="image-20240723194324191"></p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725094033403.png" alt="image-20240725094033403"></p>
<p>final class A { }</p>
<p>public final void hi() {}</p>
<p>public final double TAX_RATE &#x3D; 0.08;&#x2F;&#x2F;常量</p>
<p>public static final double TAX_RATE &#x3D; 99.9;</p>
<pre><code class="hljs plaintext">//当不希望某个局部变量被修改，可以使用 final 修饰
class F &#123;
    public void cry() &#123;
//这时，NUM 也称为 局部常量
        final double NUM = 0.01;
//NUM = 0.9;
        System.out.println(&quot;NUM=&quot; + NUM);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725095011997.png" alt="image-20240725095011997"></p>
<pre><code class="hljs plaintext">class AA &#123;
    /*
    1. 定义时：如 public final double TAX_RATE=0.08;
    2. 在构造器中
    3. 在代码块中
    */
    public final double TAX_RATE = 0.08;//1.定义时赋值
    public final double TAX_RATE2 ;
    public final double TAX_RATE3 ;
    public AA() &#123;//构造器中赋值
        TAX_RATE2 = 1.1;
    &#125;
    &#123;//在代码块赋值
        TAX_RATE3 = 8.8;
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725101855889.png" alt="image-20240725101855889"></p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725155654016.png" alt="image-20240725155654016"></p>
<pre><code class="hljs plaintext">abstract class Animal &#123;
    private String name;
    public Animal(String name) &#123;
        this.name = name;
    &#125;
//思考：这里 eat 这里你实现了，其实没有什么意义
//即： 父类方法不确定性的问题
//===&gt; 考虑将该方法设计为抽象(abstract)方法
//===&gt; 所谓抽象方法就是没有实现的方法
//===&gt; 所谓没有实现就是指，没有方法体
//===&gt; 当一个类中存在抽象方法时，需要将该类声明为 abstract 类
//===&gt; 一般来说，抽象类会被继承，有其子类来实现抽象方法. 
    public abstract void eat() ;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725160337428.png" alt="image-20240725160337428"></p>
<p><strong>注意事项和细节：</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725160623681.png" alt="image-20240725160623681"></p>
<pre><code class="hljs plaintext">public class AbstractDetail01 &#123;
    public static void main(String[] args) &#123;
//抽象类，不能被实例化
//new A();
    &#125;
&#125;
//抽象类不一定要包含 abstract 方法。也就是说,抽象类可以没有 abstract 方法
//，还可以有实现的方法。
abstract class A &#123;
    public void hi() &#123;
        System.out.println(&quot;hi&quot;);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725160911284.png" alt="image-20240725160911284"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725160917675.png" alt="image-20240725160917675"></p>
<pre><code class="hljs plaintext">//如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为 abstract 类
abstract class E &#123;
    public abstract void hi();
&#125;
abstract class F extends E &#123;
&#125;
class G extends E &#123;
    @Override
    public void hi() &#123; //这里相等于 G 子类实现了父类 E 的抽象方法，所谓实现方法，就是有方法体
    &#125;
&#125;</code></pre>

<p>实现就是有方法体就可以了，方法体为空也可以。</p>
<p>在子类中实现抽象方法的时候，方法的访问修饰符、类型等不变。</p>
<h2 id="抽象类最佳实践-模板设计模式"><a href="#抽象类最佳实践-模板设计模式" class="headerlink" title="抽象类最佳实践-模板设计模式"></a>抽象类最佳实践-模板设计模式</h2><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板。</p>
<p>能解决的问题：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725162340448.png" alt="image-20240725162340448"></p>
<pre><code class="hljs plaintext">abstract class Template &#123; //抽象类-模板设计模式
    public abstract void job();//抽象方法
    public void calculateTime() &#123;//实现方法，调用 job 方法
//得到开始的时间
        long start = System.currentTimeMillis();
        job(); //动态绑定机制
//得的结束的时间
        long end = System.currentTimeMillis();
        System.out.println(&quot;任务执行时间 &quot; + (end - start));
    &#125;
&#125;

class AA extends Template &#123;
    //计算任务
//1+....+ 800000
    @Override
    public void job() &#123; //实现 Template 的抽象方法 job
        long num = 0;
        for (long i = 1; i &lt;= 800000; i++) &#123;
            num += i;
        &#125;
    &#125;
&#125;

class BB extends Template&#123;
    public void job() &#123;//这里也去，重写了 Template 的 job 方法
        long num = 0;
        for (long i = 1; i &lt;= 80000; i++) &#123;
            num *= i;
        &#125;
    &#125;
&#125;

public class c&#123;
    public static void main(String[] args) &#123;
        AA aa = new AA();
        aa.calculateTime(); //这里还是需要有良好的 OOP 基础，对多态
        BB bb = new BB();
        bb.calculateTime();
    &#125;
&#125;</code></pre>

<p>为什么 aa.calculateTime()，计算的是AA里的job运行时间而不是父类里的job。</p>
<pre><code class="hljs plaintext">当 calculateTime()方法内部调用 job() 方法时，Java 虚拟机根据对象的实际类型也就是运行类型（AA 或 BB）来决定调用哪个 job() 方法。因此，aa.calculateTime() 调用的是 AA 类中的 job() 方法，而 bb.calculateTime() 调用的是 BB 类中的 job() 方法。
这是多态性的一个关键点：方法调用在运行时根据对象的实际类型绑定。
简而言之，这是因为 Java 的动态绑定机制确保在运行时调用的是子类的实现，而不是父类的声明。</code></pre>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h3><pre><code class="hljs plaintext">interface UsbInterface &#123; //接口
    //规定接口的相关方法,老师规定的.即规范...
     public void start();
    public void stop();
&#125;

class Camera implements UsbInterface&#123;//实现接口,就是把接口方法实现
    @Override
    public void start() &#123;
        System.out.println(&quot;相机开始工作...&quot;);
    &#125;
    @Override
    public void stop() &#123;
        System.out.println(&quot;相机停止工作....&quot;);
    &#125;
&#125;
//Phone 类 实现 UsbInterface
//解读 1. 即 Phone 类需要实现 sbInterface 接口 规定/声明的方法
class Phone implements UsbInterface &#123;
    @Override
    public void start() &#123;
        System.out.println(&quot;手机开始工作...&quot;);
    &#125;
    @Override
    public void stop() &#123;
        System.out.println(&quot;手机停止工作.....&quot;);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725174711688.png" alt="image-20240725174711688"></p>
<p>不难，重点是<strong>何时使用</strong>接口。</p>
<p>注意事项和细节：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725192856145.png" alt="image-20240725192856145"></p>
<pre><code class="hljs plaintext">interface IA &#123;
    void say();//修饰符 public protected 默认 private
    void hi();
&#125;
class Cat implements IA&#123;
    @Override
    public void say() &#123;
    &#125;
    @Override
    public void hi() &#123;
    &#125;
&#125;
abstract class Tiger implements IA &#123;

&#125;</code></pre>

<p>一个普通类实现接口,就必须将该接口的所有方法都实现,可以使用 alt+enter （得先将光标放于该类上）来解决。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725194357733.png" alt="image-20240725194357733"></p>
<pre><code class="hljs plaintext">public class InterfaceDetail02 &#123;
    public static void main(String[] args) &#123;
//老韩证明 接口中的属性,是 public static final
        System.out.println(IB.n1);//说明 n1 就是 static
//IB.n1 = 30; 说明 n1 是 final
    &#125;
&#125;
interface IB &#123;
    //接口中的属性,只能是 final 的，而且是 public static final 修饰符
    int n1 = 10; //等价 public static final int n1 = 10;
    void hi();
&#125;
interface IC &#123;
    void say();
&#125;
//接口不能继承其它的类,但是可以继承多个别的接口
interface ID extends IB,IC &#123;
&#125;
//接口的修饰符 只能是 public 和默认，这点和类的修饰符是一样的
interface IE&#123;&#125;
//一个类同时可以实现多个接口
class Pig implements IB,IC &#123;
    @Override
    public void hi() &#123;
    &#125;
    @Override
    public void say() &#123;
    &#125;
&#125;</code></pre>

<h3 id="接口与继承"><a href="#接口与继承" class="headerlink" title="接口与继承"></a>接口与继承</h3><p><strong>接口的静态方法不能被子接口继承，也不被实现类继承。接口的默认方法 可以被子接口和子类继承。</strong></p>
<p>接口也可以继承另一个接口，上面就有例子。</p>
<pre><code class="hljs plaintext">public class ExtendsVsInterface &#123;
    public static void main(String[] args) &#123;
        LittleMonkey wuKong = new LittleMonkey(&quot;悟空&quot;);
        wuKong.climbing();
        wuKong.swimming();
        wuKong.flying();
    &#125;
&#125;
//猴子
class Monkey &#123;
    private String name;
    public Monkey(String name) &#123;
        this.name = name;
    &#125;
    public void climbing() &#123;
        System.out.println(name + &quot; 会爬树...&quot;);
    &#125;
    public String getName() &#123;
        return name;
    &#125;
&#125;
//接口
interface Fishable &#123;
    void swimming();
&#125;
interface Birdable &#123;
    void flying();
&#125;
//继承
//小结: 当子类继承了父类，就自动的拥有父类的功能
// 如果子类需要扩展功能，可以通过实现接口的方式扩展.
// 可以理解 实现接口 是 对 java 单继承机制的一种补充.
class LittleMonkey extends Monkey implements Fishable,Birdable &#123;
    public LittleMonkey(String name) &#123;
        super(name);
    &#125;
    @Override
    public void swimming() &#123;
        System.out.println(getName() + &quot; 通过学习，可以像鱼儿一样游泳...&quot;);
    &#125;
    @Override
    public void flying() &#123;
        System.out.println(getName() + &quot; 通过学习，可以像鸟儿一样飞翔...&quot;);
    &#125;
&#125;</code></pre>

<p>一个类可以同时继承和实现多个接口：<code>class LittleMonkey extends Monkey implements Fishable,Birdable</code> </p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725194954602.png" alt="image-20240725194954602"></p>
<h3 id="接口的多态特性"><a href="#接口的多态特性" class="headerlink" title="接口的多态特性"></a>接口的多态特性</h3><p>目前看到的，除了多态参数，其它多态可以的接口也可以，比如多态数组、向上、向下转型啥的。</p>
<p><strong>向上转型：</strong></p>
<pre><code class="hljs plaintext">public class InterfacePolyParameter &#123;
    public static void main(String[] args) &#123;
//接口的多态体现
//接口类型的变量 if01 可以指向 实现了 IF 接口类的对象实例
        IF if01 = new Monster();
        if01 = new Car();
//继承体现的多态
//父类类型的变量 a 可以指向 继承 AAA 的子类的对象实例
        AAA a = new BBB();
        a = new CCC();
    &#125;
&#125;
interface IF &#123;&#125;
class Monster implements IF&#123;&#125;
class Car implements IF&#123;&#125;
class AAA &#123;
&#125;
class BBB extends AAA &#123;&#125;
class CCC extends AAA &#123;&#125;</code></pre>

<p><strong>接口类型数组，向下转型：</strong></p>
<pre><code class="hljs plaintext">public class InterfacePolyArr &#123;
    public static void main(String[] args) &#123;
//多态数组 -&gt; 接口类型数组
        Usb[] usbs = new Usb[2];
        usbs[0] = new Phone_();
        usbs[1] = new Camera_();
/*
给 Usb 数组中，存放 Phone 和 相机对象，Phone 类还有一个特有的方法 call（），
请遍历 Usb 数组，如果是 Phone 对象，除了调用 Usb 接口定义的方法外，
还需要调用 Phone 特有方法 call
*/
        for(int i = 0; i &lt; usbs.length; i++) &#123;
            usbs[i].work();//动态绑定.. //和前面一样，我们仍然需要进行类型的向下转型
            if(usbs[i] instanceof Phone_) &#123;//判断他的运行类型是 Phone_
                ((Phone_) usbs[i]).call();
            &#125;
        &#125;
    &#125;
&#125;
interface Usb&#123;
    void work();
&#125;
class Phone_ implements Usb &#123;
    public void call() &#123;
        System.out.println(&quot;手机可以打电话...&quot;);
    &#125;
    @Override
    public void work() &#123;
        System.out.println(&quot;手机工作中...&quot;);
    &#125;
&#125;
class Camera_ implements Usb &#123;
    @Override
    public void work() &#123;
        System.out.println(&quot;相机工作中...&quot;);
    &#125;
&#125;</code></pre>

<p><strong>多态传递现象（接口之间的继承）：</strong></p>
<pre><code class="hljs plaintext">public class InterfacePolyPass &#123;
    public static void main(String[] args) &#123;
//接口类型的变量可以指向实现了该接口的类的对象实例
        IG ig = new Teacher();
//如果 IG 继承了 IH 接口，而 Teacher 类实现了 IG 接口
//那么，实际上就相当于 Teacher 类也实现了 IH 接口. //这就是所谓的 接口多态传递现象. 
        IH ih = new Teacher();
    &#125;
&#125;
interface IH &#123;
    void hi();
&#125;
interface IG extends IH&#123; &#125;
class Teacher implements IG &#123;
    @Override
    public void hi() &#123;
    &#125;
&#125;</code></pre>

<p>一道题：</p>
<pre><code class="hljs plaintext">public class InterfaceExercise02 &#123;
    public static void main(String[] args) &#123;
    &#125;
&#125;
interface A &#123; // 1min 看看
    int x = 0;
&#125; //想到 等价 public static final int x = 0;
class B &#123;
    int x = 1;
&#125; //普通属性
class C extends B implements A &#123;
    public void pX() &#123;
//System.out.println(x); //错误，原因不明确 x
//可以明确的指定 x
//访问接口的 x 就使用 A.x
//访问父类的 x 就使用 super.x
        System.out.println(A.x + &quot; &quot; + super.x);
    &#125;
    public static void main(String[] args) &#123;
        new C().pX();
    &#125;
&#125;</code></pre>

<p><code>class C extends B implements A</code>这句是对的，没有语法错误。</p>
<p>如何区分X:</p>
<pre><code class="hljs plaintext">//访问接口的 x 就使用 A.x
//访问父类的 x 就使用 super.x</code></pre>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果定义类在局部位置(方法中&#x2F;代码块) :(1) 局部内部类 (2) 匿名内部类 。</p>
<p>定义在成员位置 (1) 成员内部类 (2) 静态内部类。</p>
<p><strong>基本介绍：</strong><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725213723566.png" alt="image-20240725213723566"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725213754328.png" alt="image-20240725213754328"></p>
<p><strong>分类：</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725213940513.png" alt="image-20240725213940513"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>可以参考局部变量</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725214604330.png" alt="image-20240725214604330"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725214609681.png" alt="image-20240725214609681"></p>
<pre><code class="hljs plaintext">public class c&#123;//
    public static void main(String[] args) &#123;
//演示一遍
        Outer02 outer02 = new Outer02();
        outer02.m1();
        System.out.println(&quot;outer02 的 hashcode=&quot; + outer02);
    &#125;
&#125;
class Outer02 &#123;//外部类
    private int n1 = 100;
    private void m2() &#123;
        System.out.println(&quot;Outer02 m2()&quot;);
    &#125;//私有方法
    public void m1() &#123;//方法
//1.局部内部类是定义在外部类的局部位置,通常在方法
//3.不能添加访问修饰符,但是可以使用 final 修饰
//4.作用域 : 仅仅在定义它的方法或代码块中
        final class Inner02 &#123;//局部内部类(本质仍然是一个类)
//2.可以直接访问外部类的所有成员，包含私有的
            private int n1 = 800;
            public void f1() &#123;
//5. 局部内部类可以直接访问外部类的成员，比如下面 外部类 n1 和 m2()
//7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，
// 使用 外部类名.this.成员）去访问
// 老韩解读 Outer02.this 本质就是外部类的对象, 即哪个对象调用了 m1, Outer02.this 就是哪个对象
                System.out.println(&quot;n1=&quot; + n1 + &quot; 外部类的 n1=&quot; + Outer02.this.n1);
                System.out.println(&quot;Outer02.this hashcode=&quot; + Outer02.this);
                m2();
            &#125;
        &#125;
//6. 外部类在方法中，可以创建 Inner02 对象，然后调用方法即可
        Inner02 inner02 = new Inner02();
        inner02.f1();
    &#125;
&#125;</code></pre>

<p><code>System.out.println(&quot;outer02 的 hashcode=&quot; + outer02);</code>这个输出的是  全类名+@+哈希码的十六进制（调用了toString），<code>System.out.println(&quot;Outer02.this hashcode=&quot; + Outer02.this);</code>这个也是。</p>
<h4 id="匿名内部类（重要）"><a href="#匿名内部类（重要）" class="headerlink" title="匿名内部类（重要）"></a>匿名内部类（重要）</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725220102012.png" alt="image-20240725220102012"></p>
<p><strong>记住最后有一个分号。</strong></p>
<p>new后面加接口的相当于是实现接口，接类的相当于是继承。</p>
<p>接口： IA tiger &#x3D; new IA(){}；类：Animal animal &#x3D; new Animal()，可以调用构造器。</p>
<pre><code class="hljs plaintext">public class AnonymousInnerClass &#123;
    public static void main(String[] args) &#123;
        Outer04 outer04 = new Outer04();
        outer04.method();
    &#125;
&#125;
class Outer04 &#123; //外部类
    private int n1 = 10;//属性
    public void method() &#123;//方法
//基于接口的匿名内部类
//老韩解读
//1.需求： 想使用 IA 接口,并创建对象
//2.传统方式，是写一个类，实现该接口，并创建对象
//3.老韩需求是 Tiger/Dog 类只是使用一次，后面再不使用
//4. 可以使用匿名内部类来简化开发
//5. tiger 的编译类型 ? IA
//6. tiger 的运行类型 ? 就是匿名内部类 Outer04$1
/*
我们看底层 会分配 类名 Outer04$1
class Outer04$1 implements IA &#123;
    @Override
    public void cry() &#123;
        System.out.println(&quot;老虎叫唤...&quot;);
    &#125;
&#125;
*/
//7. jdk 底层在创建匿名内部类 Outer04$1,立即马上就创建了 Outer04$1 实例，并且把地址
// 返回给 tiger
//8. 匿名内部类使用一次，就不能再使用
        IA tiger = new IA() &#123;
            @Override
            public void cry() &#123;
                System.out.println(&quot;老虎叫唤...&quot;);
            &#125;
        &#125;;
        System.out.println(&quot;tiger 的运行类型=&quot; + tiger.getClass());
        tiger.cry();
        tiger.cry();
        tiger.cry();
        //演示基于类的匿名内部类
        //分析
        //1. father 编译类型 Father
        //2. father 运行类型 Outer04$2
        //3. 底层会创建匿名内部类
        /*
        class Outer04$2 extends Father&#123;
        @Override
        public void test() &#123;
        System.out.println(&quot;匿名内部类重写了 test 方法&quot;);
        &#125;
        &#125;
        */
        //4. 同时也直接返回了 匿名内部类 Outer04$2 的对象
        //5. 注意(&quot;jack&quot;) 参数列表会传递给 构造器
            Father father = new Father(&quot;jack&quot;)&#123;
                @Override
                public void test() &#123;
                    System.out.println(&quot;匿名内部类重写了 test 方法&quot;);
                &#125;
            &#125;;
            System.out.println(&quot;father 对象的运行类型=&quot; + father.getClass());//Outer04$2
            father.test();
    //基于抽象类的匿名内部类
            Animal animal = new Animal()&#123;
                @Override
                void eat() &#123;
                    System.out.println(&quot;小狗吃骨头...&quot;);
                &#125;
            &#125;;
            animal.eat();
        &#125;
    &#125;
    interface IA &#123;//接口
        public void cry();
    &#125;
    class Father &#123;//类
        public Father(String name) &#123;//构造器
            System.out.println(&quot;接收到 name=&quot; + name);
        &#125;
        public void test() &#123;//方法
        &#125;
    &#125;
abstract class Animal &#123; //抽象类
    abstract void eat();
&#125;</code></pre>

<p>getClass()  返回的是此时的运行类型，哪一个类的。</p>
<p>这里所说的匿名内部类只能使用一次，注意是说匿名内部<strong>类</strong>，而不是说对象，指向匿名内部类的<strong>对象</strong>可以使用多次。</p>
<p>tiger可以使用多次，但是匿名内部类——下面部分——只能使用一次。</p>
<pre><code class="hljs plaintext">new IA() &#123;
            @Override
            public void cry() &#123;
                System.out.println(&quot;老虎叫唤...&quot;);
            &#125;
        &#125;;</code></pre>

<p>由于普通的类有类名，如：public class Amimal{…}，使用时Animal al &#x3D; new Animal()；可根据这个Animal类名多次new使用，创建实例，Animal类的代码在new时是固定的。<br>而匿名内部类没有类名，每次使用时，都要new 类名（）{…};这里的代码不是固定的，每次都可以变化，故只能用一次。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240726194749047.png" alt="image-20240726194749047"></p>
<p>类似于创造对象的语法：Father father &#x3D; new Father(“jack”){}，不过后面要加上内容。</p>
<p>体现对象特征：<strong>可以当作实参</strong>。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240726195140571.png" alt="image-20240726195140571"></p>
<p>第三点和前面的局部内部类一样。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240726195227118.png" alt="image-20240726195227118"></p>
<pre><code class="hljs plaintext">public class InnerClassExercise01 &#123;
    public static void main(String[] args) &#123;
//当做实参直接传递，简洁高效
        f1(new IL() &#123;
            @Override
            public void show() &#123;
                System.out.println(&quot;这是一副名画~~...&quot;);
            &#125;
        &#125;);
//传统方法
        f1(new Picture());
    &#125;
    //静态方法,形参是接口类型
    public static void f1(IL il) &#123;
        il.show();
    &#125;
&#125;
//接口
interface IL &#123;
    void show();
&#125;
//类-&gt;实现 IL =&gt; 编程领域 (硬编码)
class Picture implements IL &#123;
    @Override
    public void show() &#123;
        System.out.println(&quot;这是一副名画 XX...&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">public interface Printable &#123; 
 void print(String message); 
&#125;
public static void method(Printable p)&#123; 
 String message = &quot;匿名内部类&quot;; 
 p.print(message); 
&#125; 
 public static void main(String[]args)&#123; 
    method(new Printable()&#123; 
        public void print(String message)&#123; 
         	System.out.println(message); 
         &#125; 
     &#125;); 
 &#125;</code></pre>

<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240726214516539.png" alt="image-20240726214516539"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240726214606711.png" alt="image-20240726214606711"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240726214615158.png" alt="image-20240726214615158"></p>
<pre><code class="hljs plaintext">public class MemberInnerClass01 &#123;
    public static void main(String[] args) &#123;
        Outer08 outer08 = new Outer08();
        outer08.t1();
//外部其他类，使用成员内部类的三种方式
//老韩解读
// 第一种方式
// outer08.new Inner08(); 相当于把 new Inner08()当做是 outer08 成员
// 这就是一个语法，不要特别的纠结. 
		Outer08.Inner08 inner08 = outer08.new Inner08();
        inner08.say();
// 第二方式 在外部类中，编写一个方法，可以返回 Inner08 对象
        Outer08.Inner08 inner08Instance = outer08.getInner08Instance();
        inner08Instance.say();
    &#125;
&#125;
class Outer08 &#123; //外部类
    private int n1 = 10;
    public String name = &quot;张三&quot;;
    private void hi() &#123;
        System.out.println(&quot;hi()方法...&quot;);
    &#125;
    //1.注意: 成员内部类，是定义在外部内的成员位置上
//2.可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员
    public class Inner08 &#123;//成员内部类
        private double sal = 99.8;
        private int n1 = 66;
        public void say() &#123;
//可以直接访问外部类的所有成员，包含私有的
//如果成员内部类的成员和外部类的成员重名，会遵守就近原则. //，可以通过 外部类名.this.属性 来访问外部类的成员
            System.out.println(&quot;n1 = &quot; + n1 + &quot; name = &quot; + name + &quot; 外部类的 n1=&quot; + Outer08.this.n1);
            hi();
        &#125;
    &#125;
    //方法，返回一个 Inner08 实例
    public Inner08 getInner08Instance()&#123;
        return new Inner08();
    &#125;
    //写方法
    public void t1() &#123;
//使用成员内部类
//创建成员内部类的对象，然后使用相关的方法
        Inner08 inner08 = new Inner08();
        inner08.say();
        System.out.println(inner08.sal);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">System.out.println(inner08.sal);</code></pre>

<p>仍可以直接输出sal，虽然它是成员内部类，但是仍处于同一个类中，所以即使是private，也可以直接用。</p>
<p>外部其它类使用成员内部类的三种方式：</p>
<p>1、 <code>outer08.new Inner08()</code>  相当于把 new Inner08()当做是 outer08 成员</p>
<pre><code class="hljs plaintext">outer08.new Inner08().say();</code></pre>

<p>2、创建一个成员内部类的对象，通过对象去访问他里面的方法：</p>
<pre><code class="hljs plaintext">Outer08.Inner08 inner08 = outer08.new Inner08();
inner08.say();</code></pre>

<p>3、在外部类中，编写一个方法，可以返回成员内部类对象：</p>
<pre><code class="hljs plaintext">Outer08 outer08 = new Outer08();
Outer08.Inner08 inner08Instance = outer08.getInner08Instance();
inner08Instance.say();</code></pre>

<p>或者将这个方法定义为静态方法会更加简单。</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727102408708.png" alt="image-20240727102408708"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727102414626.png" alt="image-20240727102414626"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727102419556.png" alt="image-20240727102419556"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727102424525.png" alt="image-20240727102424525"></p>
<p>这个不用加this。</p>
<p>外部其它类使用静态内部类的方式和上面一个的完全一样。</p>
<hr>
<p>一道题：</p>
<pre><code class="hljs plaintext">public class Test &#123;//外部类
    public Test() &#123;//构造器
        Inner s1 = new Inner();
        s1.a = 10;
        Inner s2 = new Inner();
        System.out.println(s2.a);
    &#125;
    class Inner &#123; //内部类，成员内部类
        public int a = 5;
    &#125;
    public static void main(String[] args) &#123;
        Test t = new Test();
        Inner r = t.new Inner();//5
        System.out.println(r.a);//5
    &#125;
&#125;</code></pre>

<p><code>Inner r = t.new Inner();</code>这句话前面不用再引入Test类的原因是这句代码原本就是再Test类里面进行的。</p>
<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h3><p>枚举类[枚: 一个一个，举： 例举 。 即把具体的对象一个一个例举出来的类就称为枚举类]</p>
<p>何时使用：（1）需要创建的类只有有限几个对象（2）只读，不需要修改。</p>
<p>1）枚举对应英文(enumeration, 简写 enum。</p>
<p>2）枚举是一组常量的集合。 </p>
<p>3） 可以这里理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象。</p>
<p>枚举的两种实现方式：1）自定义类实现枚举； 2) 使用 enum 关键字实现枚举。</p>
<h3 id="自定义类实现枚举"><a href="#自定义类实现枚举" class="headerlink" title="自定义类实现枚举"></a>自定义类实现枚举</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240730103701253.png" alt="image-20240730103701253"></p>
<pre><code class="hljs plaintext">public class Enumeration02 &#123;
    public static void main(String[] args) &#123;
        System.out.println(Season.AUTUMN);
        System.out.println(Season.SPRING);
    &#125;
&#125;
//演示字定义枚举实现
class Season &#123;//类
    private String name;
    private String desc;//描述
    //定义了四个对象, 固定. 
    public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);
    public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;寒冷&quot;);
    public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;凉爽&quot;);
    public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;炎热&quot;);
//1. 将构造器私有化,目的防止 直接 new
//2. 去掉 setXxx 方法, 防止属性被修改
//3. 在 Season 内部，直接创建固定的对象
//4. 优化，可以加入 final 修饰符
    private Season(String name, String desc) &#123;
        this.name = name;
        this.desc = desc;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public String getDesc() &#123;
        return desc;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Season&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, desc=&#x27;&quot; + desc + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p>小结：自定义类实现枚举特点：</p>
<ol>
<li>构造器私有化</li>
<li>本类内部创建一组对象[四个 春夏秋冬]</li>
<li>对外暴露对象（通过为对象添加 public final static 修饰符）</li>
<li>可以提供 get 方法，但是不要提供 set</li>
</ol>
<h3 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a>enum关键字实现枚举</h3><pre><code class="hljs plaintext">public class Enumeration03 &#123;
    public static void main(String[] args) &#123;
        System.out.println(Season2.AUTUMN);
        System.out.println(Season2.SUMMER);
    &#125;
&#125;
//演示使用 enum 关键字来实现枚举类
enum Season2 &#123;//类
    //如果使用了 enum 来实现枚举类
//1. 使用关键字 enum 替代 class
//2. public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;) 直接使用 SPRING(&quot;春天&quot;, &quot;温暖&quot;) 解读 常量名(实参列表)
//3. 如果有多个常量(对象)， 使用 ,号间隔即可
//4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面
//5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()
    SPRING(&quot;春天&quot;, &quot;温暖&quot;), WINTER(&quot;冬天&quot;, &quot;寒冷&quot;), AUTUMN(&quot;秋天&quot;, &quot;凉爽&quot;), SUMMER(&quot;夏天&quot;, &quot;炎热&quot;)/*, What()*/;
    private String name;
    private String desc;//描述
    private Season2() &#123;//无参构造器
    &#125;
    private Season2(String name, String desc) &#123;
        this.name = name;
        this.desc = desc;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public String getDesc() &#123;
        return desc;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Season&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, desc=&#x27;&quot; + desc + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p>不去重新定义toString的话，它输出的是枚举类里面每个对象的对象名。</p>
<p>注意事项：</p>
<ol>
<li>当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类</li>
<li>传统的 public static final Season2 SPRING &#x3D; new Season2(“春天”, “温暖”); 简化成 SPRING(“春天”, “温暖”)， 这里必<br>须知道，它调用的是哪个构造器. </li>
<li>如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</li>
<li>当有多个枚举对象时，使用’,’间隔，最后有一个分号结尾</li>
<li>枚举对象必须放在枚举类的行首.</li>
</ol>
<h3 id="enum常用方法-增强for"><a href="#enum常用方法-增强for" class="headerlink" title="enum常用方法+增强for"></a>enum常用方法+增强for</h3><p>说明：使用关键字 enum 时，会隐式继承 Enum 类, 这样我们就可以使用 Enum 类相关的方法。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731104137732.png" alt="image-20240731104137732"></p>
<p>使用 Season2 枚举类，来演示各种方法</p>
<pre><code class="hljs plaintext">//补充了一个增强 for
// int[] nums = &#123;1, 2, 9&#125;;
// //普通的 for 循环
// System.out.println(&quot;=====普通的 for=====&quot;);
// for (int i = 0; i &lt; nums.length; i++) &#123;
// System.out.println(nums[i]);
// &#125;
// System.out.println(&quot;=====增强的 for=====&quot;);
// //执行流程是 依次从 nums 数组中取出数据，赋给 i, 如果取出完毕，则退出 for
// for(int i : nums) &#123;
// System.out.println(&quot;i=&quot; + i);
// &#125;</code></pre>

<pre><code class="hljs plaintext">public class EnumMethod &#123;
    public static void main(String[] args) &#123;
//使用 Season2 枚举类，来演示各种方法
        Season2 autumn = Season2.AUTUMN;
//输出枚举对象的名字
        System.out.println(autumn.name());
//ordinal() 输出的是该枚举对象的次序/编号，从 0 开始编号
//AUTUMN 枚举对象是第三个，因此输出 2
        System.out.println(autumn.ordinal());
//从反编译可以看出 values 方法，返回 Season2[]
//含有定义的所有枚举对象
        Season2[] values = Season2.values();
        System.out.println(&quot;===遍历取出枚举对象(增强 for)====&quot;);
        for (Season2 season: values) &#123;//增强 for 循环
            System.out.println(season);
        &#125;
//valueOf：将字符串转换成枚举对象，要求字符串必须
        为已有的常量名，否则报异常
//执行流程
//1. 根据你输入的 &quot;AUTUMN&quot; 到 Season2 的枚举对象去查找
//2. 如果找到了，就返回，如果没有找到，就报错
        Season2 autumn1 = Season2.valueOf(&quot;AUTUMN&quot;);
        System.out.println(&quot;autumn1=&quot; + autumn1);
        System.out.println(autumn == autumn1);
//compareTo：比较两个枚举常量，比较的就是编号
//老韩解读
//1. 就是把 Season2.AUTUMN 枚举对象的编号 和 Season2.SUMMER 枚举对象的编号比较
//2. 看看结果
/*
public final int compareTo(E o) &#123;
return self.ordinal - other.ordinal;
&#125;
Season2.AUTUMN 的编号[2] - Season2.SUMMER 的编号[3]
*/
        System.out.println(Season2.AUTUMN.compareTo(Season2.SUMMER));
    &#125;
&#125;</code></pre>

<h3 id="enum实现接口"><a href="#enum实现接口" class="headerlink" title="enum实现接口"></a>enum实现接口</h3><ol>
<li>使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制。</li>
<li>枚举类和普通类一样，可以实现接口，如下形式。<br>enum 类名 implements 接口 1，接口 2{}</li>
</ol>
<pre><code class="hljs plaintext">interface IPlaying &#123;
    public void playing();
&#125;
enum Music implements IPlaying &#123;
    CLASSICMUSIC;
    @Override
    public void playing() &#123;
	    System.out.println(&quot;播放好听的音乐...&quot;);
    &#125;
&#125;</code></pre>

<p>调用：<code>Music.CLASSICMUSIC.playing();</code></p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="基础-4"><a href="#基础-4" class="headerlink" title="基础"></a>基础</h3><pre><code class="hljs plaintext">1) 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。
2) 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。
3) 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角
色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。</code></pre>

<pre><code class="hljs plaintext">三个基本的 Annotation:
1) @Override: 限定某个方法，是重写父类方法, 该注解只能用于方法
2) @Deprecated: 用于表示某个程序元素(类, 方法等)已过时
3) @SuppressWarnings: 抑制编译器警告</code></pre>

<h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731153546504.png" alt="image-20240731153546504"></p>
<p>如果你写了@Override 注解，编译器就会去检查该方法是否真的重写了父类的方法，如果的确重写了，则编译通过，如果没有构成重写，则编译错误。</p>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><pre><code class="hljs plaintext">@Deprecated
class A &#123;
    @Deprecated
    public int n1 = 10;
    @Deprecated
    public void hi()&#123;
    &#125;
&#125;
</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731153824416.png" alt="image-20240731153824416"></p>
<h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><ol>
<li>当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息</li>
<li>在{“”} 中，可以写入你希望抑制(不显示)警告信息</li>
<li>关于 SuppressWarnings 作用范围是和你放置的位置相关<br>&#x2F;&#x2F; 比如 @SuppressWarnings 放置在 main 方法，那么抑制警告的范围就是 main<br>&#x2F;&#x2F; 通常我们可以放置具体的语句, 方法, 类.</li>
</ol>
<pre><code class="hljs plaintext">@SuppressWarnings(&#123;&quot;rawtypes&quot;&#125;)</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731154135263.png" alt="image-20240731154135263"></p>
<h1 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常-Exception"></a>异常-Exception</h1><h2 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h2><p>例子：</p>
<pre><code class="hljs plaintext">public class Exception01 &#123;
    public static void main(String[] args) &#123;
        int num1 = 10;
        int num2 = 0;//Scanner();
//老韩解读
//1. num1 / num2 =&gt; 10 / 0
//2. 当执行到 num1 / num2 因为 num2 = 0, 程序就会出现(抛出)异常 ArithmeticException
//3. 当抛出异常后，程序就退出，崩溃了 , 下面的代码就不在执行
//4. 大家想想这样的程序好吗? 不好，不应该出现了一个不算致命的问题，就导致整个系统崩溃
//5. java 设计者，提供了一个叫 异常处理机制来解决该问题
// int res = num1 / num2;
//如果程序员，认为一段代码可能出现异常/问题，可以使用 try-catch 异常处理机制来解决
//从而保证程序的健壮性
//将该代码块-&gt;选中-&gt;快捷键 ctrl + alt + t -&gt; 选中 try-catch
//6. 如果进行异常处理，那么即使出现了异常，程序可以继续执行
        try &#123;
            int res = num1 / num2;
        &#125; catch (Exception e) &#123;
//e.printStackTrace();
            System.out.println(&quot;出现异常的原因=&quot; + e.getMessage());//输出异常信息
        &#125;
        System.out.println(&quot;程序继续运行....&quot;);
    &#125;
&#125;</code></pre>

<p>将该代码块-&gt;选中-&gt;快捷键 ctrl + alt + t -&gt; 选中 try-catch，不能使用系统给你的，需要做些修改，不然只会将问题再输出一遍，程序仍然会中断。</p>
<p>将catch后面的方法体变为<code>System.out.println(&quot;出现异常的原因=&quot; + e.getMessage());</code>，程序就不会中断了。</p>
<p>输出异常信息：</p>
<pre><code class="hljs plaintext">e.printStackTrace();
或者
System.out.println(&quot;出现异常的原因=&quot; + e.getMessage());</code></pre>

<p>下面是程序给的：如果将<code>throw new RuntimeException(e);</code>注释掉，程序也会继续往下运行。</p>
<pre><code class="hljs plaintext">try &#123;
    int res = num1 / num2;
&#125; catch (Exception e) &#123;
    throw new RuntimeException(e);
&#125;</code></pre>

<h2 id="基础-5"><a href="#基础-5" class="headerlink" title="基础"></a>基础</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731161904912.png" alt="image-20240731161904912"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731162157449.png" alt="image-20240731162157449"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731164151694.png" alt="image-20240731164151694"></p>
<h2 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h2><ol>
<li>NullPointerException 空指针异常</li>
<li>ArithmeticException 数学运算异常</li>
<li>ArrayIndexOutOfBoundsException 数组下标越界异常</li>
<li>ClassCastException 类型转换异常</li>
<li>NumberFormatException 数字格式不正确异常[]</li>
</ol>
<p>4、当试图将对象强制转换为不是实例的子类时，抛出该异常。</p>
<pre><code class="hljs plaintext">public class ClassCastException_ &#123;
    public static void main(String[] args) &#123;
        A b = new B(); //向上转型
        B b2 = (B)b;//向下转型，这里是 OK
        C c2 = (C)b;//这里抛出 ClassCastException
    &#125;
&#125;
class A &#123;&#125;
class B extends A &#123;&#125;
class C extends A &#123;&#125;</code></pre>

<p>5、当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常</p>
<pre><code class="hljs plaintext">public class NumberFormatException_ &#123;
    public static void main(String[] args) &#123;
        String name = &quot;韩顺平教育&quot;;
//将 String 转成 int
        int num = Integer.parseInt(name);//抛出 NumberFormatException
        System.out.println(num);//1234
    &#125;
&#125;</code></pre>

<h2 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731162633775.png" alt="image-20240731162633775"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731162648857.png" alt="image-20240731162648857"></p>
<p>例子没看懂</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731162833533.png" alt="image-20240731162833533"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731162906866.png" alt="image-20240731162906866"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731163027886.png" alt="image-20240731163027886"></p>
<h3 id="try-catch-异常处理"><a href="#try-catch-异常处理" class="headerlink" title="try-catch 异常处理"></a>try-catch 异常处理</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731163110864.png" alt="image-20240731163110864"></p>
<p>上面的引入例子</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731163332984.png" alt="image-20240731163332984"></p>
<pre><code class="hljs plaintext">public class TryCatchDetail &#123;
    public static void main(String[] args) &#123;
//ctrl + atl + t
//老韩解读
//1. 如果异常发生了，则异常发生后面的代码不会执行，直接进入到 catch 块
//2. 如果异常没有发生，则顺序执行 try 的代码块，不会进入到 catch
//3. 如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用如下代码- finally
        try &#123;
            String str = &quot;韩顺平&quot;;
            int a = Integer.parseInt(str);
            System.out.println(&quot;数字：&quot; + a);
        &#125; catch (NumberFormatException e) &#123;
            System.out.println(&quot;异常信息=&quot; + e.getMessage());
        &#125; finally &#123;
            System.out.println(&quot;finally 代码块被执行...&quot;);
        &#125;
        System.out.println(&quot;程序继续...&quot;);
    &#125;
&#125;</code></pre>

<p>如果异常发生了，则异常发生后面的代码不会执行，直接进入到 catch 块：这里讲的异常后面的代码的范围是在try里面的，try里面的某处代码发生问题后，这处后面的代码不执行，直接跳到catch。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731164241784.png" alt="image-20240731164241784"></p>
<pre><code class="hljs plaintext">public class c&#123;
    public static void main(String[] args) &#123;
//老韩解读
//1.如果 try 代码块有可能有多个异常
//2.可以使用多个 catch 分别捕获不同的异常，相应处理
//3.要求子类异常写在前面，父类异常写在后面
        try &#123;
            Person person = new Person();
//person = null;
            System.out.println(person.getName());//NullPointerException
            int n1 = 10;
            int n2 = 0;
            int res = n1 / n2;//ArithmeticException
        &#125; catch (NullPointerException e) &#123;
            System.out.println(&quot;空指针异常=&quot; + e.getMessage());
        &#125; catch (ArithmeticException e) &#123;
            System.out.println(&quot;算术异常=&quot; + e.getMessage());
        &#125; catch (Exception e) &#123;
            System.out.println(e.getMessage());
        &#125; finally &#123;
        &#125;
    &#125;
&#125;
class Person &#123;
    private String name = &quot;jack&quot;;
    public String getName() &#123;
        return name;
    &#125;
&#125;</code></pre>

<p>上面代码不存在空指针问题。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731164845230.png" alt="image-20240731164845230"></p>
<p>有异常才会崩掉。</p>
<h3 id="利用try-catch解决问题"><a href="#利用try-catch解决问题" class="headerlink" title="利用try-catch解决问题"></a>利用try-catch解决问题</h3><p>如果用户输入的不是一个整数，就提示他反复输入，直到输入一个整数为止</p>
<pre><code class="hljs plaintext">import java.util.Scanner;

public class TryCatchExercise04 &#123;
    public static void main(String[] args) &#123;
//如果用户输入的不是一个整数，就提示他反复输入，直到输入一个整数为止
//思路
//1. 创建 Scanner 对象
//2. 使用无限循环，去接收一个输入
//3. 然后将该输入的值，转成一个 int
//4. 如果在转换时，抛出异常，说明输入的内容不是一个可以转成 int 的内容
//5. 如果没有抛出异常，则 break 该循环
        Scanner scanner = new Scanner(System.in);
        int num = 0;
        String inputStr = &quot;&quot;;
        while (true) &#123;
            System.out.println(&quot;请输入一个整数:&quot;); //
            inputStr = scanner.next();
            try &#123;
                num = Integer.parseInt(inputStr); //这里是可能抛出异常
                break;
            &#125; catch (NumberFormatException e) &#123;
                System.out.println(&quot;你输入的不是一个整数:&quot;);
            &#125;
        &#125;
        System.out.println(&quot;你输入的值是=&quot; + num);
    &#125;
&#125;</code></pre>

<h3 id="throws-异常处理"><a href="#throws-异常处理" class="headerlink" title="throws 异常处理"></a>throws 异常处理</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731173758424.png" alt="image-20240731173758424"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731174140998.png" alt="image-20240731174140998"></p>
<p>没有用try-catch去处理异常，啥都没写就是默认throws处理，不用去写，就是默认它处理的。</p>
<pre><code class="hljs plaintext">import java.io.FileInputStream;
import java.io.FileNotFoundException;
/**
 * @author 韩顺平
 * @version 1.0
 */
public class ThrowsDetail &#123;
    public static void main(String[] args) &#123;
        f2();
    &#125;
    public static void f2() /*throws ArithmeticException*/ &#123;
//1.对于编译异常，程序中必须处理，比如 try-catch 或者 throws
//2.对于运行时异常，程序中如果没有处理，默认就是 throws 的方式处理
        int n1 = 10;
        int n2 = 0;
        double res = n1 / n2;
    &#125;
    public static void f1() throws FileNotFoundException &#123;
//这里大家思考问题 调用 f3() 报错
//老韩解读
//1. 因为 f3() 方法抛出的是一个编译异常
//2. 即这时，就要 f1() 必须处理这个编译异常
//3. 在 f1() 中，要么 try-catch-finally ,或者继续 throws 这个编译异常
        f3(); // 抛出异常
    &#125;
    public static void f3() throws FileNotFoundException &#123;
        FileInputStream fis = new FileInputStream(&quot;d://aa.txt&quot;);
    &#125;
    public static void f4() &#123;
//老韩解读:
//1. 在 f4()中调用方法 f5() 是 OK
//2. 原因是 f5() 抛出的是运行异常
//3. 而 java 中，并不要求程序员显示处理,因为有默认处理机制
        f5();
    &#125;
    public static void f5() throws ArithmeticException &#123;
    &#125;
&#125;
class Father &#123; //父类
    public void method() throws RuntimeException &#123;
    &#125;
&#125;
class Son extends Father &#123;//子类
    //3. 子类重写父类的方法时，对抛出异常的规定:子类重写的方法，
// 所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常类型的子类型
//4. 在 throws 过程中，如果有方法 try-catch , 就相当于处理异常，就可以不必 throws
    @Override
    public void method() throws ArithmeticException &#123;
    &#125;
&#125;</code></pre>

<p>有点没看懂上面那个。</p>
<p><strong>编写方法</strong>抛出异常：</p>
<p>声明一个方法抛出异常要在括号后面加<code>throws 异常</code>。</p>
<p>编写程序，定义一个 static 方法 methodA()，令其声明抛出一个 IOException 异常，再定义 另一个 static 方法 methodB()，在该方法中调用 methodA()方法。在 main()方法中调用 methodB() 方法。试编译该类，看编译器会报告什么？对于这种情况应如何处理？</p>
<pre><code class="hljs plaintext">import java.io.IOException;
public class c&#123;
    public static void methodA() throws IOException&#123;
        System.out.println(&quot;In method A&quot;);
    &#125;
    public static void methodB()&#123;
        methodA(); // 编译错误，没有处理 methodA()方法抛出的非运行时异常
        System.out.println(&quot;In method B&quot;);
    &#125;
    public static void main(String args[])&#123;
        methodB();
    &#125;
&#125;</code></pre>

<p>编译器报告：</p>
<p>java: 未报告的异常错误java.io.IOException; 必须对其进行捕获或声明以便抛出</p>
<p>处理：</p>
<p>（1）声明 methodB()方法抛出 IOException 异常。 </p>
<p>（2）在 methodB()方法中使用 try-catch 结构对 methodA()方法调用进行异常处理。</p>
<pre><code class="hljs plaintext">try&#123; 

methodA(); 

&#125;catch(IOException e) &#123; &#125;</code></pre>

<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240801110702617.png" alt="image-20240801110702617"></p>
<p>步骤：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240801110714899.png" alt="image-20240801110714899"></p>
<pre><code class="hljs plaintext">public class CustomException &#123;
    public static void main(String[] args) /*throws AgeException*/ &#123;
        int age = 180;
//要求范围在 18 – 120 之间，否则抛出一个自定义异常
        if(!(age &gt;= 18 &amp;&amp; age &lt;= 120)) &#123;
//这里我们可以通过构造器，设置信息
            throw new AgeException(&quot;年龄需要在 18~120 之间&quot;);
        &#125;
        System.out.println(&quot;你的年龄范围正确.&quot;);
    &#125;
&#125;
//自定义一个异常
//老韩解读
//1. 一般情况下，我们自定义异常是继承 RuntimeException
//2. 即把自定义异常做成 运行时异常，好处时，我们可以使用默认的处理机制
//3. 即比较方便
class AgeException extends RuntimeException &#123;
    public AgeException(String message) &#123;//构造器
        super(message);
    &#125;
&#125;</code></pre>

<p>记住这个例子，以后的按这个例子来写。</p>
<p>写一个方法，令其打印出保存下来的 String 对象：</p>
<pre><code class="hljs plaintext">public void output1()&#123;
        System.out.println(getMessage());
    &#125;</code></pre>

<p>要调用这个方法的话，一定要记得把catch里面异常的类型改为这个方法所在的自定义异常类，然后才能调用这个方法。如果是原来的Exception的话，由于自定义的是它的子类，而它作为父类是不能调用子类的方法的，除非向下转型。</p>
<pre><code class="hljs plaintext">public class c&#123;
    public static void main(String[] args)&#123;
        try&#123;
            throw new MyException(&quot;My Exception.&quot;);
        &#125;catch(MyException e)&#123;
            e.output1();
            System.out.println(e.getMessage());
        &#125;
    &#125;
&#125;

class MyException extends Exception&#123;
    public MyException() &#123; &#125;
    public MyException(String message)&#123;
        super(message);
    &#125;
    public void output1()&#123;
        System.out.println(getMessage());
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240801111139204.png" alt="image-20240801111139204"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240801111510841.png" alt="image-20240801111510841"></p>
<p>finally里面的内容是try运行完后无论如何都会运行的。</p>
<p>为什么“制造异常”在后面：因为在A中的throw生成了一个RuntimeException异常，所以main方法中的try就发生了异常，然后catch捕捉RuntimeException异常，之后在它的方法体中输出RuntimeException异常的内容“制造异常”，所以“制造异常”在后面。</p>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>针对八种基本数据类型相应的引用类型—包装类。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802102316270.png" alt="image-20240802102316270"></p>
<p>有了类的特点，就可以调用类中的方法。</p>
<h3 id="包装类和基本数据类型的转换"><a href="#包装类和基本数据类型的转换" class="headerlink" title="包装类和基本数据类型的转换"></a>包装类和基本数据类型的转换</h3><p>装箱：基本数据类型-&gt;包装类型；拆箱相反。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802102713074.png" alt="image-20240802102713074"></p>
<pre><code class="hljs plaintext">//jdk5 前是手动装箱和拆箱
//手动装箱 int-&gt;Integer
int n1 = 100;
Integer integer = new Integer(n1);//现在会报错
Integer integer1 = Integer.valueOf(n1);
//手动拆箱
//Integer -&gt; int
int i = integer.intValue();</code></pre>

<pre><code class="hljs plaintext">//jdk5（包括jdk5）后，就可以自动装箱和自动拆箱
int n2 = 200;
//自动装箱 int-&gt;Integer
Integer integer2 = n2; //底层使用的是 Integer.valueOf(n2)
//自动拆箱 Integer-&gt;int
int n3 = integer2; //底层仍然使用的是 intValue()方法</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802104712915.png" alt="image-20240802104712915"></p>
<p>第一个输出1.0的原因：</p>
<p>在 Java 中，三元运算符的两种可能结果会被提升为一个共同的类型。在这个例子中，<code>new Integer(1)</code> 和 <code>new Double(2.0)</code> 将会被提升为 <code>Double</code> 类型，因为 <code>Double</code> 是 <code>Integer</code> 和 <code>Double</code> 的共同父类。然后 <code>obj1</code> 会被赋值为 <code>Double</code> 类型的 <code>1.0</code>。</p>
<pre><code class="hljs plaintext">//示例六
Integer i11=127;
int i12=127;
//只要有基本数据类型，判断的是值是否相同，会自动拆箱
System.out.println(i11==i12); //T
//示例七
Integer i13=128;
int i14=128;
System.out.println(i13==i14);//T</code></pre>

<h3 id="包装类型和-String-类型的相互转换"><a href="#包装类型和-String-类型的相互转换" class="headerlink" title="包装类型和 String 类型的相互转换"></a>包装类型和 String 类型的相互转换</h3><pre><code class="hljs plaintext">//包装类(Integer)-&gt;String
Integer i = 100;//自动装箱
//方式 1
String str1 = i + &quot;&quot;;
//方式 2
String str2 = i.toString();
//方式 3
String str3 = String.valueOf(i);</code></pre>

<pre><code class="hljs plaintext">//String -&gt; 包装类(Integer)
String str4 = &quot;12345&quot;;
Integer i2 = Integer.parseInt(str4);//使用到自动装箱
Integer i3 = new Integer(str4);//构造器</code></pre>

<p><code>Integer i2 = Integer.parseInt(str4);</code>先转化为int类型，再用到自动装箱变为包装类。</p>
<h3 id="Integer-类和-Character-类的常用方法"><a href="#Integer-类和-Character-类的常用方法" class="headerlink" title="Integer 类和 Character 类的常用方法"></a>Integer 类和 Character 类的常用方法</h3><pre><code class="hljs plaintext">System.out.println(Integer.MIN_VALUE); //返回最小值
System.out.println(Integer.MAX_VALUE);//返回最大值
System.out.println(Character.isDigit(&#x27;a&#x27;));//判断是不是数字
System.out.println(Character.isLetter(&#x27;a&#x27;));//判断是不是字母
System.out.println(Character.isUpperCase(&#x27;a&#x27;));//判断是不是大写
System.out.println(Character.isLowerCase(&#x27;a&#x27;));//判断是不是小写
System.out.println(Character.isWhitespace(&#x27;a&#x27;));//判断是不是空格
System.out.println(Character.toUpperCase(&#x27;a&#x27;));//转成大写
System.out.println(Character.toLowerCase(&#x27;A&#x27;));//转成小写</code></pre>

<p>其它的与Integer类相似。</p>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="基础-6"><a href="#基础-6" class="headerlink" title="基础"></a>基础</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802112155115.png" alt="image-20240802112155115"></p>
<p>1）字符串的字符使用 Unicode 字符编码，一个字符(不区分字母还是汉字)占两个字节；</p>
<p>2）String 是 final 类，不能被其他的类继承。</p>
<p>创建String对象的两种方式：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802112932591.png" alt="image-20240802112932591"></p>
<p>两种方式的区别：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802112946033.png" alt="image-20240802112946033"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802112952647.png" alt="image-20240802112952647"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802113113614.png" alt="image-20240802113113614"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802152635252.png" alt="image-20240802152635252"></p>
<h3 id="字符串的特性"><a href="#字符串的特性" class="headerlink" title="字符串的特性"></a>字符串的特性</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802152156272.png" alt="image-20240802152156272"></p>
<p>变量名储存的只是地址。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802152322585.png" alt="image-20240802152322585"></p>
<p>两个变量相加和两个字符串（两个常量）直接相加创造的对象个数不同。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802152329006.png" alt="image-20240802152329006"></p>
<h3 id="String类的常用方法-进制转化"><a href="#String类的常用方法-进制转化" class="headerlink" title="String类的常用方法+进制转化"></a>String类的常用方法+进制转化</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802153728020.png" alt="image-20240802153728020"></p>
<pre><code class="hljs plaintext">// 2.equalsIgnoreCase 忽略大小写的判断内容是否相等
String username = &quot;johN&quot;;
if (&quot;john&quot;.equalsIgnoreCase(username)) &#123;
System.out.println(&quot;Success!&quot;);
&#125; else &#123;
System.out.println(&quot;Failure!&quot;);
&#125;
// 3.length 获取字符的个数，字符串的长度
System.out.println(&quot;韩顺平&quot;.length());
// 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1
String s1 = &quot;wer@terwe@g&quot;;
int index = s1.indexOf(&#x27;@&#x27;);
System.out.println(index);// 3
System.out.println(&quot;weIndex=&quot; + s1.indexOf(&quot;we&quot;));//0
// 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1
s1 = &quot;wer@terwe@g@&quot;;
index = s1.lastIndexOf(&#x27;@&#x27;);
System.out.println(index);//11
System.out.println(&quot;ter 的位置=&quot; + s1.lastIndexOf(&quot;ter&quot;));//4
// 6.substring 截取指定范围的子串
String name = &quot;hello,张三&quot;;
//下面 name.substring(6) 从索引 6 开始截取后面所有的内容
System.out.println(name.substring(6));//截取后面的字符
//name.substring(0,5)表示从索引 0 开始截取，截取到索引 5-1=4 位置
System.out.println(name.substring(2,5));//llo</code></pre>

<pre><code class="hljs plaintext">String[] elem = sentence.split(&quot;[, .]&quot;);//这句代表sentence内以&quot;,&quot;  &quot; &quot;  &quot;.&quot;三个为分界点。</code></pre>

<pre><code class="hljs plaintext">index = result.indexOf(&quot;hello&quot;, index + &quot;&lt;censored&gt;&quot;.length());
result，&lt;censored&gt;都是字符串，这个方法还可以指定从哪个位置开始查找。前面是查找的内容，后面是索引。</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802154437791.png" alt="image-20240802154437791"></p>
<pre><code class="hljs plaintext">// 1.toUpperCase 转换成大写
String s = &quot;heLLo&quot;;
System.out.println(s.toUpperCase());//HELLO
// 2.toLowerCase</code></pre>

<p>concat可以连续使用，只要在括号后面继续加上就好了。</p>
<p>replace() 是全替换，方法执行后，返回的结果才是替换过的，对原字符串无影响。</p>
<p><code>String s11 = s1.replace(&quot;林黛玉&quot;, &quot;jack&quot;);</code>林黛玉全部被替换，这是没有指定范围的情况，如果指定了范围就只会替代那个范围的字符，如下(forbidden是违禁词，字符串)，还有一个例子在StringBuffer那边：</p>
<pre><code class="hljs plaintext">// 替换当前违禁词为&lt;censored&gt;
result.replace(index, index + forbidden.length(), &quot;&lt;censored&gt;&quot;);</code></pre>

<pre><code class="hljs plaintext">String poem = &quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;;
String[] split = poem.split(&quot;,&quot;);
poem = &quot;E:\\aaa\\bbb&quot;;
split = poem.split(&quot;\\\\&quot;);
for (int i = 0; i &lt; split.length; i++) &#123;
    System.out.println(split[i]);
    System.out.println(s.toLowerCase());//hello
// 3.concat 拼接字符串
String s1 = &quot;宝玉&quot;;
s1 = s1.concat(&quot;林黛玉&quot;).concat(&quot;薛宝钗&quot;).concat(&quot;together&quot;);
System.out.println(s1);//宝玉林黛玉薛宝钗 together
// 4.replace 替换字符串中的字符
s1 = &quot;宝玉 and 林黛玉 林黛玉 林黛玉&quot;;
//在 s1 中，将 所有的 林黛玉 替换成薛宝钗
// 老韩解读: s1.replace() 方法执行后，返回的结果才是替换过的. // 注意对 s1 没有任何影响
String s11 = s1.replace(&quot;宝玉&quot;, &quot;jack&quot;);
System.out.println(s1);//宝玉 and 林黛玉 林黛玉 林黛玉
System.out.println(s11);//jack and 林黛玉 林黛玉 林黛玉
// 5.split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \\等
String poem = &quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;;
//老韩解读：
// 1. 以 , 为标准对 poem 进行分割 , 返回一个数组
// 2. 在对字符串进行分割时，如果有特殊字符，需要加入 转义符 \
String[] split = poem.split(&quot;,&quot;);
poem = &quot;E:\\aaa\\bbb&quot;;
split = poem.split(&quot;\\\\&quot;);
System.out.println(&quot;==分割后内容===&quot;);
for (int i = 0; i &lt; split.length; i++) &#123;
	System.out.println(split[i]);
&#125;</code></pre>

<p>原本的split数组存储的是诗句，但是下面再使用它来存储新的分割字符串时，不是以覆盖的形式覆盖原先内容，应该是原本存储内容全部清空然后存储新的内容，或者不是清空而是split存储的地址变了。</p>
<pre><code class="hljs plaintext">// 6.toCharArray 转换成字符数组
s = &quot;happy&quot;;
char[] chs = s.toCharArray();
for (int i = 0; i &lt; chs.length; i++) &#123;
	System.out.println(chs[i]);
&#125;
// 7.compareTo 比较两个字符串的大小，如果前者大，
// 则返回正数，后者大，则返回负数，如果相等，返回 0
// 老韩解读
// (1) 如果长度相同，并且每个字符也相同，就返回 0
// (2) 如果长度相同或者不相同，但是在进行比较时，可以区分大小
// 就返回 if (c1 != c2) &#123;
// return c1 - c2;
// &#125;
// (3) 如果前面的部分都相同，就返回 str1.len - str2.len
String a = &quot;jcck&quot;;// len = 3
String b = &quot;jack&quot;;// len = 4
System.out.println(a.compareTo(b)); // 返回值是 &#x27;c&#x27; - &#x27;a&#x27; = 2 的值
// 8.format 格式字符串
/* 占位符有:
* %s 字符串 %c 字符 %d 整型 %.2f 浮点型
*
*/
String name = &quot;john&quot;;
int age = 10;
double score = 56.857;
char gender = &#x27;男&#x27;;
//将所有的信息都拼接在一个字符串. 
String info =&quot;我的姓名是&quot; + name + &quot;年龄是&quot; + age + &quot;,成绩是&quot; + score + &quot;性别是&quot; + gender + &quot;。希望大家喜欢我！&quot;;
System.out.println(info);
//老韩解读
//1. %s , %d , %.2f %c 称为占位符
//2. 这些占位符由后面变量来替换
//3. %s 表示后面由 字符串来替换
//4. %d 是整数来替换
//5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理
//6. %c 使用 char 类型来替换
String formatStr = &quot;我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！&quot;;
String info2 = String.format(formatStr, name, age, score, gender);
System.out.println(&quot;info2=&quot; + info2);</code></pre>

<h4 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240819211720021.png" alt="image-20240819211720021"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240819211739407.png" alt="image-20240819211739407"></p>
<p>方法三：递归</p>
<h2 id="StringBuffer-类"><a href="#StringBuffer-类" class="headerlink" title="StringBuffer 类"></a>StringBuffer 类</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802162302892.png" alt="image-20240802162302892"></p>
<pre><code class="hljs plaintext">//1. StringBuffer 的直接父类 是 AbstractStringBuilder
//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化
//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final
// 该 value 数组存放 字符串内容，引出存放在堆中的
//4. StringBuffer 是一个 final 类，不能被继承
//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)
// 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String
StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802163521972.png" alt="image-20240802163521972"></p>
<h3 id="String和StringBuffer的相互转换"><a href="#String和StringBuffer的相互转换" class="headerlink" title="String和StringBuffer的相互转换"></a>String和StringBuffer的相互转换</h3><pre><code class="hljs plaintext">//看 String——&gt;StringBuffer
String str = &quot;hello tom&quot;;
//方式 1 使用构造器
//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响
StringBuffer stringBuffer = new StringBuffer(str);
//方式 2 使用的是 append 方法
StringBuffer stringBuffer1 = new StringBuffer();
stringBuffer1 = stringBuffer1.append(str);
//看看 StringBuffer -&gt;String
StringBuffer stringBuffer3 = new StringBuffer(&quot;韩顺平教育&quot;);
//方式 1 使用 StringBuffer 提供的 toString 方法
String s = stringBuffer3.toString();
//方式 2: 使用构造器来搞定
String s1 = new String(stringBuffer3);</code></pre>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>上承String类方法。</p>
<pre><code class="hljs plaintext">StringBuffer s = new StringBuffer(&quot;hello&quot;);
//增
s.append(&#x27;,&#x27;);// &quot;hello,&quot;
s.append(&quot;张三丰&quot;);//&quot;hello,张三丰&quot;
s.append(&quot;赵敏&quot;).append(100).append(true).append(10.5);//&quot;hello,张三丰赵敏100true10.5&quot; System.out.println(s);//&quot;hello,张三丰赵敏 100true10.5&quot;
//删
/*
* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符
* 解读: 删除 11~14 的字符 [11, 14)
*/
s.delete(11, 14);
System.out.println(s);//&quot;hello,张三丰赵敏true10.5&quot;
//改
//老韩解读，使用 周芷若 替换 索引 9-11 的字符 [9,11)
s.replace(9, 11, &quot;周芷若&quot;);
System.out.println(s);//&quot;hello,张三丰周芷若 true10.5&quot;
//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1
int indexOf = s.indexOf(&quot;张三丰&quot;);
System.out.println(indexOf);//6
//插
//老韩解读，在索引为 9 的位置插入 &quot;赵敏&quot;,原来索引为 9 的内容自动后移
s.insert(9, &quot;赵敏&quot;);
System.out.println(s);//&quot;hello,张三丰赵敏周芷若 true10.5&quot;
//长度
System.out.println(s.length());//22
System.out.println(s);</code></pre>

<p>对StringBuffer类对象进行修改，字数不需要对等，它会自动调整空间。</p>
<p>方法括号里的数字代表的都是索引数字。</p>
<p>insert，在索引为 9 的位置插入 “赵敏”,原来索引为 9 的内容<strong>自动后移</strong>。</p>
<p>**reverse()**，StringBuffer也可以用。</p>
<p> <code>StringBuilder</code> 的 <code>reverse()</code> 方法会直接修改 <code>str</code> 本身，而不是创建一个新的字符串。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240824154300761.png" alt="image-20240824154300761"></p>
<h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><pre><code class="hljs plaintext">String str = null;// ok
StringBuffer sb = new StringBuffer(); //ok
sb.append(str);//需要看源码 , 底层调用的是 AbstractStringBuilder 的 appendNull
System.out.println(sb.length());//4
System.out.println(sb);//null
//下面的构造器，会抛出 NullpointerException
StringBuffer sb1 = new StringBuffer(str);//看底层源码 super(str.length() + 16);
System.out.println(sb1);</code></pre>

<p>str为空，所以将str转换为StringBuffer时会产生空指针异常；但是<strong>str的字符串长度为4</strong>，因为存储了null。</p>
<h2 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h2><h3 id="介绍和比较"><a href="#介绍和比较" class="headerlink" title="介绍和比较"></a>介绍和比较</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803152208071-1722669728912-1.png" alt="image-20240803152208071"></p>
<pre><code class="hljs plaintext">StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);</code></pre>

<p>String类要先转化为StringBuffer才能转化为StringBuider。</p>
<p>&#x2F;&#x2F;1. StringBuffer 的直接父类 是 AbstractStringBuilder<br>&#x2F;&#x2F;2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化<br>&#x2F;&#x2F;3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final<br>&#x2F;&#x2F; 该 value 数组存放 字符串内容，引出存放在堆中的<br>&#x2F;&#x2F;4. StringBuffer 是一个 final 类，不能被继承<br>&#x2F;&#x2F;5. 因为 StringBuffer 字符内容是存在 char[] value, 所以再变化(增加&#x2F;删除)不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803153113712.png" alt="image-20240803153113712"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803153150977.png" alt="image-20240803153150977"></p>
<h3 id="StringBuilder-常用方法"><a href="#StringBuilder-常用方法" class="headerlink" title="StringBuilder 常用方法"></a>StringBuilder 常用方法</h3><p>和StringBuffer的方法一样。</p>
<h2 id="Math类-常用方法（均为静态方法）"><a href="#Math类-常用方法（均为静态方法）" class="headerlink" title="Math类-常用方法（均为静态方法）"></a>Math类-常用方法（均为静态方法）</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803154943978.png" alt="image-20240803154943978"></p>
<pre><code class="hljs plaintext">//1.abs 绝对值
int abs = Math.abs(-9);
System.out.println(abs);//9
//2.pow 求幂
double pow = Math.pow(2, 4);//2 的 4 次方
System.out.println(pow);//16
//3.ceil 向上取整,返回&gt;=该参数的最小整数(转成 double);
double ceil = Math.ceil(3.9);
System.out.println(ceil);//4.0
//4.floor 向下取整，返回&lt;=该参数的最大整数(转成 double)
double floor = Math.floor(4.001);
System.out.println(floor);//4.0
//5.round 四舍五入 Math.floor(该参数+0.5)
long round = Math.round(5.51);
System.out.println(round);//6
//6.sqrt 求开方
double sqrt = Math.sqrt(9.0);
System.out.println(sqrt);//3.0
//7.random 求随机数
// random 返回的是 0 &lt;= x &lt; 1 之间的一个随机小数
// 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7
// 即返回一个数 x 2 &lt;= x &lt;= 7
// 老韩解读 Math.random() * (b-a) 返回的就是 0 &lt;= 数 &lt; b-a
// (1) (int)(a) &lt;= x &lt;= (int)(a + Math.random() * (b-a +1) )
// (2) 使用具体的数给小伙伴介绍 a = 2 b = 7
// (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6)
// Math.random()*6 返回的是 0 &lt;= x &lt; 6 小数
// 2 + Math.random()*6 返回的就是 2&lt;= x &lt; 8 小数
// (int)(2 + Math.random()*6) = 2 &lt;= x &lt;= 7
// (3) 公式就是 (int)(a + Math.random() * (b-a +1) )
for(int i = 0; i &lt; 100; i++) &#123;
	System.out.println((int)(2 + Math.random() * (7 - 2 + 1)));
&#125;
//max , min 返回最大值和最小值
int min = Math.min(1, 9);
int max = Math.max(45, 90);
System.out.println(&quot;min=&quot; + min);
System.out.println(&quot;max=&quot; + max);</code></pre>

<p>Math.round()返回的是long类型的数。</p>
<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><h3 id="常用方法（静态）"><a href="#常用方法（静态）" class="headerlink" title="常用方法（静态）"></a>常用方法（静态）</h3><p>需要引入Arrays类</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803160114605.png" alt="image-20240803160114605"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803160118325.png" alt="image-20240803160118325"></p>
<p>toString就是返回数组内容；sort可以对字符数组进行排序。</p>
<p>fill方法是把原数组里的所有元素全部替换成填充的数字。</p>
<p>fill(arr,fromIndex,toIndex,value)，在范围内的替换为value。</p>
<p>基本数据类型和包装类都可以调用Arrays的方法。</p>
<pre><code class="hljs plaintext">import java.util.Arrays;
public class c&#123;
    public static void main(String[] args)&#123;
        int[] arr = &#123;1, 2, 90, 123, 567&#125;;
// binarySearch 通过二分搜索法进行查找，要求必须排好
// 老韩解读
//1. 使用 binarySearch 二叉查找
//2. 要求该数组是有序的. 如果该数组是无序的，不能使用 binarySearch
//3. 如果数组中不存在该元素，就返回 return -(low + 1); //low为该元素应该插入的位置，以维持数组的排序顺序。
        int index = Arrays.binarySearch(arr, 567);
        System.out.println(&quot;index=&quot; + index);
//copyOf 数组元素的复制
// 老韩解读
//1. 从 arr 数组中，拷贝 arr.length 个元素到 newArr 数组中
//2. 如果拷贝的长度 &gt; arr.length 就在新数组的后面 增加 null
//3. 如果拷贝长度 &lt; 0 就抛出异常 NegativeArraySizeException
//4. 该方法的底层使用的是 System.arraycopy()
        int[] newArr = Arrays.copyOf(arr, arr.length);
        System.out.println(&quot;==拷贝执行完毕后==&quot;);
        System.out.println(Arrays.toString(newArr));
//fill 数组元素的填充
        int[] num = new int[]&#123;9,3,2&#125;;
//老韩解读
//1. 使用 99 去填充 num 数组，可以理解成是替换原理的元素
        Arrays.fill(num, 99);
        System.out.println(&quot;==num 数组填充后==&quot;);
        System.out.println(Arrays.toString(num));
//equals 比较两个数组元素内容是否完全一致
        int[] arr2 = &#123;1, 2, 90, 123&#125;;
//老韩解读
//1. 如果 arr 和 arr2 数组的元素一样，则方法 true;
//2. 如果不是完全一样，就返回 false
        boolean equals = Arrays.equals(arr, arr2);
        System.out.println(&quot;equals=&quot; + equals);
    &#125;
&#125;</code></pre>

<h3 id="sort排序的定制排序"><a href="#sort排序的定制排序" class="headerlink" title="sort排序的定制排序"></a>sort排序的定制排序</h3><p>sort是可以重载的，也可以通过传入一个<strong>接口 Comparator</strong> 实现定制排序，调用 定制排序 时，传入两个参数 (1) 排序的数组 arr &#x2F;&#x2F; (2) 实现了 Comparator 接口的匿名内部类 , 要求实现 compare 方法。</p>
<p>下面的是自己编写的冒泡排序方法加上实现定制排序的Comparator匿名类，用sort实现这种定制排序的原理和这种形式是一样的。</p>
<p><code>Arrays.sort(arr, new Comparator()&#123;&#125;)</code></p>
<pre><code class="hljs plaintext">import java.util.Arrays;
import java.util.Comparator;
public class c&#123;
    public static void main(String[] args)&#123;
        int[] arr = &#123;1, -1, 8, 0, 20&#125;;
//bubble01(arr);
        bubble02(arr, new Comparator() &#123;
            @Override
            public int compare(Object o1, Object o2) &#123;
                int i1 = (Integer) o1;
                int i2 = (Integer) o2;
                return i2 - i1;// return i2 - i1;
            &#125;
        &#125;);
        System.out.println(&quot;==定制排序后的情况==&quot;);
        System.out.println(Arrays.toString(arr));
    &#125;
    //使用冒泡完成排序
    public static void bubble01(int[] arr) &#123;
        int temp = 0;
        for (int i = 0; i &lt; arr.length - 1; i++) &#123;
            for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;
//从小到大
                if (arr[j] &gt; arr[j + 1]) &#123;
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                &#125;
            &#125;
        &#125;
    &#125;
    //结合冒泡 + 定制
    public static void bubble02(int[] arr, Comparator c) &#123;
        int temp = 0;
        for (int i = 0; i &lt; arr.length - 1; i++) &#123;
            for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;
//数组排序由 c.compare(arr[j], arr[j + 1])返回的值决定
                if (c.compare(arr[j], arr[j + 1]) &gt; 0) &#123;
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803164210193.png" alt="image-20240803164210193"></p>
<pre><code class="hljs plaintext">import java.util.Arrays;
import java.util.Comparator;</code></pre>

<pre><code class="hljs plaintext">//(1)price 从大到小
 Arrays.sort(books, new Comparator() &#123;
     //这里是对 Book 数组排序，因此 o1 和 o2 就是 Book 对象
     @Override
     public int compare(Object o1, Object o2) &#123;
         Book book1 = (Book) o1;
         Book book2 = (Book) o2;
         double priceVal = book2.getPrice() - book1.getPrice();
         //这里老师进行了一个转换
         //如果发现返回结果和我们输出的不一致，就修改一下返回的 1 和 -1
         if(priceVal &gt; 0) &#123;
         return 1;
         &#125; else if(priceVal &lt; 0) &#123;
         return -1;
         &#125; else &#123;
         return 0;
         &#125;
     &#125;
 &#125;);</code></pre>

<pre><code class="hljs plaintext">//(2)price 从小到大
 Arrays.sort(books, new Comparator() &#123;
     //这里是对 Book 数组排序，因此 o1 和 o2 就是 Book 对象
     @Override
     public int compare(Object o1, Object o2) &#123;
         Book book1 = (Book) o1;
         Book book2 = (Book) o2;
         double priceVal = book2.getPrice() - book1.getPrice();
         if(priceVal &gt; 0) &#123;
         return -1;
         &#125; else if(priceVal &lt; 0) &#123;
         return 1;
         &#125; else &#123;
         return 0;
         &#125;
     &#125;
 &#125;);</code></pre>

<pre><code class="hljs plaintext">//(3)按照书名长度从大到小
Arrays.sort(books, new Comparator() &#123;
//这里是对 Book 数组排序，因此 o1 和 o2 就是 Book 对象
    @Override
    public int compare(Object o1, Object o2) &#123;
        Book book1 = (Book) o1;
        Book book2 = (Book) o2;
//要求按照书名的长度来进行排序
        return book2.getName().length() - book1.getName().length();
    &#125;
&#125;);</code></pre>

<h2 id="System-类-常用方法"><a href="#System-类-常用方法" class="headerlink" title="System 类-常用方法"></a>System 类-常用方法</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804155633708.png" alt="image-20240804155633708"></p>
<pre><code class="hljs plaintext">//exit 退出当前程序
 System.out.println(&quot;ok1&quot;);
 //老韩解读
 //1. exit(0) 表示程序退出
 //2. 0 表示一个状态 , 正常的状态
 System.exit(0);//
 System.out.println(&quot;ok2&quot;);
 //currentTimeMillens:返回当前时间距离 1970-1-1 的毫秒数
// 老韩解读:
System.out.println(System.currentTimeMillis());
//实现方法，调用 job 方法
//得到开始的时间
        long start = System.currentTimeMillis();
        job();
//得的结束的时间
        long end = System.currentTimeMillis();
        System.out.println(&quot;任务执行时间 &quot; + (end - start));</code></pre>

<p>arraycopy的翻前面的去看。</p>
<h2 id="BigInteger-和-BigDecimal-类"><a href="#BigInteger-和-BigDecimal-类" class="headerlink" title="BigInteger 和 BigDecimal 类"></a>BigInteger 和 BigDecimal 类</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804161408893.png" alt="image-20240804161408893"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804161509764.png" alt="image-20240804161509764"></p>
<p>使用方法都需要引入相关类。</p>
<pre><code class="hljs plaintext">import java.math.BigInteger;

//当我们编程中，需要处理很大的整数，long 不够用
//可以使用 BigInteger 的类来搞定
        BigInteger bigInteger = new BigInteger(&quot;23788888899999999999999999999&quot;);
        BigInteger bigInteger2 = new BigInteger(&quot;10099999999999999999999999999999999999999999999999999999999999999999999999999999999&quot;);
        System.out.println(bigInteger);
//老韩解读
//1. 在对 BigInteger 进行加减乘除的时候，需要使用对应的方法，不能直接进行 + - * /
//2. 可以创建一个 要操作的 BigInteger 然后进行相应操作
        BigInteger add = bigInteger.add(bigInteger2);
        System.out.println(add);//
        BigInteger subtract = bigInteger.subtract(bigInteger2);
        System.out.println(subtract);//减
        BigInteger multiply = bigInteger.multiply(bigInteger2);
        System.out.println(multiply);//乘
        BigInteger divide = bigInteger.divide(bigInteger2);
        System.out.println(divide);//除</code></pre>

<p><code>BigInteger add = bigInteger.add(bigInteger2);</code>代表的是bigInteger和bigInteger2相加，其它的类似。</p>
<p>BigDecimal类的方法调用和赋值与BigInteger类似。</p>
<pre><code class="hljs plaintext">import java.math.BigDecimal;</code></pre>

<p>需要注意的是除法。</p>
<pre><code class="hljs plaintext">//System.out.println(bigDecimal.divide(bigDecimal2));//可能抛出异常 ArithmeticException
//在调用 divide 方法时，指定精度即可. BigDecimal.ROUND_CEILING
//如果有无限循环小数，就会保留 分子 的精度
System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING));</code></pre>

<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804162504069.png" alt="image-20240804162504069"></p>
<pre><code class="hljs plaintext">import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class c &#123;
    public static void main(String[] args) throws ParseException &#123;  // 添加 throws ParseException
        //1. 获取当前系统时间
        //2. 这里的 Date 类是在 java.util 包
        //3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换
        Date d1 = new Date(); // 获取当前系统时间
		d1.getTime(); //返回的是一个 long 类型的值，表示自1970年1月1日00:00:00 UTC以来的毫秒数。
        System.out.println(&quot;当前日期=&quot; + d1);
        Date d2 = new Date(9234567); // 通过指定毫秒数得到时间
        System.out.println(&quot;d2=&quot; + d2); // 获取某个时间对应的毫秒数

        // 老韩解读
        //1. 创建 SimpleDateFormat 对象，可以指定相应的格式
        //2. 这里的格式使用的字母是规定好，不能乱写
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy 年 MM 月 dd 日 HH:mm:ss E&quot;);
        String format = sdf.format(d1); // format:将日期转换成指定格式的字符串
        System.out.println(&quot;当前日期=&quot; + format);

        // 老韩解读
        //1. 可以把一个格式化的 String 转成对应的 Date
        //2. 得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换
        //3. 在把 String -&gt; Date ， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常
        String s = &quot;2024 年 08 月 04 日 04:32:53 周日&quot;;
        Date parse = sdf.parse(s);
        System.out.println(&quot;parse=&quot; + sdf.format(parse));
    &#125;
&#125;</code></pre>

<p>如果想要将String转成对应的Date的话，需要引入<code>import java.text.ParseException;</code>，并且在主方法还需要抛出ParseException， <code>public static void main(String[] args) throws ParseException</code>，因为即使格式正确，但是<code>Date parse = sdf.parse(s);</code>这句在编译时仍会产生该异常，在主方法添加完后，如果格式不正确就会在运行时产生该异常，导致不能运行下去。</p>
<p><strong><code>date.getTime()</code></strong>:</p>
<ul>
<li><code>date.getTime()</code> 返回的是一个 <code>long</code> 类型的值，表示自1970年1月1日00:00:00 UTC以来的毫秒数。</li>
</ul>
<pre><code class="hljs plaintext">//1. 创建 SimpleDateFormat 对象，可以指定相应的格式
        //2. 这里的格式使用的字母是规定好，不能乱写
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy 年 MM 月 dd 日 HH:mm:ss E&quot;);</code></pre>

<p>格式不是固定的，字母是固定的，格式是自己编写的。</p>
<p>h代表12小时制，H代表24小时制，但输入时都需按照24小时制输入。</p>
<h3 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804165247557.png" alt="image-20240804165247557"></p>
<pre><code class="hljs plaintext">import java.util.Calendar;

public class c &#123;
    public static void main(String[] args)&#123;
        //1. Calendar 是一个抽象类， 并且构造器是 private
//2. 可以通过 getInstance() 来获取实例
//3. 提供大量的方法和字段提供给程序员
        //4. Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)
//5. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=&gt; Calendar.HOUR_OF_DAY
        Calendar c = Calendar.getInstance(); //创建日历类对象//比较简单，自由
        System.out.println(&quot;c=&quot; + c);
//2.获取日历对象的某个日历字段
        System.out.println(&quot;年：&quot; + c.get(Calendar.YEAR));
// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号
        System.out.println(&quot;月：&quot; + (c.get(Calendar.MONTH) + 1));
        System.out.println(&quot;日：&quot; + c.get(Calendar.DAY_OF_MONTH));
        System.out.println(&quot;小时：&quot; + c.get(Calendar.HOUR));
        System.out.println(&quot;分钟：&quot; + c.get(Calendar.MINUTE));
        System.out.println(&quot;秒：&quot; + c.get(Calendar.SECOND));
//Calender 没有专门的格式化方法，所以需要程序员自己来组合显示
        System.out.println(c.get(Calendar.YEAR) + &quot;-&quot; + (c.get(Calendar.MONTH) + 1) + &quot;-&quot; +
                c.get(Calendar.DAY_OF_MONTH) +
                &quot; &quot; + c.get(Calendar.HOUR_OF_DAY) + &quot;:&quot; + c.get(Calendar.MINUTE) + &quot;:&quot; + c.get(Calendar.SECOND) );
    &#125;
&#125;</code></pre>

<h3 id="第三代日期类（感觉比较好用）"><a href="#第三代日期类（感觉比较好用）" class="headerlink" title="第三代日期类（感觉比较好用）"></a>第三代日期类（感觉比较好用）</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804175601112.png" alt="image-20240804175601112"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804175615009.png" alt="image-20240804175615009"></p>
<pre><code class="hljs plaintext">import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

public class c &#123;
    public static void main(String[] args)&#123;
        //1. 使用 now() 返回表示当前日期时间的 对象
        LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()
        System.out.println(ldt);
//2. 使用 DateTimeFormatter 对象来进行格式化
// 创建 DateTimeFormatter 对象
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String format = dateTimeFormatter.format(ldt);
        System.out.println(&quot;格式化的日期=&quot; + format);
        System.out.println(&quot;年=&quot; + ldt.getYear());
        System.out.println(&quot;月=&quot; + ldt.getMonth());
        System.out.println(&quot;月=&quot; + ldt.getMonthValue());
        System.out.println(&quot;日=&quot; + ldt.getDayOfMonth());
        System.out.println(&quot;时=&quot; + ldt.getHour());
        System.out.println(&quot;分=&quot; + ldt.getMinute());
        System.out.println(&quot;秒=&quot; + ldt.getSecond());
        LocalDate now = LocalDate.now(); //可以获取年月日
        LocalTime now2 = LocalTime.now();//获取到时分秒
//提供 plus 和 minus 方法可以对当前时间进行加或者减
//看看 890 天后，是什么时候 把 年月日-时分秒
        LocalDateTime localDateTime = ldt.plusDays(890);
        System.out.println(&quot;890 天后=&quot; + dateTimeFormatter.format(localDateTime));
//看看在 3456 分钟前是什么时候，把 年月日-时分秒输出
        LocalDateTime localDateTime2 = ldt.minusMinutes(3456);
        System.out.println(&quot;3456 分钟前 日期=&quot; + dateTimeFormatter.format(localDateTime2));
    &#125;
&#125;</code></pre>

<p>plusDays，minusMinutes应该就是plus和minus后面加时间表示后面括号里的数字代表什么。</p>
<h3 id="DateTimeFormatter-格式日期类"><a href="#DateTimeFormatter-格式日期类" class="headerlink" title="DateTimeFormatter 格式日期类"></a>DateTimeFormatter 格式日期类</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804180459515.png" alt="image-20240804180459515"></p>
<p>SimpleDateFormate用于第一代日期类。</p>
<h3 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804200138404.png" alt="image-20240804200138404"></p>
<p>表示的是格林威治时间。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805113308968.png" alt="image-20240805113308968"></p>
<h2 id="集合的框架体系"><a href="#集合的框架体系" class="headerlink" title="集合的框架体系"></a>集合的框架体系</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805113551076.png" alt="image-20240805113551076"></p>
<p>迭代器（Iterable）：是所有集合的基础，定义了遍历集合元素的方法。</p>
<p>集合（Collection）：是Java集合框架的根接口，提供了基本的集合操作，如添加、删除和检查元素。</p>
<p>列表（List）：是Collection的子接口，支持元素的随机访问，并允许在列表中插入和删除元素。</p>
<p>向量（Vector）：是List的一个实现，提供了线程安全的操作，但性能上可能不如ArrayList。</p>
<p>数组列表（ArrayList）：是List的另一个实现，使用动态数组来存储元素，提供了快速访问和修改的功能。</p>
<p>链表（LinkedList）：也是List的一个实现，使用链表结构存储元素，适用于频繁的插入和删除操作。</p>
<p>树集（TreeSet）：是基于红黑树实现的Set接口，它确保集合元素处于排序状态，不允许重复元素。</p>
<p>哈希集（HashSet）：是Set接口的另一个实现，不保证集合的迭代顺序，且允许null元素的存在。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805113556309.png" alt="image-20240805113556309"></p>
<p>Map：是Java中最基础的数据结构之一，提供了键值对的存储方式。</p>
<p>HashMap：是Map接口的一个常用实现，通过哈希表来存储键值对，提供了较快的访问速度。</p>
<p>TreeMap：是Map接口的另一种实现，它使用红黑树来存储键值对，可以确保元素按照键的顺序进行排序。</p>
<p>Hashtable：是Java早期版本中提供的一个线程安全的哈希表实现，但因其性能较低，在现代Java开发中较少使用。</p>
<p>LinkedHashMap：保留了插入顺序的HashMap实现，它维护了一个双向链表来记录元素的插入顺序。</p>
<p>Properties：是Java标准库中的一个类，用于处理键值对，通常用于配置文件或作为字典使用。</p>
<pre><code class="hljs plaintext">1. 集合主要是两组(单列集合 , 双列集合)
2. Collection 接口有两个重要的子接口 List，Set , 他们的实现子类都是单列集合
3. Map 接口的实现子类 是双列集合，存放的 K-V</code></pre>

<pre><code class="hljs plaintext">import java.util.ArrayList;
import java.util.HashMap;

public class c &#123;
    public static void main(String[] args)&#123;
        ArrayList arrayList = new ArrayList();
        arrayList.add(&quot;jack&quot;);
        arrayList.add(&quot;tom&quot;);
        HashMap hashMap = new HashMap();
        hashMap.put(&quot;NO1&quot;, &quot;北京&quot;);
        hashMap.put(&quot;NO2&quot;, &quot;上海&quot;);
    &#125;
&#125;</code></pre>

<h2 id="Collection-接口和常用方法"><a href="#Collection-接口和常用方法" class="headerlink" title="Collection 接口和常用方法"></a>Collection 接口和常用方法</h2><h3 id="Collection-接口实现类的特点"><a href="#Collection-接口实现类的特点" class="headerlink" title="Collection 接口实现类的特点"></a>Collection 接口实现类的特点</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805153109897.png" alt="image-20240805153109897"></p>
<p>Collection 接口常用方法,以实现子类 ArrayList 来演示</p>
<pre><code class="hljs plaintext">import java.util.ArrayList;
import java.util.List;

public class c &#123;
    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)
    public static void main(String[] args)&#123;
        List list = new ArrayList();
// add:添加单个元素
        list.add(&quot;jack&quot;);
        list.add(10);//list.add(new Integer(10))
        list.add(true);
        System.out.println(&quot;list=&quot; + list);
// remove:删除指定元素，并返回该元素
//list.remove(0);//删除第一个元素
        list.remove(true);//指定删除某个元素
        System.out.println(&quot;list=&quot; + list);
// contains:查找元素是否存在
        System.out.println(list.contains(&quot;jack&quot;));//T
// size:获取元素个数
        System.out.println(list.size());//2
// isEmpty:判断是否为空
        System.out.println(list.isEmpty());//F
// clear:清空
        list.clear();
        System.out.println(&quot;list=&quot; + list);
// addAll:添加多个元素
        ArrayList list2 = new ArrayList();
        list2.add(&quot;红楼梦&quot;);
        list2.add(&quot;三国演义&quot;);
        list.addAll(list2);//list.addAll(&quot;红楼梦&quot;,&quot;三国演义&quot;)，这样是错的
        System.out.println(&quot;list=&quot; + list);
// containsAll:查找多个元素是否都存在
        System.out.println(list.containsAll(list2));//T
// removeAll：删除多个元素
        list.add(&quot;聊斋&quot;);
        list.removeAll(list2);
        System.out.println(&quot;list=&quot; + list);//[聊斋]
// 说明：以 ArrayList 实现类来演示.
    &#125;
&#125;</code></pre>

<p>remove:删除指定元素后数组列表里的元素会自动填补空缺。</p>
<p>remove括号里面加的是索引的话（索引&gt;内容，如果存储1的话，那么remove(1)删除的是序列为1的元素而不是1），会返回一个Object型的该索引对应的数据，但如果后面加的是对象的话就不会返回。</p>
<p>原文里面用<code>@SuppressWarnings(&#123;&quot;all&quot;&#125;)</code>抑制全部警告，我感觉这样不好，所以就一个个抑制没什么大问题的警报，<code>@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</code>，这两个是由List以及相关方法引起的（也适用于下面的内容，Set、Map），与语法对错无关。</p>
<h3 id="Collection-接口遍历元素方式"><a href="#Collection-接口遍历元素方式" class="headerlink" title="Collection 接口遍历元素方式"></a>Collection 接口遍历元素方式</h3><h4 id="使用-Iterator-迭代器"><a href="#使用-Iterator-迭代器" class="headerlink" title="使用 Iterator(迭代器)"></a>使用 Iterator(迭代器)</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805160915142.png" alt="image-20240805160915142"></p>
<p>Collection的子接口例如List等也都可以使用迭代器。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805160927232.png" alt="image-20240805160927232"></p>
<p>coll是Collection的一个对象。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805160957407.png" alt="image-20240805160957407"></p>
<pre><code class="hljs plaintext">import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        Collection col = new ArrayList();
        col.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1));
        col.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1));
        col.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6));
//System.out.println(&quot;col=&quot; + col);
//现在老师希望能够遍历 col 集合
//1. 先得到 col 对应的 迭代器
        Iterator iterator = col.iterator();
//2. 使用 while 循环遍历
// while (iterator.hasNext()) &#123;//判断是否还有数据
// //返回下一个元素，类型是 Object
// Object obj = iterator.next();
// System.out.println(&quot;obj=&quot; + obj);
// &#125;
//老师教大家一个快捷键，快速生成 while =&gt; itit
//显示所有的快捷键的的快捷键 ctrl + j
        while (iterator.hasNext()) &#123;
            Object obj = iterator.next();
            System.out.println(&quot;obj=&quot; + obj);
        &#125;
//3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素
// iterator.next();//NoSuchElementException
//4. 如果希望再次遍历，需要重置我们的迭代器
        iterator = col.iterator();
        System.out.println(&quot;===第二次遍历===&quot;);
        while (iterator.hasNext()) &#123;
            Object obj = iterator.next();
            System.out.println(&quot;obj=&quot; + obj);
        &#125;
    &#125;
&#125;
class Book &#123;
    private String name;
    private String author;
    private double price;
    public Book(String name, String author, double price) &#123;
        this.name = name;
        this.author = author;
        this.price = price;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Book&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, author=&#x27;&quot; + author + &#x27;\&#x27;&#x27; +
                &quot;, price=&quot; + price +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p><code>System.out.println(&quot;col=&quot; + col);</code>仍然可以一次性输出col的内容。</p>
<h4 id="for-循环增强"><a href="#for-循环增强" class="headerlink" title="for 循环增强"></a>for 循环增强</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805161907452.png" alt="image-20240805161907452"></p>
<pre><code class="hljs plaintext">List list = new ArrayList();
list.add(new Dog(&quot;小黑&quot;, 3));
list.add(new Dog(&quot;大黄&quot;, 100));
list.add(new Dog(&quot;大壮&quot;, 8));
//先使用 for 增强
for (Object dog : list) &#123;
	System.out.println(&quot;dog=&quot; + dog);
&#125;
//使用迭代器
System.out.println(&quot;===使用迭代器来遍历===&quot;);
Iterator iterator = list.iterator();</code></pre>

<p><code>for (Object dog : list)</code>这个for语句里的对象类型必须是Object。因为元素在存入list中的时候会转化为Object类型。</p>
<h2 id="List-接口和常用方法"><a href="#List-接口和常用方法" class="headerlink" title="List 接口和常用方法"></a>List 接口和常用方法</h2><h3 id="介绍和常用方法"><a href="#介绍和常用方法" class="headerlink" title="介绍和常用方法"></a>介绍和常用方法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805165417212.png" alt="image-20240805165417212"></p>
<p>索引是从 0 开始的。</p>
<pre><code class="hljs plaintext">import java.util.ArrayList;
import java.util.List;
public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        List list = new ArrayList();
        list.add(&quot;张三丰&quot;);
        list.add(&quot;贾宝玉&quot;);
        // void add(int index, Object ele):在 index 位置插入 ele 元素
//在 index = 1 的位置插入一个对象
        list.add(1, &quot;韩顺平&quot;);
        System.out.println(&quot;list=&quot; + list);
        // boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来
        List list2 = new ArrayList();
        list2.add(&quot;jack&quot;);
        list2.add(&quot;tom&quot;);
        list.addAll(1, list2);
        System.out.println(&quot;list=&quot; + list);
// Object get(int index):获取指定 index 位置的元素
//说过
// int indexOf(Object obj):返回 obj 在集合中首次出现的位置
        System.out.println(list.indexOf(&quot;tom&quot;));//2
// int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置
        list.add(&quot;韩顺平&quot;);
        System.out.println(&quot;list=&quot; + list);
        System.out.println(list.lastIndexOf(&quot;韩顺平&quot;));
// Object remove(int index):移除指定 index 位置的元素，并返回此元素
        list.remove(0);
        System.out.println(&quot;list=&quot; + list);
// Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换. list.set(1, &quot;玛丽&quot;);
        System.out.println(&quot;list=&quot; + list);
// List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合
// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex
        List returnlist = list.subList(0, 2);
        System.out.println(&quot;returnlist=&quot; + returnlist);
    &#125;
&#125;</code></pre>

<p><code>void add(int index, Object ele):在 index 位置插入 ele 元素</code>原索引位置的元素依次后移。</p>
<p><code>list.getLast()</code>：取最后一个元素。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240823223412800.png" alt="image-20240823223412800"></p>
<h3 id="List-的三种遍历方式"><a href="#List-的三种遍历方式" class="headerlink" title="List 的三种遍历方式"></a>List 的三种遍历方式</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805170327199.png" alt="image-20240805170327199"></p>
<pre><code class="hljs plaintext">使用普通 for
for (int i = 0; i &lt; list.size(); i++) &#123;	
	System.out.println(&quot;对象=&quot; + list.get(i));
&#125;</code></pre>

<h2 id="ArrayList-底层结构和源码分析"><a href="#ArrayList-底层结构和源码分析" class="headerlink" title="ArrayList 底层结构和源码分析"></a>ArrayList 底层结构和源码分析</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805171457469.png" alt="image-20240805171457469"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805171512437.png" alt="image-20240805171512437"></p>
<p>指定大小：List list &#x3D; new ArrayList(5);</p>
<p>想看源码去pdf里面看。</p>
<h2 id="Vector-底层结构和源码剖析"><a href="#Vector-底层结构和源码剖析" class="headerlink" title="Vector 底层结构和源码剖析"></a>Vector 底层结构和源码剖析</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805193045404.png" alt="image-20240805193045404"></p>
<p>想看源码自己去pdf里面看。</p>
<p>Vector 和 ArrayList 的比较</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805193215719.png" alt="image-20240805193215719"></p>
<h2 id="LinkedList-底层结构"><a href="#LinkedList-底层结构" class="headerlink" title="LinkedList 底层结构"></a>LinkedList 底层结构</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805193504840.png" alt="image-20240805193504840"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805193519644.png" alt="image-20240805193519644"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805194122247.png" alt="image-20240805194122247"></p>
<h2 id="Set-接口和常用方法"><a href="#Set-接口和常用方法" class="headerlink" title="Set 接口和常用方法"></a>Set 接口和常用方法</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806103202514.png" alt="image-20240806103202514"></p>
<p>和 List 接口一样, Set 接口也是 Collection 的子接口，因此，常用方法和 Collection 接口一样。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806103231006.png" alt="image-20240806103231006"></p>
<h2 id="Set-接口实现类"><a href="#Set-接口实现类" class="headerlink" title="Set 接口实现类"></a>Set 接口实现类</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><h4 id="基础-7"><a href="#基础-7" class="headerlink" title="基础"></a>基础</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806103343391.png" alt="image-20240806103343391"></p>
<p>可以连续存放相同的值，程序不会报错，但最后只会存储第一个值，就是只存储一个。</p>
<h4 id="底层机制-存储自定义类时的注意事项"><a href="#底层机制-存储自定义类时的注意事项" class="headerlink" title="底层机制+存储自定义类时的注意事项"></a>底层机制+存储自定义类时的注意事项</h4><p>想看源码去pdf。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806112731405.png" alt="image-20240806112731405"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806112707254.png" alt="image-20240806112707254"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806112715287.png" alt="image-20240806112715287"></p>
<p>哈希值一样后根据equals方法判断内容是否相同，因此要注意存储的对象类型是否有覆盖equals方法，若没有则按Object类的equals方法来，即比较两个对象的引用（内存地址）是否相同。</p>
<pre><code class="hljs plaintext">import java.util.HashSet;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        HashSet set = new HashSet();
        //说明
//1. 在执行 add 方法后，会返回一个 boolean 值
//2. 如果添加成功，返回 true, 否则返回 false
//3. 可以通过 remove 指定删除哪个对象
        System.out.println(set.add(&quot;john&quot;));//T
        System.out.println(set.add(&quot;lucy&quot;));//T
        System.out.println(set.add(&quot;john&quot;));//F
        System.out.println(set.add(&quot;jack&quot;));//T
        System.out.println(set.add(&quot;Rose&quot;));//T
        set.remove(&quot;john&quot;);
        System.out.println(&quot;set=&quot; + set);//3 个
//
        set = new HashSet();
        System.out.println(&quot;set=&quot; + set);//0
//4 Hashset 不能添加相同的元素/数据?
        set.add(&quot;lucy&quot;);//添加成功
        set.add(&quot;lucy&quot;);//加入不了
        set.add(new Dog(&quot;tom&quot;));//OK
        set.add(new Dog(&quot;tom&quot;));//Ok
        System.out.println(&quot;set=&quot; + set);
//在加深一下. 非常经典的面试题.
        //看源码，做分析， 先给小伙伴留一个坑，以后讲完源码，你就了然
//去看他的源码，即 add 到底发生了什么?=&gt; 底层机制.
        set.add(new String(&quot;hsp&quot;));//ok
        set.add(new String(&quot;hsp&quot;));//加入不了.
        System.out.println(&quot;set=&quot; + set);
    &#125;
&#125;
class Dog &#123; //定义了 Dog 类
    private String name;
    public Dog(String name) &#123;
        this.name = name;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Dog&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p>在Java中，<code>HashSet</code>是基于哈希表实现的集合，它确保集合中的元素是唯一的，即不能添加相同的元素（根据元素的<code>equals()</code>和<code>hashCode()</code>方法判断）。</p>
<p>然而，在示例中，<code>Dog</code>类没有覆盖<code>equals()</code>和<code>hashCode()</code>方法。因此，默认情况下，<code>HashSet</code>会使用<code>Object</code>类中的<code>equals()</code>和<code>hashCode()</code>方法来比较对象的引用是否相等。<code>HashSet</code>使用默认的<code>Object</code>类的实现，这将比较对象的引用（内存地址）。在Java中，对象的引用不同即使其内容相同，也会被视为不同的对象。</p>
<p>具体到代码，当添加两个相同名称的<code>Dog</code>对象时，例如<code>new Dog(&quot;tom&quot;)</code>，由于每次使用<code>new</code>关键字创建一个新的对象实例，这两个对象的引用是不同的。即使它们的内容相同，它们在内存中的地址也不同。</p>
<p>因此，<code>HashSet</code>会将这两个对象视为不同的元素，并将它们都添加到集合中。</p>
<p>在Java中，<code>String</code>类覆盖了<code>equals()</code>和<code>hashCode()</code>方法，String类的hashCode方法是根据字符串的内容来计算哈希值的。这意味着两个内容相同的<code>String</code>对象会被认为是相等的，并且它们的哈希码也相同。因此，当你尝试将两个内容相同的<code>String</code>对象添加到<code>HashSet</code>中时，第二个<code>String</code>对象不会被添加，因为<code>HashSet</code>检测到集合中已经存在一个相同的元素。</p>
<p>如果希望<code>HashSet</code>根据对象的内容（比如<code>Dog</code>对象的名称）来判断是否相等，则需要在<code>Dog</code>类中覆盖<code>equals()</code>和<code>hashCode()</code>方法。例如，可以根据<code>name</code>属性来实现这两个方法，这样相同名称的<code>Dog</code>对象就会被视为相等，不能重复添加到<code>HashSet</code>中。</p>
<pre><code class="hljs plaintext">class Dog &#123;
    private String name;

    public Dog(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Dog dog = (Dog) o;
        return Objects.equals(name, dog.name);
    &#125;

    @Override
    public int hashCode() &#123;
        return Objects.hash(name);
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Dog&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p>为什么没有重写hashCode方法还是会存储两个相同的Dog对象。</p>
<p>在这种情况下，即使两个<code>Dog</code>对象的<code>name</code>属性相同，它们的哈希码仍然是基于<code>Object</code>类的<code>hashCode()</code>方法，该方法返回对象的内存地址。因此，两个相同<code>name</code>的<code>Dog</code>对象会有不同的哈希码，被存储在不同的哈希桶中。而HashSet的存储机制是当俩个哈希码相同的时候才会调用equals方法进行判断，若两个对象的哈希码都不同则存储在两个不同的地方，不会调用equals。</p>
<p><code>Objects.equals(Object a, Object b)</code>方法会执行以下操作：</p>
<ol>
<li><p>如果<code>a</code>和<code>b</code>都是<code>null</code>，返回<code>true</code>。</p>
</li>
<li><p>如果只有一个是<code>null</code>，返回<code>false</code>。</p>
</li>
<li><p>否则，返回<code>a.equals(b)</code>的结果。</p>
<p>使用equals还避免了<code>name</code>字段为<code>null</code>时的空指针异常。</p>
</li>
</ol>
<p>若自定义类有两个属性，两个属性都相同则为同一对象，如下覆盖，其余类似</p>
<pre><code class="hljs plaintext">@Override
public boolean equals(Object o) &#123;
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Employee employee = (Employee) o;
    return age == employee.age &amp;&amp;
    Objects.equals(name, employee.name);
&#125;
@Override
public int hashCode() &#123;
	return Objects.hash(name, age);
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806113412779.png" alt="image-20240806113412779"></p>
<h3 id="LinkedHashSet-double类的compare"><a href="#LinkedHashSet-double类的compare" class="headerlink" title="LinkedHashSet+double类的compare	"></a>LinkedHashSet+double类的compare	<img src="/../source/imgs/$%7Bfiilname%7D/image-20240806154342854.png" alt="image-20240806154342854"></h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806154547157.png" alt="image-20240806154547157"></p>
<p><code>Double</code>类中的<code>compare</code>方法用于比较两个<code>double</code>值。它返回一个整数，指示第一个<code>double</code>值是等于、少于还是大于第二个<code>double</code>值。这种方法可以避免浮点数直接比较时可能出现的误差问题。</p>
<pre><code class="hljs plaintext">Double.compare(double d1, double d2)</code></pre>

<p>返回值：</p>
<ul>
<li>如果<code>d1</code>等于<code>d2</code>，返回<code>0</code>。</li>
<li>如果<code>d1</code>小于<code>d2</code>，返回一个负数。</li>
<li>如果<code>d1</code>大于<code>d2</code>，返回一个正数。</li>
</ul>
<h2 id="Map-接口和常用方法"><a href="#Map-接口和常用方法" class="headerlink" title="Map 接口和常用方法"></a>Map 接口和常用方法</h2><h3 id="基础-8"><a href="#基础-8" class="headerlink" title="基础"></a>基础</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806201214488.png" alt="image-20240806201214488"></p>
<p>当有相同的 k , 就等价于替换。</p>
<pre><code class="hljs plaintext">import java.util.HashMap;
import java.util.Map;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        Map map = new HashMap();
        map.put(&quot;no1&quot;, &quot;韩顺平&quot;);//k-v
        map.put(&quot;no2&quot;, &quot;张无忌&quot;);//k-v
        map.put(&quot;no1&quot;, &quot;张三丰&quot;);//当有相同的 k , 就等价于替换. 
        map.put(&quot;no3&quot;, &quot;张三丰&quot;);//k-v
        map.put(null, null); //k-v
        map.put(null, &quot;abc&quot;); //等价替换
        map.put(&quot;no4&quot;, null); //k-v
        map.put(&quot;no5&quot;, null); //k-v
        map.put(1, &quot;赵敏&quot;);//k-v
        map.put(new Object(), &quot;金毛狮王&quot;);//k-v
// 通过 get 方法，传入 key ,会返回对应的 value
        System.out.println(map.get(&quot;no2&quot;));//张无忌
        System.out.println(&quot;map=&quot; + map);
    &#125;
&#125;</code></pre>

<h3 id="Map-接口常用方法"><a href="#Map-接口常用方法" class="headerlink" title="Map 接口常用方法"></a>Map 接口常用方法</h3><pre><code class="hljs plaintext">import java.util.HashMap;
import java.util.Map;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        Map map = new HashMap();
        map.put(&quot;邓超&quot;, new Book(&quot;&quot;, 100));//OK
        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);//替换-&gt; 一会分析源码
        map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);//OK
        map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);//OK
        map.put(&quot;刘令博&quot;, null);//OK
        map.put(null, &quot;刘亦菲&quot;);//OK
        map.put(&quot;鹿晗&quot;, &quot;关晓彤&quot;);//OK
        map.put(&quot;hsp&quot;, &quot;hsp 的老婆&quot;);
        System.out.println(&quot;map=&quot; + map);
// remove:根据键删除映射关系
        map.remove(null);
        System.out.println(&quot;map=&quot; + map);
// get：根据键获取值
        Object val = map.get(&quot;鹿晗&quot;);
        System.out.println(&quot;val=&quot; + val);
// size:获取元素个数
        System.out.println(&quot;k-v=&quot; + map.size());
// isEmpty:判断个数是否为 0
        System.out.println(map.isEmpty());//F
// clear:清除 k-v
//map.clear();
        System.out.println(&quot;map=&quot; + map);
// containsKey:查找键是否存在
        System.out.println(&quot;结果=&quot; + map.containsKey(&quot;hsp&quot;));//T
    &#125;
&#125;
class Book &#123;
    private String name;
    private int num;
    public Book(String name, int num) &#123;
        this.name = name;
        this.num = num;
    &#125;
&#125;</code></pre>

<p>遍历方法：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806204935015.png" alt="image-20240806204935015"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806204948094.png" alt="image-20240806204948094"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806203631348.png" alt="image-20240806203631348"></p>
<pre><code class="hljs plaintext">import java.util.*;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        Map map = new HashMap();
        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);
        map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);
        map.put(&quot;刘令博&quot;, null);
        map.put(null, &quot;刘亦菲&quot;);
        map.put(&quot;鹿晗&quot;, &quot;关晓彤&quot;);
//第一组: 先取出 所有的 Key , 通过 Key 取出对应的 Value
        Set keyset = map.keySet();
//(1) 增强 for
        System.out.println(&quot;-----第一种方式-------&quot;);
        for (Object key : keyset) &#123;
            System.out.println(key + &quot;-&quot; + map.get(key));
        &#125;
//(2) 迭代器
        System.out.println(&quot;----第二种方式--------&quot;);
        Iterator iterator = keyset.iterator();
        while (iterator.hasNext()) &#123;
            Object key = iterator.next();
            System.out.println(key + &quot;-&quot; + map.get(key));
        &#125;
//第二组: 把所有的 values 取出
        Collection values = map.values();
//这里可以使用所有的 Collections 使用的遍历方法
//(1) 增强 for
        System.out.println(&quot;---取出所有的 value 增强 for----&quot;);
        for (Object value : values) &#123;
            System.out.println(value);
        &#125;
//(2) 迭代器
        System.out.println(&quot;---取出所有的 value 迭代器----&quot;);
        Iterator iterator2 = values.iterator();
        while (iterator2.hasNext()) &#123;
            Object value = iterator2.next();
            System.out.println(value);
        &#125;
//第三组: 通过 entrySet 来获取 k-v
        Set entrySet = map.entrySet();// entrySet&lt;Map.Entry&lt;K,V&gt;&gt;
//(1) 增强 for
        System.out.println(&quot;----使用 EntrySet 的 for 增强(第 3 种)----&quot;);
        for (Object entry : entrySet) &#123;
//将 entry 转成 Map.Entry
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + &quot;-&quot; + m.getValue());
        &#125;
//(2) 迭代器
        System.out.println(&quot;----使用 EntrySet 的 迭代器(第 4 种)----&quot;);
        Iterator iterator3 = entrySet.iterator();
        while (iterator3.hasNext()) &#123;
            Object entry = iterator3.next();
//System.out.println(next.getClass());//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)
//向下转型 Map.Entry
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + &quot;-&quot; + m.getValue());
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="Map-接口实现类"><a href="#Map-接口实现类" class="headerlink" title="Map 接口实现类"></a>Map 接口实现类</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808110338660.png" alt="image-20240808110338660"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808110429658.png" alt="image-20240808110429658"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808110554802.png" alt="image-20240808110554802"></p>
<p>源码看pdf</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808110724566.png" alt="image-20240808110724566"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808110754123.png" alt="image-20240808110754123"></p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808111227573.png" alt="image-20240808111227573"></p>
<p>key和value也不能为null。</p>
<p>没教第3、4点。</p>
<h2 id="开发中如何选择集合实现类"><a href="#开发中如何选择集合实现类" class="headerlink" title="开发中如何选择集合实现类"></a>开发中如何选择集合实现类</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808111527052.png" alt="image-20240808111527052"></p>
<p><strong>TreeSet</strong></p>
<pre><code class="hljs plaintext">import java.util.Comparator;
import java.util.TreeSet;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        //1. 当我们使用无参构造器，创建 TreeSet 时，仍然是无序的
        //2. 老师希望添加的元素，按照字符串大小来排序
        //3. 使用 TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)
        // 并指定排序规则
        //4. 简单看看源码
        //老韩解读
        /*
        1. 构造器把传入的比较器对象，赋给了 TreeSet 的底层的 TreeMap 的属性 this.comparator
        public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;
            this.comparator = comparator;
        &#125;
        2. 在 调用 treeSet.add(&quot;tom&quot;), 在底层会执行到
        if (cpr != null) &#123;//cpr 就是我们的匿名内部类(对象)
        do &#123;
             parent = t;
            //动态绑定到我们的匿名内部类(对象)compare
            cmp = cpr.compare(key, t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else //如果相等，即返回 0,这个 Key 就没有加入
                return t.setValue(value);
            &#125; while (t != null);    
        &#125;
        */
        // TreeSet treeSet = new TreeSet();
        TreeSet treeSet = new TreeSet(new Comparator() &#123;
            @Override
            public int compare(Object o1, Object o2) &#123;
//下面 调用 String 的 compareTo 方法进行字符串大小比较
//如果老韩要求加入的元素，按照长度大小排序
//return ((String) o2).compareTo((String) o1);
                return ((String) o1).length() - ((String) o2).length();
            &#125;
        &#125;);
//添加数据.
        treeSet.add(&quot;jack&quot;);
        treeSet.add(&quot;tom&quot;);//3
        treeSet.add(&quot;sp&quot;);
        treeSet.add(&quot;a&quot;);
        treeSet.add(&quot;abc&quot;);//3
        System.out.println(&quot;treeSet=&quot; + treeSet);
    &#125;
&#125;</code></pre>

<p>根据源码，当想加入的两个对象有compare判断返回0时就只会添加第一个。例子里的”tom”和”abc”就只添加了”tom”。</p>
<p>如果只是<code>TreeSet treeSet = new TreeSet();</code>就是没有添加Comparator的时候，是按自然顺序排列的。</p>
<p><strong>TreeMap</strong></p>
<p>道理和TreeSet一样。</p>
<h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808153830100.png" alt="image-20240808153830100"></p>
<h3 id="排序操作-Collections里的static方法"><a href="#排序操作-Collections里的static方法" class="headerlink" title="排序操作(Collections里的static方法)"></a>排序操作(Collections里的static方法)</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808154056938.png" alt="image-20240808154056938"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808154617956.png" alt="image-20240808154617956"></p>
<pre><code class="hljs plaintext">import java.util.*;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        //创建 ArrayList 集合，用于测试.
        List list = new ArrayList();
        list.add(&quot;tom&quot;);
        list.add(&quot;smith&quot;);
        list.add(&quot;king&quot;);
        list.add(&quot;milan&quot;);
        list.add(&quot;tom&quot;);
// reverse(List)：反转 List 中元素的顺序
        Collections.reverse(list);
        System.out.println(&quot;list=&quot; + list);
// shuffle(List)：对 List 集合元素进行随机排序
// for (int i = 0; i &lt; 5; i++) &#123;
// Collections.shuffle(list);
// System.out.println(&quot;list=&quot; + list);
// &#125;
// sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序
        Collections.sort(list);
        System.out.println(&quot;自然排序后&quot;);
        System.out.println(&quot;list=&quot; + list);
// sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
//我们希望按照 字符串的长度大小排序
        Collections.sort(list, new Comparator() &#123;
            @Override
            public int compare(Object o1, Object o2) &#123;
//可以加入校验代码.
                return ((String) o2).length() - ((String) o1).length();//注意是o2-o1
            &#125;
        &#125;);
        System.out.println(&quot;字符串长度大小排序=&quot; + list);//从长到短排
// swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换
//比如
        Collections.swap(list, 0, 1);
        System.out.println(&quot;交换后的情况&quot;);
        System.out.println(&quot;list=&quot; + list);
//Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
        System.out.println(&quot;自然顺序最大元素=&quot; + Collections.max(list));
//Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素
//比如，我们要返回长度最大的元素
        Object maxObject = Collections.max(list, new Comparator() &#123;
            @Override
            public int compare(Object o1, Object o2) &#123;
                return ((String)o1).length() - ((String)o2).length();
            &#125;//看源码得知应该是如果compare(o1,o2)&gt;0,则等于o1
        &#125;);
        System.out.println(&quot;长度最大的元素=&quot; + maxObject);
//Object min(Collection)
//Object min(Collection，Comparator)
//上面的两个方法，参考 max 即可
//int frequency(Collection，Object)：返回指定集合中指定元素的出现次数
        System.out.println(&quot;tom 出现的次数=&quot; + Collections.frequency(list, &quot;tom&quot;));
//void copy(List dest,List src)：将 src 中的内容复制到 dest 中
        ArrayList dest = new ArrayList();
//为了完成一个完整拷贝，我们需要先给 dest 赋值，大小和 list.size()一样
        for(int i = 0; i &lt; list.size(); i++) &#123;
            dest.add(&quot;&quot;);
        &#125;
//拷贝
        Collections.copy(dest, list);
        System.out.println(&quot;dest=&quot; + dest);
//boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值
//如果 list 中，有 tom 就替换成 汤姆
        Collections.replaceAll(list, &quot;tom&quot;, &quot;汤姆&quot;);
        System.out.println(&quot;list 替换后=&quot; + list);
    &#125;
&#125;</code></pre>

<p>自然排序是一种默认的对象排序方式，它是根据对象的内在特征或属性来排序的，通常是按升序。例如，对于整数，自然排序是按照数字的大小进行排序；对于字符串，自然排序是按照字母的字典顺序进行排序。自然排序通常是最直观和常见的排序方式，它使得对象在集合中以一种有序的方式存储和检索。</p>
<p>在 Java 中，自然排序是通过 Comparable 接口来实现的。这个接口定义了一个 compareTo 方法，允许对象自己来决定如何与其他对象进行比较。对于自定义类型，需要确保该类实现了Comparable接口，并重写compareTo方法来定义自然顺序（例子在下面）。</p>
<pre><code class="hljs plaintext">import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
//从大到小排序
public class Main &#123;
    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        Customer customer1 = new Customer(&quot;小明&quot;,scanner.nextInt());
        Customer customer2 = new Customer(&quot;小军&quot;,scanner.nextInt());
        Customer customer3 = new Customer(&quot;小红&quot;,scanner.nextInt());
        List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();
        customers.add(customer1);
        customers.add(customer2);
        customers.add(customer3);
        Collections.sort(customers);
        System.out.println(customers);
    &#125;
&#125;

class Customer implements Comparable&lt;Customer&gt;&#123;
    private String name;
    private int consumption;
    public Customer(String name, int consumption) &#123;
        this.name = name;
        this.consumption = consumption;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Customer&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, consumption=&quot; + consumption +
                &#x27;&#125;&#x27;;
    &#125;
    public int compareTo(Customer customer) &#123;
        return customer.consumption - this.consumption;
    &#125;
&#125;</code></pre>

<p><strong>frequency:</strong></p>
<pre><code class="hljs plaintext">import java.util.*;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        String sentence = &quot;Asenal.North London Forever!We are champion.We want more.&quot;;
        String[] split = sentence.split(&quot;[ .!]&quot;);
        List list = Arrays.asList(split);
        Map map = new HashMap();
        for(Object object : list)&#123;
            map.put(object,Collections.frequency(list,object));
        &#125;
        System.out.println(map);
    &#125;
&#125;</code></pre>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="引入-3"><a href="#引入-3" class="headerlink" title="引入"></a>引入</h2><pre><code class="hljs plaintext">/*
请编写程序，在 ArrayList 中，添加 3 个 Dog 对象
Dog 对象含有 name 和 age, 并输出 name 和 age (要求使用 getXxx())
*/
//使用传统的方法来解决
ArrayList arrayList = new ArrayList();
arrayList.add(new Dog(&quot;旺财&quot;, 10));
arrayList.add(new Dog(&quot;发财&quot;, 1));
arrayList.add(new Dog(&quot;小黄&quot;, 5));
//假如我们的程序员，不小心，添加了一只猫
arrayList.add(new Cat(&quot;招财猫&quot;, 8));
//遍历
for (Object o : arrayList) &#123;
//向下转型 Object -&gt;Dog
Dog dog = (Dog) o;
System.out.println(dog.getName() + &quot;-&quot; + dog.getAge());
&#125;</code></pre>

<p>可以发现无论是猫还是狗都可以存入arrayList中，并且程序在编译阶段不会出错，但是在运行阶段会出错。</p>
<p>分析使用传统方法解决问题：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809110141506.png" alt="image-20240809110141506"></p>
<p>使用泛型来解决：<code>ArrayList&lt;Dog&gt; arrayList = new ArrayList&lt;Dog&gt;();</code></p>
<pre><code class="hljs plaintext">//1. 当我们 ArrayList&lt;Dog&gt; 表示存放到 ArrayList 集合中的元素是 Dog 类型 (细节后面说...)
//2. 如果编译器发现添加的类型，不满足要求，就会报错
//3. 在遍历的时候，可以直接取出 Dog 类型而不是 Object
//4. public class ArrayList&lt;E&gt; &#123;&#125; E 称为泛型,那么 Dog-&gt;E
        ArrayList&lt;Dog&gt; arrayList = new ArrayList&lt;Dog&gt;();
        arrayList.add(new Dog(&quot;旺财&quot;, 10));
        arrayList.add(new Dog(&quot;发财&quot;, 1));
        arrayList.add(new Dog(&quot;小黄&quot;, 5));
//假如我们的程序员，不小心，添加了一只猫
//        arrayList.add(new Cat(&quot;招财猫&quot;, 8));
        System.out.println(&quot;===使用泛型====&quot;);
        for (Dog dog : arrayList) &#123;
            System.out.println(dog.getName() + &quot;-&quot; + dog.getAge());
        &#125;</code></pre>

<p>使用泛型来解决问题时，当添加猫的时候系统就会发出警报了。</p>
<h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809111102632.png" alt="image-20240809111102632"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809111218256-1723173139016-1.png" alt="image-20240809111218256"></p>
<p>与第4点相关的代码：</p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args)&#123;
        //注意，特别强调： E 具体的数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型
        Person&lt;String&gt; person = new Person&lt;String&gt;(&quot;韩顺平教育&quot;);
        person.show(); //String
/*
        你可以这样理解，上面的 Person 类
class Person &#123;
    String s ;//E 表示 s 的数据类型, 该数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E
    是什么类型
    public Person(String s) &#123;//E 也可以是参数类型
        this.s = s;
    &#125;
    public String f() &#123;//返回类型使用 E
        return s;
    &#125;
&#125;
*/
        Person&lt;Integer&gt; person2 = new Person&lt;Integer&gt;(100);
        person2.show();//Integer
/*
class Person &#123;
    Integer s ;//E 表示 s 的数据类型, 该数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E
    是什么类型
    public Person(Integer s) &#123;//E 也可以是参数类型
        this.s = s;
    &#125;
    public Integer f() &#123;//返回类型使用 E
        return s;
    &#125;
&#125;
*/
    &#125;
&#125;
//泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，
// 或者是某个方法的返回值的类型，或者是参数类型
class Person&lt;E&gt; &#123;
    E s;//E 表示 s 的数据类型, 该数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型

    public Person(E s) &#123;//E 也可以是参数类型
        this.s = s;
    &#125;

    public E f() &#123;//返回类型使用 E
        return s;
    &#125;

    public void show() &#123;
        System.out.println(s.getClass());//显示 s 的运行类型
    &#125;
&#125;</code></pre>

<h2 id="泛型的语法"><a href="#泛型的语法" class="headerlink" title="泛型的语法"></a>泛型的语法</h2><p>声明：<img src="/../source/imgs/$%7Bfiilname%7D/image-20240809112640233.png" alt="image-20240809112640233"></p>
<p>实例化：<img src="/../source/imgs/$%7Bfiilname%7D/image-20240809112658580.png" alt="image-20240809112658580"></p>
<img src="../source/imgs/${fiilname}/image-20240809112743876.png" alt="image-20240809112743876" style="zoom:50%;" />

<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">c</span> &#123;
    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;
        <span class="hljs-comment">//使用泛型方式给 HashSet 放入 3 个学生对象</span>
        HashSet&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Student&gt;();
        students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">18</span>));
        students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">28</span>));
        students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;mary&quot;</span>, <span class="hljs-number">19</span>));
<span class="hljs-comment">//遍历</span>
        <span class="hljs-keyword">for</span> (Student student : students) &#123;
            System.out.println(student);
        &#125;
<span class="hljs-comment">//使用泛型方式给 HashMap 放入 3 个学生对象</span>
<span class="hljs-comment">//K -&gt; String,V-&gt;Student</span>
        HashMap&lt;String, Student&gt; hm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Student&gt;();
<span class="hljs-comment">/*</span>
<span class="hljs-comment">public class HashMap&lt;K,V&gt; &#123;&#125;</span>
<span class="hljs-comment">*/</span>
        hm.put(<span class="hljs-string">&quot;milan&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;milan&quot;</span>, <span class="hljs-number">38</span>));
        hm.put(<span class="hljs-string">&quot;smith&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;smith&quot;</span>, <span class="hljs-number">48</span>));
        hm.put(<span class="hljs-string">&quot;hsp&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;hsp&quot;</span>, <span class="hljs-number">28</span>));
<span class="hljs-comment">//迭代器 EntrySet</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span>
<span class="hljs-comment">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span>
<span class="hljs-comment">    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;</span>
<span class="hljs-comment">&#125;</span>
<span class="hljs-comment">*/</span>
        Set&lt;Map.Entry&lt;String, Student&gt;&gt; entries = hm.entrySet();
<span class="hljs-comment">/*</span>
<span class="hljs-comment">public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span>
<span class="hljs-comment">	return new EntryIterator();</span>
<span class="hljs-comment">&#125;</span>
<span class="hljs-comment">*/</span>
        Iterator&lt;Map.Entry&lt;String, Student&gt;&gt; iterator = entries.iterator();
        System.out.println(<span class="hljs-string">&quot;==============================&quot;</span>);
        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
            Map.Entry&lt;String, Student&gt; next = iterator.next();
            System.out.println(next.getKey() + <span class="hljs-string">&quot;-&quot;</span> + next.getValue());
        &#125;
    &#125;
&#125;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    &#125;
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> name;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> age;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;
        <span class="hljs-built_in">this</span>.age = age;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +
                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, age=&quot;</span> + age +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">Iterator&lt;Map.Entry&lt;String, Student&gt;&gt; iterator = entries.iterator();</code></pre>

<h2 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809113352685.png" alt="image-20240809113352685"></p>
<pre><code class="hljs plaintext">import java.util.*;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        //2. 说明
//因为 E 指定了 A 类型, 构造器传入了 new A()
//在给泛型指定具体类型后，可以传入该类型或者其子类类型
        Pig&lt;A&gt; aPig = new Pig&lt;A&gt;(new A());
        aPig.f();
        Pig&lt;A&gt; aPig2 = new Pig&lt;A&gt;(new B());
        aPig2.f();
//3. 泛型的使用形式
        ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();
        List&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();
//在实际开发中，我们往往简写
//编译器会进行类型推断, 老师推荐使用下面写法
        ArrayList&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; list4 = new ArrayList&lt;&gt;();
        ArrayList&lt;Pig&gt; pigs = new ArrayList&lt;&gt;();
//4. 如果是这样写 泛型默认是 Object
        ArrayList arrayList = new ArrayList();//等价 ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;Object&gt;();
/*
public boolean add(Object e) &#123;
    ensureCapacityInternal(size + 1); // Increments modCount!!
    elementData[size++] = e;
    return true;
&#125;
*/
        Tiger tiger = new Tiger();
/*
class Tiger &#123;//类
    Object e;
    public Tiger() &#123;&#125;
    public Tiger(Object e) &#123;
        this.e = e;
    &#125;
&#125;
*/
    &#125;
&#125;
class Tiger&lt;E&gt; &#123;//类
    E e;
    public Tiger() &#123;&#125;
    public Tiger(E e) &#123;
        this.e = e;
    &#125;
&#125;
class A &#123;&#125;
class B extends A &#123;&#125;
class Pig&lt;E&gt; &#123;//
    E e;
    public Pig(E e) &#123;
        this.e = e;
    &#125;
    public void f() &#123;
        System.out.println(e.getClass()); //运行类型
    &#125;
&#125;</code></pre>

<h2 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h2><h3 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809165532655.png" alt="image-20240809165532655"></p>
<p>上面有出现过。</p>
<pre><code class="hljs plaintext">package com.Hnu.experiment;

import java.util.*;

public class test &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;&#125;)
    public static void main(String[] args)&#123;
        //T=Double, R=String, M=Integer
        Tiger&lt;Double,String,Integer&gt; g = new Tiger&lt;&gt;(&quot;john&quot;);
        g.setT(10.9); //OK
//g.setT(&quot;yy&quot;); //错误，类型不对
        System.out.println(g);
        Tiger g2 = new Tiger(&quot;john~~&quot;);//OK T=Object R=Object M=Object
        g2.setT(&quot;yy&quot;); //OK ,因为 T=Object &quot;yy&quot;=String 是 Object 子类
        System.out.println(&quot;g2=&quot; + g2);
    &#125;
&#125;
//老韩解读
//1. Tiger 后面泛型，所以我们把 Tiger 就称为自定义泛型类
//2, T, R, M 泛型的标识符, 一般是单个大写字母
//3. 泛型标识符可以有多个. //4. 普通成员可以使用泛型 (属性、方法)
//5. 使用泛型的数组，不能初始化
//6. 静态方法中不能使用类的泛型
class Tiger&lt;T, R, M&gt; &#123;
    String name;
    R r; //属性使用到泛型
    M m;
    T t;
    //因为数组在 new 不能确定 T 的类型，就无法在内存开空间
    T[] ts;
    public Tiger(String name) &#123;
        this.name = name;
    &#125;
    public Tiger(R r, M m, T t) &#123;//构造器使用泛型
        this.r = r;
        this.m = m;
        this.t = t;
    &#125;
    public Tiger(String name, R r, M m, T t) &#123;//构造器使用泛型
        this.name = name;
        this.r = r;
        this.m = m;
        this.t = t;
    &#125;
//因为静态是和类相关的，在类加载时，对象还没有创建
//所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化,所以不能使用类的泛型
// static R r2;
// public static void m1(M m) &#123;
//
// &#125;
//方法使用泛型
public String getName() &#123;
    return name;
&#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public R getR() &#123;
        return r;
    &#125;
    public void setR(R r) &#123;//方法使用到泛型
        this.r = r;
    &#125;
    public M getM() &#123;//返回类型可以使用泛型. 
         return m;
    &#125;
    public void setM(M m) &#123;
        this.m = m;
    &#125;
    public T getT() &#123;
        return t;
    &#125;
    public void setT(T t) &#123;
        this.t = t;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Tiger&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, r=&quot; + r +
                &quot;, m=&quot; + m +
                &quot;, t=&quot; + t +
                &quot;, ts=&quot; + Arrays.toString(ts) +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<h3 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809170146345.png" alt="image-20240809170146345"></p>
<p>接口中定义的属性都是静态属性，所以不能使用泛型来定义。</p>
<p>继承接口的时候也要确定泛型。</p>
<pre><code class="hljs plaintext">//实现接口时，直接指定泛型接口的类型
//给 U 指定 Integer 给 R 指定了 Float
//所以，当我们实现 IUsb 方法时，会使用 Integer 替换 U, 使用 Float 替换 R
class BB implements IUsb&lt;Integer, Float&gt; &#123;
    @Override
    public Float get(Integer integer) &#123;
        return null;
    &#125;
    @Override
    public void hi(Float aFloat) &#123;
    &#125;
    @Override
    public void run(Float r1, Float r2, Integer u1, Integer u2) &#123;
    &#125;
&#125;
//没有指定类型，默认为 Object
//建议直接写成 IUsb&lt;Object,Object&gt;
class CC implements IUsb &#123; //等价 class CC implements IUsb&lt;Object,Object&gt; &#123;
    @Override
    public Object get(Object o) &#123;
        return null;
    &#125;
    @Override
    public void hi(Object o) &#123;
    &#125;
    @Override
    public void run(Object r1, Object r2, Object u1, Object u2) &#123;
    &#125;
&#125;
interface IUsb&lt;U, R&gt; &#123;
    int n = 10;
    //U name; 不能这样使用
//普通方法中，可以使用接口泛型
    R get(U u);
    void hi(R r);
    void run(R r1, R r2, U u1, U u2);
    //在 jdk8 中，可以在接口中，使用默认方法, 也是可以使用泛型
    default R method(U u) &#123;
        return null;
    &#125;
&#125;</code></pre>

<h3 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809171004302.png" alt="image-20240809171004302"></p>
<p>为什么在方法前要声明一个泛型呢，不声明会怎么样。</p>
<p>这个方法不声明且定义这个类的时候也没有声明的话那编译会出错，前面为什么可以只是使用了泛型而不在方法那边声明，因为这个方法使用的泛型在定义那个类的时候就已经声明过了。</p>
<p><code>public &lt;K&gt; void hello(R r, K k)</code>只声明一个的原因是R在定义这个类的时候就已经声明过了。</p>
<pre><code class="hljs plaintext">package com.Hnu.experiment;

import java.util.*;

public class test &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;&#125;)
    public static void main(String[] args)&#123;
        Car car = new Car();
        car.fly(&quot;宝马&quot;, 100);//当调用方法时，传入参数，编译器，就会确定类型
        System.out.println(&quot;=======&quot;);
        car.fly(300, 100.1);//当调用方法时，传入参数，编译器，就会确定类型
//测试
//T-&gt;String, R-&gt; ArrayList
        Fish&lt;String, ArrayList&gt; fish = new Fish&lt;&gt;();
        fish.hello(new ArrayList(), 11.3f);
    &#125;
&#125;
//泛型方法，可以定义在普通类中, 也可以定义在泛型类中
class Car &#123;//普通类
    public void run() &#123;//普通方法
    &#125;
    //说明 泛型方法
//1. &lt;T,R&gt; 就是泛型
//2. 是提供给 fly 使用的
    public &lt;T, R&gt; void fly(T t, R r) &#123;//泛型方法
        System.out.println(t.getClass());//String
        System.out.println(r.getClass());//Integer
    &#125;
&#125;
class Fish&lt;T, R&gt; &#123;//泛型类

    public void run() &#123;//普通方法
    &#125;

    public &lt;U, M&gt; void eat(U u, M m) &#123;//泛型方法
    &#125;

    //说明
//1. 下面 hi 方法不是泛型方法
//2. 是 hi 方法使用了类声明的 泛型
    public void hi(T t) &#123;
    &#125;

    //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型
    public &lt;K&gt; void hello(R r, K k) &#123;
        System.out.println(r.getClass());//ArrayList
        System.out.println(k.getClass());//Float
    &#125;
&#125;</code></pre>

<h2 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="headerlink" title="泛型的继承和通配符"></a>泛型的继承和通配符</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240810105516928.png" alt="image-20240810105516928"></p>
<p>在给泛型指定具体类型后，可以传入该类型或者其子类类型，意思是传入的变量可以是子类，但后面写的泛型不能是子类。</p>
<pre><code class="hljs plaintext">import java.util.*;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        Object o = new String(&quot;xx&quot;);
//泛型没有继承性
//List&lt;Object&gt; list = new ArrayList&lt;String&gt;();
//举例说明下面三个方法的使用
        List&lt;Object&gt; list1 = new ArrayList&lt;&gt;();
        List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
        List&lt;AA&gt; list3 = new ArrayList&lt;&gt;();
        List&lt;BB&gt; list4 = new ArrayList&lt;&gt;();
        List&lt;CC&gt; list5 = new ArrayList&lt;&gt;();
//如果是 List&lt;?&gt; c ，可以接受任意的泛型类型
        printCollection1(list1);
        printCollection1(list2);
        printCollection1(list3);
        printCollection1(list4);
        printCollection1(list5);
//List&lt;? extends AA&gt; c： 表示 上限，可以接受 AA 或者 AA 子类
// printCollection2(list1);//×
// printCollection2(list2);//×
        printCollection2(list3);//√
        printCollection2(list4);//√
        printCollection2(list5);//√
//List&lt;? super AA&gt; c: 支持 AA 类以及 AA 类的父类，不限于直接父类
        printCollection3(list1);//√
//printCollection3(list2);//×
        printCollection3(list3);//√
//printCollection3(list4);//×
//printCollection3(list5);//×
//冒泡排序
//插入排序
//....
    &#125;
    // ? extends AA 表示 上限，可以接受 AA 或者 AA 子类
    public static void printCollection2(List&lt;? extends AA&gt; c) &#123;
        for (Object object : c) &#123;
            System.out.println(object);
        &#125;
    &#125;
    //说明: List&lt;?&gt; 表示 任意的泛型类型都可以接受
    public static void printCollection1(List&lt;?&gt; c) &#123;
        for (Object object : c) &#123; // 通配符，取出时，就是 Object
            System.out.println(object);
        &#125;
    &#125;
    // ? super 子类类名 AA:支持 AA 类以及 AA 类的父类，不限于直接父类，
//规定了泛型的下限
    public static void printCollection3(List&lt;? super AA&gt; c) &#123;
        for (Object object : c) &#123;
            System.out.println(object);
        &#125;
    &#125;
&#125;
class AA &#123;
&#125;
class BB extends AA &#123;
&#125;
class CC extends BB &#123;
&#125;</code></pre>

<h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><pre><code class="hljs plaintext">import org.junit.jupiter.api.Test;

public class c &#123;
    public static void main(String[] args)&#123;
        //传统方式
//new JUnit_().m1();
//new JUnit_().m2();
    &#125;
    @Test
    public void m1() &#123;
        System.out.println(&quot;m1 方法被调用&quot;);
    &#125;
    @Test
    public void m2() &#123;
        System.out.println(&quot;m2 方法被调用&quot;);
    &#125;
    @Test
    public void m3() &#123;
        System.out.println(&quot;m3 方法被调用&quot;);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240810112032671.png" alt="image-20240810112032671"></p>
<p>方便，方法可以进行单独测试。</p>
<h1 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h1><h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240811165750263.png" alt="image-20240811165750263"></p>
<h2 id="常用的文件操作"><a href="#常用的文件操作" class="headerlink" title="常用的文件操作"></a>常用的文件操作</h2><h3 id="创建文件对象相关构造器和方法"><a href="#创建文件对象相关构造器和方法" class="headerlink" title="创建文件对象相关构造器和方法"></a>创建文件对象相关构造器和方法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240811165842195.png" alt="image-20240811165842195"></p>
<pre><code class="hljs plaintext">import org.junit.jupiter.api.Test;
import java.io.*;</code></pre>

<pre><code class="hljs plaintext">//方式 1 new File(String pathname)
@Test
public void create01() &#123;
    String filePath = &quot;e:\\news1.txt&quot;;
    File file = new File(filePath);
    try &#123;
        file.createNewFile();
        System.out.println(&quot;文件创建成功&quot;);
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre>

<p>Java中的printStackTrace()方法是Throwable类的一个公共方法，它用于打印异常（Exception）或错误（Error）的栈追踪信息到标准错误流（System.err）。当程序抛出异常或错误，并被捕获后，可以使用printStackTrace()方法输出详细的调用栈信息，这在调试程序时非常有用，因为它可以帮助开发者确定异常发生的位置和原因。</p>
<p>e或者E都可以。</p>
<pre><code class="hljs plaintext">//方式 2 new File(File parent,String child) //根据父目录文件+子路径构建
//e:\news2.txt    
    @Test
    public void create02() &#123;
        File parentFile = new File(&quot;e:\\&quot;);
        String fileName = &quot;news2.txt&quot;;
//这里的 file 对象，在 java 程序中，只是一个对象
//只有执行了 createNewFile 方法，才会真正的，在磁盘创建该文件
        File file = new File(parentFile, fileName);
        try &#123;
            file.createNewFile();
            System.out.println(&quot;创建成功~&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;</code></pre>

<pre><code class="hljs plaintext">//方式 2 new File(File parent,String child) //根据父目录文件+子路径构建
//e:\work\work1.txt
    @Test
    public void create02() &#123;
        File parentFile = new File(&quot;e:\\work\\&quot;);//转义字符&#x27;\&#x27;
        String fileName = &quot;work1.txt&quot;;
//这里的 file 对象，在 java 程序中，只是一个对象
//只有执行了 createNewFile 方法，才会真正的，在磁盘创建该文件
        File file = new File(parentFile, fileName);
        try &#123;
            file.createNewFile();
            System.out.println(&quot;创建成功~&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;</code></pre>

<p>得先在E盘里有个work文件夹才可以。上面还可以写作：</p>
<pre><code class="hljs plaintext">File parentFile = new File(&quot;e:\\&quot;);
String fileName = &quot;work\\work1.txt&quot;;</code></pre>

<pre><code class="hljs plaintext"> //方式 3 new File(String parent,String child) //根据父目录+子路径构建
    @Test
    public void create03() &#123;
//String parentPath = &quot;e:\\&quot;;
        String parentPath = &quot;e:\\&quot;;
        String fileName = &quot;news4.txt&quot;;
        File file = new File(parentPath, fileName);
        try &#123;
            file.createNewFile();
            System.out.println(&quot;创建成功~&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;</code></pre>

<p>file.creatNewFile()必须用try-catch包围不然会编译异常。</p>
<h3 id="获取文件的相关信息"><a href="#获取文件的相关信息" class="headerlink" title="获取文件的相关信息"></a>获取文件的相关信息</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240812170556243.png" alt="image-20240812170556243"></p>
<pre><code class="hljs plaintext">package com.Hnu.experiment;

import org.junit.jupiter.api.Test;
import java.io.*;

public class test &#123;
    public static void  main(String[] args)&#123;
    &#125;
    //方式 1 new File(String pathname)
    @Test
    public void create01() &#123;
        String filePath = &quot;e:\\news1.txt&quot;;
        File file = new File(filePath);
        try &#123;
            file.createNewFile();
            System.out.println(&quot;文件创建成功&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        //调用相应的方法，得到对应信息
        System.out.println(&quot;文件名字=&quot; + file.getName());
//getName、getAbsolutePath、getParent、length、exists、isFile、isDirectory
        System.out.println(&quot;文件绝对路径=&quot; + file.getAbsolutePath());
        System.out.println(&quot;文件父级目录=&quot; + file.getParent());
        System.out.println(&quot;文件大小(字节)=&quot; + file.length());
        System.out.println(&quot;文件是否存在=&quot; + file.exists());//T
        System.out.println(&quot;是不是一个文件=&quot; + file.isFile());//T
        System.out.println(&quot;是不是一个目录=&quot; + file.isDirectory());//F
    &#125;
&#125;</code></pre>

<p>isFile()和isDirectory()括号里面都不能加对象。</p>
<h3 id="目录的操作和文件删除"><a href="#目录的操作和文件删除" class="headerlink" title="目录的操作和文件删除"></a>目录的操作和文件删除</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813110428523.png" alt="image-20240813110428523"></p>
<p>没例子</p>
<h2 id="IO-流原理及流的分类"><a href="#IO-流原理及流的分类" class="headerlink" title="IO 流原理及流的分类"></a>IO 流原理及流的分类</h2><p>原理：<img src="/../source/imgs/$%7Bfiilname%7D/image-20240813110530651.png" alt="image-20240813110530651"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813110536404.png" alt="image-20240813110536404"></p>
<p>分类：<img src="/../source/imgs/$%7Bfiilname%7D/image-20240813110635780.png" alt="image-20240813110635780"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813110653713.png" alt="image-20240813110653713"></p>
<h2 id="FileInputStream-文件–-程序"><a href="#FileInputStream-文件–-程序" class="headerlink" title="FileInputStream(文件–&gt; 程序)"></a>FileInputStream(文件–&gt; 程序)</h2><p>演示 FileInputStream 的使用(字节输入流 文件–&gt; 程序)：</p>
<p>读取的内容是文件里的内容。</p>
<pre><code class="hljs plaintext">import org.junit.jupiter.api.Test;

import java.io.*;

public class c &#123;
    public static void main(String[] args)&#123;
    &#125;
    /**
     * 演示读取文件... * 单个字节的读取，效率比较低
     * -&gt; 使用 read(byte[] b)
     */
    @Test
    public void readFile01() &#123;
        String filePath = &quot;e:\\hello.txt&quot;;
        int readData = 0;
        FileInputStream fileInputStream = null;
        try &#123;
//创建 FileInputStream 对象，用于读取 文件
            fileInputStream = new FileInputStream(filePath);
//从该输入流读取一个字节的数据。 如果没有输入可用，此方法将阻止。
//如果返回-1 , 表示读取完毕
            while ((readData = fileInputStream.read()) != -1) &#123;
                System.out.print((char)readData);//转成 char 显示
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
//关闭文件流，释放资源.
            try &#123;
                fileInputStream.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
    /**
     * 使用 read(byte[] b) 读取文件，提高效率
     */
    @Test
    public void readFile02() &#123;
        String filePath = &quot;e:\\hello.txt&quot;;
//字节数组
        byte[] buf = new byte[8]; //一次读取 8 个字节.
        int readLen = 0;
        FileInputStream fileInputStream = null;
        try &#123;
//创建 FileInputStream 对象，用于读取 文件
            fileInputStream = new FileInputStream(filePath);
//从该输入流读取最多 buf.length 字节的数据到字节数组。 此方法将阻塞，直到某些输入可用。
//如果返回-1 , 表示读取完毕
//如果读取正常, 返回实际读取的字节数
            while ((readLen = fileInputStream.read(buf)) != -1) &#123;
                System.out.print(new String(buf, 0, readLen));//显示
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //关闭文件流，释放资源.
            try &#123;
                fileInputStream.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p><code>fileInputStream.read()</code>括号是空的就默认是一个一个字节读取。</p>
<p><code>new String(buf, 0, readLen)</code>，该方法在下面的FileReader有介绍，为什么不直接是(buf)，因为文件里的内容可能不是8的倍数，而读取内容是在buf里面以覆盖的形式存储的，所以直接是buf的话会输出额外内容。</p>
<p>为什么System.out.print((char)readData)需要强制转化为char?</p>
<p><code>FileInputStream.read()</code> 方法每次读取一个字节的数据，并返回该字节的数据作为 <code>int</code> 类型。具体来说，返回的 <code>int</code> 范围是 0 到 255（因为一个字节是 8 位，最大值是 255）。如果读取到文件的末尾，<code>read()</code> 方法返回 -1，表示已经没有数据可以读取了。</p>
<p>由于返回类型是 <code>int</code>，而不是直接返回 <code>byte</code> 或 <code>char</code>，这是因为它需要处理可能的 EOF（End of File）情况，即 -1。</p>
<h2 id="FileOutputStream-程序-文本"><a href="#FileOutputStream-程序-文本" class="headerlink" title="FileOutputStream(程序-&gt;文本)"></a>FileOutputStream(程序-&gt;文本)</h2><p>直接写入文件，不是像BufferedOutputStream要等流关闭后才可以写入。</p>
<pre><code class="hljs plaintext">import org.junit.jupiter.api.Test;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class c &#123;
    public static void main(String[] args)&#123;
    &#125;
    /**
     * 演示使用 FileOutputStream 将数据写到文件中, * 如果该文件不存在，则创建该文件
     */
    @Test
    public void writeFile() &#123;
//创建 FileOutputStream 对象
        String filePath = &quot;e:\\a.txt&quot;;
        FileOutputStream fileOutputStream = null;
        try &#123;
//得到 FileOutputStream 对象 对象
//老师说明
//1. new FileOutputStream(filePath) 创建方式，当写入内容，会覆盖原来的内容
//2. new FileOutputStream(filePath, true) 创建方式，当写入内容，是追加到文件后面
            fileOutputStream = new FileOutputStream(filePath, true);
//写入一个字节
//fileOutputStream.write(&#x27;H&#x27;);//
//写入字符串
            String str = &quot;hsp,world!&quot;;
//str.getBytes() 可以把 字符串-&gt; 字节数组
//fileOutputStream.write(str.getBytes());
/*
write(byte[] b, int off, int len) 将 len 字节从位于偏移量 off 的指定字节数组写入此文件输出流
*/
            fileOutputStream.write(str.getBytes(), 0, 3);//写入htp
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
                fileOutputStream.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>要求: 编程完成图片&#x2F;音乐的拷贝：</p>
<pre><code class="hljs plaintext">import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.FileInputStream;

public class c &#123;
    public static void main(String[] args)&#123;
        //完成 文件拷贝，将 e:\\Koala.jpg 拷贝 c:\\
//思路分析
        //1. 创建文件的输入流 , 将文件读入到程序
//2. 创建文件的输出流， 将读取到的文件数据，写入到指定的文件.
        String srcFilePath = &quot;e:\\Koala.jpg&quot;;
        String destFilePath = &quot;e:\\Koala3.jpg&quot;;
        FileInputStream fileInputStream = null;
        FileOutputStream fileOutputStream = null;
        try &#123;
            fileInputStream = new FileInputStream(srcFilePath);
            fileOutputStream = new FileOutputStream(destFilePath);
//定义一个字节数组,提高读取效果
            byte[] buf = new byte[1024];
            int readLen = 0;
            while ((readLen = fileInputStream.read(buf)) != -1) &#123;
//读取到后，就写入到文件 通过 fileOutputStream
//即，是一边读，一边写
                fileOutputStream.write(buf, 0, readLen);//一定要使用这个方法
            &#125;
            System.out.println(&quot;拷贝 ok~&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
//关闭输入流和输出流，释放资源
                if (fileInputStream != null) &#123;
                    fileInputStream.close();
                &#125;
                if (fileOutputStream != null) &#123;
                    fileOutputStream.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>该程序中的fileOutputStream.write(buf, 0, readLen)buf是字节数组，存储的不是字母，那么写入文本的时候写入的是数字还是字母？</p>
<p><code>buf</code> 是一个字节数组，里面存储的是从源文件（即 <code>Koala.jpg</code>）中读取的原始二进制数据。写入的内容是图片的二进制数据，而不是数字或者字母。换句话说，写入的是文件的<strong>原始字节数据</strong>。二进制文件，比如图片、音频、视频等，都是以字节流的形式存储的，每个字节都可能代表一个像素的颜色值、一段声音的波形等。</p>
<ul>
<li><strong>对于图片文件</strong>：<code>fileOutputStream.write(buf, 0, readLen)</code> 写入的字节数据会被重新组装成图片文件，能够正确显示出原始图片内容。</li>
<li><strong>对于文本文件</strong>：如果你在处理文本文件，这些字节数据可能代表字符的编码值（如 ASCII、UTF-8 编码），写入后重新读取时会显示原来的文本。</li>
</ul>
<h2 id="FileReader-和-FileWriter-处理字符流"><a href="#FileReader-和-FileWriter-处理字符流" class="headerlink" title="FileReader 和 FileWriter(处理字符流)"></a>FileReader 和 FileWriter(处理字符流)</h2><p>这俩只能处理字符，但是上面两个stream可以处理二进制数据，也就是字节流。</p>
<p><strong><code>FileReader</code></strong>: 用于读取文本文件中的字符数据。它将字节数据自动转换为字符数据，使用系统默认的字符编码或指定的字符编码。</p>
<p><strong><code>FileWriter</code></strong>: 用于将字符数据写入文本文件。它会将字符数据转换为字节数据，并写入文件中。</p>
<p>reader想要从文本中读到内容首先要有这个文本文件才可以不然就会报错，writer就不需要先创建文本了，它会自动创建如果没有的话。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813173129946.png" alt="image-20240813173129946"></p>
<p>FileReader 相关方法：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813173513118.png" alt="image-20240813173513118"></p>
<p>new String（在上面的String类有讲到）括号里的也可以是byte数组<code>new String(byte[] bytes, int offset, int length)</code>。字符串在底层实际上也是以字节的形式存储的。字符串（<code>String</code>）在 Java 中是以字符（<code>char</code>）的形式表示的，而 <code>char</code> 在 Java 中是 16 位的 Unicode 字符。另一方面，<code>byte</code> 是 8 位的。因此，字节数组中的每个 <code>byte</code> 实际上可以表示一个 ASCII 字符（对于简单的英文字符）或者是一个 UTF-8 编码的字节（对于复杂的多字节字符，如汉字）。当调用时，Java 会将字节数组 <code>bytes</code> 中的数据按照指定的字符编码解码成字符串。默认情况下，Java 使用平台默认的字符集（通常是 UTF-8）来解释这些字节，并将它们转换为对应的字符。</p>
<p>FileWriter 常用方法：<img src="/../source/imgs/$%7Bfiilname%7D/image-20240813173546876.png" alt="image-20240813173546876"></p>
<pre><code class="hljs plaintext">import org.junit.jupiter.api.Test;

import java.io.*;

public class c &#123;
    public static void main(String[] args)&#123;
    &#125;
    /**
     * 单个字符读取文件
     */
    @Test
    public void readFile01() &#123;
        String filePath = &quot;e:\\story.txt&quot;;
        FileReader fileReader = null;
        int data = 0;
//1. 创建 FileReader 对象
        try &#123;
            fileReader = new FileReader(filePath);
//循环读取 使用 read, 单个字符读取
            while ((data = fileReader.read()) != -1) &#123;
                System.out.print((char) data);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
                if (fileReader != null) &#123;
                    fileReader.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
    /**
     * 字符数组读取文件
     */
    @Test
    public void readFile02() &#123;
        System.out.println(&quot;~~~readFile02 ~~~&quot;);
        String filePath = &quot;e:\\story.txt&quot;;
        FileReader fileReader = null;
        int readLen = 0;
        char[] buf = new char[8];
//1. 创建 FileReader 对象
        try &#123;
            fileReader = new FileReader(filePath);
//循环读取 使用 read(buf), 返回的是实际读取到的字符数
//如果返回-1, 说明到文件结束
            while ((readLen = fileReader.read(buf)) != -1) &#123;
                System.out.print(new String(buf, 0, readLen));
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
                if (fileReader != null) &#123;
                    fileReader.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>使用 FileWriter 将 “风雨之后，定见彩虹” 写入到 note.txt 文件中：</p>
<pre><code class="hljs plaintext">import java.io.FileWriter;
import java.io.IOException;

public class c &#123;
    public static void main(String[] args)&#123;
        String filePath = &quot;e:\\note.txt&quot;;
//创建 FileWriter 对象
        FileWriter fileWriter = null;
        char[] chars = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;
        try &#123;
            fileWriter = new FileWriter(filePath);//默认是覆盖写入
// 3) write(int):写入单个字符
            fileWriter.write(&#x27;H&#x27;);
// 4) write(char[]):写入指定数组
            fileWriter.write(chars);
// 5) write(char[],off,len):写入指定数组的指定部分
            fileWriter.write(&quot;韩顺平教育&quot;.toCharArray(), 0, 3);
// 6) write（string）：写入整个字符串
            fileWriter.write(&quot; 你好北京~&quot;);
            fileWriter.write(&quot;风雨之后，定见彩虹&quot;);
            // 7) write(string,off,len):写入字符串的指定部分
            fileWriter.write(&quot;上海天津&quot;, 0, 2);
//在数据量大的情况下，可以使用循环操作.
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
//对应 FileWriter , 一定要关闭流，或者 flush 才能真正的把数据写入到文件
            try &#123;
//fileWriter.flush();
//关闭文件流，等价 flush() + 关闭
                fileWriter.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        System.out.println(&quot;程序结束...&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">fileWriter = new FileWriter(filePath);//默认是覆盖写入</code></pre>

<p>覆盖写入没有错，那为什么按照上面的程序，最后note文本里的内容会是存进去的所有内容呢？因为它们全部都是在同一个try-catch里面存进去的，而<strong>对应 FileWriter , 要关闭流，或者 flush 才能真正的把数据写入到文件</strong>，关闭流是在finally里面，所以上面那些内容都是一起、一次被写入note的，只写了这一次，所以内容是全部。如果后面继续写入其它内容就会覆盖之前写的内容了。</p>
<p>怎么继续写入呢，如果直接在后面fileWriter.write的话会因为流关闭而出现异常，所以要重新要这样，再开一个：</p>
<pre><code class="hljs plaintext">fileWriter = new FileWriter(filePath);
fileWriter.write(&#x27;H&#x27;);
fileWriter.close();</code></pre>

<pre><code class="hljs plaintext">fileWriter = new FileWriter(filePath,true);//这个会追加到后面</code></pre>

<h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813223615180.png" alt="image-20240813223615180"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813223620304.png" alt="image-20240813223620304"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813223704614.png" alt="image-20240813223704614"></p>
<h3 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h3><p>功能：<img src="/../source/imgs/$%7Bfiilname%7D/image-20240814111046367.png" alt="image-20240814111046367"></p>
<h4 id="BufferedReader-和-BufferedWriter-字符操作"><a href="#BufferedReader-和-BufferedWriter-字符操作" class="headerlink" title="BufferedReader 和 BufferedWriter(字符操作)"></a>BufferedReader 和 BufferedWriter(字符操作)</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814111410113-1723605250860-1.png" alt="image-20240814111410113"></p>
<p><strong>1、使用BufferedReader读取文本文件并显示在控制台</strong></p>
<pre><code class="hljs plaintext">import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class c &#123;
    public static void main(String[] args) throws IOException &#123;
        String filePath = &quot;e:\\a.java&quot;;
//创建 bufferedReader
        BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));
        //读取
        String line; //按行读取, 效率高
//说明
//1. bufferedReader.readLine() 是按行读取文件
//2. 当返回 null 时，表示文件读取完毕
        while ((line = bufferedReader.readLine()) != null) &#123;
            System.out.println(line);
        &#125;
//关闭流, 这里注意，只需要关闭 BufferedReader ，因为底层会自动的去关闭 节点流
        bufferedReader.close();
    &#125;
&#125;</code></pre>

<p>为什么这边没有try-catch呢，因为这次在主方法就抛出了异常。</p>
<p>为什么FileNotFoundException和java.io.IOException可以用同一个catch(IOException e)捕获？</p>
<p>在Java中，<code>FileNotFoundException</code>是<code>IOException</code>的一个子类。这意味着<code>FileNotFoundException</code>是<code>IOException</code>的一个更具体的类型。当你使用<code>catch(IOException e)</code>块时，它可以捕获类型为<code>IOException</code>的异常，以及它的任何子类（包括<code>FileNotFoundException</code>）。</p>
<p><strong>2、使用BufferedWriter输入</strong></p>
<pre><code class="hljs plaintext">import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class c &#123;
    public static void main(String[] args) throws IOException &#123;
        String filePath = &quot;e:\\ok.txt&quot;;
//创建 BufferedWriter
//说明:
//1. new FileWriter(filePath, true) 表示以追加的方式写入
//2. new FileWriter(filePath) , 表示以覆盖的方式写入
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(filePath));
        bufferedWriter.write(&quot;hello, 韩顺平教育!&quot;);
        bufferedWriter.newLine();//插入一个和系统相关的换行
        bufferedWriter.write(&quot;hello2, 韩顺平教育!&quot;);
        bufferedWriter.newLine();
        bufferedWriter.write(&quot;hello3, 韩顺平教育!&quot;);
        bufferedWriter.newLine();
//说明：关闭外层流即可 ， 传入的 new FileWriter(filePath) ,会在底层关闭
        bufferedWriter.close();
    &#125;
&#125;</code></pre>

<p>验证是覆盖写入，后面加上</p>
<pre><code class="hljs plaintext">bufferedWriter = new BufferedWriter(new FileWriter(filePath));
bufferedWriter.write(&quot;hello3, 韩顺平教育!&quot;);
bufferedWriter.close();</code></pre>

<p><strong>3、综合使用BufferedReader和BufferedWriter完成文件拷贝</strong></p>
<pre><code class="hljs plaintext">import java.io.*;

public class c &#123;
    public static void main(String[] args)&#123;
        //1. BufferedReader 和 BufferedWriter 是安装字符操作
//2. 不要去操作 二进制文件[声音，视频，doc, pdf ], 可能造成文件损坏
        String srcFilePath = &quot;e:\\a.java&quot;;
        String destFilePath = &quot;e:\\a2.java&quot;;
// String srcFilePath = &quot;e:\\0245_韩顺平零基础学 Java_引出 this.avi&quot;;
// String destFilePath = &quot;e:\\a2 韩顺平.avi&quot;;
        BufferedReader br = null;
        BufferedWriter bw = null;
        String line;
        try &#123;
            br = new BufferedReader(new FileReader(srcFilePath));
            bw = new BufferedWriter(new FileWriter(destFilePath));
//说明: readLine 读取一行内容，但是没有换行
            while ((line = br.readLine()) != null) &#123;
//每读取一行，就写入
                bw.write(line);
//插入一个换行
                bw.newLine();
            &#125;
            System.out.println(&quot;拷贝完毕...&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
//关闭流
            try &#123;
                if(br != null) &#123;
                    br.close();
                &#125;
                if(bw != null) &#123;
                    bw.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<ol>
<li>为什么拷贝的时候要换行？</li>
</ol>
<p>在你的代码中，<code>BufferedReader.readLine()</code> 方法被用来读取文件中的一行内容。<code>readLine()</code> 方法会读取一行文本，但它不会包含行尾的换行符（即不会包含 <code>\n</code> 或 <code>\r\n</code>）。</p>
<p>因此，如果你只是用 <code>bw.write(line);</code> 来写入文件，那么原文件中的换行符将不会被复制到目标文件中，结果就是所有的行都会被写入同一行中。为了保持原文件的格式不变，在每次写入一行内容后，需要手动添加一个换行符。<code>bw.newLine();</code> 方法就是用于这个目的的，它会根据操作系统的换行符标准（Windows 是 <code>\r\n</code>，Unix&#x2F;Linux 是 <code>\n</code>）插入适当的换行符，从而确保目标文件的内容和原文件一致。</p>
<ol start="2">
<li>关闭流的条件为什么是不为空？</li>
</ol>
<p>在使用文件流时，关闭流是非常重要的步骤。关闭流能够释放系统资源，避免内存泄漏以及锁定文件等问题。如果不关闭流，可能会导致文件无法被其他进程或操作所访问。</p>
<p>关闭流之前要检查流对象是否为 <code>null</code>，是因为如果某个流在创建过程中发生异常，那么该流对象可能依然是 <code>null</code>。如果你在 <code>null</code> 的情况下直接调用 <code>close()</code> 方法，就会引发 <code>NullPointerException</code>。</p>
<h4 id="BufferedInputStream-和-BufferedOutputStream-字节流"><a href="#BufferedInputStream-和-BufferedOutputStream-字节流" class="headerlink" title="BufferedInputStream 和 BufferedOutputStream(字节流)"></a>BufferedInputStream 和 BufferedOutputStream(字节流)</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814171441700.png" alt="image-20240814171441700"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814171506503.png" alt="image-20240814171506503"></p>
<p><strong>使用Buffered……流完成文件的复制</strong></p>
<p>使用 BufferedOutputStream 和 BufferedInputStream，使用他们，<strong>可以完成二进制文件拷贝</strong>. </p>
<p>思考：字节流可以操作二进制文件，可以操作文本文件吗？当然可以</p>
<pre><code class="hljs plaintext">import java.io.*;

public class c &#123;
    public static void main(String[] args)&#123;
        // String srcFilePath = &quot;e:\\Koala.jpg&quot;;
// String destFilePath = &quot;e:\\hsp.jpg&quot;;
// String srcFilePath = &quot;e:\\0245_韩顺平零基础学 Java_引出 this.avi&quot;;
// String destFilePath = &quot;e:\\hsp.avi&quot;;
        String srcFilePath = &quot;e:\\a.java&quot;;
        String destFilePath = &quot;e:\\a3.java&quot;;
//创建 BufferedOutputStream 对象 BufferedInputStream 对象
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        try &#123;
//因为 FileInputStream 是 InputStream 子类
            bis = new BufferedInputStream(new FileInputStream(srcFilePath));
            bos = new BufferedOutputStream(new FileOutputStream(destFilePath));
//循环的读取文件，并写入到 destFilePath
            byte[] buff = new byte[1024];
            int readLen = 0;
//当返回 -1 时，就表示文件读取完毕
            while ((readLen = bis.read(buff)) != -1) &#123;
                bos.write(buff, 0, readLen);
            &#125;
            System.out.println(&quot;文件拷贝完毕~~~&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
//关闭流 , 关闭外层的处理流即可，底层会去关闭节点流
            try &#123;
                if (bis != null) &#123;
                    bis.close();
                &#125;
                if (bos != null) &#123;
                    bos.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="FileOutputStream和BufferedOutputStream的区别"><a href="#FileOutputStream和BufferedOutputStream的区别" class="headerlink" title="FileOutputStream和BufferedOutputStream的区别"></a>FileOutputStream和BufferedOutputStream的区别</h5><p><strong>FileOutputStream</strong><br>直接写入文件：FileOutputStream 是用于将数据写入文件（如二进制文件）的输出流。它是字节流的一种，直接连接到文件。<br>无缓冲：FileOutputStream 默认情况下不提供缓冲功能。这意味着每次调用 write 方法时，数据都会直接写入到文件中，这可能会导致频繁的磁盘I&#x2F;O操作，从而影响性能。<br>用途：适用于需要直接控制文件写入过程，或者对性能要求不是非常高的场景。<br><strong>BufferedOutputStream</strong><br>缓冲写入：BufferedOutputStream 为另一个输出流（如 FileOutputStream）添加缓冲功能。它内部维护了一个缓冲区，数据首先写入到这个缓冲区中，当缓冲区满或者显式调用 flush() 方法时，缓冲区中的数据才会被写入到目标输出流（如文件）中。<br>性能提升：由于减少了磁盘I&#x2F;O操作的次数（因为数据是批量写入的），BufferedOutputStream 相比 FileOutputStream 提供了更好的性能。<br>用途：适用于需要高效写入大量数据的场景，如文件复制、大文件写入等。<br><strong>总结</strong><br>如果你需要直接写入文件，且对性能要求不高，或者写入的数据量不大，可以直接使用 FileOutputStream。<br>如果你需要高效写入大量数据到文件，推荐使用 BufferedOutputStream，因为它通过缓冲机制减少了磁盘I&#x2F;O操作的次数，从而提高了性能。</p>
<h5 id="FileInputStream和BufferedInputStream的区别"><a href="#FileInputStream和BufferedInputStream的区别" class="headerlink" title="FileInputStream和BufferedInputStream的区别"></a>FileInputStream和BufferedInputStream的区别</h5><p><strong>FileInputStream</strong><br>直接读取文件：FileInputStream 是用于从文件中读取数据的输入流。它是字节流的一种，直接连接到文件，并以字节为单位读取数据。<br>无缓冲：FileInputStream 在读取文件时，默认情况下不提供缓冲功能。这意味着每次调用 read() 方法时，都会直接从文件中读取数据，这可能会导致频繁的磁盘I&#x2F;O操作，从而影响性能。<br>用途：适用于需要直接读取文件内容，且对性能要求不是非常高的场景。<br><strong>BufferedInputStream</strong><br>缓冲读取：BufferedInputStream 为另一个输入流（如 FileInputStream）添加缓冲功能。它内部维护了一个缓冲区，数据首先被读取到这个缓冲区中，当需要读取数据时，直接从缓冲区中获取，减少了磁盘I&#x2F;O操作的次数。<br>性能提升：由于使用了缓冲机制，BufferedInputStream 相比 FileInputStream 提供了更好的读取性能。特别是在处理大文件或需要频繁读取文件的场景下，性能优势更加明显。<br>内部实现：BufferedInputStream 的底层仍旧调用了 FileInputStream 的 read0() 方法来从文件中读取数据，但它会在读取之前将数据预先读取到缓冲区中。当缓冲区中的数据被读取完毕后，它会再次从文件中读取数据填充缓冲区。<br>用途：适用于需要高效读取大量数据的场景，如文件解析、数据处理等。</p>
<h3 id="对象流-ObjectInputStream-和-ObjectOutputStream"><a href="#对象流-ObjectInputStream-和-ObjectOutputStream" class="headerlink" title="对象流-ObjectInputStream 和 ObjectOutputStream"></a>对象流-ObjectInputStream 和 ObjectOutputStream</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814214504483.png" alt="image-20240814214504483"></p>
<p>对象流介绍：</p>
<p>功能：提供了对基本类型或对象类型的序列化和反序列化的方法<br>ObjectOutputStream 提供 序列化功能<br>ObjectInputStream 提供 反序列化功能</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814214703422.png" alt="image-20240814214703422"></p>
<pre><code class="hljs plaintext">import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class c &#123;
    public static void main(String[] args)throws Exception&#123;
        //序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存
        String filePath = &quot;e:\\data.dat&quot;;
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath));
//序列化数据到 e:\data.dat
        oos.writeInt(100);// int -&gt; Integer (实现了 Serializable)
        oos.writeBoolean(true);// boolean -&gt; Boolean (实现了 Serializable)
        oos.writeChar(&#x27;a&#x27;);// char -&gt; Character (实现了 Serializable)
        oos.writeDouble(9.5);// double -&gt; Double (实现了 Serializable)
        oos.writeUTF(&quot;韩顺平教育&quot;);//String
//保存一个 dog 对象
        oos.writeObject(new Dog(&quot;旺财&quot;, 10, &quot;日本&quot;, &quot;白色&quot;));
        oos.close();
        System.out.println(&quot;数据保存完毕(序列化形式)&quot;);
    &#125;
&#125;
class Dog implements Serializable&#123;
    private String name;
    private int year;
    private String country;
    private String color;

    public Dog() &#123;
    &#125;

    public Dog(String name, int year, String country, String color) &#123;
        this.color=color;
        this.name=name;
        this.year=year;
        this.country=country;
    &#125;
&#125;</code></pre>

<p>自定义类要实现接口才能被保存，所以<code>class Dog implements Serializable</code>。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814220715469.png" alt="image-20240814220715469"></p>
<pre><code class="hljs plaintext">import java.io.FileInputStream;
import java.io.ObjectInputStream;
import java.io.Serializable;

public class c &#123;
    public static void main(String[] args)throws Exception&#123;
        // 1.创建流对象
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;e:\\data.dat&quot;));
// 2.读取， 注意顺序
        System.out.println(ois.readInt());
        System.out.println(ois.readBoolean());
        System.out.println(ois.readChar());
        System.out.println(ois.readDouble());
        System.out.println(ois.readUTF());
        System.out.println(ois.readObject());
// 3.关闭
        ois.close();
        System.out.println(&quot;以反序列化的方式读取(恢复)ok~&quot;);
    &#125;
&#125;
class Dog implements Serializable&#123;
    private String name;
    private int year;
    private String country;
    private String color;

    public Dog() &#123;
    &#125;

    public Dog(String name, int year, String country, String color) &#123;
        this.color=color;
        this.name=name;
        this.year=year;
        this.country=country;
    &#125;
&#125;</code></pre>

<p>读取的数据里面有自定义类那该自定义类得在程序里面定义了才可以被读取。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814221818587.png" alt="image-20240814221818587"></p>
<h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240815104404950.png" alt="image-20240815104404950"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240815104422172.png" alt="image-20240815104422172"></p>
<h3 id="转换流-InputStreamReader-和-OutputStreamWriter"><a href="#转换流-InputStreamReader-和-OutputStreamWriter" class="headerlink" title="转换流-InputStreamReader 和 OutputStreamWriter"></a>转换流-InputStreamReader 和 OutputStreamWriter</h3><p>使用 BufferedReader 对象读取txt文件，默认情况下，读取文件是按照 utf-8 编码，读取中文文件的时候可能会出现乱码问题，因为中文是多字节的，而utf-8是处理单字节的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240815105730149.png" alt="image-20240815105730149"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240815110054951.png" alt="image-20240815110054951"></p>
<pre><code class="hljs plaintext">import java.io.*;

public class c &#123;
    public static void main(String[] args) throws IOException &#123;
        String filePath = &quot;e:\\a.txt&quot;;
//解读
//1. 把 FileInputStream 转成 InputStreamReader
        //2. 指定编码 gbk
//InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath), &quot;gbk&quot;);
//3. 把 InputStreamReader 传入 BufferedReader
//BufferedReader br = new BufferedReader(isr);
//将 2 和 3 合在一起
        BufferedReader br = new BufferedReader(new InputStreamReader(
                new FileInputStream(filePath), &quot;gbk&quot;));
//4. 读取
        String s = br.readLine();
        System.out.println(&quot;读取内容=&quot; + s);
//5. 关闭外层流
        br.close();
    &#125;
&#125;</code></pre>

<p>但是为什么在txt文件里输入中文，使用BufferedReader读取的时候却可以正常输出呢？因为这个时候输入用的就是utf-8编码的，而BufferedReader默认是用utf-8编码的，所以可以正常输出，而转化流按gbk形式读取，所以会出现乱码情况。想用上面程序正常读取中文，那中文得是以gbk形式存储的才行。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240815112143826.png" alt="image-20240815112143826"></p>
<pre><code class="hljs plaintext">import java.io.*;

public class c &#123;
    public static void main(String[] args) throws IOException &#123;
        OutputStreamWriter osw =
                new OutputStreamWriter(new FileOutputStream(&quot;e:\\a.txt&quot;), &quot;gbk&quot;);
        // 2.写入
        osw.write(&quot;hello,韩顺平教育~&quot;);
// 3.关闭
        osw.close();
        System.out.println(&quot;保存成功~&quot;);
    &#125;
&#125;</code></pre>

<h2 id="打印流-PrintStream-和-PrintWriter"><a href="#打印流-PrintStream-和-PrintWriter" class="headerlink" title="打印流-PrintStream 和 PrintWriter"></a>打印流-PrintStream 和 PrintWriter</h2><p>只用输出流没有输入流。</p>
<p>PrintWriter：需要close才可以存入</p>
<pre><code class="hljs plaintext">import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class c &#123;
    public static void main(String[] args) throws IOException &#123;
        //PrintWriter printWriter = new PrintWriter(System.out);
        PrintWriter printWriter = new PrintWriter(new FileWriter(&quot;e:\\f2.txt&quot;));
        printWriter.print(&quot;hi, 北京你好~~~~&quot;);
        printWriter.close();//flush + 关闭流, 才会将数据写入到文件..
    &#125;
&#125;</code></pre>

<p>像下面的一样，这边也可以用write。</p>
<p>PrintStream：不用close就可以存入</p>
<pre><code class="hljs plaintext">import java.io.IOException;
import java.io.PrintStream;

public class c &#123;
    public static void main(String[] args) throws IOException &#123;
        PrintStream out = System.out;
//在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器
/*
public void print(String s) &#123;
if (s == null) &#123;
    s = &quot;null&quot;;
&#125;
write(s);
&#125;
*/
        out.print(&quot;john, hello&quot;);//也可以使用println自带换行。
//因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印/输出
        out.write(&quot;韩顺平,你好&quot;.getBytes());
        out.close();
//我们可以去修改打印流输出的位置/设备
//1. 输出修改成到 &quot;e:\\f1.txt&quot;
//2. &quot;hello, 韩顺平教育~&quot; 就会输出到 e:\f1.txt
//3. public static void setOut(PrintStream out) &#123;
// checkIO();
// setOut0(out); // native 方法，修改了 out
// &#125;
        System.setOut(new PrintStream(&quot;e:\\f1.txt&quot;));
        System.out.println(&quot;hello, 韩顺平教育~&quot;);
    &#125;
&#125;</code></pre>

<p>这个输入时覆盖写入，也不能使用追加写入，只能是覆盖。</p>
<h2 id="Properties-类"><a href="#Properties-类" class="headerlink" title="Properties 类"></a>Properties 类</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240816110944717.png" alt="image-20240816110944717"></p>
<p>传统方法：</p>
<pre><code class="hljs plaintext">import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
public class Properties01 &#123;
    public static void main(String[] args) throws IOException &#123;
//读取 mysql.properties 文件，并得到 ip, user 和 pwd
        BufferedReader br = new BufferedReader(new FileReader(&quot;src\\mysql.properties&quot;));
        String line = &quot;&quot;;
        while ((line = br.readLine()) != null) &#123; //循环读取
            String[] split = line.split(&quot;=&quot;);
//如果我们要求指定的 ip 值
            if (&quot;ip&quot;.equals(split[0])) &#123;
                System.out.println(split[0] + &quot;值是: &quot; + split[1]);
            &#125;
        &#125;
        br.close();
    &#125;
&#125;</code></pre>

<p>Properties介绍：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240816111311259.png" alt="image-20240816111311259"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240816111320424.png" alt="image-20240816111320424"></p>
<p>使用Properties类进行读取、创建：</p>
<pre><code class="hljs plaintext">//读取
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Properties;
public class Properties02 &#123;
    public static void main(String[] args) throws IOException &#123;
//使用 Properties 类来读取 mysql.properties 文件
//1. 创建 Properties 对象
        Properties properties = new Properties();
//2. 加载指定配置文件
        properties.load(new FileReader(&quot;src\\mysql.properties&quot;));
//3. 把 k-v 显示控制台
        properties.list(System.out);
//4. 根据 key 获取对应的值
        String user = properties.getProperty(&quot;user&quot;);
        String pwd = properties.getProperty(&quot;pwd&quot;);
        System.out.println(&quot;用户名=&quot; + user);
        System.out.println(&quot;密码是=&quot; + pwd);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">//创建
//Properties 父类是 Hashtable ， 底层就是 Hashtable 核心方法
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;
public class Properties03 &#123;
    public static void main(String[] args) throws IOException &#123;
//使用 Properties 类来创建 配置文件, 修改配置文件内容
        Properties properties = new Properties();
//创建
//1.如果该文件没有 key 就是创建
//2.如果该文件有 key ,就是修改
        properties.setProperty(&quot;charset&quot;, &quot;utf8&quot;);
        properties.setProperty(&quot;user&quot;, &quot;汤姆&quot;);//注意保存时，是中文的 unicode 码值
        properties.setProperty(&quot;pwd&quot;, &quot;888888&quot;);
//将 k-v 存储文件中即可
        properties.store(new FileOutputStream(&quot;src\\mysql2.properties&quot;), null);
        System.out.println(&quot;保存配置文件成功~&quot;);
    &#125;
&#125;</code></pre>

</article>
<div class="article-footer">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    

</div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/10/05/C%E8%AF%AD%E8%A8%80-0/">C语言</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/10/05/python2/">python2</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">Odegaard</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-text">输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C-%E2%80%9D%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">“+”的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0"><span class="toc-text">整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-text">字符型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B-boolean"><span class="toc-text">布尔类型 boolean</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">查看类的使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-text">基本数据类型转化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-text">自动类型转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-text">强制类型转化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8CString%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E5%8C%96"><span class="toc-text">基本数据类型和String类型的转化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">三元运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">位运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-text">程序控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if-%E6%99%AE%E9%80%9A%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F"><span class="toc-text">if+普通输入变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6"><span class="toc-text">switch+输入字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for"><span class="toc-text">for</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while%E5%92%8Cdo-while"><span class="toc-text">while和do while</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break"><span class="toc-text">break</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#equal%E6%96%B9%E6%B3%95"><span class="toc-text">equal方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#continue"><span class="toc-text">continue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%9F%A5%E6%89%BE"><span class="toc-text">数组，排序，查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%95%B0%E7%BB%84"><span class="toc-text">复制数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#arraycopy"><span class="toc-text">arraycopy ()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copyOfRange"><span class="toc-text">copyOfRange</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copyOf"><span class="toc-text">copyOf</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-%E6%89%A9%E5%AE%B9"><span class="toc-text">添加&#x2F;扩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-text">查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89"><span class="toc-text">面向对象编程（基础）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">类与对象的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%AD%97%E6%AE%B5"><span class="toc-text">属性&#x2F;成员变量&#x2F;字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">类和对象的内存分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-1"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="toc-text">成员方法传参机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-text">方法重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">构造方法&#x2F;构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">对象创建的流程分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E7%90%86%E8%A7%A3-hashcode"><span class="toc-text">初始理解+hashcode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="toc-text">深入理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-text">注意和细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89"><span class="toc-text">面向对象编程（中级）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">IDEA常用快捷键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85"><span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%8C%85"><span class="toc-text">引入包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sort%E6%8E%92%E5%BA%8F%E3%80%81collections%E3%80%81Integer"><span class="toc-text">sort排序、collections、Integer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E8%AE%A8%E8%AE%BA"><span class="toc-text">深入讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#super"><span class="toc-text">super</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90"><span class="toc-text">本质分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-%E8%A6%86%E7%9B%96"><span class="toc-text">方法重写&#x2F;覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-1"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-text">向上和向下转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-text">动态绑定机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">多态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-text">多态参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="toc-text">Object类详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95"><span class="toc-text">equals方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode-%E6%96%B9%E6%B3%95"><span class="toc-text">hashCode 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-%E6%96%B9%E6%B3%95"><span class="toc-text">toString 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89"><span class="toc-text">面向对象编程（高级）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">类变量和类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-text">类变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">类方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3main%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95"><span class="toc-text">理解main方法语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">抽象类最佳实践-模板设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-2"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text">接口与继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E6%80%81%E7%89%B9%E6%80%A7"><span class="toc-text">接口的多态特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">匿名内部类（重要）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">静态内部类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-text">枚举和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-3"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-text">自定义类实现枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-text">enum关键字实现枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E5%A2%9E%E5%BC%BAfor"><span class="toc-text">enum常用方法+增强for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">enum实现接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-4"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Override"><span class="toc-text">@Override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deprecated"><span class="toc-text">@Deprecated</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SuppressWarnings"><span class="toc-text">@SuppressWarnings</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8-Exception"><span class="toc-text">异常-Exception</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-2"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-5"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-text">运行时异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8"><span class="toc-text">编译异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">try-catch 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8try-catch%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-text">利用try-catch解决问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throws-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">throws 异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-text">自定义异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">包装类和基本数据类型的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%92%8C-String-%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">包装类型和 String 类型的相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer-%E7%B1%BB%E5%92%8C-Character-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Integer 类和 Character 类的常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-6"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">字符串的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%96"><span class="toc-text">String类的常用方法+进制转化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%96"><span class="toc-text">进制转化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer-%E7%B1%BB"><span class="toc-text">StringBuffer 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%92%8CStringBuffer%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">String和StringBuffer的相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E9%A2%98"><span class="toc-text">测试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder-%E7%B1%BB"><span class="toc-text">StringBuilder 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%AF%94%E8%BE%83"><span class="toc-text">介绍和比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">StringBuilder 常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math%E7%B1%BB-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E5%9D%87%E4%B8%BA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-text">Math类-常用方法（均为静态方法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays-%E7%B1%BB"><span class="toc-text">Arrays 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E9%9D%99%E6%80%81%EF%BC%89"><span class="toc-text">常用方法（静态）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">sort排序的定制排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-%E7%B1%BB-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">System 类-常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigInteger-%E5%92%8C-BigDecimal-%E7%B1%BB"><span class="toc-text">BigInteger 和 BigDecimal 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text">日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text">第一代日期类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text">第二代日期类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB%EF%BC%88%E6%84%9F%E8%A7%89%E6%AF%94%E8%BE%83%E5%A5%BD%E7%94%A8%EF%BC%89"><span class="toc-text">第三代日期类（感觉比较好用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DateTimeFormatter-%E6%A0%BC%E5%BC%8F%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text">DateTimeFormatter 格式日期类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instant-%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">Instant 时间戳</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-text">集合的框架体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Collection 接口和常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">Collection 接口实现类的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection-%E6%8E%A5%E5%8F%A3%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0%E6%96%B9%E5%BC%8F"><span class="toc-text">Collection 接口遍历元素方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">使用 Iterator(迭代器)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF%E5%A2%9E%E5%BC%BA"><span class="toc-text">for 循环增强</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">List 接口和常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">介绍和常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List-%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">List 的三种遍历方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">ArrayList 底层结构和源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-text">Vector 底层结构和源码剖析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text">LinkedList 底层结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Set 接口和常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">Set 接口实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet"><span class="toc-text">HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-7"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6-%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">底层机制+存储自定义类时的注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashSet-double%E7%B1%BB%E7%9A%84compare"><span class="toc-text">LinkedHashSet+double类的compare	</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Map 接口和常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-8"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Map 接口常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">Map 接口实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashtable"><span class="toc-text">Hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Properties"><span class="toc-text">Properties</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">开发中如何选择集合实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">Collections 工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C-Collections%E9%87%8C%E7%9A%84static%E6%96%B9%E6%B3%95"><span class="toc-text">排序操作(Collections里的static方法)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-3"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">泛型的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-text">自定义泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">自定义泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">自定义泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">自定义泛型方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">泛型的继承和通配符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUnit"><span class="toc-text">JUnit</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO-%E6%B5%81"><span class="toc-text">IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-text">文件流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">常用的文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">创建文件对象相关构造器和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="toc-text">获取文件的相关信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C%E5%92%8C%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4"><span class="toc-text">目录的操作和文件删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-%E6%B5%81%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">IO 流原理及流的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileInputStream-%E6%96%87%E4%BB%B6%E2%80%93-%E7%A8%8B%E5%BA%8F"><span class="toc-text">FileInputStream(文件–&gt; 程序)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileOutputStream-%E7%A8%8B%E5%BA%8F-%E6%96%87%E6%9C%AC"><span class="toc-text">FileOutputStream(程序-&gt;文本)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileReader-%E5%92%8C-FileWriter-%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-text">FileReader 和 FileWriter(处理字符流)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-text">节点流和处理流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-text">处理流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedReader-%E5%92%8C-BufferedWriter-%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C"><span class="toc-text">BufferedReader 和 BufferedWriter(字符操作)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedInputStream-%E5%92%8C-BufferedOutputStream-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-text">BufferedInputStream 和 BufferedOutputStream(字节流)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FileOutputStream%E5%92%8CBufferedOutputStream%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">FileOutputStream和BufferedOutputStream的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FileInputStream%E5%92%8CBufferedInputStream%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">FileInputStream和BufferedInputStream的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81-ObjectInputStream-%E5%92%8C-ObjectOutputStream"><span class="toc-text">对象流-ObjectInputStream 和 ObjectOutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">标准输入输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81-InputStreamReader-%E5%92%8C-OutputStreamWriter"><span class="toc-text">转换流-InputStreamReader 和 OutputStreamWriter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81-PrintStream-%E5%92%8C-PrintWriter"><span class="toc-text">打印流-PrintStream 和 PrintWriter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Properties-%E7%B1%BB"><span class="toc-text">Properties 类</span></a></li></ol></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.md-text img:not([class]), .md-text .image-container img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
