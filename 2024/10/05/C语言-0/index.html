<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>C语言 | coygOdegaard</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="size和strlen  若先定义了一个字符数组却没有直接赋值，那么后面再直接赋值即B是不行的；采用A一个个输入可以；只能用C进行赋值。 在字符数组中，sizeof会将’\0’计算在数组大小里面；strlen 则不会。 指针类函数指针    指针数组是数组，存储的是指针。 例：int arr[10]&#x3D;{0};   &#x2F;&#x2F;整型数组，数组用来存放整型(int)     in">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言">
<meta property="og:url" content="http://example.com/2024/10/05/C%E8%AF%AD%E8%A8%80-0/index.html">
<meta property="og:site_name" content="coygOdegaard">
<meta property="og:description" content="size和strlen  若先定义了一个字符数组却没有直接赋值，那么后面再直接赋值即B是不行的；采用A一个个输入可以；只能用C进行赋值。 在字符数组中，sizeof会将’\0’计算在数组大小里面；strlen 则不会。 指针类函数指针    指针数组是数组，存储的是指针。 例：int arr[10]&#x3D;{0};   &#x2F;&#x2F;整型数组，数组用来存放整型(int)     in">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231120202724760.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231121170743913.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231121170813279.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240103205959123.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240103211527763.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240104192506645.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240104193736429.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240104195039871.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231124214349048.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231124214430334.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231124214842663.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231124215609356.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231124222009122.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231124222927472.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231124223145890.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231124223306726.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231204222701538.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231124223539702.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231128102311992.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231128104301300.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231128215809538.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231128233441169.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231129145750566.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231129155416219.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231129155741175.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231205155942730.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231205162854728.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231205163707012.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20231205164222817.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240122210202548.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240122211732940.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240122212028150.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231211212515250.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231211205858599.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20240125161412126.png">
<meta property="og:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20240121164754559.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240125161931649.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240206211018948.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240125221755975.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240125221716337.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240125221950701.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240125222037168.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240125222135444.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240213204949165.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240213231214406.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240213231317116.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240213231332778.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240213231435350.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240213231503510.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240213231542438.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240213231625192.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240213231753060.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240213231809288.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240213231832523.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240213231921627.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240215152206911.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240215152218344.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240217203955099.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240217213347657.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240217213607992.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240217213623742.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240217220348613.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240217213941826.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240216221429404.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240216221444962.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240216223851646.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240216223902150.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240217104124564.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240217110715052.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240217110742049.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240217151215674.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240217151257573.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240217151318182.png">
<meta property="og:image" content="http://example.com/source/imgs/$%7Bfiilname%7D/image-20240217152230808.png">
<meta property="article:published_time" content="2024-10-05T09:52:53.000Z">
<meta property="article:modified_time" content="2024-10-05T10:26:25.374Z">
<meta property="article:author" content="Odegaard">
<meta property="article:tag" content="语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/10/05/source/imgs/$%7Bfiilname%7D/image-20231120202724760.png">
  
    <link rel="alternative" href="/atom.xml" title="coygOdegaard" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/三笠.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">Odegaard</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 10px;">大数据</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">语言</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a gunner.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/三笠.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-C语言-0" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/05/C%E8%AF%AD%E8%A8%80-0/" class="article-date">
  	<time datetime="2024-10-05T09:52:53.000Z" itemprop="datePublished">2024-10-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C语言
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%AD%E8%A8%80/" rel="tag">语言</a></li></ul>
	</div>

        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="size和strlen"><a href="#size和strlen" class="headerlink" title="size和strlen"></a>size和strlen</h1><img src="../source/imgs/${fiilname}/image-20231120202724760.png" alt="image-20231120202724760" style="zoom:50%;" />

<p>若先定义了一个字符数组却没有直接赋值，那么后面再直接赋值即B是不行的；采用A一个个输入可以；只能用C进行赋值。</p>
<p>在字符数组中，sizeof会将’\0’计算在数组大小里面；strlen 则不会。</p>
<h1 id="指针类"><a href="#指针类" class="headerlink" title="指针类"></a>指针类</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><img src="../source/imgs/${fiilname}/image-20231121170743913.png" alt="image-20231121170743913" style="zoom:50%;" />

<img src="../source/imgs/${fiilname}/image-20231121170813279.png" alt="image-20231121170813279" style="zoom:50%;" />

<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>是数组，存储的是指针。</p>
<p>例：int arr[10]&#x3D;{0};   &#x2F;&#x2F;整型数组，数组用来存放整型(int)</p>
<pre><code>    int* parr[4];       //指针数组，数组用来存放整型指针(int *)
</code></pre>
<p><strong>[]的优先级大于</strong>*</p>
<p>用法一：存储一些变量的地址</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240103205959123.png" alt="image-20240103205959123"></p>
<p>用法二：用来存储数组的头地址</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240103211527763.png" alt="image-20240103211527763"></p>
<h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><p>是指针，存储的是数组的地址。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240104192506645.png" alt="image-20240104192506645"></p>
<p>int arr[10]</p>
<p>arr和&amp;arr的输出结果相同。但是&amp;arr表示的是一整个数组首元素的地址，而不是数组单个首元素的地址，所以&amp;arr+1，逃过的是整个数组的大小；arr表示的是数组首元素的地址，所以arr+1代表的是跳过一个元素。</p>
<p><strong>用法一</strong>：用来表示一维数组</p>
<p>（1）第一种输出方式</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240104193736429.png" alt="image-20240104193736429"></p>
<p>解引用：指针被解除引用就是它所指向的变量了，解引用的操作符是’*’。</p>
<p>例如某指针变量p，解引用就是*p，也就是p所指向的变量了。</p>
<p>（2）第二种输出方式</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240104195039871.png" alt="image-20240104195039871"></p>
<p><strong>用法二</strong>：处理二维数组，较经常使用，用于此比较简单</p>
<p>看课本去</p>
<h1 id="c预处理器"><a href="#c预处理器" class="headerlink" title="c预处理器"></a>c预处理器</h1><p><strong>预处理器后面不需要“；”</strong></p>
<img src="../source/imgs/${fiilname}/image-20231124214349048.png" alt="image-20231124214349048" style="zoom:60%;" />

<p>某种程度上”#define”后面的名称相当于函数名称，再后面的东西相当于函数体</p>
<img src="../source/imgs/${fiilname}/image-20231124214430334.png" alt="image-20231124214430334" style="zoom:60%;" />

<img src="../source/imgs/${fiilname}/image-20231124214842663.png" alt="image-20231124214842663" style="zoom:60%;" />

<p>这些宏不能被修改，DATE和TIME得用%s。每个两侧是两个下划线。</p>
<h2 id=""><a href="#" class="headerlink" title="\"></a>\</h2><p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符“\”，然后就可以换行继续写了。可以参考下面的程序</p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><img src="../source/imgs/${fiilname}/image-20231124215609356.png" alt="image-20231124215609356" style="zoom:50%;" />

<p>使用“#”即可输出a,b且不需要定义a和b。message_for有点像函数，但从某种程度上比函数方便。</p>
<p><strong>“#”不能在程序中使用</strong></p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><img src="../source/imgs/${fiilname}/image-20231124222009122.png" alt="image-20231124222009122" style="zoom:50%;" />

<h2 id="defined"><a href="#defined" class="headerlink" title="defined()"></a>defined()</h2><p>预处理器 <strong>defined</strong> 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符<strong>已定义，则值为真（非零）</strong>。如果指定的标识符<strong>未定义，则值为假（零）</strong>。</p>
<img src="../source/imgs/${fiilname}/image-20231124222927472.png" alt="image-20231124222927472" style="zoom:50%;" />

<h2 id="参数化的宏"><a href="#参数化的宏" class="headerlink" title="参数化的宏"></a>参数化的宏</h2><p>可以用来写函数</p>
<img src="../source/imgs/${fiilname}/image-20231124223145890.png" alt="image-20231124223145890" style="zoom:60%;" />

<p>在使用带有参数的宏之前，必须使用 <strong>#define</strong> 指令定义。<strong>参数列表是括在圆括号内</strong>，且必须紧跟在宏名称的后边。<strong>宏名称和左圆括号之间不允许有空格</strong>。</p>
<img src="../source/imgs/${fiilname}/image-20231124223306726.png" alt="image-20231124223306726" style="zoom:60%;" />

<img src="../source/imgs/${fiilname}/image-20231204222701538.png" alt="image-20231204222701538" style="zoom:67%;" />

<p>使用#define含参时，<strong>参数括号很重要</strong></p>
<img src="../source/imgs/${fiilname}/image-20231124223539702.png" alt="image-20231124223539702" style="zoom:60%;" />

<h1 id="算数转化"><a href="#算数转化" class="headerlink" title="算数转化"></a>算数转化</h1><img src="../source/imgs/${fiilname}/image-20231128102311992.png" alt="image-20231128102311992" style="zoom:50%;" />

<p><strong>常用的算术转换不适用于赋值运算符、逻辑运算符 &amp;&amp; 和 ||。</strong></p>
<p>对于赋值运算符，如 “&#x3D;”，它并不执行算术转换。如果一个变量是 int 类型，而另一个变量是 double 类型，那么它们之间进行赋值运算时，double 类型的值不会被转换成 int 类型，而是直接将 double 类型的值赋给 int 类型的变量。</p>
<p>对于逻辑运算符 “&amp;&amp;” 和 “||”，C 语言中也没有进行算术转换。这两个运算符只对真和假进行逻辑判断，而不是进行算术运算。因此，无论表达式两边的值是什么类型，都不会进行算术转换。</p>
<p>例：</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()

&#123;

int a = 5;
double b = 3.14;

// 赋值运算不执行算术转换
a = b; // a 的值现在是 3.14，而不是 3

// 逻辑运算符也不执行算术转换
if (a &gt; b) &#123; // 这里不会试图比较两个数的数值大小，而是直接比较它们的类型和值
    printf(&quot;a is greater than b&quot;);
&#125;

&#125;</code></pre>

<img src="../source/imgs/${fiilname}/image-20231128104301300.png" alt="image-20231128104301300" style="zoom:80%;" />

<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h2 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h2><p>用来打开文件，基本语法格式：FILE *fopen( const char *filename, const char *mode );</p>
<p>在这里，<strong>filename</strong> 是字符串，用来命名文件，访问模式 <strong>mode</strong> 的值可以是下列值中的一个：</p>
<img src="../source/imgs/${fiilname}/image-20231128215809538.png" alt="image-20231128215809538" style="zoom:67%;" />

<pre><code class="hljs plaintext">`#include &lt;stdio.h&gt;`
`int main() &#123;`
    `FILE *fp;`
    `char c;`
    `fp = fopen(&quot;test.txt&quot;, &quot;r&quot;); // 打开名为test.txt的文件，以只读方式打开`
    `if (fp == NULL) &#123; // 如果打开文件失败`
        `printf(&quot;Failed to open file.\n&quot;);`
        `return 1;`
    `&#125;`
    `while ((c = fgetc(fp)) != EOF) &#123; // 从文件中读取一个字符，直到文件末尾`
        `printf(&quot;%c&quot;, c); // 输出读取到的字符`
    `&#125;`
    `fclose(fp); // 关闭文件`
    `return 0;`
`&#125;`</code></pre>



<h2 id="fclose函数"><a href="#fclose函数" class="headerlink" title="fclose函数"></a>fclose函数</h2><p>关闭文件，基本语法格式：int fputc( int c, FILE *fp );</p>
<p>如果成功关闭文件，<strong>fclose( )</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。</p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>将<strong>字符</strong>写入文件中：**int fputc( int c, FILE *fp )**;函数 <strong>fputc()</strong> 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <strong>EOF</strong>。</p>
<p>将<strong>字符串</strong>写入文件中：**int fputs( const char *s, FILE *fp )**;函数 <strong>fputs()</strong> 把字符串 <strong>s</strong> 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <strong>EOF</strong>。</p>
<p>也可以使用 <strong>int fprintf(FILE *fp,const char *format, …)</strong> 函数把一个字符串写入到文件中。</p>
<pre><code class="hljs plaintext">`#include &lt;stdio.h&gt;`

`int main()`
`&#123;`
   `FILE *fp = NULL;`

   `fp = fopen(&quot;/tmp/test.txt&quot;, &quot;w+&quot;);`
   `fprintf(fp, &quot;This is testing for fprintf...\n&quot;);`
   `fputs(&quot;This is testing for fputs...\n&quot;, fp);`
   `fclose(fp);`
`&#125;`</code></pre>

<p>当上面的代码被编译和执行时，它会在 &#x2F;tmp 目录中创建一个新的文件 <strong>test.txt</strong>，并使用两个不同的函数写入两行。接下来让我们来读取这个文件。</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>读取单个字符：int fgetc( FILE * fp );</p>
<p>读取字符串：char *fgets( char *buf, int n, FILE *fp );函数 <strong>fgets()</strong> 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 <strong>buf</strong>（比如字符数组），并在最后追加一个 <strong>null</strong> 字符来终止字符串。如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。</p>
<p>您也可以使用 <strong>int fscanf(FILE *fp, const char *format, …)</strong> 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。</p>
<img src="../source/imgs/${fiilname}/image-20231128233441169.png" alt="image-20231128233441169" style="zoom:80%;" />

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>先找递归出口；相当于while循环，没有符合出口条件就继续递归。</p>
<img src="../source/imgs/${fiilname}/image-20231129145750566.png" alt="image-20231129145750566" style="zoom:50%;" />

<p>与直接的语句(如while循环)相比，递归函数会耗费更多的运行时间，并且要占用大量的栈空间。</p>
<p>采用递归方法来解决问题，必须符合以下三个条件：</p>
<p>1、可以把要解决的问题转化为一个新问题，而这个新的问题的解决方法仍与原来的解决方法相同，只是所处理的对象有规律地递增或递减。</p>
<p>说明：解决问题的方法相同，调用函数的参数每次不同（有规律的递增或递减），如果没有规律也就不能适用递归调用。</p>
<p>2、可以应用这个转化过程使问题得到解决。</p>
<p>说明：使用其他的办法比较麻烦或很难解决，而使用递归的方法可以很好地解决问题。</p>
<p>3、必定要有一个明确的结束递归的条件。</p>
<p>说明：一定要能够在适当的地方结束递归调用。不然可能导致系统崩溃。</p>
<p><strong>深度优先遍历</strong></p>
<p><strong>题目：</strong>将一个正整数N分解成几个正整数相加，可以有多种分解方法，例如7&#x3D;6+1，7&#x3D;5+2，7&#x3D;5+1+1，…。编程求出正整数N的所有整数分解式子。</p>
<p>输入格式：</p>
<p>每个输入包含一个测试用例，即正整数N (0&lt;N≤30)。</p>
<p>输出格式：</p>
<p>按递增顺序输出N的所有整数分解式子。递增顺序是指：对于两个分解序列<em>N</em>1&#x3D;{<em>n</em>1,<em>n</em>2,⋯}和<em>N</em>2&#x3D;{<em>m</em>1,<em>m</em>2,⋯}，若存在<em>i</em>使得<em>n</em>1&#x3D;<em>m</em>1,⋯,<em>n**i</em>&#x3D;<em>m**i</em>，但是<em>n**i</em>+1&lt;<em>m**i</em>+1,则<em>N</em>1序列必定在<em>N</em>2序列之前输出。每个式子由小到大相加，式子间用分号隔开，且每输出4个式子后换行。</p>
<p>输入样例：</p>
<pre><code class="hljs in">7</code></pre>

<p>输出样例：</p>
<pre><code class="hljs out">7=1+1+1+1+1+1+1;7=1+1+1+1+1+2;7=1+1+1+1+3;7=1+1+1+2+2
7=1+1+1+4;7=1+1+2+3;7=1+1+5;7=1+2+2+2
7=1+2+4;7=1+3+3;7=1+6;7=2+2+3
7=2+5;7=3+4;7=7</code></pre>

<p>a[0]&#x3D;1-&gt;a[1]&#x3D;1-&gt;a[2]&#x3D;1-&gt;index&#x3D;3</p>
<p>​			-&gt;a[1]&#x3D;2-&gt;index&#x3D;2</p>
<p>a[0]&#x3D;2-&gt;无法继续，递归没有出口就不用理会</p>
<p>a[0]&#x3D;3-&gt;index&#x3D;1</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
int part[30]=&#123;0&#125;;
int n,cout=0;
void divide(int sub,int min,int m)
&#123;
	if(sub==0)
	&#123;
		printf(&quot;%d=%d&quot;,n,part[0]);
		for(int i=1;i&lt;m;i++)
			printf(&quot;+%d&quot;,part[i]);
		if(part[0]==n);//为了让最后一个输出没有分号
		else if(cout&lt;3)
		&#123;
			cout++;
			printf(&quot;;&quot;);
		&#125;
		else&#123;
			cout=0;
			printf(&quot;\n&quot;);
		&#125;
	&#125;
	else&#123;
		for(int i=min;i&lt;=sub;i++)
		&#123;
			part[m]=i;
			min=i;
			divide(sub-min,min,m+1);
		&#125;	
	&#125;
&#125;
int main() &#123;
	int num;
	scanf(&quot;%d&quot;,&amp;num);
	n=num;
	divide(num,1,0);
    return 0;
&#125;</code></pre>



<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>定义一个函数，函数可以接受可变数量的参数.</p>
<img src="../source/imgs/${fiilname}/image-20231129155416219.png" alt="image-20231129155416219" style="zoom:75%;" />

<p>常用的宏有：</p>
<ul>
<li><code>**va_start(ap, last_arg)**</code>：初始化可变参数列表。<code>ap</code> 是一个 <code>va_list</code> 类型的变量，<code>last_arg</code> 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 <code>ap</code> 指向可变参数列表中的第一个参数。</li>
<li><code>**va_arg(ap, type)**</code>：获取可变参数列表中的下一个参数。<code>ap</code> 是一个 <code>va_list</code> 类型的变量，<code>type</code> 是下一个参数的类型。该宏返回类型为 <code>type</code> 的值，并将 <code>ap</code> 指向下一个参数。</li>
<li><code>**va_end(ap)**</code>：结束可变参数列表的访问。<code>ap</code> 是一个 <code>va_list</code> 类型的变量。该宏将 <code>ap</code> 置为 <code>NULL</code>。</li>
</ul>
<pre><code class="hljs plaintext">`#include &lt;stdio.h&gt;`
`#include &lt;stdarg.h&gt;`

`double average(int num,...)`
`&#123;`

    va_list valist;
    double sum = 0.0;
    int i;
     
    /* 为 num 个参数初始化 valist */
    va_start(valist, num);
     
    /* 访问所有赋给 valist 的参数 */
    for (i = 0; i &lt; num; i++)
    &#123;
       sum += va_arg(valist, int);
    &#125;
    /* 清理为 valist 保留的内存 */
    va_end(valist);
     
    return sum/num;

`&#125;`

`int main()`
`&#123;`
   `printf(&quot;Average of 2, 3, 4, 5 = %f\n&quot;, average(4, 2,3,4,5));`
   `printf(&quot;Average of 5, 10, 15 = %f\n&quot;, average(3, 5,10,15));`
`&#125;`</code></pre>

<p>输出结果为：Average of 2, 3, 4, 5 &#x3D; 3.500000<br>                       Average of 5, 10, 15 &#x3D; 10.000000</p>
<img src="../source/imgs/${fiilname}/image-20231129155741175.png" alt="image-20231129155741175" style="zoom:60%;" />

<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><img src="../source/imgs/${fiilname}/image-20231205155942730.png" alt="image-20231205155942730" style="zoom:80%;" />

<p><strong>malloc的内存空间不会初始化，值是未知的，calloc的内存空间会被初始化为0</strong></p>
<p><strong>realloc里面如果那个数组原本的空间为0的话，那realloc的功能相当于malloc</strong></p>
<p>但是，如果您预先不知道需要存储的文本长度，例如您想存储有关一个主题的详细描述。在这里，我们<strong>需要定义一个指针</strong>，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示：</p>
<img src="../source/imgs/${fiilname}/image-20231205162854728.png" alt="image-20231205162854728" style="zoom:80%;" />

<p>上面的程序也可以使用 <strong>calloc()</strong> 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：</p>
<pre><code class="hljs plaintext">calloc(200, sizeof(char));</code></pre>

<h2 id="重新调整内存的大小"><a href="#重新调整内存的大小" class="headerlink" title="重新调整内存的大小"></a>重新调整内存的大小</h2><img src="../source/imgs/${fiilname}/image-20231205163707012.png" alt="image-20231205163707012" style="zoom:80%;" />

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code class="hljs plaintext">Name = Zara Ali
Description: Zara ali a DPS student.She is in class 10th</code></pre>

<p>您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20231205164222817.png" alt="image-20231205164222817"></p>
<h2 id="申请二维数组的空间"><a href="#申请二维数组的空间" class="headerlink" title="申请二维数组的空间"></a>申请二维数组的空间</h2><p><strong>方法一</strong>：二级指针</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240122210202548.png" alt="image-20240122210202548"></p>
<p>地址是连续的</p>
<p><strong>方法二</strong>：数组指针</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240122211732940.png" alt="image-20240122211732940"></p>
<p><strong>方法三</strong>：一维数组模拟二维数组</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240122212028150.png" alt="image-20240122212028150"></p>
<p>一般使用第一种和第二种方法，如果以指针为参数传递到一个函数一个二维数组要用方法一，方法二会报错。但是方法二简洁，然后用完要释放。</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>冒泡排序里，j&#x3D;0;</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;
	int a[5]=&#123;3,1,7,5,4&#125;;
	int i,j,t;
	for(i=1;i&lt;5;i++)&#123;
		for(j=0;j&lt;5;j++)&#123;
			if(a[j]&gt;a[j+1])&#123;
				t=a[j];
				a[j]=a[j+1];
				a[j+1]=t;
			&#125;
		&#125;
	&#125;
	for(i=0;i&lt;5;i++)
		printf(&quot;%d&quot;,a[i]);
	return 0;
&#125;</code></pre>

<p>选择排序：</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;
	int a[5]=&#123;3,1,7,5,4&#125;;
	int i,j,t;
	for(i=0;i&lt;4;i++)&#123;
		for(j=i;j&lt;5;j++)&#123;
			if(a[j]&lt;a[i])&#123;
				t=a[i];
				a[i]=a[j];
				a[j]=t;
			&#125;
		&#125;
	&#125;
	for(i=0;i&lt;5;i++)
		printf(&quot;%d &quot;,a[i]);
	return 0;
&#125;</code></pre>

<img src="../source/imgs/${fiilname}/image-20231211212515250.png" alt="image-20231211212515250" style="zoom:80%;" />

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><img src="../source/imgs/${fiilname}/image-20231211205858599.png" alt="image-20231211205858599" style="zoom:60%;" />

<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
void insertion_sort(int a[], int len)&#123;
    int i,t,temp;
    for(t=1;t&lt;len;t++)&#123;
    	temp=a[t];
    	for(i=t;i&gt;=0;i--)&#123;
    		if(a[i-1]&gt;temp)
				a[i]=a[i-1];
    		else &#123;
    			a[i]=temp;
    			break;
			&#125;
		&#125;
	&#125;
&#125;
int main() &#123;
    int arr[] = &#123; 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 &#125;;
    int len = (int) sizeof(arr) / sizeof(*arr);
    insertion_sort(arr, len);
    int i;
    for (i = 0; i &lt; len; i++)
		printf(&quot;%d &quot;,arr[i]);
    return 0;
&#125;</code></pre>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>稳定，速度快，适合大数据量的排序</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
void printA(int* arr,int len)&#123;
	for(int i=0;i&lt;len;i++)&#123;
		printf(&quot;%d &quot;,arr[i]);
	&#125;
	printf(&quot;\n&quot;);
&#125;
void merge(int* arr,int left,int mid,int right)&#123;
	int i=left;
	int j=mid;
	int* temp=(int*)malloc((right-left)*4);
	int index=0;
	while(i&lt;mid&amp;&amp;j&lt;right)&#123;
		if(arr[i]&lt;arr[j])&#123;
			temp[index]=arr[i];
			i++;
		&#125;else&#123;
			temp[index]=arr[j];
			j++;
		&#125;
		index++;
	&#125;
	while(i&lt;mid)&#123;
		temp[index]=arr[i];
		index++;
		i++;
	&#125;
	while(j&lt;right)&#123;
		temp[index]=arr[j];
		index++;
		j++;
	&#125;for(int i=0;i&lt;index;i++)&#123;
		arr[left+i]=temp[i];
	&#125;
	free(temp);
&#125;
void mergeSort(int* arr,int left,int right)&#123;
	if(right-left&lt;=1)&#123;
		return;
	&#125;
	int mid=(left+right)/2;
	mergeSort(arr,left,mid);
	mergeSort(arr,mid,right);
	merge(arr,left,mid,right);
&#125;
int main()&#123;
	int* arr1=(int*)malloc(4*4);
	arr1[0]=10;
	arr1[1]=9;
	arr1[2]=8;
	arr1[3]=7;
	mergeSort(arr1,0,4);
	printA(arr1,4);
	return 0;
&#125;</code></pre>



<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>还没写</p>
<h1 id="亦或"><a href="#亦或" class="headerlink" title="亦或"></a>亦或</h1><p>异或运算符”∧”也称XOR运算符。它的规则是若参加运算的两个二进位同号，则结果为0（假）；异号则为1（真）。即 0∧0＝0，0∧1＝1， 1^0&#x3D;1，1∧1＝0。</p>
<p><strong>相同为0，不相同为1</strong></p>
<p>运算 说明<br>0 ^ 0&#x3D;0,0 ^ 1&#x3D;1，0亦或任何数，其结果&#x3D;任何数<br>1 ^ 0&#x3D;1,1 ^ 1&#x3D;0，1亦或任何数，其结果&#x3D;任何数取反<br>x ^ x&#x3D;0 任何数异或自己，等于把自己置0</p>
<img src="../source/imgs/${fiilname}/image-20240125161412126.png" alt="image-20240125161412126" style="zoom:80%;" />

<p>常见用途:</p>
<p>（1）使特定位翻转</p>
<p>比如：01111010，想使其低4位翻转，即1变为0，0变为1。可以将它与00001111进行∧运算，即</p>
<p>​         0111 1010</p>
<p>​         0000 1111</p>
<p>结果：    0111 0101</p>
<p>结果值的低4位正好是原数低4位的翻转。要使哪几位翻转就将与其∧运算的该几位置为1即可。这是因为原数中值为1的位与1进行∧运算得0，原数中的位值0与1进行∧运算的结果得1。</p>
<p>(2)实现两个值的交换</p>
<p>通过按位异或运算，可以实现两个值的交换，而不必使用临时变量。例如交换两个整数a&#x3D;3，b&#x3D;4的值，可通过下列语句实现：</p>
<p>a＝a∧b;<br>b＝b∧a;<br>a&#x3D;a∧b;</p>
<p>0011 —a &#x3D;3</p>
<p>0100 —b &#x3D;4</p>
<p>-———-</p>
<p>0111—-a &#x3D;7</p>
<p>0100—-b &#x3D;4</p>
<p>-———-</p>
<p>0011—–b &#x3D;3</p>
<p>0111——a &#x3D;&#x3D;7</p>
<p>0100—-a &#x3D;&#x3D;3</p>
<p>（3）还可以找到一组数内只出现一次的数，只需要把所有数一起做异或运算如：1 2 3 4 5 1 2 3 4</p>
<p>因为1^1&#x3D;0，2^2&#x3D;0，3^3&#x3D;0，4^4&#x3D;0，5^0&#x3D;5</p>
<p>又异或满足交换律和结合律</p>
<p>1^2^3^4^5^1^2^3^4&#x3D;5</p>
<p>所以5只出现了一次</p>
<h1 id="strtok函数"><a href="#strtok函数" class="headerlink" title="strtok函数"></a>strtok函数</h1><p><code>strtok</code> 函数是 C 语言中用于分割字符串的函数。它在字符串中查找特定的分隔符，并将字符串分割成多个子字符串。以下是一些简单的 <code>strtok</code> 函数的例子：</p>
<p>一、基本使用</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() &#123;
    char str[] = &quot;apple,orange,banana&quot;;
    char *token = strtok(str, &quot;,&quot;);
    

while (token != NULL) &#123;
    printf(&quot;%s\n&quot;, token);
    token = strtok(NULL, &quot;,&quot;);
&#125;

return 0;

&#125;</code></pre>

<p>二、使用不同分隔符</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() &#123;
    char str[] = &quot;apple orange:banana&quot;;
    char *token = strtok(str, &quot; :&quot;);
    

while (token != NULL) &#123;
    printf(&quot;%s\n&quot;, token);
    token = strtok(NULL, &quot; :&quot;);
&#125;

return 0;

&#125;</code></pre>

<p>三、处理多个连续分隔符</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() &#123;
    char str[] = &quot;apple,,orange,,banana&quot;;
    char *token = strtok(str, &quot;,&quot;);
    

while (token != NULL) &#123;
    printf(&quot;%s\n&quot;, token);
    token = strtok(NULL, &quot;,&quot;);
&#125;

return 0;

&#125;</code></pre>

<p>输出：</p>
<pre><code class="hljs plaintext">apple
orange
banana</code></pre>

<p>请注意，<code>strtok</code> 函数在每次调用时会修改原始字符串，用 <code>NULL</code> 作为第一个参数来继续处理相同的字符串。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;

int main()
&#123;
    int i, n, t1 = 0, t2 = 1, nextTerm;

    printf(&quot;输出几项: &quot;);
    scanf(&quot;%d&quot;, &amp;n);
     
    printf(&quot;斐波那契数列: &quot;);
     
    for (i = 1; i &lt;= n; ++i)
    &#123;
        printf(&quot;%d, &quot;, t1);
        nextTerm = t1 + t2;
        t1 = t2;
        t2 = nextTerm;
    &#125;
    return 0;

&#125;</code></pre>

<h2 id="金字塔型图案"><a href="#金字塔型图案" class="headerlink" title="金字塔型图案"></a>金字塔型图案</h2><p>使用字母</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
int main()
&#123;
    int i, j;
    char input, alphabet = &#x27;A&#x27;;

    printf(&quot;输入大写字母: &quot;);
    scanf(&quot;%c&quot;,&amp;input);
     
    for(i=1; i &lt;= (input-&#x27;A&#x27;+1); ++i)
    &#123;
        for(j=1;j&lt;=i;++j)
        &#123;
            printf(&quot;%c&quot;, alphabet);
        &#125;
        ++alphabet;
     
        printf(&quot;\n&quot;);
    &#125;
    return 0;

&#125;</code></pre>

<p>金字塔</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
int main()
&#123;
    int i, space, rows, k=0;

    printf(&quot;Enter number of rows: &quot;);
    scanf(&quot;%d&quot;,&amp;rows);
     
    for(i=1; i&lt;=rows; ++i, k=0)
    &#123;
        for(space=1; space&lt;=rows-i; ++space)
        &#123;
            printf(&quot;  &quot;);
        &#125;
     
        while(k != 2*i-1)
        &#123;
            printf(&quot;* &quot;);
            ++k;
        &#125;
     
        printf(&quot;\n&quot;);
    &#125;
    
    return 0;

&#125;</code></pre>

<p>space&#x3D;1比较巧妙，直接代表中间的那个“*”；但是k难一点</p>
<h2 id="菱形"><a href="#菱形" class="headerlink" title="菱形"></a>菱形</h2><p>可扩展</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
int main()
&#123;
    int i,j,k;
    for(i=0;i&lt;=3;i++) &#123;
        for(j=0;j&lt;=2-i;j++) &#123;
            printf(&quot; &quot;);
        &#125;
        for(k=0;k&lt;=2*i;k++) &#123;
            printf(&quot;*&quot;);
        &#125;
        printf(&quot;\n&quot;);
    &#125;
    for(i=0;i&lt;=2;i++) &#123;
        for(j=0;j&lt;=i;j++) &#123;
            printf(&quot; &quot;);
        &#125;
        for(k=0;k&lt;=4-2*i;k++) &#123;
            printf(&quot;*&quot;);
        &#125;
        printf(&quot;\n&quot;);
    &#125;

&#125;</code></pre>

<img src="../source/imgs/${fiilname}/image-20240121164754559.png" alt="image-20240121164754559" style="zoom:50%;" />

<h2 id="二进制转化为十进制"><a href="#二进制转化为十进制" class="headerlink" title="二进制转化为十进制"></a>二进制转化为十进制</h2><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int convertBinaryToDecimal(long long n);

int main()
&#123;
    long long n;
    printf(&quot;输入一个二进制数: &quot;);
    scanf(&quot;%lld&quot;, &amp;n);
    printf(&quot;二进制数 %lld 转换为十进制为 %d&quot;, n, convertBinaryToDecimal(n));
    return 0;
&#125;

int convertBinaryToDecimal(long long n)
&#123;
    int decimalNumber = 0, i = 0, remainder;
    while (n!=0)
    &#123;
        remainder = n%10;
        n /= 10;
        decimalNumber += remainder*pow(2,i);
        ++i;
    &#125;
    return decimalNumber;
&#125;</code></pre>

<p>重点是<strong>pow</strong>的运用</p>
<h2 id="字符串的翻转"><a href="#字符串的翻转" class="headerlink" title="@字符串的翻转"></a>@字符串的翻转</h2><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
void reverseSentence();

int main()
&#123;
    printf(&quot;输入一个字符串: &quot;);
    reverseSentence();

    return 0;

&#125;

void reverseSentence()
&#123;
    char c;
    scanf(&quot;%c&quot;, &amp;c);

    if( c != &#x27;\n&#x27;)
    &#123;
        reverseSentence();
        printf(&quot;%c&quot;,c);
    &#125;

&#125;</code></pre>

<p>很巧妙，也可以用来翻转一串数字</p>
<h2 id="矩阵转化"><a href="#矩阵转化" class="headerlink" title="矩阵转化"></a>矩阵转化</h2><pre><code class="hljs plaintext">for(i=0; i&lt;r; ++i)

        for(j=0; j&lt;c; ++j) 

       &#123; 

           transpose[j][i]= a[i][j];

        &#125;</code></pre>

<h2 id="删除字符串中的特殊字符"><a href="#删除字符串中的特殊字符" class="headerlink" title="删除字符串中的特殊字符"></a>删除字符串中的特殊字符</h2><p>可以推广</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;

int main()
&#123;
    char line[150];
    int i, j;
    printf(&quot;输入一个字符串: &quot;);
    fgets(line, (sizeof line / sizeof line[0]), stdin);//输入字符串
	//gets(line);
    for(i = 0; line[i] != &#x27;\0&#x27;; ++i)
    &#123;
        while (!( (line[i] &gt;= &#x27;a&#x27; &amp;&amp; line[i] &lt;= &#x27;z&#x27;) || (line[i] &gt;= &#x27;A&#x27; &amp;&amp; line[i] &lt;= &#x27;Z&#x27;) || line[i] == &#x27;\0&#x27;) )
        &#123;
            for(j = i; line[j] != &#x27;\0&#x27;; ++j)
            &#123;
                line[j] = line[j+1];
            &#125;
            line[j] = &#x27;\0&#x27;;
        &#125;
    &#125;
    printf(&quot;输出: &quot;);
    puts(line);
    return 0;
&#125;</code></pre>

<p>注意while循环里的条件</p>
<p>里面输入字符串是用fgets函数（看之后的笔记，估计得用stdin才能输入字符串到数组中），也可以用gets函数</p>
<h3 id="fgets函数"><a href="#fgets函数" class="headerlink" title="fgets函数"></a>fgets函数</h3><p>C 库函数 <strong>char *fgets(char *str, int n, FILE *stream)</strong> 从指定的流 stream 读取一行，并把它存储在 <strong>str</strong> 所指向的字符串内。当读取 <strong>(n-1)</strong> 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p>
<p>下面是 fgets() 函数的声明。</p>
<pre><code class="hljs plaintext">char *fgets(char *str, int n, FILE *stream)</code></pre>

<p>参数</p>
<ul>
<li><strong>str</strong> – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。</li>
<li><strong>n</strong> – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。</li>
</ul>
<h2 id="查找字符在字符串中出现的次数"><a href="#查找字符在字符串中出现的次数" class="headerlink" title="查找字符在字符串中出现的次数"></a>查找字符在字符串中出现的次数</h2><p>#include &lt;stdio.h&gt;</p>
<p>int main()<br>{<br>   char str[1000], ch;<br>   int i, frequency &#x3D; 0;</p>
<p>   printf(“输入字符串: “);<br>   fgets(str, (sizeof str &#x2F; sizeof str[0]), stdin);</p>
<p>   printf(“输入要查找的字符: “);<br>   scanf(“%c”,&amp;ch);</p>
<p>   for(i &#x3D; 0; <strong>str[i] !&#x3D; ‘\0’</strong>; ++i)<br>   {<br>       <strong>if(ch &#x3D;&#x3D; str[i])</strong><br>           ++frequency;<br>   }</p>
<p>   printf(“字符 %c 在字符串中出现的次数为 %d”, ch, frequency);</p>
<p>   return 0;<br>}</p>
<p>用这个if条件可以不需要输入要输多少或者判断字符串长度</p>
<h2 id="约瑟夫生者死者小游戏（continue-逻辑）"><a href="#约瑟夫生者死者小游戏（continue-逻辑）" class="headerlink" title="约瑟夫生者死者小游戏（continue,逻辑）"></a>约瑟夫生者死者小游戏（continue,逻辑）</h2><p>30 个人在一条船上，超载，需要 15 人下船。</p>
<p>于是人们排成一队，排队的位置即为他们的编号。</p>
<p>报数，从 1 开始，数到 9 的人下船。</p>
<p>如此循环，直到船上仅剩 15 人为止，问都有哪些编号的人下船了呢？</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;

int c = 0;
int i = 1;
int j = 0;
int a[30] = &#123; 0 &#125;;
int b[30] = &#123; 0 &#125;;

int main() &#123;
    while (i&lt;=31) &#123;
        if (i == 31) &#123;
            i = 1;
        &#125; else if (c == 15) &#123;
            break;
        &#125; else &#123;
            if (b[i] != 0) &#123;
                i++;
                continue;
            &#125; else &#123;
                j++;
                if (j != 9) &#123;
                    i++;
                    continue;
                &#125; else &#123;
                    b[i] = 1;
                    a[i] = j;//可有可无
                    j = 0;
                    printf(&quot;第%d号下船了\n&quot;, i);
                    i++;
                    c++;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>continue的用法,但是这题用continue反而加大了难度。直接一个if就可以了。</p>
<h1 id="经典"><a href="#经典" class="headerlink" title="经典"></a>经典</h1><p>1、将一个正整数分解质因数</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;
    int n,i;
    printf(&quot;请输入整数：&quot;);
    scanf(&quot;%d&quot;,&amp;n);
    printf(&quot;%d=&quot;,n);
    for(i=2;i&lt;=n;i++)
    &#123;
        while(n%i==0)
        &#123;
            printf(&quot;%d&quot;,i);
            n/=i;
            if(n!=1) printf(&quot;*&quot;);
        &#125;
    &#125;
    

    printf(&quot;\n&quot;);
    return 0;

&#125;</code></pre>

<h2 id="2、辗转相除法"><a href="#2、辗转相除法" class="headerlink" title="2、辗转相除法"></a>2、辗转相除法</h2><p>求两数的最大公约数和最小公倍数</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;
    int a,b,t,r,n;
    printf(&quot;请输入两个数字：\n&quot;);
    scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
    if(a&lt;b)
    &#123;t=b;b=a;a=t;&#125;
    r=a%b;
    n=a*b;
    while(r!=0)
    &#123;
        a=b;
        b=r;
        r=a%b;
    &#125;
    printf(&quot;这两个数的最大公约数是%d，最小公倍数是%d\n&quot;,b,n/b);
    

return 0;

&#125;</code></pre>

<p>3、</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>一、</strong></p>
<p>你的程序要读入一行文本，其中以空格分隔为若干个单词，以<code>.</code>结束。你要输出每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如<code>it&#39;s</code>算一个单词，长度为4。注意，行中可能出现连续的空格；最后的<code>.</code>不计算在内。</p>
<p>输入格式：</p>
<p>输入在一行中给出一行文本，以<code>.</code>结束</p>
<p>输出格式：</p>
<p>在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。</p>
<p>输入样例：</p>
<pre><code class="hljs in">It&#x27;s great to see you here.</code></pre>

<p>输出样例：</p>
<pre><code class="hljs out">4 5 2 3 3 4</code></pre>

<p>方法一.我自己的，比较规矩，不奇特</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
&#123;
	char sentence[1000];
	int i,j=0,num[100]=&#123;0&#125;,len,m=0;
	gets(sentence);
	len=strlen(sentence);
	for(i=0;i&lt;len;i++)
	&#123;
		if(sentence[i]!=&#x27; &#x27;)&#123;
			if(sentence[i]!=&#x27;.&#x27;)&#123;
			num[j]++;
			m=1;
			&#125;else break;
		&#125;
		if(sentence[i]==&#x27; &#x27;&amp;&amp;m==1)&#123;
			j++;
			m=0;
		&#125;
	&#125;
	for(i=0;i&lt;=j;i++)&#123;
		if(num[i]==0) break;
		printf(&quot;%d&quot;,num[i]);
		if(i!=j&amp;&amp;m!=0) 
			printf(&quot; &quot;);
		&#125;
	return 0;
&#125;</code></pre>

<p>方法二：新奇，简单</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
&#123;
	int i=0,t = 0;
	int k = 0;
	int s[20] = &#123; 0 &#125;;
	char arr[20];
	while (1)
	&#123;
		scanf(&quot;%s&quot;, arr);
		t = strlen(arr);
		if (arr[t - 1] == &#x27;.&#x27;)
		&#123;
			t = t-1;
			s[i]=t;
			break;
		&#125;
		s[i]=t;
		i++;	
	&#125;
	for(i=0;i&lt;20;i++)
	&#123;
		if (s[i] == 0)
			break;
		printf(&quot;%d&quot;, s[i]);
	&#125;
	return 0;
&#125;</code></pre>

<h2 id="2、"><a href="#2、" class="headerlink" title="@2、"></a>@2、</h2><p>输入一个整数（位数不超过9位）代表一个人民币值（单位为元），请转换成财务要求的大写中文格式。如23108元，转换后变成“贰万叁仟壹百零捌”元。为了简化输出，用小写英文字母a-j顺序代表大写数字0-9，用S、B、Q、W、Y分别代表拾、百、仟、万、亿。于是23108元应被转换输出为“<code>cWdQbBai</code>”元。</p>
<p>输入格式：</p>
<p>输入在一行中给出一个不超过9位的非负整数。</p>
<p>输出格式：</p>
<p>在一行中输出转换后的结果。注意“零”的用法必须符合中文习惯。</p>
<p>输入样例1：</p>
<p>813227345</p>
<p>输出样例1：</p>
<p><code>iYbQdBcScWhQdBeSf</code></p>
<p>输入样例2：</p>
<p>6900</p>
<p>输出样例2：</p>
<p><code>gQjB</code></p>
<p><strong>方法一</strong></p>
<p>123456<br>a[0]&#x3D;6<br>a[1]&#x3D;5<br>a[2]&#x3D;4<br>a[3]&#x3D;3<br>a[4]&#x3D;2<br>a[5]&#x3D;1</p>
<p>数不超过9位，则最大位亿。用数组将每一位数分解储存，然后遍历。因为十、百、千在千位、百位、十位、千万位、百万位、十万位都要输出一次。所以要余4，</p>
<p>如果余数为0，则是个位、万位或者亿位不需要输出。</p>
<p>如果余数为1，则是十位或者十万位，需要输出S。</p>
<p>如果余数为2，则是百位或者百万位，需要输出B。</p>
<p>如果余数为3，则是千位或者千万位，需要输出Q。</p>
<p>如果遍历的数为0，根据实际情况不管多少0只输出一个。</p>
<p>如果遍历的数不为0，则进行上述余4，判断余数。</p>
<p>如果数最大为亿，则输出Y</p>
<p>如果是千万、百万、十万位、则要输出W</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;
	int n,count=0;
	int num[10]=&#123;0&#125;;   //用于存放数字的每一位，要初始化为0，不然会错 
	scanf(&quot;%d&quot;,&amp;n);
	while(n)
	&#123;   //分解数字的各个位数 
		num[count++]=n%10;
		n/=10;
	&#125;
	for(int i=count-1;i&gt;=0;i--)
	&#123;
		if(num[i]!=0)
		&#123;   //不为 0 
			switch(i%4) //十、百、千 是四个一循环
			&#123;   //如果余数为 0 根据实际则不用没有后面的 
				case 0: printf(&quot;%c&quot;,num[i]+&#x27;a&#x27;); break;
				case 1: printf(&quot;%cS&quot;,num[i]+&#x27;a&#x27;); break;
				case 2: printf(&quot;%cB&quot;,num[i]+&#x27;a&#x27;); break;
				case 3: printf(&quot;%cQ&quot;,num[i]+&#x27;a&#x27;); break;
			&#125;
		&#125;
		//用于输出数字中间有多个 0 的情况，这种情况只输出一个 0 
		else if(num[i]==0&amp;&amp;num[i-1]!=0&amp;&amp;i&gt;0)
			printf(&quot;%c&quot;,num[i]+&#x27;a&#x27;);
		if(i==8)  //上亿的数输出 Y 
			printf(&quot;Y&quot;);
		//如果上十万、百万、千万、亿的则输出 W 
		else if(i==4&amp;&amp;(num[4]+num[5]+num[6]+num[7])&gt;0)
			printf(&quot;W&quot;);
	&#125;
	if(count==0)  //如果数为 0 则输出 a 
		printf(&quot;a&quot;);
	return 0;
&#125;</code></pre>

<p><strong>方法二</strong></p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
void f(int k);
void g(int k);
int main()
&#123;
	int num;
	int i;
	scanf(&quot;%d&quot;,&amp;num);
	if(num==0)
		printf(&quot;a&quot;);
	int buf[10]=&#123;0&#125;;
	int cnt=0;
	do&#123;
		buf[cnt++]=num%10;//个位数存入数组
		num/=10;//sum值改变
	&#125;while(num!=0);
	for(int i=cnt-1;i&gt;=0;i--)&#123;
		if(buf[i]!=0)&#123;
			f(buf[i]);
			g(i);
		&#125;
		if(buf[i]==0&amp;&amp;(i==8||i==4))
			g(i);
		if(buf[i]==0&amp;&amp;(i==2||i==6)&amp;&amp;buf[i-2]!=0)
			f(0);
		if(buf[i]==0&amp;&amp;(i==1||i==5)&amp;&amp;buf[i-1]!=0)
			f(0);
	&#125;
	return 0;
&#125;
void f(int k)&#123;
    switch (k)&#123;
        case 0:printf(&quot;a&quot;);
            break;
        case 1:printf(&quot;b&quot;);
            break;
        case 2:printf(&quot;c&quot;);
            break; 
        case 3:printf(&quot;d&quot;);
            break;
        case 4:printf(&quot;e&quot;);
            break;
        case 5:printf(&quot;f&quot;);
            break;
        case 6:printf(&quot;g&quot;);
            break;
        case 7:printf(&quot;h&quot;);
            break;
        case 8:printf(&quot;i&quot;);
            break;
        case 9:printf(&quot;j&quot;);
            break;
    &#125;
&#125;
void g(int k)&#123;
    switch (k)&#123;
    	case 1:printf(&quot;S&quot;);
        	break;
    	case 2:printf(&quot;B&quot;);
        	break; 
    	case 3:printf(&quot;Q&quot;);
        	break;
    	case 4:printf(&quot;W&quot;);
        	break;
    	case 5:printf(&quot;S&quot;);
        	break;
    	case 6:printf(&quot;B&quot;);	
        	break;
    	case 7:printf(&quot;Q&quot;);
        	break;
    	case 8:printf(&quot;Y&quot;);
        	break;
    	case 9:printf(&quot;S&quot;);
        	break;
	&#125;
&#125;</code></pre>

<h2 id="3、用亦或寻找单身狗数"><a href="#3、用亦或寻找单身狗数" class="headerlink" title="3、用亦或寻找单身狗数"></a>3、用亦或寻找单身狗数</h2><p>一、只有一个单身狗数</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240125161931649.png" alt="image-20240125161931649"></p>
<h2 id="4、本题要求实现一个打印非负整数阶乘的函数。"><a href="#4、本题要求实现一个打印非负整数阶乘的函数。" class="headerlink" title="4、本题要求实现一个打印非负整数阶乘的函数。"></a>4、本题要求实现一个打印非负整数阶乘的函数。</h2><p>函数接口定义：</p>
<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print_Factorial</span> <span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">int</span> N )</span></span>;</code></pre>

<p>其中<code>N</code>是用户传入的参数，其值不超过1000。如果<code>N</code>是非负整数，则该函数必须在一行中打印出<code>N</code>!的值，否则打印“Invalid input”。</p>
<p>裁判测试程序样例：</p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print_Factorial</span> <span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">int</span> N )</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> N;
    
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);
    <span class="hljs-built_in">Print_Factorial</span>(N);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* 你的代码将被嵌在这里 */</span></code></pre>

<p>输入样例：</p>
<pre><code class="hljs in">15</code></pre>

<p>输出样例：</p>
<pre><code class="hljs out">1307674368000</code></pre>

<pre><code class="hljs plaintext">void Print_Factorial(int N)
&#123;
    int a[3000];
    int temp,num,digit;           //temp：每一位的结果  num:进位   digit：结果的位数
    int i,j;
    a[0]=1;
    digit=1;                      //从第1位开始 
    if(N&gt;=0) &#123;
        for(i=2;i&lt;=N;i++)&#123;
            for(j=0;j&lt;digit;j++)&#123;
              temp=a[j]*i+num;    
              a[j]=temp%10;       //把当前位的数字存入数字 
              num=temp/10;        //向前面一位进位 
            &#125; 
            while(num)&#123;           //当现有位数算完，仍有进位，则数组需扩大 
                a[digit]=num%10;
                num/=10;
                digit++;
            &#125;
        &#125;
        for(i=digit-1;i&gt;=0;i--)&#123;
            printf(&quot;%d&quot;,a[i]);
        &#125;
    &#125;
    else printf(&quot;Invalid input&quot;);
&#125;</code></pre>

<p><strong>5、</strong>这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数<code>x</code>，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字<code>s</code>，表示<code>x</code>乘以<code>s</code>是一个光棍，第二个数字<code>n</code>是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。</p>
<p>提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除<code>x</code>为止。但难点在于，<code>s</code>可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。</p>
<p>输入格式：</p>
<p>输入在一行中给出一个不以5结尾的正奇数<code>x</code>（&lt;1000）。</p>
<p>输出格式：</p>
<p>在一行中输出相应的最小的<code>s</code>和<code>n</code>，其间以1个空格分隔。</p>
<p>输入样例：</p>
<pre><code class="hljs in">31</code></pre>

<p>输出样例：</p>
<pre><code class="hljs out">3584229390681 15</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206211018948.png" alt="image-20240206211018948"></p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int main()
&#123;
    int N;
    scanf(&quot;%d&quot;,&amp;N);
    int i,x,n;
    i=1,n=N,x=1;
    while(n/10)
    &#123;
        n/=10;
        x+=pow(10,i);
        i++;
    &#125;
    if(N==x)
    &#123;
        printf(&quot;1 %d\n&quot;,i);
        return 0;
    &#125;
    x+=pow(10,i);   //比N多一位的光棍数 
    while(x%N)
    &#123;
        printf(&quot;%d&quot;,x/N);
        x=(x%N)*10+1;
        i++;
    &#125; 
    printf(&quot;%d %d\n&quot;,x/N,i+1);
    return 0;
&#125;</code></pre>

<p>6、</p>
<p>本题要求你实现一个稍微更值钱一点的 AI 英文问答程序，规则是：</p>
<ul>
<li>无论用户说什么，首先把对方说的话在一行中原样打印出来；</li>
<li>消除原文中多余空格：把相邻单词间的多个空格换成 1 个空格，把行首尾的空格全部删掉，把标点符号前面的空格删掉；</li>
<li>把原文中所有大写英文字母变成小写，除了 <code>I</code>；</li>
<li>把原文中所有独立的 <code>can you</code>、<code>could you</code> 对应地换成 <code>I can</code>、<code>I could</code>—— 这里“独立”是指被空格或标点符号分隔开的单词；</li>
<li>把原文中所有独立的 <code>I</code> 和 <code>me</code> 换成 <code>you</code>；</li>
<li>把原文中所有的问号 <code>?</code> 换成惊叹号 <code>!</code>；</li>
<li>在一行中输出替换后的句子作为 AI 的回答。</li>
</ul>
<p>输入格式：</p>
<p>输入首先在第一行给出不超过 10 的正整数 N，随后 N 行，每行给出一句不超过 1000 个字符的、以回车结尾的用户的对话，对话为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。</p>
<p>输出格式：</p>
<p>按题面要求输出，每个 AI 的回答前要加上 <code>AI:</code> 和一个空格。</p>
<p>输入样例：</p>
<pre><code class="hljs in">6
Hello ?
 Good to chat   with you
can   you speak Chinese?
Really?
Could you show me 5
What Is this prime? I,don &#x27;t know</code></pre>

<p>输出样例：</p>
<pre><code class="hljs out">Hello ?
AI: hello!
 Good to chat   with you
AI: good to chat with you
can   you speak Chinese?
AI: I can speak chinese!
Really?
AI: really!
Could you show me 5
AI: I could show you 5
What Is this prime? I,don &#x27;t know
AI: what Is this prime! you,don&#x27;t know</code></pre>

<p><strong>答案：</strong></p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;ctype.h&gt;
#define len 10000

void substitute(char a[][len],char* q,char* t1,char* r1,int i);
void dele(char a[][len],int i)
&#123;
    int j=0;
    int k=0;
    int count=0;
    char temp[]=&quot;  &quot;;
  /*把行首的空格全部删掉*/
     count=strlen(a[i]);
	for(;;)
	&#123;
		if(a[i][j]==&#x27; &#x27;) j++;
		else break;
	&#125;
	for(k=0;j&lt;=count;j++)
		a[i][k++]=a[i][j];
     /*把相邻单词间的多个空格换成 1 个空格*/
     for(;;)
     &#123;
         if(strstr(a[i],temp)!=NULL)
         &#123;
            for(j=(strstr(a[i],temp)-a[i]);j&lt;count;++j)
                a[i][j]=a[i][j+1];
         &#125;
         else
           break;
     &#125;
	     /*把标点符号前面的空格删掉*/
     j=0;
     for(;j&lt;count;++j)
        if(ispunct(a[i][j+1])!=0&amp;&amp;a[i][j]==32)
        &#123;
             for(k=j;k&lt;count;++k)
                a[i][k]=a[i][k+1];
             --j;
        &#125;
    /*把行尾的空格全部删掉*/
    for(;;)
    &#123;
        count=strlen(a[i]);
        if(a[i][count-1]==32)
            a[i][count-1]=0;
        else
            break;
    &#125;
    return;
&#125;
/*把原文中所有独立的can you could you 对应地换成 I can、I could—— 这里“独立”是指被空格或标点符号分隔开的单词,把原文中所有独立的 I 和 me 换成 you*/
void replace(char a[][len],int i)
&#123;
    char t1[]=&quot;can you&quot;;
    char t2[]=&quot;could you&quot;;
    char r1[]=&quot;i can&quot;;
    char r2[]=&quot;i could&quot;;
	int j=0;
	char t3[]=&quot;I&quot;;
    char t4[]=&quot;me&quot;;
    char r3[]=&quot;you&quot;;
	char *q=a[i];
	/*can you*/    
	substitute(a,a[i],t1,r1,i);

/*could you*/
substitute(a,a[i],t2,r2,i);

/*I*/
substitute(a,a[i],t3,r3,i);

/*me*/
substitute(a,a[i],t4,r3,i);

/* i变成I*/
while(strstr(a[i],r1)!=NULL)
&#123;
	q=strstr(a[i],r1);
	*q=&#x27;I&#x27;;
&#125;
/* i变成I*/
while(strstr(a[i],r2)!=NULL)
&#123;
	q=strstr(a[i],r2);
	*q=&#x27;I&#x27;;
&#125;
     /*感叹号替换*/
for(j=0;a[i][j]!=0;++j)
  if(a[i][j]==&#x27;?&#x27;)
    a[i][j]=&#x27;!&#x27;;

return;

&#125;

/*把原文中所有大写英文字母变成小写，除了 I；把原文中所有的问号 ? 换成惊叹号 !；*/
void lower(char a[][len],int i)
&#123;
    int j=0,cout;
    cout=strlen(a[i]);
    /*变小写*/
    for(j=0;j&lt;cout;++j)
      if(a[i][j]!=&#x27;I&#x27;)
         a[i][j]=tolower(a[i][j]);
    return;
&#125;

void substitute(char a[][len],char* q,char* t1,char* r1,int i)
&#123;
	char temp1[len]=&#123;0&#125;;
	int leap=0;
	int count=0;
	leap=strlen(t1);
	for(;;)
    &#123;
        if(strstr(q,t1)!=NULL)
        &#123;
            q=strstr(q,t1);
            if((isalnum(*(q-1))!=0&amp;&amp;q!=a[i])||isalnum(*(q+leap))!=0)
                q=q+leap;
            else
			&#123;
				count=q-a[i];
				strncpy(temp1,a[i],count);
				strcat(temp1,r1);
				strcat(temp1,q+leap);
				strcpy(a[i],temp1);
                memset(temp1,0,len);
			&#125;                                
		&#125;
		else
			break;
	&#125;
	return;
&#125;

int main(void)
&#123;
    char a[11][len]=&#123;0&#125;;
    int i=0;
    int n=0;

scanf(&quot;%d&quot;,&amp;n);
getchar();
for(i=0;i&lt;n;++i)
    gets(a[i]);
for(i=0;i&lt;n;++i)
&#123;
	printf(&quot;%s\n&quot;,a[i]);
	dele(a,i);
	lower(a,i);
	replace(a,i);
	printf(&quot;AI: %s\n&quot;,a[i]);
&#125;
return 0;

&#125;</code></pre>

<p>为什么要先变小写再替换呢？</p>
<p>因为英文句子中的首字母要大写，所以can I会变成Can I，按理来说此时应该回答you can的，但是C为大写，不能识别，所以要先转化为小写。</p>
<p>q&#x3D;strstr(q,t1);为什么括号里面是q呢？</p>
<p>如果是a[i]的话，那每次q赋值都会从首地址开始找，若符合了if条件，那就会陷入无限循环中，且时间消耗也会更多，所以为q 更加合理。</p>
<h1 id="题目经验"><a href="#题目经验" class="headerlink" title="题目经验"></a>题目经验</h1><p><strong>1.遇到超过范围的数可以当作字符处理</strong></p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;   
    int count[10]=&#123;0&#125;;
    char a;
    while((a=getchar())!=&#x27;\n&#x27;)
    &#123;
        count[a-&#x27;0&#x27;]++;
    &#125;
    for(int i=0;i&lt;10;i++)
    &#123;
        if(count[i]!=0)
        &#123;
            printf(&quot;%d:%d\n&quot;,i,count[i]);
        &#125;
    &#125;
    return 0;
&#125;</code></pre>

<p>可以处理1000位及以下的数；<strong>getchar</strong>的用法很巧妙</p>
<hr>
<p><strong>2、</strong></p>
<p>每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。</p>
<p><strong>输入格式：</strong></p>
<p>输入第一行给出一个正整数 <em>N</em>（≤1000），随后 <em>N</em> 行，每行给出一个考生的信息：<code>准考证号 试机座位号 考试座位号</code>。其中<code>准考证号</code>由 16 位数字组成，座位从 1 到 <em>N</em> 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。</p>
<p>考生信息之后，给出一个正整数 <em>M</em>（≤<em>N</em>），随后一行中给出 <em>M</em> 个待查询的试机座位号码，以空格分隔。</p>
<p><strong>输出格式：</strong></p>
<p>对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。</p>
<p><strong>输入样例：</strong></p>
<pre><code class="hljs in">4
3310120150912233 2 4
3310120150912119 4 1
3310120150912126 1 3
3310120150912002 3 2
2
3 4</code></pre>

<p><strong>输出样例：</strong></p>
<pre><code class="hljs out">3310120150912002 2
3310120150912119 1</code></pre>

<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
struct stu&#123;
	char zhun[17];
	int sj,ks;
&#125;;
int main()
&#123;
	struct stu a[1001];
	int i,N,M;
	scanf(&quot;%d&quot;,&amp;N);
	for(i=0;i&lt;N;i++)
	&#123;
		scanf(&quot;%s %d %d&quot;,&amp;a[0].zhun,&amp;a[0].sj ,&amp;a[0].ks );
		a[a[0].sj]=a[0];
	&#125;
	scanf(&quot;%d&quot;,&amp;N);
	for(i=0;i&lt;N;i++)
	&#123;
		scanf(&quot;%d&quot;,&amp;M);
		printf(&quot;%s %d\n&quot;,a[M].zhun ,a[M].ks );
	&#125;
	return 0;
&#125;</code></pre>

<p>struct结构可以直接赋值，但是数组不行</p>
<p>for循环里直接输入数字，就可以不用在创建一个数组，更加直接，效率更高</p>
<p>程序里面给struct结构的值赋值的仔细看</p>
<hr>
<p>**3. **int&#x2F;char a<code>[2][10]</code>&#x3D;[ [‘h’,’e’,’l’,’l’,’o’], [‘w’,’o’,’r’,’l’,’d’] ];</p>
<p>像a[1][8】这种没有存储字母的，里面存的是’0’,可以输出，%c,%d都可以，所以可以用”if a【i】【j】&#x3D;&#x3D;0”来判断当前这行的有效字符是否已经输完。</p>
<hr>
<p><strong>4、</strong></p>
<pre><code class="hljs plaintext">printf(&quot;%d=%d&quot;,i,a[0]);
           for(n=1;n&lt;=k;n++)
               printf(&quot;+%d&quot;,a[n]);
           printf(&quot;\n&quot;);</code></pre>

<p><strong>5、</strong>两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
int main()
&#123;
    char i,j,k;
    for(i=&#x27;x&#x27;;i&lt;=&#x27;z&#x27;;i++) &#123;
        for(j=&#x27;x&#x27;;j&lt;=&#x27;z&#x27;;j++) &#123;
            if(i!=j) &#123;
                for(k=&#x27;x&#x27;;k&lt;=&#x27;z&#x27;;k++) &#123;
                    if(i!=k&amp;&amp;j!=k) &#123;
                        if(i!=&#x27;x&#x27;&amp;&amp;k!=&#x27;x&#x27;&amp;&amp;k!=&#x27;z&#x27;) &#123;
                            printf(&quot;顺序为：a--%c\tb--%c\tc--%c\n&quot;,i,j,k);
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;</code></pre>

<p><strong>6、</strong>两个字符数组若字符串没有完全占满数组，则后面空出来的两个数组剩余部分都相同。</p>
<p>因此要注意该程序里的<strong>m&lt;t</strong>.</p>
<p><strong>题目</strong>：输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。</p>
<p>输入格式：</p>
<p>输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。</p>
<p>输出格式：</p>
<p>在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。</p>
<p>输入样例：</p>
<pre><code class="hljs in">Tomcat is a male ccatat
cat</code></pre>

<p>输出样例：</p>
<pre><code class="hljs out">Tom is a male</code></pre>

<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
&#123;
	char a[81],b[81],i=0,t,m=0,len,c,n=1;
	gets(a);
	gets(b);
	t=strlen(b);
	len=strlen(a);
	while(n)
	&#123;
		n=0;
		for(i=0;i&lt;=len;i++)
		&#123;	
			m=0;
			if(a[i]==b[m])
			&#123;
				c=i;
				while(a[c]==b[m]&amp;&amp;m&lt;t)
				&#123;
					c++;m++;
				&#125;
			&#125;
			if(m==t)
			&#123;
				n=1;
				for(i;i&lt;=len;i++)
					a[i]=a[i+t];
				break;
			&#125;
		&#125;
	&#125;
	printf(&quot;%s&quot;,a);
	return 0;
&#125;</code></pre>

<h2 id="7、思想，旋转数组，逆置的思想"><a href="#7、思想，旋转数组，逆置的思想" class="headerlink" title="7、思想，旋转数组，逆置的思想"></a><strong>7、</strong>思想，旋转数组，逆置的思想</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240125221755975.png" alt="image-20240125221755975"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240125221716337.png" alt="image-20240125221716337"></p>
<p>第一种：写函数，相对简单一点</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240125221950701.png" alt="image-20240125221950701"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240125222037168.png" alt="image-20240125222037168"></p>
<p>第二种：不写函数，稍微麻烦一点，但不难</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240125222135444.png" alt="image-20240125222135444"></p>
<p>8、存储字符串里的单词，字符串以回车结束</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;
	char list[5][5],c;
	int i=0;
	do&#123;
		scanf(&quot;%s&quot;,list[i++]);
		c=getchar();//用c来存单词间的空格
	&#125;while(c!=&#x27;\n&#x27;);//此循环用于存储句子
	i--;
	for(i=0;i&lt;5;i++)
		printf(&quot;%s &quot;,list[i]);
    return 0;
&#125;</code></pre>

<p><strong>8、</strong>	gets 函数在读取字符串的时候<strong>会将“回车”读取为’\0’并存入数组中</strong>，所以在设置数组长度的时候最好<strong>为它预留空间</strong>，不然可能会出错。</p>
<p><strong>9、</strong>在读取数字之后，scanf 会读取到换行符，然后将其留在输入缓冲区中。然后下一个 scanf 会读取这个换行符，因为 “%c” 格式可以读取空白字符（包括空格、制表符和换行符）。这导致了不希望的结果。</p>
<p>解决方法是<strong>在 “%c” 前添加一个空格</strong>，这样可以跳过空白字符。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213204949165.png" alt="image-20240213204949165"></p>
<p><strong>10、</strong>把行尾的空格全部删掉</p>
<pre><code class="hljs plaintext">for(;;)
 &#123;
     count=strlen(a[i]);
     if(a[i][count-1]==32)
         a[i][count-1]=0;
     else
         break;
 &#125;</code></pre>



<h1 id="新的函数"><a href="#新的函数" class="headerlink" title="新的函数"></a>新的函数</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231214406.png" alt="image-20240213231214406"></p>
<h2 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a>strstr</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231317116.png" alt="image-20240213231317116"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231332778.png" alt="image-20240213231332778"></p>
<h2 id="ispunct"><a href="#ispunct" class="headerlink" title="ispunct"></a>ispunct</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231435350.png" alt="image-20240213231435350"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231503510.png" alt="image-20240213231503510"></p>
<h2 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231542438.png" alt="image-20240213231542438"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231625192.png" alt="image-20240213231625192"></p>
<h2 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231753060.png" alt="image-20240213231753060"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231809288.png" alt="image-20240213231809288"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231832523.png" alt="image-20240213231832523"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231921627.png" alt="image-20240213231921627"></p>
<p><strong><code>memset</code>函数可以给整型数组统一赋值0或1，其他的很有可能会出错。</strong></p>
<h2 id="tolower"><a href="#tolower" class="headerlink" title="tolower"></a>tolower</h2><p>toupper小写转大写，用法和tolower一样</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240215152206911.png" alt="image-20240215152206911"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240215152218344.png" alt="image-20240215152218344"></p>
<pre><code class="hljs plaintext">a[i][j]=tolower(a[i][j]);</code></pre>

<h2 id="strncat"><a href="#strncat" class="headerlink" title="strncat"></a>strncat</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217203955099.png" alt="image-20240217203955099"></p>
<h2 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217213347657.png" alt="image-20240217213347657"></p>
<p><strong>返回值</strong>(这个返回值应该是对的，其他的看不大懂)</p>
<p>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</p>
<pre><code class="hljs plaintext">#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main () &#123;
   char str[80] = &quot;This is - www.runoob.com - website&quot;;
   const char s[2] = &quot;-&quot;;
   char *token;

   /* 获取第一个子字符串 */
   token = strtok(str, s);

   /* 继续获取其他的子字符串 */
   while( token != NULL ) &#123;
      printf( &quot;%s\n&quot;, token );
    

      token = strtok(NULL, s);

   &#125;

   return(0);
&#125;</code></pre>

<p>结果：</p>
<pre><code class="hljs plaintext">This is 
 www.runoob.com 
 website</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217213607992.png" alt="image-20240217213607992"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217213623742.png" alt="image-20240217213623742"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217220348613.png" alt="image-20240217220348613"></p>
<h2 id="islower"><a href="#islower" class="headerlink" title="islower"></a>islower</h2><p>头文件：stype.h</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217213941826.png" alt="image-20240217213941826"></p>
<h1 id="一些网上的笔记"><a href="#一些网上的笔记" class="headerlink" title="一些网上的笔记"></a>一些网上的笔记</h1><p>1、</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216221429404.png" alt="image-20240216221429404"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216221444962.png" alt="image-20240216221444962"></p>
<p>2、</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216223851646.png" alt="image-20240216223851646"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216223902150.png" alt="image-20240216223902150"></p>
<p>3、</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217104124564.png" alt="image-20240217104124564"></p>
<h2 id="4、移位操作符"><a href="#4、移位操作符" class="headerlink" title="4、移位操作符"></a>4、移位操作符</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217110715052.png" alt="image-20240217110715052"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217110742049.png" alt="image-20240217110742049"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217151215674.png" alt="image-20240217151215674"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217151257573.png" alt="image-20240217151257573"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217151318182.png" alt="image-20240217151318182"></p>
<p>5、</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217152230808.png" alt="image-20240217152230808"></p>
<p>6、</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/10/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          数据结构1
        
      </div>
    </a>
  
  
    <a href="/2024/10/05/Java-1/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Java</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2025 Odegaard
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>