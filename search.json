[{"title":"test p","path":"/2025/09/29/test-p/","content":"n"},{"title":"深度学习入门","path":"/2025/09/11/深度学习入门/","content":"神经网络激活函数在神经网络发展的历史上， sigmoid函数很早就开始被使用了，而最近则主要使用ReLU（Rectified Linear Unit）函数。 ReLU函数在输入大于0时，直接输出该值；在输入小于等于0时，输出0。 ReLU函数可以表示为下面的式。 def relu(x): return np.maximum(0, x) 输出层的激活函数用σ()表示，不同于隐藏层的激活函数h()（σ读作sigma）。 输出层所用的激活函数，要根据求解问题的性质决定。一般地，回归问题可以使用恒等函数，二元分类问题可以使用 sigmoid函数，多元分类问题可以使用 softmax函数。 恒等函数会将输入按原样输出，对于输入的信息，不加以任何改动地直接输出。因此，在输出层使用恒等函数时，输入信号会原封不动地被输出。 分类问题中使用的softmax函数可以用下面的式表示。 def softmax(a): exp_a = np.exp(a) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y 上面的softmax函数的实现虽然正确描述了式，但在计算机的运算上有一定的缺陷。这个缺陷就是溢出问题。 softmax函数的实现中要进行指数函数的运算，但是此时指数函数的值很容易变得非常大。 softmax函数的实现可以像式这样进行改进。 首先，在分子和分母上都乘上C这个任意的常数（因为同时对分母和分子乘以相同的常数，所以计算结果不变）。然后，把这个C移动到指数函数（exp）中，记为log C。最后，把log C替换为另一个符号。说明，在进行softmax的指数函数的运算时，加上（或者减去)某个常数并不会改变运算的结果。这里的可以使用任何值，但是为了防止溢出，一般会使用输入信号中的最大值。 def softmax(a): c = np.max(a) exp_a = np.exp(a - c) # 溢出对策 sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y softmax函数的输出是0.0到1.0之间的实数。并且， softmax函数的输出值的总和是1。输出总和为1是softmax函数的一个重要性质。正因为有了这个性质，我们才可以把softmax函数的输出解释为“概率”。 比如，上面的例子可以解释成 y[0]的概率是0.018（1.8 %）， y[1]的概率是0.245（24.5 %）， y[2]的概率是0.737（73.7 %）。 即便使用了softmax函数，各个元素之间的大小关系也不会改变。这是因为指数函数（y exp(x)）是单调递增函数。实际上，上例中a的各元素的大小关系和y的各元素的大小关系并没有改变。比如， a的最大值是第2个元素， y的最大值也仍是第2个元素。 一般而言，神经网络只把输出值最大的神经元所对应的类别作为识别结果。并且，即便使用softmax函数，输出值最大的神经元的位置也不会变。因此，神经网络在进行分类时，输出层的softmax函数可以省略。 手写数字识别这里使用的数据集是MNIST手写数字图像集。 MNIST是机器学习领域最有名的数据集之一，被应用于从简单的实验到发表的论文研究等各种场合。实际上，在阅读图像识别或机器学习的论文时， MNIST数据集经常作为实验用的数据出现。MNIST数据集是由0到9的数字图像构成的. MNIST的图像数据是28像素 × 28像素的灰度图像（1通道），各个像素的取值在0到255之间。每个图像数据都相应地标有“7”“2”“1”等标签。 神经网络的学习损失函数这个损失函数可以使用任意函数，但一般用均方误差和交叉熵误差等。 可以用作损失函数的函数有很多，其中最有名的是均方误差 这里， yk是表示神经网络的输出， tk表示监督数据， k表示数据的维数。 在3.6节手写数字识别的例子中， yk、 tk是由如下10个元素构成的数据。 t是监督数据，将正确解标签设为1，其他均设为0。这里，标签“2”为1，表示正确解是“2”。将正确解标签表示为1，其他标签表示为0的表示方法称为one-hot表示。 除了均方误差之外， 交叉熵误差（cross entropy error）也经常被用作损失函数 这里， log表示以e为底数的自然对数（log e）。 yk是神经网络的输出， tk是正确解标签。并且， tk中只有正确解标签的索引为1，其他均为0（one-hot表示）。因此，式（4.2）实际上只计算对应正确解标签的输出的自然对数。比如，假设正确解标签的索引是“2”，与之对应的神经网络的输出是0.6，则交叉熵误差是-log 0.6 0.51；若“2”对应的输出是0.1，则交叉熵误差为-log 0.1 2.30。也就是说，交叉熵误差的值是由正确解标签所对应的输出结果决定的。 def cross_entropy_error(y, t): delta = 1e-7 return -np.sum(t * np.log(y + delta)) 这里，参数y和t是NumPy数组。函数内部在计算np.log时，加上了一个微小值delta。这是因为，当出现np.log(0)时， np.log(0)会变为负无限大的-inf，这样一来就会导致后续计算无法进行。作为保护性对策，添加一个微小值可以防止负无限大的发生。 此外，当监督数据是标签形式（非one-hot表示，而是像“2”“7”这样的标签）时，交叉熵误差可通过如下代码实现。 def cross_entropy_error(y, t): if y.ndim == 1: t = t.reshape(1, t.size) y = y.reshape(1, y.size) batch_size = y.shape[0] return -np.sum(np.log(y[np.arange(batch_size), t] + 1e-7)) / batch_size 需要求batch_size是因为此时的y不是一个数据。 作为参考，简单介绍一下np.log( y[np.arange(batch_size), t] )。 np.arange (batch_size)会生成一个从0到 batch_size-1的数组。比如当 batch_size为5时， np.arange(batch_size)会生成一个NumPy 数组 [0, 1, 2, 3, 4]。因为t中标签是以 [2, 7, 0, 9, 4]的形式存储的，所以 y[np.arange(batch_size), t]能抽出各个数据的正确解标签对应的神经网络的输出（在这个例子中， y[np.arange(batch_size), t] 会 生 成 NumPy 数 组 [y[0,2], y[1,7], y[2,0], y[3,9], y[4,4]]）。 epoch是一个单位。一个epoch表示学习中所有训练数据均被使用过一次时的更新次数。比如，对于 10000笔训练数据，用大小为 100笔数据的mini-batch进行学习时，重复随机梯度下降法100次，所有的训练数据就都被“看过”了 A。此时，100次就是一个epoch。 实际上，一般做法是事先将所有训练数据随机打乱，然后按指定的批次大小，按序生成mini-batch。这样每个mini-batch均有一个索引号，比如此例可以是0, 1, 2, . . . , 99，然后用索引号可以遍历所有的mini-batch。遍历一次所有数据，就称为一个epoch。 误差反向传播法激活函数层的实现ReLU层 激活函数ReLU（Rectified Linear Unit），它的导数是 class Relu: def __init__(self): self.mask = None def forward(self, x): self.mask = (x = 0) out = x.copy() out[self.mask] = 0 return out def backward(self, dout): dout[self.mask] = 0 dx = dout return dx Sigmoid层 sigmoid函数，它的导数是 class Sigmoid: def __init__(self): self.out = None def forward(self, x): out = 1 / (1 + np.exp(-x)) self.out = out return out def backward(self, dout): dx = dout * (1.0 - self.out) * self.out return dx 这个实现中，正向传播时将输出保存在了实例变量 out中。然后，反向传播时，使用该变量out进行计算。 AffineSoftmax层的实现Affine层 神经网络的正向传播中进行的矩阵的乘积运算在几何学领域被称为“仿射变换” 。因此，这里将进行仿射变换的处理实现为“Affine层”。 Softmax-with-Loss 层 最后介绍一下输出层的softmax函数。前面我们提到过， softmax函数会将输入值正规化之后再输出。比如手写数字识别时， Softmax层的输出如： 因为手写数字识别要进行10类分类，所以向Softmax层的输入也有10个。 神经网络中进行的处理有推理（inference）和学习两个阶段。神经网络的推理通常不使用Softmax层。比如，用图5-28的网络进行推理时，会将最后一个 Affine层的输出作为识别结果。神经网络中未被正规化的输出结果（图 5-28中 Softmax层前面的 Affine层的输出）有时被称为“得分”。也就是说，当神经网络的推理只需要给出一个答案的情况下，因为此时只对得分最大值感兴趣，所以不需要Softmax层。不过，神经网络的学习阶段则需要Softmax层。 softmax函数记为Softmax层，交叉熵误差记为Cross Entropy Error层。这里假设要进行3类分类，从前面的层接收3个输入（得分）。如图5-30所示， Softmax层将输入（a1, a2, a3）正规化，输出（y1, y2, y3）。 Cross Entropy Error层接收Softmax的输出（y1, y2, y3）和教师标签（t1, t2, t3），从这些数据中输出损失L。 Softmax层的反向传播得到了（y1 - t1, y2 - t2, y3 - t3）这样“漂亮”的结果。由于（y1, y2, y3）是Softmax层的输出，（t1, t2, t3）是监督数据，所以（y1 - t1, y2 - t2, y3 - t3）是Softmax层的输出和教师标签的差分。神经网络的反向传播会把这个差分表示的误差传递给前面的层。 与学习相关的技巧参数的更新随机梯度下降法随机梯度下降法（SGD），在解决某些问题的时候没有效率，因为梯度的方向没有指向最小值。 ，表示的函数是向x轴方向延伸的“碗”状函数。 应用SGD，SGD呈“之”字形移动。这是一个相当低效的路径。也就是说， SGD的缺点是，如果函数的形状非均向，比如呈延伸状，搜索的路径就会非常低效。 MomentumMomentum是“动量”的意思，和物理有关。用数学式表示Momentum方法，， 和前面的SGD一样， W表示要更新的权重参数，表示损失函数关于W的梯度， η表示学习率。这里新出现了一个变量v，对应物理上的速度。第一个式子表示了物体在梯度方向上受力，在这个力的作用下，物体的速度增加这一物理法则。 class Momentum: def __init__(self, lr=0.01, momentum=0.9): self.lr = lr self.momentum = momentum self.v = None def update(self, params, grads): if self.v is None: self.v = for key, val in params.items(): self.v[key] = np.zeros_like(val) for key in params.keys(): self.v[key] = self.momentum*self.v[key] - self.lr*grads[key] params[key] += self.v[key] numpy.zeros_like() ，用于创建一个与给定数组形状和数据类型相同的新数组，但所有元素都被初始化为 0。 与SGD的对比及其优势 普通SGD（随机梯度下降）：W ← W - η(∂L/∂W)在梯度为零的区域（∂L/∂W = 0），更新量直接为零，优化过程会立刻停止。这很容易陷入一些平坦的局部最优点或鞍点（这些点的梯度也是零，但不是最优解）。 Momentum方法：即使在梯度为零的点，由于 αv 项的存在，​速度不会立刻为零。之前积累的动量会推动参数 W 继续向前移动一段距离。这带来了两大好处： 有助于逃离局部最优点和鞍点：如果小球有足够的动量，它就可以“滚过”一个平坦的局部极小点或鞍点，而不是陷在里面。 抑制震荡，加速收敛：在沟壑（类似峡谷地形）中，梯度方向在沟壁间剧烈摇摆。普通的SGD会剧烈震荡，收敛缓慢。而Momentum方法中的 αv 项相当于一个迟滞系统，会将速度平均化，使更新方向更加一致地沿着沟壑的中心线（下降的主方向），从而大大减少震荡并加快收敛速度 在优化过程中，“速度” v 是一个矢量，它同时记录了方向和大小。αv 项代表的是“历史移动趋势”。 当上一时刻的速度 v 为负值，且当前梯度 -η(∂L/∂W) 也是负值时： 两者方向相同，αv 项（负值）与梯度力（负值）叠加，确实起到了加速的作用。这会使得本次更新沿着负方向走得更远、更快。 当上一时刻的速度 v 为负值，但当前梯度 -η(∂L/∂W) 为正值时： 这通常发生在参数即将越过最低点（谷底）时。此时，梯度方向改变了（从向右下变为向左下），但历史动量（αv）仍然试图将它往原来的方向（右下）推。 这时，αv（负值）和梯度力（正值）方向相反，会相互抵消一部分。这起到了“刹车”或缓冲的作用，防止参数更新在最低点附近发生过于剧烈的震荡和摇摆。 结论： αv 项并不总是起到“减速”作用。它的角色是保持历史运动趋势。这个趋势既可能加速（当与梯度同向时），也可能减速（当与梯度反向时）。这种机制使得优化过程在正确的方向上更快，同时能平滑掉一些错误方向的震荡。 但是，如果梯度为0的地方就是最低点，相比于没有动量的SGD（梯度为0就立刻停止），Momentum方法可能需要更多的迭代步骤来让这种振荡停止下来，最终精确收敛到最低点。 AdaGrad在关于学习率的有效技巧中，有一种被称为学习率衰减的方法，即随着学习的进行，使学习率逐渐减小。实际上，一开始“多”学，然后逐渐“少”学的方法，在神经网络的学习中经常被使用。 逐渐减小学习率的想法，相当于将“全体”参数的学习率值一起降低。而AdaGrad进一步发展了这个想法，针对“一个一个”的参数，赋予其“定制”的值。AdaGrad会为参数的每个元素适当地调整学习率，与此同时进行学习。 和前面的SGD一样， W表示要更新的权重参数， 表示损失函数关于W的梯度， η表示学习率。这里新出现了变量h，如式(6.5)所示，它保存了以前的所有梯度值的平方和（式（6.5）中的表示矩阵中对应元素的乘法）。然后，在更新参数时，通过乘以，就可以调整学习的尺度。这意味着，参数的元素中变动较大（被大幅更新)的元素的学习率将变小。也就是说，可以按参数的元素进行学习率衰减，使变动大的参数的学习率逐渐减小。 AdaGrad会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。实际上，如果无止境地学习，更新量就会变为 0，完全不再更新。为了改善这个问题，可以使用 RMSProp方法。RMSProp方法并不是将过去所有的梯度一视同仁地相加，而是逐渐地遗忘过去的梯度，在做加法运算时将新梯度的信息更多地反映出来。这种操作从专业上讲，称为“指数移动平均”，呈指数函数式地减小过去的梯度的尺度。 class AdaGrad: def __init__(self, lr=0.01): self.lr = lr self.h = None def update(self, params, grads): if self.h is None: self.h = for key, val in params.items(): self.h[key] = np.zeros_like(val) for key in params.keys(): self.h[key] += grads[key] * grads[key] params[key] -= self.lr * grads[key] / (np.sqrt(self.h[key]) + 1e-7) 由于y轴方向上的梯度较大，因此刚开始变动较大，但是后面会根据这个较大的变动按比例进行调整，减小更新的步伐。因此， y轴方向上的更新程度被减弱，“之”字形的变动程度有所衰减。 AdamMomentum参照小球在碗中滚动的物理规则进行移动， AdaGrad为参数的每个元素适当地调整更新步伐。Adam就是融合了这两个方法。具体的想看去看论文。 虽然Momentun也有类似的移动，但是相比之下， Adam的小球左右摇晃的程度有所减轻。这得益于学习的更新程度被适当地调整了。 class Adam: Adam (http://arxiv.org/abs/1412.6980v8) def __init__(self, lr=0.001, beta1=0.9, beta2=0.999): self.lr = lr self.beta1 = beta1 self.beta2 = beta2 self.iter = 0 self.m = None self.v = None def update(self, params, grads): if self.m is None: self.m, self.v = , for key, val in params.items(): self.m[key] = np.zeros_like(val) self.v[key] = np.zeros_like(val) self.iter += 1 lr_t = self.lr * np.sqrt(1.0 - self.beta2**self.iter) / (1.0 - self.beta1**self.iter) for key in params.keys(): #self.m[key] = self.beta1*self.m[key] + (1-self.beta1)*grads[key] #self.v[key] = self.beta2*self.v[key] + (1-self.beta2)*(grads[key]**2) self.m[key] += (1 - self.beta1) * (grads[key] - self.m[key]) self.v[key] += (1 - self.beta2) * (grads[key]**2 - self.v[key]) params[key] -= lr_t * self.m[key] / (np.sqrt(self.v[key]) + 1e-7) #unbias_m += (1 - self.beta1) * (grads[key] - self.m[key]) # correct bias #unbisa_b += (1 - self.beta2) * (grads[key]*grads[key] - self.v[key]) # correct bias #params[key] += self.lr * unbias_m / (np.sqrt(unbisa_b) + 1e-7) 权重的初始值隐藏层的激活值分布做一个简单的实验，观察权重初始值是如何影响隐藏层的激活值的分布的。这里要做的实验是，向一个5层神经网络（激活函数使用sigmoid函数）传入随机生成的输入数据，用直方图绘制各层激活值的数据分布。 import numpy as np import matplotlib.pyplot as plt def sigmoid(x): return 1 / (1 + np.exp(-x)) x = np.random.randn(1000, 100) # 1000个数据 node_num = 100 # 各隐藏层的节点（神经元）数 hidden_layer_size = 5 # 隐藏层有5层 activations = # 激活值的结果保存在这里 for i in range(hidden_layer_size): if i != 0: x = activations[i-1] w = np.random.randn(node_num, node_num) * 1 z = np.dot(x, w) a = sigmoid(z) # sigmoid函数 activations[i] = a for i, a in activations.items(): plt.subplot(1, len(activations), i+1) plt.title(str(i+1) + -layer) plt.hist(a.flatten(), 30, range=(0,1)) plt.show() 各层的激活值呈偏向0和1的分布。这里使用的sigmoid函数是S型函数，随着输出不断地靠近0（或者靠近1），它的导数的值逐渐接近0。因此，偏向0和1的数据分布会造成反向传播中梯度的值不断变小，最后消失。这个问题称为梯度消失。层次加深的深度学习中，梯度消失的问题可能会更加严重。 下面，将权重的标准差设为0.01，进行相同的实验。w = np.random.randn(node_num, node_num) * 0.01 这次呈集中在0.5附近的分布。因为不像刚才的例子那样偏向0和1，所以不会发生梯度消失的问题。但是，激活值的分布有所偏向，说明在表现力上会有很大问题。为什么这么说呢？因为如果有多个神经元都输出几乎相同的值，那它们就没有存在的意义了。比如，如果100个神经元都输出几乎相同的值，那么也可以由1个神经元来表达基本相同的事情。因此，激活值在分布上有所偏向会出现“表现力受限”的问题。 各层的激活值的分布都要求有适当的广度。为什么呢？因为通过在各层间传递多样性的数据，神经网络可以进行高效的学习。反过来，如果传递的是有所偏向的数据，就会出现梯度消失或者“表现力受限”的问题，导致学习可能无法顺利进行。 接着，我们尝试使用Xavier Glorot等人的论文中推荐的权重初始值（俗称“Xavier初始值”）。现在，在一般的深度学习框架中， Xavier初始值已被作为标准使用。 如果前一层的节点数为n，则初始值使用标准差为的分布。 Xavier初始值：与前一层有n个节点连接时，初始值使用标准差为的分布。 使用Xavier初始值后，前一层的节点数越多，要设定为目标节点的初始值的权重尺度就越小。现在，我们使用Xavier初始值进行实验。 node_num = 100 # 前一层的节点数 w = np.random.randn(node_num, node_num) / np.sqrt(node_num) 后面的层的分布呈稍微歪斜的形状。如果用tanh函数（双曲线函数）代替 sigmoid函数，这个稍微歪斜的问题就能得到改善。实际上，使用 tanh函数后，会呈漂亮的吊钟型分布。 tanh函数和sigmoid函数同是S型曲线函数，但tanh函数是关于原点(0, 0)对称的S型曲线，而 sigmoid函数是关于(x, y)(0, 0.5)对称的S型曲线。众所周知，用作激活函数的函数最好具有关于原点对称的性质。 ReLU的权重初始值Xavier初始值是以激活函数是线性函数为前提而推导出来的。因为sigmoid函数和 tanh函数左右对称，且中央附近可以视作线性函数，所以适合使用Xavier初始值。但当激活函数使用ReLU时，一般推荐使用ReLU专用的初始值，也就是Kaiming He等人推荐的初始值，也称为“He初始值” 。当前一层的节点数为n时， He初始值使用标准差为的高斯分布。 当“std 0.01”时，各层的激活值非常小 。神经网络上传递的是非常小的值，说明逆向传播时权重的梯度也同样很小。这是很严重的问题，实际上学习基本上没有进展。 接下来是初始值为Xavier初始值时的结果。在这种情况下，随着层的加深，偏向一点点变大。实际上，层加深后，激活值的偏向变大，学习时会出现梯度消失的问题。而当初始值为He初始值时，各层中分布的广度相同。由于即便层加深，数据的广度也能保持不变，因此逆向传播时，也会传递合适的值。 当激活函数使用ReLU时，权重初始值使用He初始值，当激活函数为 sigmoid或 tanh等S型曲线函数时，初始值使用Xavier初始值。 Batch Normalization如果设定了合适的权重初始值，则各层的激活值分布会有适当的广度，从而可以顺利地进行学习。那么，为了使各层拥有适当的广度，“强制性”地调整激活值的分布会怎样呢？实际上， Batch Normalization方法就是基于这个想法而产生的。 Batch Normalization 的算法优点： • 可以使学习快速进行（可以增大学习率）。 • 不那么依赖初始值（对于初始值不用那么神经质）。 • 抑制过拟合（降低Dropout等的必要性）。 Batch Norm的思路是调整各层的激活值分布使其拥有适当的广度。为此，要向神经网络中插入对数据分布进行正规化的层，即Batch Normalization层（下文简称Batch Norm层），如图6-16所示。 Batch Norm，顾名思义，以进行学习时的mini-batch为单位，按minibatch进行正规化。具体而言，就是进行使数据分布的均值为0、方差为1的正规化。 式（6.7）中的ε是一个微小值（比如， 10e-7等），它是为了防止出现除以0的情况。 通过将这个处理插入到激活函数的前面（或者后面） ，可以减小数据分布的偏向。 接着， Batch Norm层会对正规化后的数据进行缩放和平移的变换，，γ和β是参数。一开始γ 1， β 0，然后再通过学习调整到合适的值。 Batch Norm的反向传播在Frederik Kratzert 的博客“Understanding the backward pass through Batch Normalization Layer”里有详细说明。 几乎所有的情况下都是使用Batch Norm时学习进行得更快。同时也可以发现，实际上，在不使用Batch Norm的情况下，如果不赋予一个尺度好的初始值，学习将完全无法进行。 正则化权值衰减该方法通过在学习的过程中对大的权重进行惩罚，来抑制过拟合。很多过拟合原本就是因为权重参数取值过大才发生的。 对于所有权重，权值衰减方法都会为损失函数加上，因此，在求权重梯度的计算中，要为之前的误差反向传播法的结果加上正则化项的导数λW。 Dropout如果网络的模型变得很复杂，只用权值衰减就难以应对了。在这种情况下，我们经常会使用Dropout方法。 Dropout是一种在学习的过程中随机删除神经元的方法。训练时，随机选出隐藏层的神经元，然后将其删除。被删除的神经元不再进行信号的传递，如图6-22所示。训练时，每传递一次数据，就会随机选择要删除的神经元。然后，测试时，虽然会传递所有的神经元信号，但是对于各个神经元的输出，要乘上训练时的删除比例后再输出。 下面的实现重视易理解性。不过，因为训练时如果进行恰当的计算的话，正向传播时单纯地传递数据就可以了（不用乘以删除比例），所以深度学习的框架中进行了这样的实现。 class Dropout: def __init__(self, dropout_ratio=0.5): self.dropout_ratio = dropout_ratio self.mask = None def forward(self, x, train_flg=True): if train_flg: self.mask = np.random.rand(*x.shape) self.dropout_ratio return x * self.mask else: return x * (1.0 - self.dropout_ratio) def backward(self, dout): return dout * self.mask 机器学习中经常使用集成学习。所谓集成学习，就是让多个模型单独进行学习，推理时再取多个模型的输出的平均值。用神经网络的语境来说，比如，准备5个结构相同（或者类似）的网络，分别进行学习，测试时，以这5个网络的输出的平均值作为答案。实验告诉我们，通过进行集成学习，神经网络的识别精度可以提高好几个百分点。这个集成学习与 Dropout有密切的关系。这是因为可以将 Dropout理解为，通过在学习过程中随机删除神经元，从而每一次都让不同的模型进行学习。并且，推理时，通过对神经元的输出乘以删除比例（比如，0.5等），可以取得模型的平均值。也就是说，可以理解成， Dropout将集成学习的效果（模拟地）通过一个网络实现了。 超参数的验证超参数是指，比如各层的神经元数量、 batch大小、参数更新时的学习率或权值衰减等。如果这些超参数没有设置合适的值，模型的性能就会很差。虽然超参数的取值非常重要，但是在决定超参数的过程中一般会伴随很多的试错。 验证数据不能使用测试数据评估超参数的性能。 为什么不能用测试数据评估超参数的性能呢？这是因为如果使用测试数据调整超参数，超参数的值会对测试数据发生过拟合。换句话说，用测试数据确认超参数的值的“好坏”，就会导致超参数的值被调整为只拟合测试数据。这样的话，可能就会得到不能拟合其他数据、泛化能力低的模型。 因此，调整超参数时，必须使用超参数专用的确认数据。用于调整超参数的数据，一般称为验证数据。我们使用这个验证数据来评估超参数的好坏。 训练数据用于参数（权重和偏置）的学习，验证数据用于超参数的性能评估。为了确认泛化能力，要在最后使用（比较理想的是只用一次）测试数据。 超参数的最优化进行超参数的最优化时，逐渐缩小超参数的“好值”的存在范围非常重要。所谓逐渐缩小范围，是指一开始先大致设定一个范围，从这个范围中随机选出一个超参数（采样），用这个采样到的值进行识别精度的评估；然后，多次重复该操作，观察识别精度的结果，根据这个结果缩小超参数的“好值”的范围。通过重复这一操作，就可以逐渐确定超参数的合适范围。 在进行神经网络的超参数的最优化时，与网格搜索等有规律的搜索相比，随机采样的搜索方式效果更好。 超参数的范围只要“大致地指定”就可以了。所谓“大致地指定”，是指像0.001（10^-3）到1000（10^3）这样，以“10的阶乘”的尺度指定范围（也表述为“用对数尺度（log scale）指定”）。这在Python中可以写成 10 ** np.random. uniform(-3, 3)。 在超参数的最优化中，要注意的是深度学习需要很长时间（比如，几天或几周）。因此，在超参数的搜索中，需要尽早放弃那些不符合逻辑的超参数。于是，在超参数的最优化中，减少学习的epoch，缩短一次评估所需的时间是一个不错的办法。 步骤0 设定超参数的范围。 步骤1 从设定的超参数范围中随机采样。 步骤2 使用步骤1中采样到的超参数的值进行学习，通过验证数据评估识别精度（但是要将epoch设置得很小）。 步骤3 重复步骤1和步骤2（100次等），根据它们的识别精度的结果，缩小超参数的范围。 反复进行上述操作，不断缩小超参数的范围，在缩小到一定程度时，从该范围中选出一个超参数的值。 在超参数的最优化中，如果需要更精炼的方法，可以使用贝叶斯最优化。贝叶斯最优化运用以贝叶斯定理为中心的数学理论，能够更加严密、高效地进行最优化。 卷积神经网络 CNN整体结构CNN中新出现了卷积层（Convolution层）和池化层（Pooling层）。 之前介绍的神经网络中，相邻层的所有神经元之间都有连接，这称为全连接（fully-connected）。另外，我们用Affine层实现了全连接层。如果使用这个Affine层，一个5层的全连接的神经网络就可以通过图7-1所示的网络结构来实现。 如图7-1所示，全连接的神经网络中， Affine层后面跟着激活函数ReLU层（或者Sigmoid层）。这里堆叠了4层“Affine-ReLU”组合，然后第5层是Affine层，最后由Softmax层输出最终结果（概率）。 CNN的一个例子： CNN 中 新 增 了 Convolution 层 和 Pooling 层。 CNN 的层的连接顺序是“Convolution - ReLU -（Pooling）”（Pooling层有时会被省略）。这可以理解为之前的“Affi ne - ReLU”连接被替换成了“Convolution - ReLU -（Pooling）”连接。 还需要注意的是，在图7-2的CNN中，靠近输出的层中使用了之前的“Affine - ReLU”组合。此外，最后的输出层中使用了之前的“Affine - Softmax”组合。这些都是一般的CNN中比较常见的结构。 卷积层全连接层的问题之前介绍的全连接的神经网络中使用了全连接层（Affine层）。在全连接层中，相邻层的神经元全部连接在一起，输出的数量可以任意决定。 全连接层存在什么问题呢？那就是数据的形状被“忽视”了。比如，输入数据是图像时，图像通常是高、长、通道方向上的3维形状。但是，向全连接层输入时，需要将3维数据拉平为1维数据。实际上，前面提到的使用了MNIST数据集的例子中，输入图像就是1通道、高28像素、长28像素的（1, 28, 28）形状，但却被排成1列，以784个数据的形式输入到最开始的Affine层。 图像是3维形状，这个形状中应该含有重要的空间信息。比如，空间上邻近的像素为相似的值、 RBG的各个通道之间分别有密切的关联性、相距较远的像素之间没有什么关联等， 3维形状中可能隐藏有值得提取的本质模式。但是，因为全连接层会忽视形状，将全部的输入数据作为相同的神经元（同一维度的神经元）处理，所以无法利用与形状相关的信息。 而卷积层可以保持形状不变。当输入数据是图像时，卷积层会以3维数据的形式接收输入数据，并同样以3维数据的形式输出至下一层。因此，在CNN中，可以（有可能）正确理解图像等具有形状的数据。 另外， CNN 中，有时将卷积层的输入输出数据称为特征图（feature map）。其中，卷积层的输入数据称为输入特征图（input feature map），输出数据称为输出特征图（output feature map）。 卷积运算卷积层进行的处理就是卷积运算。卷积运算相当于图像处理中的“滤波器运算”。 滤波器运算，可以把它理解为给图像“戴上一副特殊的眼镜”或“使用一个修图工具”，来达到某种特定的效果。 在图像处理中，滤波器（Filter），有时也称为内核（Kernel）或掩模（Mask），是一个小的数字矩阵。滤波器运算就是将这个小的矩阵（滤波器）在大的数字矩阵（原始图像）上滑动，并在每个位置进行一系列数学计算，从而生成一幅新图像的过程。 这个过程在数学上称为卷积（Convolution），因此也常被称为卷积运算。 有的文献中也会用“核”这个词来表示这里所说的“滤波器”。 如何计算： 对于输入数据，卷积运算以一定间隔滑动滤波器的窗口并应用。这里所说的窗口是指图7-4中灰色的3 × 3的部分。如图7-4所示，将各个位置上滤波器的元素和输入的对应元素相乘，然后再求和（有时将这个计算称为乘积累加运算）。然后，将这个结果保存到输出的对应位置。将这个过程在所有位置都进行一遍，就可以得到卷积运算的输出。 在全连接的神经网络中，除了权重参数，还存在偏置。 CNN中，滤波器的参数就对应之前的权重。并且， CNN中也存在偏置。图7-3的卷积运算的例子一直展示到了应用滤波器的阶段。包含偏置的卷积运算的处理流如图7-5所示。 如图7-5所示，向应用了滤波器的数据加上了偏置。偏置通常只有1个（1 × 1）（本例中，相对于应用了滤波器的4个数据，偏置只有1个），这个值会被加到应用了滤波器的所有元素上。 填充在进行卷积层的处理之前，有时要向输入数据的周围填入固定的数据（比如0等），这称为填充（padding），是卷积运算中经常会用到的处理。比如，在图7-6的例子中，对大小为(4, 4)的输入数据应用了幅度为1的填充。“幅度为1的填充”是指用幅度为1像素的0填充周围。 使用填充主要是为了调整输出的大小。比如，对大小为(4, 4)的输入数据应用(3, 3)的滤波器时，输出大小变为(2, 2)，相当于输出大小比输入大小缩小了2个元素。这在反复进行多次卷积运算的深度网络中会成为问题。为什么呢？因为如果每次进行卷积运算都会缩小空间，那么在某个时刻输出大小就有可能变为 1，导致无法再应用卷积运算。为了避免出现这样的情况，就要使用填充。在刚才的例子中，将填充的幅度设为1，那么相对于输入大小(4, 4)，输出大小也保持为原来的(4, 4)。因此，卷积运算就可以在保持空间大小不变的情况下将数据传给下一层。 步幅应用滤波器的位置间隔称为步幅（stride）。之前的例子中步幅都是1，如果将步幅设为2，则如图7-7所示，应用滤波器的窗口的间隔变为2个元素。 步幅可以指定应用滤波器的间隔。 综上，增大步幅后，输出大小会变小。而增大填充后，输出大小会变大。如果将这样的关系写成算式，会如何呢？接下来，我们看一下对于填充和步幅，如何计算输出大小。 这里，假设输入大小为(H, W)，滤波器大小为(FH, FW)，输出大小为(OH, OW)，填充为P，步幅为S。 这里需要注意的是，虽然只要代入值就可以计算输出大小，但是所设定的值必须使分别可以除尽。当输出大小无法除尽时（结果是小数时），需要采取报错等对策。顺便说一下，根据深度学习的框架的不同，当值无法除尽时，有时会向最接近的整数四舍五入，不进行报错而继续运行。 3维数据的卷积运算图像是3维数据，除了高、长方向之外，还需要处理通道方向。这里，我们按照与之前相同的顺序，看一下对加上了通道方向的3维数据进行卷积运算的例子。 图7-8是卷积运算的例子，图7-9是计算顺序。这里以3通道的数据为例，展示了卷积运算的结果。和2维数据时（图7-3的例子）相比，可以发现纵深方向（通道方向）上特征图增加了。通道方向上有多个特征图时，会按通道进行输入数据和滤波器的卷积运算，并将结果相加，从而得到输出。 在3维数据的卷积运算中，输入数据和滤波器的通道数要设为相同的值。在这个例子中，输入数据和滤波器的通道数一致，均为3。滤波器大小可以设定为任意值（不过，每个通道的滤波器大小要全部相同）。这个例子中滤波器大小为(3, 3)，但也可以设定为(2, 2)、 (1, 1)、 (5, 5)等任意值。再强调一下，通道数只能设定为和输入数据的通道数相同的值（本例中为3）。 通道数为 C、高度为H、长度为W的数据的形状可以写成（C, H, W）。滤波器也一样，要按（channel, height, width）的顺序书写。比如，通道数为C、滤波器高度为FH（Filter Height）、长度为FW（Filter Width）时，可以写成（C, FH, FW）。 如果要在通道方向上也拥有多个卷积运算的输出，该怎么做呢？为此，就需要用到多个滤波器（权重）。用图表示的话，如图7-11所示。 通过应用FN个滤波器，输出特征图也生成了FN个。如果将这FN个特征图汇集在一起，就得到了形状为(FN, OH, OW)的方块。将这个方块传给下一层，就是CNN的处理流。 关于卷积运算的滤波器，也必须考虑滤波器的数量。因此，作为4维数据，滤波器的权重数据要按(output_channel, input_ channel , height, width)的顺序书写。比如，通道数为3、大小为5 × 5的滤波器有20个时，可以写成(20, 3, 5, 5)。 卷积运算中（和全连接层一样）存在偏置。在图7-11的例子中，如果进一步追加偏置的加法运算处理，则结果如下面的图7-12所示。 图7-12中，每个通道只有一个偏置。这里，偏置的形状是(FN, 1, 1)，滤波器的输出结果的形状是(FN, OH, OW)。这两个方块相加时，要对滤波器的输出结果(FN, OH, OW)按通道加上相同的偏置值。另外，不同形状的方块相加时，可以基于NumPy的广播功能轻松实现（1.5.5节）。 批处理需要将在各层间传递的数据保存为4维数据。具体地讲，就是按(batch_num, channel, height, width)的顺序保存数据。比如，将图7-12中的处理改成对N个数据进行批处理时，数据的形状如图7-13所示。 图7-13的批处理版的数据流中，在各个数据的开头添加了批用的维度。像这样，数据作为4维的形状在各层间传递。这里需要注意的是，网络间传递的是4维数据，对这N个数据进行了卷积运算。也就是说，批处理将N次的处理汇总成了1次进行。 池化层池化是缩小高、长方向上的空间的运算。比如，如图7-14所示，进行将2 × 2的区域集约成1个元素的处理，缩小空间大小。 图7-14的例子是按步幅2进行2 × 2的Max池化时的处理顺序。“Max池化”是获取最大值的运算，“2 × 2”表示目标区域的大小。一般来说，池化的窗口大小会和步幅设定成相同的值。比如， 3 × 3的窗口的步幅会设为3， 4 × 4的窗口的步幅会设为4等。 除了Max池化之外，还有Average池化等。相对于Max池化是从目标区域中取出最大值，Average池化则是计算目标区域的平均值。在图像识别领域，主要使用Max池化。因此，本书中说到“池化层”时，指的是Max池化。 池化层有以下特征： 没有要学习的参数 池化层和卷积层不同，没有要学习的参数。池化只是从目标区域中取最大值（或者平均值），所以不存在要学习的参数。 通道数不发生变化 经过池化运算，输入数据和输出数据的通道数不会发生变化。如图7-15所示，计算是按通道独立进行的。 对微小的位置变化具有鲁棒性（健壮） 输入数据发生微小偏差时，池化仍会返回相同的结果。因此，池化对输入数据的微小偏差具有鲁棒性。比如， 3 × 3的池化的情况下，如图7-16所示，池化会吸收输入数据的偏差（根据数据的不同，结果有可能不一致）。 卷积层和池化层的实现4维数组CNN中各层间传递的数据是4维数据。所谓4维数据，比如数据的形状是(10, 1, 28, 28)，则它对应10个高为28、长为28、通道为1的数据。用Python来实现的话，如下所示。 x = np.random.rand(10, 1, 28, 28) # 随机生成数据 x.shape (10, 1, 28, 28) 如果要访问第1个数据，只要写 x[0]就可以了。 x[0].shape # (1, 28, 28) 如果要访问第1个数据的第1个通道的空间数据： x[0, 0] # 或者x[0][0] 基于 im2col的展开如果老老实实地实现卷积运算，估计要重复好几层的 for语句。这样的实现有点麻烦，而且， NumPy中存在使用for语句后处理变慢的缺点（NumPy中，访问元素时最好不要用 for语句）。这里，我们不使用 for语句，而是使用im2col这个便利的函数进行简单的实现。 im2col是一个函数，将输入数据展开以适合滤波器（权重）。如图7-17所示，对3维的输入数据应用im2col后，数据转换为2维矩阵（正确地讲，是把包含批数量的4维数据转换成了2维数据）。 im2col会把输入数据展开以适合滤波器（权重）。具体地说，如图7-18所示，对于输入数据，将应用滤波器的区域（3维方块）横向展开为1列。 im2col会在所有应用滤波器的地方进行这个展开处理。 在图7-18中，为了便于观察，将步幅设置得很大，以使滤波器的应用区域不重叠。而在实际的卷积运算中，滤波器的应用区域几乎都是重叠的。在滤波器的应用区域重叠的情况下，使用im2col展开后，展开后的元素个数会多于原方块的元素个数。因此，使用im2col的实现存在比普通的实现消耗更多内存的缺点。但是，汇总成一个大的矩阵进行计算，对计算机的计算颇有益处。 使用 im2col展开输入数据后，之后就只需将卷积层的滤波器（权重）纵向展开为1列，并计算2个矩阵的乘积即可（参照图7-19）。这和全连接层的Affi ne层进行的处理基本相同。 如图7-19所示，基于 im2col方式的输出结果是2维矩阵。因为CNN中数据会保存为4维数组，所以要将2维输出数据转换为合适的形状。以上就是卷积层的实现流程。 卷积层的实现def im2col(input_data, filter_h, filter_w, stride=1, pad=0): Parameters ---------- input_data : 由(数据量, 通道, 高, 长)的4维数组构成的输入数据 filter_h : 滤波器的高 filter_w : 滤波器的长 stride : 步幅 pad : 填充 Returns ------- col : 2维数组 N, C, H, W = input_data.shape out_h = (H + 2*pad - filter_h)//stride + 1 out_w = (W + 2*pad - filter_w)//stride + 1 img = np.pad(input_data, [(0,0), (0,0), (pad, pad), (pad, pad)], constant) col = np.zeros((N, C, filter_h, filter_w, out_h, out_w)) for y in range(filter_h): y_max = y + stride*out_h for x in range(filter_w): x_max = x + stride*out_w col[:, :, y, x, :, :] = img[:, :, y:y_max:stride, x:x_max:stride] col = col.transpose(0, 4, 5, 1, 2, 3).reshape(N*out_h*out_w, -1) return col 重塑为2D矩阵： 行数：N * out_h * out_w（所有输出位置） 列数：C * filter_h * filter_w（每个位置的滤波器窗口） 现在使用im2col来实现卷积层。这里我们将卷积层实现为名为Convolution的类。 class Convolution: def __init__(self, W, b, stride=1, pad=0): self.W = W self.b = b self.stride = stride self.pad = pad def forward(self, x): FN, C, FH, FW = self.W.shape N, C, H, W = x.shape out_h = int(1 + (H + 2*self.pad - FH) / self.stride) out_w = int(1 + (W + 2*self.pad - FW) / self.stride) col = im2col(x, FH, FW, self.stride, self.pad) col_W = self.W.reshape(FN, -1).T # 滤波器的展开 out = np.dot(col, col_W) + self.b out = out.reshape(N, out_h, out_w, -1).transpose(0, 3, 1, 2) return out 卷积层的初始化方法将滤波器（权重）、偏置、步幅、填充作为参数接收。滤波器是 (FN, C, FH, FW)的 4 维形状。另外， FN、 C、 FH、 FW分别是 Filter Number（滤波器数量）、 Channel、 Filter Height、 Filter Width的缩写。 这里通过 reshape(FN,-1)将参数指定为 -1，这是reshape的一个便利的功能。通过在 reshape时指定为 -1， reshape函数会自动计算 -1维度上的元素个数，以使多维数组的元素个数前后一致。比如， (10, 3, 5, 5)形状的数组的元素个数共有750个，指定 reshape(10,-1)后，就会转换成(10, 75)形状的数组。forward的实现中，最后会将输出大小转换为合适的形状。转换时使用了NumPy的transpose函数。 transpose会更改多维数组的轴的顺序。 以上就是卷积层的 forward处理的实现。通过使用 im2col进行展开，基本上可以像实现全连接层的Affine层一样来实现。接下来是卷积层的反向传播的实现，因为和Affine层的实现有很多共通的地方，所以就不再介绍了。但有一点需要注意，在进行卷积层的反向传播时，必须进行im2col的逆处理。 “必须进行 im2col 的逆处理” 指的是将梯度信息从展开的矩阵形式转换回原始图像格式的关键步骤。 反向传播过程： 计算输出梯度（损失函数对输出的导数） 关键步骤：将梯度转换回 im2col 格式 计算滤波器梯度：滤波器梯度 = im2col(input)^T × 输出梯度 关键步骤：计算输入梯度（需要 im2col 的逆操作） 前向传播通过 im2col 改变了数据表示形式 反向传播必须沿相同路径反向传播梯度 需要将梯度从矩阵形式映射回原始图像格式 def col2im(col, input_shape, filter_h, filter_w, stride=1, pad=0): Parameters ---------- col : input_shape : 输入数据的形状（例：(10, 1, 28, 28)） filter_h : filter_w stride pad Returns ------- N, C, H, W = input_shape out_h = (H + 2*pad - filter_h)//stride + 1 out_w = (W + 2*pad - filter_w)//stride + 1 col = col.reshape(N, out_h, out_w, C, filter_h, filter_w).transpose(0, 3, 4, 5, 1, 2) img = np.zeros((N, C, H + 2*pad + stride - 1, W + 2*pad + stride - 1)) for y in range(filter_h): y_max = y + stride*out_h for x in range(filter_w): x_max = x + stride*out_w img[:, :, y:y_max:stride, x:x_max:stride] += col[:, :, y, x, :, :] return img[:, :, pad:H + pad, pad:W + pad] 池化层的实现池化层的实现和卷积层相同，都使用im2col展开输入数据。不过，池化的情况下，在通道方向上是独立的，这一点和卷积层不同。具体地讲，如图7-21所示，池化的应用区域按通道单独展开。 像这样展开之后，只需对展开的矩阵求各行的最大值，并转换为合适的形状即可（图7-22）。 Python的实现示例： class Pooling: def __init__(self, pool_h, pool_w, stride=1, pad=0): self.pool_h = pool_h self.pool_w = pool_w self.stride = stride self.pad = pad def forward(self, x): N, C, H, W = x.shape out_h = int(1 + (H - self.pool_h) / self.stride) out_w = int(1 + (W - self.pool_w) / self.stride) # 展开(1) col = im2col(x, self.pool_h, self.pool_w, self.stride, self.pad) col = col.reshape(-1, self.pool_h*self.pool_w) # 最大值(2) out = np.max(col, axis=1) # 转换(3) out = out.reshape(N, out_h, out_w, C).transpose(0, 3, 1, 2) return out 池化层的实现按下面3个阶段进行： 1.展开输入数据。2.求各行的最大值。3.转换为合适的输出大小。 CNN的实现要实现如图7-23所示的CNN。 自己去看 CNN的可视化第1层权重的可视化第1层的卷积层的权重的形状是(30, 1, 5, 5)，即30个大小为5 × 5、通道为1的滤波器。滤波器大小是5 × 5、通道数是1，意味着滤波器可以可视化为1通道的灰度图像。现在，我们将卷积层（第1层）的滤波器显示为图像。这里，我们来比较一下学习前和学习后的权重，结果如图7-24所示。 图7-24中，学习前的滤波器是随机进行初始化的，所以在黑白的浓淡上没有规律可循，但学习后的滤波器变成了有规律的图像。我们发现，通过学习，滤波器被更新成了有规律的滤波器，比如从白到黑渐变的滤波器、含有块状区域（称为blob）的滤波器等。 右边的有规律的滤波器在“观察”什么，答案就是它在观察边缘（颜色变化的分界线）和斑块（局部的块状区域）等。比如，左半部分为白色、右半部分为黑色的滤波器的情况下，如图7-25所示，会对垂直方向上的边缘有响应。 图7-25中显示了选择两个学习完的滤波器对输入图像进行卷积处理时的结果。我们发现“滤波器1”对垂直方向上的边缘有响应，“滤波器2 ”对水平方向上的边缘有响应。 由此可知，卷积层的滤波器会提取边缘或斑块等原始信息。而刚才实现的CNN会将这些原始信息传递给后面的层。 基于分层结构的信息提取第1层的卷积层中提取了边缘或斑块等“低级”信息，那么在堆叠了多层的CNN中，各层中又会提取什么样的信息呢？ 图7-26中展示了进行一般物体识别（车或狗等）的8层CNN。这个网络结构的名称是下一节要介绍的AlexNet。 AlexNet网络结构堆叠了多层卷积层和池化层，最后经过全连接层输出结果。图7-26的方块表示的是中间数据，对于这些中间数据，会连续应用卷积运算。 如图7-26所示，如果堆叠了多层卷积层，则随着层次加深，提取的信息也愈加复杂、抽象，这是深度学习中很有意思的一个地方。最开始的层对简单的边缘有响应，接下来的层对纹理有响应，再后面的层对更加复杂的物体部件有响应。也就是说，随着层次加深，神经元从简单的形状向“高级”信息变化。换句话说，就像我们理解东西的“含义”一样，响应的对象在逐渐变化。 具有代表性的CNNLeNet LeNet在1998年被提出，是进行手写数字识别的网络。如图7-27所示，它有连续的卷积层和池化层（正确地讲，是只“抽选元素”的子采样层），最后经全连接层输出结果。 和“现在的CNN”相比， LeNet有几个不同点。第一个不同点在于激活函数。 LeNet中使用sigmoid函数，而现在的CNN中主要使用ReLU函数。此外，原始的LeNet中使用子采样（subsampling）缩小中间数据的大小，而现在的CNN中Max池化是主流。 AlexNet AlexNet叠有多个卷积层和池化层，最后经由全连接层输出结果。虽然结构上AlexNet和LeNet没有大的不同，但有以下几点差异。 • 激活函数使用ReLU。 • 使用进行局部正规化的LRN（Local Response Normalization）层。 • 使用Dropout。 深度学习深度学习是加深了层的深度神经网络。基于之前介绍的网络，只需通过叠加层，就可以创建深度网络。 加深网络创建一个如图8-1所示的网络结构的CNN（一个比之前的网络都深的网络）。这里使用的卷积层全都是3 × 3的小型滤波器，特点是随着层的加深，通道数变大（卷积层的通道数从前面的层开始按顺序以16、 16、 32、 32、 64、 64的方式增加）。此外，如图8-1所示，插入了池化层，以逐渐减小中间数据的空间大小；并且，后面的全连接层中使用了Dropout层。 这个网络使用He初始值作为权重的初始值，使用Adam 更新权重参数。把上述内容总结起来，这个网络有如下特点。 • 基于3× 3的小型滤波器的卷积层。 • 激活函数是ReLU。 • 全连接层的后面使用Dropout层。 • 基于Adam的最优化。 • 使用He初始值作为权重初始值。 对于手写数字识别这样一个比较简单的任务，没有必要将网络的表现力提高到那么高的程度。因此，可以说加深层的好处并不大。而之后要介绍的大规模的一般物体识别的情况，因为问题复杂，所以加深层对提高识别精度大有裨益。 集成学习、学习率衰减、 Data Augmentation（数据扩充）等都有助于提高识别精度。尤其是Data Augmentation，虽然方法很简单，但在提高识别精度上效果显著。 Data Augmentation基于算法“人为地”扩充输入图像（训练图像）。具体地说，如图8-4所示，对于输入图像，通过施加旋转、垂直或水平方向上的移动等微小变化，增加图像的数量。这在数据集的图像数量有限时尤其有效。 除了如图8-4所示的变形之外， Data Augmentation还可以通过其他各种方法扩充图像，比如裁剪图像的“crop处理”、将图像左右翻转的“flip处理”（flip处理只在不需要考虑图像对称性的情况下有效。）等。对于一般的图像，施加亮度等外观上的变化、放大缩小等尺度上的变化也是有效的。 加深层的好处： 可以减少网络的参数数量。说得详细一点，就是与没有加深层的网络相比，加深了层的网络可以用更少的参数达到同等水平（或者更强）的表现力。这一点结合卷积运算中的滤波器大小来思考就好理解了。比如，图8-5展示了由5 × 5的滤波器构成的卷积层。 一次5 × 5的卷积运算的区域可以由两次3 × 3的卷积运算抵充。并且，相对于前者的参数数量25（5 × 5），后者一共是18（2 × 3 × 3），通过叠加卷积层，参数数量减少了。而且，这个参数数量之差会随着层的加深而变大。比如，重复三次3 × 3的卷积运算时，参数的数量总共是27。而为了用一次卷积运算“观察”与之相同的区域，需要一个7 × 7的滤波器，此时的参数数量是49。 叠加小型滤波器来加深网络的好处是可以减少参数的数量，扩大感受野（receptive field，给神经元施加变化的某个局部空间区域）。并且，通过叠加层，将 ReLU等激活函数夹在卷积层的中间，进一步提高了网络的表现力。这是因为向网络添加了基于激活函数的“非线性”表现力，通过非线性函数的叠加，可以表现更加复杂的东西。 加深层的另一个好处就是使学习更加高效。与没有加深层的网络相比，通过加深层，可以减少学习数据，从而高效地进行学习。为了直观地理解这一点，CNN的卷积层会分层次地提取信息。具体地说，在前面的卷积层中，神经元会对边缘等简单的形状有响应，随着层的加深，开始对纹理、物体部件等更加复杂的东西有响应。 我们先牢记这个网络的分层结构，然后考虑一下“狗”的识别问题。要用浅层网络解决这个问题的话，卷积层需要一下子理解很多“狗”的特征。“狗”有各种各样的种类，根据拍摄环境的不同，外观变化也很大。因此，要理解“狗”的特征，需要大量富有差异性的学习数据，而这会导致学习需要花费很多时间。 不过，通过加深网络，就可以分层次地分解需要学习的问题。因此，各层需要学习的问题就变成了更简单的问题。比如，最开始的层只要专注于学习边缘就好，这样一来，只需用较少的学习数据就可以高效地进行学习。这是为什么呢？因为和印有“狗”的照片相比，包含边缘的图像数量众多，并且边缘的模式比“狗”的模式结构更简单。 通过加深层，可以分层次地传递信息。比如，因为提取了边缘的层的下一层能够使用边缘的信息，所以应该能够高效地学习更加高级的模式。也就是说，通过加深层，可以将各层要学习的问题分解成容易解决的简单问题，从而可以进行高效的学习。 深度学习的高速化深度学习中什么样的处理比较耗时。图8-14中以AlexNet的 forward处理为对象，用饼图展示了各层所耗费的时间。 从图中可知， AlexNex中，大多数时间都被耗费在卷积层上。实际上，卷积层的处理时间加起来占GPU整体的95%，占CPU整体的89%！因此，如何高速、高效地进行卷积层中的运算是深度学习的一大课题。虽然图8-14是推理时的结果，不过学习时也一样，卷积层中会耗费大量时间。 卷积层中进行的运算可以追溯至乘积累加运算。因此，深度学习的高速化的主要课题就变成了如何高速、高效地进行大量的乘积累加运算。 GPU计算，是指基于GPU进行通用的数值计算的操作。 深度学习中需要进行大量的乘积累加运算（或者大型矩阵的乘积运算）。这种大量的并行运算正是GPU所擅长的（反过来说， CPU比较擅长连续的、复杂的计算）。因此，与使用单个CPU相比，使用GPU进行深度学习的运算可以达到惊人的高速化。下面我们就来看一下基于GPU可以实现多大程度的高速化。图8-15是基于CPU和GPU进行AlexNet的学习时分别所需的时间。 从图中可知，使用CPU要花40天以上的时间，而使用GPU则可以将时间缩短至6天。此外，还可以看出，通过使用cuDNN这个最优化的库，可以进一步实现高速化。 大多数深度学习框架只受益于NVIDIA的GPU。这是因为深度学习的框架中使用了NVIDIA提供的CUDA这个面向GPU计算的综合开发环境。 通过 im2col可以将卷积层进行的运算转换为大型矩阵的乘积。相比按小规模的单位进行计算，GPU更擅长计算大规模的汇总好的数据。也就是说，通过基于 im2col以大型矩阵的乘积的方式汇总计算，更容易发挥出GPU的能力。 为了进一步提高深度学习所需的计算的速度，可以考虑在多个GPU或者多台机器上进行分布式计算。现在的深度学习框架中，出现了好几个支持多GPU或者多机器的分布式学习的框架。其中， Google的TensorFlow、微软的CNTK（Computational Network Toolki）在开发过程中高度重视分布式学习。以大型数据中心的低延迟· 高吞吐网络作为支撑，基于这些框架的分布式学习呈现出惊人的效果。 基于分布式学习，可以达到何种程度的高速化呢？图8-16中显示了基于TensorFlow的分布式学习的效果。 如图8-16所示，随着GPU个数的增加，学习速度也在提高。实际上，与使用1个GPU时相比，使用100个GPU（设置在多台机器上，共100个）似乎可以实现56倍的高速化。 关于分布式学习，“如何进行分布式计算”是一个非常难的课题。它包含了机器间的通信、数据的同步等多个无法轻易解决的问题。可以将这些难题都交给TensorFlow等优秀的框架。 在深度学习的高速化中，除了计算量之外，内存容量、总线带宽等也有可能成为瓶颈。关于内存容量，需要考虑将大量的权重参数或中间数据放在内存中。关于总线带宽，当流经GPU（或者CPU）总线的数据超过某个限制时，就会成为瓶颈。考虑到这些情况，我们希望尽可能减少流经网络的数据的位数。 计算机中为了表示实数，主要使用64位或者32位的浮点数。通过使用较多的位来表示数字，虽然数值计算时的误差造成的影响变小了，但计算的处理成本、内存使用量却相应地增加了，还给总线带宽带来了负荷。 关于数值精度（用几位数据表示数值），我们已经知道深度学习并不那么需要数值精度的位数。这是神经网络的一个重要性质。这个性质是基于神经网络的健壮性而产生的。这里所说的健壮性是指，比如，即便输入图像附有一些小的噪声，输出结果也仍然保持不变。可以认为，正是因为有了这个健壮性，流经网络的数据即便有所“劣化”，对输出结果的影响也较小。 计算机中表示小数时，有32位的单精度浮点数和64位的双精度浮点数等格式。根据以往的实验结果，在深度学习中，即便是16位的半精度浮点数（half float），也可以顺利地进行学习。 以往的深度学习的实现中并没有注意数值的精度，不过Python中一般使用64位的浮点数。 NumPy中提供了16位的半精度浮点数类型（不过，只有16位类型的存储，运算本身不用16位进行），即便使用NumPy的半精度浮点数，识别精度也不会下降。"},{"title":"python暑假","path":"/2025/07/08/python暑假/","content":"杂1、在 Python 中，判断一个字符串（或任何序列）中有多少个不重复的元素，最简单、最可靠的方法是使用 set (集合)。 2、多字符替换 # 创建映射表：将aeiou替换为12345 table = str.maketrans(aeiou, 12345) text = hello world result = text.translate(table) # 输出: h2ll4 w4rld 如何对字典元素进行排序1、按键排序（升序） my_dict = banana: 3, apple: 4, pear: 1, orange: 2 # 方法1：返回排序后的键值对元组列表 sorted_items = sorted(my_dict.items()) # 默认按键升序 print(sorted_items) # list类型 # 输出: [(apple, 4), (banana, 3), (orange, 2), (pear, 1)] # 方法2：生成有序字典（Python 3.7+） from collections import OrderedDict sorted_dict = OrderedDict(sorted(my_dict.items())) print(sorted_dict) # 输出: OrderedDict([(apple, 4), (banana, 3), ...]) OrderedDict是collections 模块提供的特殊字典子类，会记录键的插入顺序，按插入顺序返回元素。 2、按值排序（升序） # 使用lambda函数指定按值排序 sorted_items = sorted(my_dict.items(), key=lambda item: item[1]) print(sorted_items) # 输出: [(pear, 1), (orange, 2), (banana, 3), (apple, 4)] 3、降序排序 加上reverse关键字。 split分割字符串针对字符串 2/5 4/15 1/30 -2/60 8/3 进行分隔处理，’‘和’ ‘作为分割符 # 原始字符串 input_str = 2/5 4/15 1/30 -2/60 8/3 # 方法1：分两步处理（先按空格分割，再按斜杠分割） parts = input_str.split() result = [] for fraction in parts: numerator, denominator = fraction.split(/) result.append((numerator, denominator)) print(方法1结果:, result) # 输出: [(2, 5), (4, 15), (1, 30), (-2, 60), (8, 3)] # 方法2：使用列表推导式（更简洁） result_clean = [frac.split(/) for frac in input_str.split()] print(方法2结果:, result_clean) # 输出: [[2, 5], [4, 15], [1, 30], [-2, 60], [8, 3]] 假如有多个字符要作为分割的标准，要如何进行分割？ import re text = apple;banana,cherry|date:fig separators = ;,|: # 分隔符列表（含空格） # 方法1：使用字符类 [] result = re.split(r[;,|: ]+, text) # 方法2：使用替代符号 | result = re.split(r;|,|\\||:|\\s+, text) # \\s 包含所有空白字符 print(f分割结果: result) # 输出: [apple, banana, cherry, date, fig] 处理连续分割符 text = data1,,data2;;data3 data4 result = [s for s in re.split(r[,\\s;]+, text) if s] # 过滤空字符串 print(f过滤空值结果: result) # 输出: [data1, data2, data3, data4] 在result = re.split(r[;,|: ]+, text)中，[;,|: ]+是一个字符类（方括号 []），但它没有使用捕获分组括号(),正则表达式引擎会找到所有匹配的分隔符，但不会在结果中保留它们，最终结果只包含非分隔符部分。 result = re.split(r([-+=]), text) 使用了捕获分组括号 ()，所以会将分隔符也包含在结果中 Python的 和 % a b：结果向下取整（向负无穷方向）。例如，7 3 2，但 -7 3 -3。 a % b：结果的符号与除数b的符号相同。例如，-7 % 3 2 (因为 -3 * 3 + 2 -7)。 取整python中使用round(number,decimal)函数进行四舍五入操作，number是要四舍五入的函数，decimal是舍入到第几位小数，默认为0。 在python中round的四舍五入是银行家舍入，当舍入位置正好在中间（即 0.5）时，会选择最接近的偶数。 2.5 处于两个整数之间：2 是偶数，3 是奇数 → 选择 2。 在这里如果想要使用原始的四舍五入的话，需要自己编写一个函数。 def round_traditional(x): return int(x + 0.5) if x 0 else int(x - 0.5) print(round_traditional(2.5)) # 3 print(round_traditional(3.5)) # 4 向上取整：math.ceil() 向下取整：math.floor() 判断字符串为空直接判断 s = # 空字符串 # 简洁的判断方式 if not s: print(字符串为空) # 等价于 if s == : print(字符串为空) 方法 1：直接布尔判断 def is_empty(s): return not s 长度判断 def is_empty(s): return len(s) == 0 与空字符串比较 def is_empty(s): return s == 多级排序1、通过元组实现多级排序 data = [ (Alice, 25, 90), (Bob, 30, 85), (Charlie, 25, 95), (David, 30, 80) ] # 第一优先级：年龄升序（正数），第二优先级：分数降序（负数） sorted_data = sorted(data, key=lambda x: (x[1], -x[2])) 2、自定义排序函数 def custom_sort(item): # 返回一个元组定义排序优先级 return (item[1], -item[2]) # 年龄升序，分数降序 sorted_data = sorted(data, key=custom_sort) 3、多次排序 # 先按次要条件排序，再按主要条件排序（重要：从最次要开始） temp = sorted(data, key=lambda x: x[2], reverse=True) # 分数降序 sorted_data = sorted(temp, key=lambda x: x[1]) # 年龄升序 赋最大值或最小值最大值初始化 # 使用 float(inf) 表示最大浮点数 max_val = float(inf) # 也可以使用 sys.maxsize (系统支持的最大整数值) import sys max_val = sys.maxsize 最小值初始化 # 使用 float(-inf) 表示最小浮点数 min_val = float(-inf) # 对于包含负数的场景 min_val = sys.maxsize * -1 deque(双端队列)collections.deque是双向链表的实现，支持高效的两端操作（O(1)时间）。 固定长度支持：通过maxlen参数限制队列长度，超长时自动丢弃另一端元素（如deque([1,2,3], maxlen=3)添加新元素会移除旧元素） from collections import deque dq = deque() #可以通过索引的方式访问 dq.append(a) # 右侧添加 → deque([a]) dq.appendleft(b) # 左侧添加 → deque([b, a]) dq.pop() # 右侧删除 → 返回 a dq.popleft() # 左侧删除 → 返回 b clear() # 清空所有元素 extend(iterable)\t# 在右端批量添加元素 dq.extend([4,5]) → deque([1,2,3,4,5]) extendleft(iterable)\t# 在左端批量添加元素（添加顺序逆序）\tdq.extendleft([0,-1]) → deque([-1,0,1,2,3]) 通过这个实现队列或栈： 队列 (FIFO)：append入队 + popleft出队 栈 (LIFO)：append入栈 + pop出栈 Counter（计数器）from collections import Counter 统计可哈希对象（如字符串、列表）中元素的频率，返回形如元素: 次数的字典子类。 访问不存在的键返回0而非KeyError。 提供加法（+）、减法（-）、交集（）、并集（|）等集合操作。 Counter(iterable)\t通过可迭代对象（如列表、字符串）初始化\tCounter(hello) → h:1, e:1, l:2, o:1 Counter(**kwargs)\t通过关键字参数初始化\tCounter(a=3, b=2) → a:3, b:2 c[key]\t返回键对应的计数（键不存在时返回0）\tc[a] → 3；c[x] → 0 most_common(n)\t返回前n个高频元素及计数\tCounter(abracadabra).most_common(2) → [(a,5), (b,2)] update(iterable)\t批量增加计数（支持可迭代对象、字典或Counter）\tc.update([a,d]) → a:4, b:2, d:1 subtract(iterable)\t批量减少计数（允许负值）\tc.subtract(a:2) → a:2, b:2 elements()\t返回所有元素的迭代器（按计数重复）\tlist(Counter(a=2,b=1).elements()) → [a,a,b] c1 + c2\t合并计数（相同键的计数相加）\tCounter(a=3)+Counter(a=1,b=2) → a:4, b:2 c1 - c2\t计算计数差（保留正计数）\tCounter(a=3,b=1)-Counter(a=1,b=2) → a:2 c1 c2\t交集（取相同键的最小计数）\tCounter(a=3,b=1) Counter(a=2,b=2) → a:2, b:1 快速分析单词字符频率： text = the quick brown fox jumps over the lazy dog word_count = Counter(text.split()) top_words = word_count.most_common(3) # [(the, 2), (quick, 1), (brown, 1)] match-casePython 3.10 引入的模式匹配语法. match value: case A: return Case A case B: return Case B case _: # 默认分支 return Default 支持类型、结构匹配（如列表、元组）： def handle_data(data): match data: case [x, y]: return f坐标: (x, y) case name: name, age: age: return f用户: name, age岁 case int() | float() as num: return f数字: num case _: return 未知类型 print(handle_data([3, 4])) # 输出: 坐标: (3, 4) print(handle_data(name: Alice)) # 输出: 用户: Alice, None岁 进制转化bin(): 十进制 → 二进制（返回带前缀 0b 的字符串） num = 42 binary = bin(num) # 0b101010 pure_binary = bin(num)[2:] # 101010（切片去前缀） oct(): 十进制 → 八进制（前缀 0o） octal = oct(42)[2:] # 52 hex(): 十进制 → 十六进制（前缀 0x，字母小写） hex_str = hex(42)[2:] # 2a hex_upper = hex(42)[2:].upper() # 2A（转大写） int(): 其他进制 → 十进制（需指定源进制基数） decimal = int(101010, 2) # 二进制 → 十进制 → 42 decimal = int(2A, 16) # 十六进制 → 42 decimal = int(52, 8) # 八进制 → 42 sys模块调整递归深度Python 默认递归深度约 1000 层 import sys # 获取当前递归深度限制 current_limit = sys.getrecursionlimit() print(f当前递归深度限制: current_limit) # 设置新的递归深度限制 sys.setrecursionlimit(10000) # 提高到 10000 层 # 递归函数示例 def deep_recursion(n): if n = 0: return 0 return deep_recursion(n-1) + 1 try: result = deep_recursion(5000) # 尝试深度递归 except RecursionError as e: print(f递归错误: e) # 获取当前调用栈深度 frames = sys._getframe() depth = 0 while frames: depth += 1 frames = frames.f_back print(f实际达到的递归深度: depth) sys._getframe() ，它返回一个帧对象（frame object），该对象代表了当前调用栈中的一个执行帧。 import sys # 基本调用形式 frame = sys._getframe([depth]) ​depth​ (可选参数)：指定要获取的栈帧深度 0：当前帧（默认值） 1：调用当前函数的帧 2：调用调用者的帧，依此类推 f_back\t指向调用者帧的引用\tcaller_frame = frame.f_back 定制排序在 Python 中实现定制排序主要依靠内置函数 sorted() 和列表方法 list.sort() 的 key 和 reverse 参数，结合自定义规则函数或 lambda 表达式。 fruits = [banana, apple, grape] fruits.sort(key=len) # 按长度排序 # 按字符串长度排序 words = [apple, banana, cherry] sorted_words = sorted(words, key=len) # 输出：[apple, cherry, banana][1,3] # 按元组第二个元素排序 pairs = [(1, 3), (4, 1), (2, 5)] sorted_pairs = sorted(pairs, key=lambda x: x[1]) # 输出：[(4, 1), (1, 3), (2, 5)][2,6] # 按学生年龄降序排序 students = [name: Alice, age: 25, name: Bob, age: 20] sorted_students = sorted(students, key=lambda s: s[age], reverse=True) # 输出：[name: Alice, age: 25, name: Bob, age: 20][8,10] 多级排序（多个条件）： 先按年龄升序，年龄相同再按姓名升序。 students = [(Alice, 25), (Bob, 20), (Charlie, 25)] sorted_students = sorted(students, key=lambda x: (x[1], x[0])) # 输出：[(Bob, 20), (Alice, 25), (Charlie, 25)][5,8] 使用 functools.cmp_to_key 实现传统比较函数 from functools import cmp_to_key def compare(x, y): if x % 2 == y % 2: # 奇偶性相同 return x - y # 数值升序 elif x % 2 == 1: # x为奇数则排前面 return -1 else: return 1 numbers = [3, 1, 2, 4] sorted_numbers = sorted(numbers, key=cmp_to_key(compare)) # 输出：[1, 3, 2, 4]（奇数在前、升序）[2,6] from functools import cmp_to_key def multi_sort(a, b): if a.score != b.score: return b.score - a.score # 成绩降序 return a.age - b.age # 年龄升序 students.sort(key=cmp_to_key(multi_sort)) 如果要比较的对象是类的话，也可以选择在类中重写它的’’运算符，也就是__lt__方法： class Task: def __init__(self, priority, desc): self.priority = priority self.desc = desc def __lt__(self, other): # 定义比较规则 return self.priority other.priority # 数值小优先 heap = [] heap.append(Task(3, Low)) heap.append(Task(1, High)) heap.sort() # 效果和使用lambda表达式的效果一样：heap.sort(key=lambda x: x.priority) for item in heap: print(item.priority) 全局变量在模块顶层（函数、类外部）定义的变量自动成为全局变量，可在模块内任何地方访问。 # 模块顶层定义的全局变量 global_count = 0 # 可被模块内所有函数访问 MAX_ATTEMPTS = 3 # 通常用大写表示常量 def increment(): global global_count # 声明使用全局变量 global_count += 1 # 修改全局变量 def get_count(): return global_count # 可直接读取 increment() print(get_count()) # 输出: 1 在函数内部要修改全局变量时，必须使用 global 关键字声明： total = 0 # 全局变量 def add_values(a, b): global total # 声明使用全局变量 total = a + b # 修改全局变量 add_values(5, 3) print(total) # 输出: 8 如果不使用 global，Python 会创建一个同名的局部变量。 functools reduce：累积计算 功能：对可迭代对象进行累积操作，返回单一结果。​参数​： function：二元操作函数（如lambda x, y: x+y） iterable：可迭代对象 initializer：初始值（可选） from functools import reduce # 计算阶乘（无初始值） factorial = reduce(lambda x, y: x * y, range(1, 6)) # 120 cmp_to_key：兼容传统比较 常用函数 abs(x)功能：返回数值 x 的绝对值。 all(iterable) 功能：如果给定的可迭代对象中所有元素都为真（或可迭代对象为空），则返回 True，否则返回 False。 any(iterable) 功能：如果给定的可迭代对象中至少有一个元素为真，则返回 True，否则返回 False。 bin(x) 功能：将整数 x 转换为二进制字符串。 5.chr(i) 功能：返回整数 i 对应的字符。 6.complex([real[, imag]]) 功能：返回一个复数。 print(complex(2, 3)) # 输出 (2+3j) 7、**divmod(a, b)** 功能：返回除法的商和余数。 8、**enumerate(iterable, start=0)** 功能：将一个可迭代对象组合为一个索引序列，返回 (index, value) 对。 for idx, val in enumerate([a, b, c]): print(idx, val) 0 a 1 b 2 c 9、**eval(expression, globals=None, locals=None)** 功能：执行一个字符串表达式，并返回表达式的结果。 print(eval(3 + 5)) # 输出 8 10、filter(function, iterable)功能：筛选出可迭代对象中符合条件的元素。 print(list(filter(lambda x: x 0, [-1, 2, 3, -4]))) # 输出 [2, 3] 11、float(x)功能：将 x 转换为浮点数。 12、hash(x)功能：返回对象 x 的哈希值。 13、**hex(x)** 功能：将整数 x 转换为十六进制字符串 14、**int(x, base=10)** 功能：将 x 转换为整数。 15、**isinstance(obj, classinfo)** 功能：检查对象 obj 是否是 classinfo 类或其子类的实例。 print(isinstance(5, int)) # 输出 True 16、**iter(iterable)** 功能：返回一个迭代器。 it = iter([1, 2, 3])print(next(it)) # 输出 1 17、**max(iterable, \\*[, key, default])** 功能：返回可迭代对象中的最大值。 print(max([1, 2, 3])) # 输出 3 18、**min(iterable, \\*[, key, default])** 功能：返回可迭代对象中的最小值。 19、**next(iterator[, default])** 功能：返回迭代器的下一个元素。如果没有元素，返回 default。 20、**oct(x)** 功能：将整数 x 转换为八进制字符串。 21、**ord(c)** 功能：返回字符 c 的 Unicode 码。 22、**pow(x, y[, z])** 功能：返回 x 的 y 次方。如果提供了 z，则返回 x**y % z。 23、**print(\\*objects, sep= , end= , file=sys.stdout)** 24、**reversed(seq)** 功能：返回一个反转的迭代器。 print(list(reversed([1, 2, 3]))) # 输出 [3, 2, 1] 25、**str([object])** 功能：将对象转换为字符串。 26、**sum(iterable, /, start=0)** 功能：返回可迭代对象中所有元素的和，start 是初始值。 27、**zip(\\*iterables)** 功能：将多个可迭代对象“压缩”成一个元组的迭代器。 print(list(zip([1, 2], [a, b]))) # 输出 [(1, a), (2, b)] 28、 set.pop() 方法用于随机移除并返回集合中的一个元素，不传入参数。 29、 rfind()和rindex() 30、 31、sorted(Iterable, key函数(排序规则), reverseFalse) Iterable: 可迭代对象 key: 排序规则(排序函数), 在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数. 根据函数运算的结果进行排序 reverse: 是否是倒序. True: 倒序, False: 正序 sys.stdin.readline()import sys line = sys.stdin.readline() n, pipe_len = map(int, line.split()) valves = [] for _ in range(n): valves.append(list(map(int, sys.stdin.readline().split()))) print(valves) 输入： 3 10 1 1 6 5 10 2 输出： [[1, 1], [6, 5], [10, 2]] sys.stdin.readline()：从标准输入（stdin）读取一行数据，包含行尾换行符 import sys data = sys.stdin.readline() # 输入Hello → 返回Hello 需手动调用.strip()或.rstrip( )移除多余字符： name = sys.stdin.readline().strip() # 输入Alice → 返回Alice 循环逐行读：迭代处理大规模输入 for line in sys.stdin: processed_line = line.strip() 高效读取大规模测试数据： import sys n = int(sys.stdin.readline().strip()) # 读取第一行（数据量） data = [sys.stdin.readline().strip() for _ in range(n)] # 读取后续n行 优先队列 heapqPython的heapq模块提供了基于列表的最小堆实现，常用于高效管理优先级队列。 数据结构： 实现最小堆（父节点值 ≤ 子节点值），堆顶元素（heap[0]）始终为最小值。 底层使用列表存储，通过下标关系维护堆结构：父节点索引为(i-1)//2，子节点为2*i+1和2*i+2。 常用方法： heap [] 方法 功能 示例 适用场景 heappush(heap, item) 插入元素并维护堆结构 heapq.heappush(heap, (2, task)) 动态添加元素到堆 heappop(heap) 弹出堆顶最小元素 min_val = heapq.heappop(heap) 获取并移除最小值 heapify(x) 将列表原地转为堆 heapq.heapify([5, 1, 3]) # [1,5,3] 初始化无序列表为堆 heappushpop(heap, item) 插入后弹出最小值 min_val = heapq.heappushpop(heap, 4) 组合操作（效率更高） heapreplace(heap, item) 弹出最小值后插入 min_val = heapq.heapreplace(heap, 4) 更新堆顶元素 nlargest(n, iterable) 返回前n个最大元素 heapq.nlargest(3, [4,1,7]) # [7,4,1] 快速获取Top N大值 nsmallest(n, iterable) 返回前n个最小元素 heapq.nsmallest(2, [4,1,7]) # [1,4] 快速获取Top N小值 nlargestnsmallest 适合单次查询，频繁操作建议用堆维护。 heappushpop 比先push再pop效率更高（减少一次堆调整） heapq可插入任意可比较对象。 添加的元素为基本数据类型（具有可比性）： 数字（int、float）：按数值大小比较 字符串（str）：按字典序比较 布尔值（bool）：False True 添加的元素为元组（Tuple）：按元素顺序逐级比较（最常用） # 元组 (优先级, 数据) heapq.heappush(heap, (2, task1)) heapq.heappush(heap, (1, task2)) # (1, ...) 优先级更高 实现自定义排序： 定义 __lt__ 方法（推荐） 在类中重写 运算符，heapq 自动根据此方法比较 方法__lt__返回的是boolean值，True是self排前面，False是other排前面。 import heapq class Task: def __init__(self, priority, desc): self.priority = priority self.desc = desc def __lt__(self, other): # 定义比较规则 return self.priority other.priority # 数值小优先 heap = [] heapq.heappush(heap, Task(3, Low)) heapq.heappush(heap, Task(1, High)) print(heapq.heappop(heap).desc) # 输出：High 自定义类优先队列 import heapq class Job: def __init__(self, name, urgency): self.name = name self.urgency = urgency # 1-10，值越小越紧急 def __lt__(self, other): return self.urgency other.urgency # 创建堆并操作 jobs = [] heapq.heappush(jobs, Job(Fix Bug, 2)) heapq.heappush(jobs, Job(Write Docs, 5)) heapq.heappush(jobs, Job(Deploy, 1)) while jobs: job = heapq.heappop(jobs) print(f[Urgency job.urgency] job.name) # 输出： # [Urgency 1] Deploy # [Urgency 2] Fix Bug # [Urgency 5] Write Docs 元素本身可以是可变对象（如列表、自定义类实例），但禁止在堆内直接修改影响排序的关键属性（如优先级）。 若需更新优先级，先移除旧元素 → 修改 → 重新插入 利用heapq实现最大堆 直接使用 heapq.nlargest() 获取前 K 个最大值，无需维护堆结构。 import heapq data = [5, 7, 9, 4, 3] # 获取前 K 个最大值 top_k = heapq.nlargest(3, data) # [9, 7, 5] print(top_k) # 获取最大值 max_val = heapq.nlargest(1, data)[0] # 9 插入时取负数，取出时再取负还原。 import heapq # 创建最大堆 max_heap = [] data = [5, 7, 9, 4, 3] # 插入元素（取负） for num in data: heapq.heappush(max_heap, -num) # 存入：[-9, -7, -5, -4, -3] # 弹出最大值 max_val = -heapq.heappop(max_heap) # 取出：9 → 堆变为[-7, -5, -4, -3] print(max_val) # 输出：9 # 查看堆顶（不弹出） peek = -max_heap[0] # 当前最大值：7 适用于数值型数据（整数、浮点数），非数值类型（如字符串）需转换为数值或封装元组(-priority, data)处理。 重写 __lt__ 方法反转比较逻辑，使对象在堆中“大值”被视为“小值”，建一个新类。 import heapq class MaxHeapObj: def __init__(self, val): self.val = val def __lt__(self, other): return self.val other.val # 反转比较规则 def __repr__(self): return str(self.val) # 封装对象 max_heap = [] data = [5, 7, 9, 4, 3] for num in data: heapq.heappush(max_heap, MaxHeapObj(num)) # 弹出最大值 max_obj = heapq.heappop(max_heap).val # 9 print(max_obj) 适用于复杂对象（需自定义比较规则），需保留原始数据的场景（避免取负导致混淆）。 布隆过滤器class BitArray: def __init__(self, num_bits): # 每个整数元素用于存储 32 位 self.bits_per_element = 32 # 计算所需的整数数量 self.array_size = (num_bits + self.bits_per_element - 1) // self.bits_per_element # 初始化全零数组 self.arr = [0] * self.array_size # 存储实际位数 self.num_bits = num_bits def get_bit(self, i): 获取指定位置（i）的位状态（0或1） if not 0 = i self.num_bits: raise IndexError(f位索引超出范围: i) # 计算整数索引和位索引 num_index = i // self.bits_per_element bit_index = i % self.bits_per_element # 获取位状态 return (self.arr[num_index] bit_index) 1 def set_bit(self, i, value=1): 设置指定位置（i）的位状态为 1 或 0 if not 0 = i self.num_bits: raise IndexError(f位索引超出范围: i) num_index = i // self.bits_per_element bit_index = i % self.bits_per_element if value == 1: # 设置为 1：使用位或操作 self.arr[num_index] |= (1 bit_index) elif value == 0: # 设置为 0：使用位与操作配合掩码 self.arr[num_index] = ~(1 bit_index) else: raise ValueError(值必须是 0 或 1) def __str__(self): 以二进制字符串形式显示位数组状态 # 为每个整数创建 32 位的二进制字符串 # 并连接所有位（只显示实际的 num_bits 位） all_bits = .join(fx:032b for x in self.arr) return all_bits[:self.num_bits] if __name__ == __main__: # 使用示例：参考图片中的 Java 代码逻辑 num_bits = 200 # 假设总位数大于178 bit_array = BitArray(num_bits) # 测试案例1：获取和设置第178位 print(f第178位的初始状态: bit_array.get_bit(178)) # 将178位设置为1 bit_array.set_bit(178, 1) print(f将178位设置为1后的状态: bit_array.get_bit(178)) # 将178位设置为0 bit_array.set_bit(178, 0) print(f将178位设置为0后的状态: bit_array.get_bit(178)) # 测试输出完整位状态 print( 完整位状态:) print(bit_array) # 测试错误处理 try: bit_array.set_bit(300) # 超出范围 except IndexError as e: print(f 错误测试: e) bisectPython的bisect模块是一个基于二分查找算法的标准库模块，专门用于在已排序的列表中高效地查找、插入元素，并保持列表的有序性。其核心优势是通过二分查找（时间复杂度O(log n)）替代线性操作（O(n)），显著提升大规模数据处理的效率。 插入新元素时直接将其放置在正确位置，无需调用sort()重新排序。 查找元素： 方法 功能描述 示例（输入列表a = [1, 3, 4, 4, 6]） bisect_left(a, x) 返回第一个大于或等于x的元素的索引（重复时靠左） bisect_left(a, 4) → 2 bisect_right(a, x) 返回第一个大于x的元素的索引（重复时靠右） bisect_right(a, 4) → 4 bisect()（别名：bisect_right） 与bisect_right功能相同，推荐使用更明确的命名 bisect(a, 4) → 4 插入元素： 方法 功能描述 示例（输入列表a = [1, 3, 4, 6]） insort_left(a, x) 将x插入到第一个大于或等于x的位置（重复时靠左） insort_left(a, 4) → [1, 3, 4, 4, 6] insort_right(a, x) 将x插入到第一个大于x的位置（重复时靠右） insort_right(a, 4) → [1, 3, 4, 4, 4, 6] insort()（别名：insort_right） 与insort_right功能相同，默认使用此方法 insort(a, 5) → [1, 3, 4, 5, 6] 也可以用于自定义的类元素： import bisect class Task: def __init__(self, priority, desc): self.priority = priority self.desc = desc def __lt__(self, other): # 定义比较规则 return self.priority other.priority # 数值小优先 heap = [] heap.append(Task(3, Low)) heap.append(Task(1, High)) heap.sort() for item in heap: print(item.priority) bisect.insort(heap,Task(2, Middle)) for item in heap: print(item.priority)","tags":["算法"]},{"title":"机器学习","path":"/2025/05/08/机器学习/","content":"引言机器学习是什么 目前存在几种不同类型的学习算法。主要的两种类型被我们称之为监督学习和无监督学习。监督学习这个想法是指，我们将教计算机如何去完成任务，而在无监督学习中，我们打算让它自己进行学习。 监督学习监督学习指的就是我们给学习算法一个数据集，这个数据集由“正确答案”组成。在房价的例子中，我们给了一系列房子的数据，我们给定数据集中每个样本的正确价格，即它们实际的售价然后运用学习算法，算出更多的正确答案。 回归问题：试着推测出一个连续值的结果。下面的房子例子就是回归问题，要推测的结果就是房子的价格。 回归这个词的意思是，我们在试着推测出这一系列连续值属性。 分类问题，分类指的是，我们试着推测出离散的输出值：0或1，良性或恶性。感觉就是判断给出的数据属于哪一类。 在这个例子中只有一个特征，就是肿瘤的尺寸，在其它一些机器学习问题中，可能会遇到不止一种特征。举个例子，我们不仅知道肿瘤的尺寸，还知道对应患者的年龄。在其他机器学习问题中，通常有更多的特征，比如肿块密度，肿瘤细胞尺寸的一致性和形状的一致性等等，还有一些其他的特征。之后会讲一个算法，叫支持向量机，里面有一个巧妙的数学技巧，能让计算机处理无限多个特征。 回归问题和分类问题都属于监督学习，其基本思想是，数据集中的每个样本都有相应的“正确答案”，再根据这些样本作出预测，就像房子和肿瘤的例子中做的那样。回归问题，即通过回归来推出一个连续的输出；分类问题，其目标是推出一组离散的结果。 无监督学习不同于监督学习的数据的样子，即无监督学习中没有任何的标签或者是有相同的标签或者就是没标签。所以我们已知数据集，却不知如何处理，也未告知每个数据点是什么，任何信息都不知道，只知道是一个数据集。 这个图是上面肿瘤的例子，⭕代表良性，❌代表恶性，在监督学习中有这种标志说明是什么情况，但在无监督学习中没有标志，只是数据。 针对数据集，无监督学习能判断出数据有两个不同的聚集簇。这是一个，那是另一个，二者不同。是的，无监督学习算法可能会把这些数据分成两个不同的簇，这个就叫做聚类算法。 无监督学习就是我们没法提前告知算法一些信息。 就是这里是有一堆数据，我不知道数据里面有什么，我不知道谁是什么类型，我甚至不知道人们有哪些不同的类型，这些类型又是什么。但你能自动地找到数据中的结构吗？就是说你要自动地聚类那些个体到各个类，我没法提前知道哪些是哪些。因为我们没有给算法正确答案来回应数据集中的数据，所以这就是无监督学习。 上面的都是聚类的例子，聚类只是无监督学习的一种。 接下来介绍的鸡尾酒宴问题属于无监督学习中的盲源分离问题。 可能在一个这样的鸡尾酒宴中的两个人，他俩同时都在说话，假设现在是在个有些小的鸡尾酒宴中。我们放两个麦克风在房间中，因为这些麦克风在两个地方，离说话人的距离不同每个麦克风记录下不同的声音，虽然是同样的两个说话人。听起来像是两份录音被叠加到一起，或是被归结到一起，产生了我们现在的这些录音。另外，这个算法还会区分出两个音频资源，这两个可以合成或合并成之前的录音，实际上，鸡尾酒算法的第一个输出结果是： 1，2，3，4，5，6，7，8，9，10, 第二个输出是这样： 1，2，3，4，5，6，7，8，9，10。 第一个输出代表分离出的第一个声源，第二个输出代表分离出的第二个声源。 这里的数字序列可能是对分离后信号的简化表示。实际应用中，输出是时间序列信号（如音频波形），每个数字可能代表某个时间点的信号强度或特征。无需去深度思考。 单变量线性回归模型表示监督学习的第一个例子。预测住房价格的，我们要使用一个数据集，数据集包含俄勒冈州波特兰市的住房价格。在这里，我要根据不同房屋尺寸所售出的价格，画出我的数据集。比方说，如果你朋友的房子是1250平方尺大小，你要告诉他们这房子能卖多少钱。 它被称作监督学习是因为对于每个数据来说，我们给出了“正确的答案”，即告诉我们：根据我们的数据来说，房子实际的价格是多少，而且，更具体来说，这是一个回归问题。回归一词指的是，我们根据之前的数据预测出一个准确的输出值，对于这个例子就是价格。 在监督学习中我们有一个数据集，这个数据集被称训练集。 在整个课程中用小写的m来表示训练样本的数目。 假如上面房子的回归问题的训练集（Training Set）如下表所示： 将训练集“喂”给我们的学习算法，进而学习得到一个假设h，然后将我们要预测的房屋的尺寸作为输入变量输入给h，预测出该房屋的交易价格作为输出变量输出为结果。 h表示的是一个函数，由学习算法根据训练集输出，输入是房屋尺寸大小，输出的是房子价格。 h的一种可能表达方式为：$$h_θ (x)θ_0+θ_1 x$$因为只含有一个特征输入变量，因此这样的问题叫作单变量线性回归问题。 代价函数 有一个像这样的训练集， 𝑚代表了训练样本的数量，比如 𝑚 47。而我们的假设函数，也就是用来进行预测的函数，是这样的线性函数形式$$h_θ (x)θ_0+θ_1 x$$接下来为我们的模型选择合适的参数（ parameters） 𝜃0 和 𝜃1，在房价问题这个例子中便是直线的斜率和在𝑦 轴上的截距。 我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的差距（下图中蓝线所指）就是建模误差（ modeling error）。 目标便是选择出可以使得建模误差的平方和能够最小的模型参数， 即使得代价函数最小。 绘制一个等高线图，三个坐标分别为𝜃0和𝜃1 和𝐽(𝜃0, 𝜃1)： 可以看出在三维空间中存在一个使得𝐽(𝜃0, 𝜃1)最小的点。 代价函数也被称作平方误差函数，有时也被称为平方误差代价函数，代价函数是解决回归问题最常用的手段。 代价函数的直观理解代价函数是用来干嘛的，我们为什么要用它。 为了便于理解，使𝜃00。 yi代表的是训练集中的数据。h𝜃的参数是x，J的参数是𝜃1。上图可以看出当𝜃11时，代价函数J0。 接下来时当𝜃10.5时： 等于1时： 对于每个𝜃1的值，都对应着一个假设函数的值或者一条直线，并且根据每个不同的𝜃1，我们都可以得到一个不同的J(𝜃1)的值。 梯度下降梯度下降是一个用来求函数最小值的算法，我们将使用梯度下降算法来求出代价函数𝐽(𝜃0, 𝜃1) 的最小值。 梯度下降背后的思想是：开始时我们随机选择一个参数的组合(𝜃0, 𝜃1, . . . . . . , 𝜃𝑛)，计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到到到一个局部最小值，因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值，选择不同的初始参数组合，可能会找到不同的局部最小值。 这个算法是怎么工作的，可以这样想：想象一下你正站立在山的一点上， 在梯度下降算法中，我们要做的就是旋转 360 度，看看我们的周围哪个方向可以最快下山。来到山坡上，我们站在山坡上的一点，你看一下周围，你会发现最佳的下山方向，你再看看周围，然后再一次想想，我应该从什么方向下山？然后你按照自己的判断又迈出一步，重复上面的步骤，从这个新的点，你环顾四周，并决定从什么方向将会最快下山，然后又迈进了一小步，并依此类推，直到你接近局部最低点的位置。 批量梯度下降算法的公式为： 上面那行英语的意思是，反复用这个公式直到收敛。其中𝑎是学习率，它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大，在批量梯度下降中，我们每一次都同时让所有的参数减去学习速率乘以代价函数的导数。 符号:=的意思是赋值，这是一个赋值运算符。单独的=代表的是比较运算符。 梯度下降中，我们要同时更新𝜃0和𝜃1，当 𝑗 0 和𝑗 1时，会产生更新，所以你将更新𝐽(𝜃0)和𝐽(𝜃1)。 记住，要同时更新，不能先更新一个再更新另一个，先更新其中一个的话会导致接下来算出的微分项的值出现变换，因为其中一个值变了。 梯度下降的直观理解梯度下降算法：，描述：对𝜃赋值，使得𝐽(𝜃)按梯度下降最快方向进行，一直迭代下去，最终得到局部最小值。其中𝑎是学习率，它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。 求导的目的，基本上可以说取这个红点的切线， 现在，这条线有一个正斜率，也就是说它有正导数，因此，我得到的新的𝜃1， 𝜃1更新后等于𝜃1减去一个正数乘以𝑎。 如果𝑎太小或𝑎太大会出现什么情况： 如果𝑎太小了，即我的学习速率太小，结果就是只能这样像小宝宝一样一点点地挪动，去努力接近最低点，这样就需要很多步才能到达最低点，所以如果𝑎太小的话，可能会很慢，因为它会一点点挪动，它会需要很多步才能到达全局最低点。 如果𝑎太大，那么梯度下降法可能会越过最低点，甚至可能无法收敛，下一次迭代又移动了一大步，越过一次，又越过一次，一次次越过最低点，直到你发现实际上离最低点越来越远，所以，如果𝑎太大，它会导致无法收敛，甚至发散。 假设将𝜃1初始化在局部最低点，因为它已经在一个局部的最优处或局部最低点，结果是局部最优点的导数将等于零，使得𝜃1不再改变，因此，如果你的参数已经处于局部最低点，那么梯度下降法更新其实什么都没做，它不会改变参数的值。这也解释了为什么即使学习速率𝑎保持不变时，梯度下降也可以收敛到局部最低点。 在梯度下降法中，当我们接近局部最低点时，梯度下降法会自动采取更小的幅度，这是因为当我们接近局部最低点时，很显然在局部最低时导数等于零，所以当我们接近局部最低时，导数值会自动变得越来越小，所以梯度下降将自动采取较小的幅度，这就是梯度下降的做法。所以实际上没有必要再另外减小𝑎。 可以用梯度下降算法来最小化任何代价函数𝐽，不只是线性回归中的代价函数𝐽。 梯度下降的线性回归用梯度下降算法，并将其应用于具体的拟合直线的线性回归算法里。 先计算微分项： 所以，算法会被改写为： 不断重复，直到收敛。记住，𝜃0和𝜃1要同时更新。 使用梯度下降算法是因为它更容易到达局部最小值，而根据初始化的不同，会得到不同的局部最优解。但是，事实证明，用于线性回归的代价函数总是一个弓形样子的函数，叫作凸函数，这种函数没有局部最优解，只有一个全局最优解。 一般来说初始化参数的时候都设为0。 刚刚使用的算法，有时也称为批量梯度下降。 ”批量梯度下降”，指的是在梯度下降的每一步中，我们都用到了所有的训练样本，在梯度下降中，在计算微分求导项时，我们需要进行求和运算，所以，在每一个单独的梯度下降中，我们最终都要计算这样一个东西，这个项需要对所有𝑚个训练样本求和。 多变量线性回归多维特征对房价模型增加更多的特征，例如房间数楼层等，构成一个含有多个变量的模型，模型中的特征为(𝑥1, 𝑥1, . . . , 𝑥𝑛)。 这上面的公式是𝜃TX的原因是上面的X(2)是一列，形状是[4,1]，jupyter里面的数据的形状是[1,4]，所以里面的公式是X𝜃T，具体的情况要具体分析，记住基本公式，参数乘以变量。 多变量梯度下降在多变量线性回归中的代价函数，这个代价函数是所有建模误差的平方和，即： ，其中$$h_θ (x)θ^T Xθ_0+θ_1 x_1+θ_2 x_2+…+θ_n x_n$$多变量线性回归的批量梯度下降算法为： 即，求导得： 跟前面单变量的公式没有什么大变化，就是求导后需要计算的变多了。 计算代价函数的代码如下： def computeCost(X, y, theta): inner = np.power(((X * theta.T) - y), 2) return np.sum(inner) / (2 * len(X)) 梯度下降法实践 1-特征缩放在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛。 以房价问题为例，假设我们使用两个特征，房屋的尺寸和房间的数量，尺寸的值为 0- 2000 平方英尺，而房间数量的值则是 0-5，以两个参数分别为横纵坐标，绘制代价函数的等高线图（在这里先忽略𝜃0）， 能看出图像会显得很扁，梯度下降算法需要非常多次的迭代才能收敛。 解决的方法是尝试将所有特征的尺度都尽量缩放到**-1 到 1** 之间。 ，这也是在做特征缩放时的通常目的，但其实并不严格要求必须是-1到1，在这些附近都可以，重点是将范围靠近-1到1。所以，如果有一个特征也就是变量的范围是-0.0001到0.0001的话，得对其进行扩展。一般在-3到3，-13到13都是可以的。 除了将特征除以它的最大值外，还可以进行一种叫作均值归一化的工作，包括： 1、将原来的变量值减去平均值除以（最大值-最小值），一般用这个就足够了 2、$$x_n(x_n-μ_n)s_n，其中 μ_n是平均值，s_n是标准差。$$ 梯度下降法实践 2-学习率如何确定梯度下降算法在正常工作，画图表： 梯度下降算法的每次迭代受到学习率的影响，如果学习率𝑎过小，则达到收敛所需的迭代次数会非常高；如果学习率𝑎过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。 通常可以考虑尝试些学习率：𝛼 0.01， 0.03， 0.1， 0.3， 1， 3， 10 特征和多项式回归多项式回归，可以使用线性回归的方式来拟合非常复杂的函数，或者是非线性函数。 以预测房价模型为例（在线性回归模型中你可以选择提供的特征作为特征，也可以选择自己创建一个新的特征，哎下面的例子中，题目给了临街宽度和纵深两个特征，我们也可以自己创建一个特征——面积，这样子可以简化线性回归模型，得到一个更好的模型）： 线性回归并不适用于所有数据，有时我们需要曲线来适应我们的数据，二次方或者三次方模型：$$h_θ (x)θ_0+θ_1 x_1+θ_2 x_2^2，h_θ (x)θ_0+θ_1 x_1+θ_2 x_2^2+θ_3 x_3^3$$另外，我们可以令$$𝑥_2 𝑥_2^2, 𝑥_3 𝑥_3^3$$，从而将模型转化为线性回归模型，由于次方的存在导致参数范围被扩大了很多，所以在运行梯度下降算法前，必须进行特征缩放。除了上面给出的这一种，还有一种是开平方：$$h_θ (x)θ_0+θ_1 (size)+θ_2 \\sqrt{size}$$通过不同的参数形式，最后的曲线也会有所不同。 正规方程到目前为止，我们都在使用梯度下降算法，但是对于某些线性回归问题，正规方程方法是更好的解决方案。如： 运用正规方程方法求解参数： 对于那些不可逆的矩阵（通常是因为特征之间不独立，如同时包含英尺为单位的尺寸和米为单位的尺寸两个特征，也有可能是特征数量大于训练集的数量），正规方程方法是不能用的。 只要特征变量的数目并不大，标准方程是一个很好的计算参数𝜃的替代方法。具体地说，只要特征变量数量小于一万，通常使用标准方程法，而不使用梯度下降法。 import numpy as np def normalEqn(X, y): theta = np.linalg.inv(X.T@X)@X.T@y # X.T@X 等价于 X.T.dot(X)，X是ndarray数组 return theta 注意，这里返回的theta不是一个数，而是一个元组。 逻辑回归分类问题在分类问题中，要预测的变量y是离散的值。 在分类问题中，我们尝试预测的是结果是否属于某一个类（例如正确或错误），从二元的分类问题开始。 我们将因变量可能属于的两个类分别称为负向类和正向类，则因变量 y0或1 ，其中 0 表示负向类，1 表示正向类。 逻辑回归算法的性质是：它的输出值永远在 0 到 1 之间。 逻辑回归算法是一个分类算法，适用于y取离散的值的情况下。 假说表示为什么线性回归算法不适用于分类问题？ 根据线性回归模型我们只能预测连续的值，然而对于分类问题（例子是肿瘤分类），我们需要输出0或1，我们可以预测：$$当h_θ (x)0.5时，预测 y1。当h_θ (x)0.5时，预测 y0 。$$没有极端数据出现的时候使用线性回归算法看着也可以，但一旦极端数据出现，整体的判断标准就会被破坏。 有极端数据出现： 所以线性回归模型并不适用于分类问题。 逻辑回归模型的假设是：$$h_θ(x)g(θ^T X)其中：X 代表特征向量，g代表逻辑函数是一个常用的逻辑函数，S形函数，公式为： g(z)\\frac{1}{1+e^{-z} }。$$θT*X，这个就是线性回归模型的结果（这里的参数向量θ是n行1列的，X的数据是一列一列的），所以逻辑回归模型是对线性回归模型的值进行处理。 import numpy as np def sigmoid(z): return 1 / (1 + np.exp(-z)) ℎ𝜃(𝑥)的意思是，对于给定的输入变量，根据选择的参数计算输出变量1 的可能性。如果对于给定的𝑥，通过已经确定的参数计算得出ℎ𝜃(𝑥) 0.7，则表示有 70%的几率𝑦为正向类，相应地𝑦为负向类的几率为 1-0.70.3。 逻辑回归的本质：逻辑回归是一种线性分类模型。它通过一个线性方程（例如，zθ0+θ1x1+θ2x2）将输入特征（如测试1和测试2的结果）映射到一个概率值（通过sigmoid函数）。决策边界（即区分接受抛弃的阈值）是线性的，比如一条直线（在二维特征空间中）。 判定边界 根据逻辑回归模型的这个图，我们知道当𝑧 0 时，𝑔(𝑧) 0.5；𝑧 0 时，𝑔(𝑧) 0.5；𝑧 0 时，𝑔(𝑧) 0.5； 又 𝑧 𝜃𝑇𝑥 ，即： 𝜃𝑇𝑥 0 时，预测 𝑦 1；𝜃𝑇𝑥 0 时，预测 𝑦 0。 对于上面那个模型，我们可以很明显地看出是一条直线将预测结果分成两部分。 又两个例子可以看出，我们要根据分界线的形状来判断我们应该使用的分界线函数是什么。 代价函数对于线性回归模型，定义的代价函数是所有模型误差的平方和。要是将逻辑回归模型的函数代入到这个代价函数中，得到的代价函数将是一个非凸函数，这意味着代价函数会有许多局部最小值，这将影响梯度下降算法寻找全局最小值。 定义代价函数为：$$J(θ)\\frac{1}{m} ∑_{i1}^mCost(h_θ (x^i ),y^i )$$ h𝜃x的取值范围在0~1。 这样构建的Cost函数的特点是：当实际的 𝑦 1 且ℎ𝜃(𝑥)也为 1 时误差为 0，当 𝑦 1 但ℎ𝜃(𝑥)不为 1 时误差随着ℎ𝜃(𝑥)变小而变大；当实际的 𝑦 0 且ℎ𝜃(𝑥)也为 0 时代价为 0，当𝑦 0 但ℎ𝜃(𝑥)不为 0 时误差随着 ℎ𝜃(𝑥)的变大而变大。 将Cost函数进行简化，就是用一个表达式表达出来，如下：$$Cost(h_θ (x),y)-y×log(h_θ (x))-(1-y)×log(1-h_θ (x))$$代入代价函数为：$$J(θ)-\\frac{1}{m}∑_{i1}^m[y^{(i)} log(h_θ (x^{(i)} ))+(1-y^{(i)})log(1-h_θ (x^{(i)} ))]$$ import numpy as np def cost(theta, X, y): theta = np.matrix(theta) X = np.matrix(X) y = np.matrix(y) first = np.multiply(-y, np.log(sigmoid(X* theta.T))) second = np.multiply((1 - y), np.log(1 - sigmoid(X* theta.T))) return np.sum(first - second) / (len(X)) sigmoid函数在上面定义了。 梯度下降算法的公式和前面的一样，记住，同时更新所有参数。 通过观察梯度下降算法的式子可以发现，这个式子和之前线性回归的梯度下降算法的式子是一样的，但ℎ𝜃(𝑥)的式子是不同的。 特征缩放的技巧也适用于逻辑回归。 高级优化共轭梯度法，BFGS (变尺度法) 和 L-BFGS (限制变尺度法) 就是一些更高级的优化算法，它们需要有一种方法来计算 𝐽(𝜃)，以及需要一种方法计算导数项，然后使用比梯度下降更复杂的算法来最小化代价函数。 这三种算法的具体细节可以不用取探究，因为过于复杂。 使用这其中任何一个算法，通常不需要手动选择学习率 𝛼，所以对于这些算法的一种思路是，给出计算导数项和代价函数的方法，你可以认为算法有一个智能的内部循环，而且，事实上，他们确实有一个智能的内部循环，称为线性搜索算法，它可以自动尝试不同的学习速率 𝛼，并自动选择一个好的学习速率 𝛼，因此它甚至可以为每次迭代选择不同的学习速率。 最好不要使用 L-BGFS、 BFGS 这些算法，除非你是数值计算方面的专家。 如何使用这些算法，这些算法适合在很大的机器学习问题中使用。 在jupyter中利用的是python中的scipy.optimize.fmin_tnc()函数，这是一个使用截断牛顿法（TNC）寻找局部最小值的优化函数，特别适用于有界约束的优化问题。 寻找决策边界 所以jupyter中的寻找决策边界会除以第三个参数值。 构造多项式特征 由上图可知其中没有线性决策界限，来良好的分开两类数据，原数据有两个特征，x1和x2，可以明显看出就这两个特征无法较好拟合这些数据，所以要构造从原始特征的多项式中得到的特征，即通过数学变换，将原始特征（ x1 和 x2）扩展为一组新特征，这些新特征是原始特征的高阶多项式组合（例如，x1平方、x2平方、x1×x2、x1立方 等）。然后，在这些新特征上训练逻辑回归模型。 为什么能解决非线性问题：尽管逻辑回归本身是线性的，但通过添加非线性特征（如平方项或交互项），模型在扩展后的高维特征空间中学习到的决策边界仍然是线性的，但这个边界在原始特征空间中会呈现为曲线、椭圆或其他非线性形状。这相当于给模型“添加了非线性能力”，而不改变其核心算法。 首先要选择阶数，阶数决定了多项式的复杂性。从二阶开始（通常足够处理大多数非线性问题），然后根据模型性能调整。 平方项：捕捉单个测试的非线性效应。 交互项（x1×x2）：捕捉两个测试的联合效应。 由于选择了高阶数的模型，为了避免过拟合，通常还要进行正则化操作。 多类别分类：一对多如何使用逻辑回归来解决多类别分类问题。 之前的二元分类问题的图，和现在的多类分类问题的图： 用 3 种不同的符号来代表 3 个类别，问题就是给出 3 个类型的数据集，如何得到一个学习算法来进行分类呢？ 面对二元分类问题可以使用逻辑回归，也可以将数据集一分为二为正类和负类，而一对多的分类思想，我们可以将其用在多类分类问题上，这个方法也被称为”一对余”方法。 现在我们有一个训练集，好比上图表示的有 3 个类别，我们用三角形表示 𝑦 1，方框表示𝑦 2，叉叉表示 𝑦 3。使用一个训练集将三元分类问题转化为三个二元分类问题，先从用三角形代表的类别 1 开始，实际上我们可以创建一个，新的”伪”训练集，类型 2 和类型 3 定为负类，类型 1 设定为正类，我们创建一个新的训练集，如下图所示的那样，我们要拟合出一个合适的分类器。 这里的三角形是正样本，而圆形代表负样本。可以这样想，设置三角形的值为 1，圆形的值为 0，下面可以训练一个标准的逻辑回归分类器，这样就得到一个边界。 选择出哪一个分类器是可信度最高效果最好的，那么就可认为得到一个正确的分类，无论𝑖值是多少，我们都有最高的概率值，我们预测𝑦就是那个值。$$最后我们得到一系列的模型简记为： h_θ^{(i) } (x)p(yi|x;θ)其中：i(1,2,3….k)$$ 正则化过拟合的问题就是过于强调拟合原始数据。 第一个模型是一个线性模型，欠拟合，不能很好地适应训练集；第三个模型是一个四次方的模型，过于强调拟合原始数据，而丢失了算法的本质：预测新数据。可以看出，若给出一个新的值使之预测，它将表现的很差，是过拟合，虽然能非常好地适应我们的训练集但在新输入变量进行预测时可能会效果不好。 分类问题中也存在这样的问题： 以多项式理解， 𝑥 的次数越高，拟合的越好，但相应的预测的能力就可能变差。 如何处理过拟合问题： 1.丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙，例如 PCA 2.正则化。 保留所有的特征，但是减少参数的大小。 代价函数在上面过拟合的回归问题中有以下模型：$$h_θ (x)θ_0+θ_1 x_1+θ_2 x_2^2+θ_3 x_3^3+θ_4 x_4^4$$正是高次项导致了过拟合的产生，所以如果能让这些高次项的系数接近于0的话，那就能很好的拟合了。 所以我们要做的就是在一定程度上减小这些参数𝜃的值，这就是正则化的基本方法。我们决定要减少𝜃3和𝜃4的大小，我们要做的便是修改代价函数，在其中𝜃3和𝜃4设置一点惩罚。这样做的话，在尝试最小化代价时也会将这个惩罚纳入考虑中，并最终导致选择较小一些的𝜃3和𝜃4。惩罚就是在代价函数中使𝜃3和𝜃4的占比变高，使得在最小化代价函数时，也会更多地考虑这两个参数。$$修改后的代价函数：min\\frac{1}{2m}[∑_{i1}^m[(h_θ (x^{(i)} )-y^{(i)} )^2+1000θ_3^2+10000θ_4^2]]$$假如有非常多的特征，我们并不知道其中哪些特征要惩罚，那么就对所有的特征进行惩罚，并且让代价函数最优化的软件来选择这些惩罚的程度。这样的结果是得到了一个较为简单的能防止过拟合问题的假设：$$J(θ)\\frac{1}{2m}[∑_{i1}^m(h_θ (x^{(i)})-y^{(i)})^2+λ∑_{j1}^nθ_j^2 ]$$其中𝜆又称为正则化参数，根据惯例，我们不对𝜃0 进行惩罚。经过正则化处理的模型与原模型的可能对比如下图所示： 如果选择的正则化参数λ过大，则会把所有的参数都最小化了，导致模型变成 ℎ𝜃(𝑥) 𝜃0，也就是上图中红色直线所示的情况，造成欠拟合。 正则化线性回归正则化线性回归的代价函数是：$$J(θ)\\frac{1}{2m}[∑_{i1}^m(h_θ (x^{(i)})-y^{(i)})^2+λ∑_{j1}^nθ_j^2 ]$$由于𝜃0没有进行正则化，所以梯度下降算法将会分成两种情况： 对第二个式子（𝑗 1,2, . . . , 𝑛 ）进行调整可以得到：$$θ_j:θ_j (1-a \\frac{λ}{m})-a \\frac{1}{m} ∑_{i1}^m(h_θ (x^{(i)})-y^{(i)})x_j^{(i)}$$可以看出，正则化线性回归的梯度下降算法的变化在于，每次都在原有算法更新规则的基础上令𝜃值减少了一个额外的值。 利用正规方程来求解正则化线性回归模型：，图中的矩阵尺寸为 (𝑛 + 1) ∗ (𝑛 + 1)，因为不算𝜃0还有n个特征。 正则化的逻辑回归模型这是正则化的逻辑回归的代价函数。 给代价函数增加一个正则化的表达式，得到代价函数：$$J(θ)\\frac{1}{m} ∑_{i1}^m[-y^{(i)} log(h_θ (x^{(i)} ))-(1-y^{(i)} )log(1-h_θ (x^{(i)} ))]+\\frac{λ}{2m} ∑_{j1}^nθ_j^2$$ import numpy as np def costReg(theta, X, y, learningRate): theta = np.matrix(theta) X = np.matrix(X) y = np.matrix(y) first = np.multiply(-y, np.log(sigmoid(X*theta.T))) second = np.multiply((1 - y), np.log(1 - sigmoid(X*theta.T))) reg = (learningRate / (2 * len(X))* np.sum(np.power(theta[:,1:theta.shape[1]],2)) return np.sum(first - second) / (len(X)) + reg 这边的 h 函数是sigmoid函数。 𝜃0不参与其中的任何一个正则化。 接下来的课程中，我们将学习一个非常强大的非线性分类器，无论是线性回归问题，还是逻辑回归问题，都可以构造多项式来解决。你将逐渐发现还有更强大的非线性分类器，可以用来解决多项式回归问题。 神经网络：表述非线性假设无论是线性回归还是逻辑回归都有这样一个缺点，即：当特征太多时，计算的负荷会非常大。 使用非线性的多项式项，能够帮助我们建立更好的分类模型，但相应的我们要计算的特征数会大大增多，普通的逻辑回归模型，不能有效地处理这么多的特征，这时候就需要神经网络。 模型表示神经网络模型建立在很多神经元之上，每一个神经元又是一个个学习模型。这些神经元（也叫激活单元）采纳一些特征作为输出，并且根据本身的模型提供一个输出。 以逻辑回归模型作为学习模型的神经元示例： 解读：上面的黄圈看作是神经元，左边的蓝圈和黄圈的连线看作是输入树突，黄圈右边的线看作是输出轴突。通过树突传递一些信息，然后神经元做一些计算，然后通过轴突输出计算结果。这个图表表示的是对h的计算，而h是sigmoid函数。x1、x2、x3是输入结点，额外的结点x0被称为偏置单位，因为x0总是等于1。x0可画可不画，根据具体情况来。 在神经网络中，参数𝜃又可被称为权重。 上面的一个小黄圈代表一个单一的神经元，而神经网络是不同的神经元组合在一起的集合。 第一层叫作输入层，在这一层输入特征项x1、x2、x3；最后一层（第3层）叫作输出层，因为这一层的神经元输出假设的最终计算结果；中间的一层称作隐藏层，神经网络中可以有不止一个隐藏层，非输出层和输入层的都叫做隐藏层。 在隐藏层出现的蓝色圈被称作偏置单位，它的值永远是1。 下面的图有3个输入单元和3个隐藏单元。 每一个𝑎都是由上一层所有的𝑥和每一个𝑥所对应的参数决定的，这样从左到右的算法称为前向传播算法。 𝜃*X不会等于a，因为g(𝜃*X)a 这边要转置应该是因为是一行一行地输入数据的。 要注意偏置单位的添加。 如果我们暂时只看第二层和第三层的话： 可以发现，其实神经网络就像是 logistic regression，只不过我们把 logistic regression 中的输入向量[𝑥1 ∼ 𝑥3] 变成了中间层的[𝑎1(2) ∼ 𝑎3(2)], 即: 特征项a1、a2、a3是作为输入的函数来学习的，所以在神经网络中，它没有使用输入特征x1、x2、x3来训练逻辑回归，而是自己根据a1、a2、a3来训练逻辑回归，所以如果在𝜃1中选择了不同的参数，那就可以学习到比较复杂的特征，就可以得到一个更好的假设，比使用原始输入时得到的假设更好（构造多项式特征？这里的特征也是通过学习模型得出来的） 神经网络中神经元相互连接的方式称为神经网络的架构。 特征和直观理解从本质上讲，神经网络能够通过学习得出其自身的一系列特征（在预设的网络架构和激活函数框架下，通过训练数据动态调整权重参数，使用梯度下降等优化算法调整，使模型逼近目标函数。）。在普通的逻辑回归中，我们被限制为使用数据中的原始特征𝑥1, 𝑥2, . . . , 𝑥𝑛，我们虽然可以使用一些二项式项来组合这些特征，但是我们仍然受到这些原始特征的限制。在神经网络中，原始特征只是输入层，在我们上面三层的神经网络例子中，第三层也就是输出层做出的预测利用的是第二层的特征，而非输入层中的原始特征，我们可以认为第二层中的特征是神经网络通过学习后自己得出的一系列用于预测输出变量的新特征。 神经网络中，单层神经元（无中间层）的计算可用来表示逻辑运算，比如逻辑与(AND)、逻辑或(OR)。 逻辑与，用下面的这样一个神经网络表示AND函数： $$其中θ_0-30,θ_120,θ_220 我们的输出函数h_θ (x)即为：h_Θ (x)g(-30+20x_1+20x_2 )$$为什么要这样设置参数？根据g(x)的图像和真值表得出。 再根据同样的步骤设计OR函数（三个权重分别为-10， 20， 20），它与AND函数的区别就是参数的取值不同。 当输入特征为布尔值（ 0 或 1）时，我们可以用一个单一的激活层可以作为二元逻辑运算符，为了表示不同的运算符，我们只需要选择不同的权重即可。 我们可以利用神经元来组合成更为复杂的神经网络以实现更复杂的运算。 实现 XNOR 功能（输入的两个值必须一样，均为 1 或均为 0），即：XNOR (x1 AND x2) OR((NOT x1)AND(NOT x2)) 首先构造一个能表达(NOT x1)AND(NOT x2)部分的神经元：(!x1)交(!x2) !(x1并x2) 非AND 然后将表示 AND 的神经元和表示(NOT x1)AND(NOT x2)的神经元以及表示 OR 的神经元进行组合： 多类分类如果我们要训练一个神经网络算法来识别路人、汽车、摩托车和卡车，在输出层我们应该有 4 个值。例如，第一个值为 1 或 0 用于预测是否是行人，第二个值用于判断是否为汽车。 输入向量𝑥有三个维度，两个中间层，输出层 4 个神经元分别用来表示 4 类，也就是每一个数据在输出层都会出现[𝑎 𝑏 𝑐 𝑑]𝑇，且𝑎, 𝑏, 𝑐, 𝑑中仅有一个为 1，表示当前类。下面是该神经网络的可能结构示例： 我们不用1代表行人，2代表车这种形式，而是构造四个分类器，输出1或0，根据哪个位置是1来判断是什么。 神经网络的学习代价函数假设神经网络的训练样本有𝑚个，每个包含一组输入𝑥和一组输出信号𝑦。L：神经网络结构的总层数；Sl（这是小L）：第 l 层的单元个数也就是神经元的数量，不包括 l 层的偏差单元。𝑆𝐿代表最后一层中处理单元的个数。 二元分类问题只有一个输出单元，所以只有一个输出结果。 多元分类问题，也就是K类分类问题，会有K个输出单元，输出是一个K维向量。 先来看一下逻辑回归问题中的代价函数：$$J(θ)\\frac{1}{m} ∑_{i1}^m[-y^{(i)} log(h_θ (x^{(i)} ))-(1-y^{(i)} )log(1-h_θ (x^{(i)} ))]+\\frac{λ}{2m} ∑_{j1}^nθ_j^2$$在逻辑回归中，我们只有一个输出变量，又称标量，也就是只有一个逻辑输出单元，也只有一个因变量y，但在神经网络中会有K个逻辑输出单元。$$h_θ (x)∈R^K，(h_θ (x))_ii^th output$$h(x)是一个K维向量；h(x)i 代表的是第 i 个输出，也就是它选择了输出向量中的第 i 个元素。 首先要计算从1到K的每一个逻辑回归算法的代价函数的和。最后的那个正则化的求和项，它是将所有的参数（除了i 0的，也就是偏差单位）都加起来。最后正则项的 j 的范围的s l+1 的l+1应该是下标，可以看下面那个图。 上面θ的 j 和 i 应该反了应该是这样的 根据这个图可以知道，参数的行号是从1开始计数的，所以上面的 i 是从1开始的。 正则化的那一项只是排除了每一层 θ0后，每一层的θ矩阵的和。最里层的循环 j 循环所有的行（由 Sl +1 层的激活单元数决定），循环 i 则循环所有的列，由该层（ Sl 层）的激活单元数所决定。 上面那个公式的意思就是：h(θ）与真实值之间的距离为每个样本-每个类输出的加和，对参数进行regularization的bias项处理所有参数的平方和。 反向传播算法就是让代价函数最小化的算法，因为是从最后往前算误差的，所以叫作反向传播算法，之前的是从第一层开始正向一层一层进行计算，直到最后一层的ℎ𝜃(𝑥)，所以是正向传播算法。$$为了计算偏导数项\\frac{∂}{∂Θ_{ij}^{(l)} } J(Θ)，我们需要采用一种反向传播算法，也就是首先计算最后一层的误差，然后再一层一层反向求出各层的误差，$$直到倒数第二层。 以一个例子来说明反向传播算法，参数是这样的 假设我们的训练集只有一个实例(𝑥, 𝑦），我们的神经网络是一个四层的神经网络，其中𝐾 4， 𝑆𝐿 4， 𝐿 4：先利用前向传播算法计算一下输出结果。 接下来计算导数项。 代表第 l 层的第 j 个结点的误差。 由于现在用来举例的只有一个样本，所以误差可以写为，向量形式是 当算出最后一层的误差后，就向前计算前面几层的误差。 ·*代表的是两个向量的对应元素相乘。 没有𝛿(1)，因为第一层是输入层，所以不会存在误差。 一个单元造成的误差是这个单元对下一层的每一个单元造成的误差的总和，所以参数矩阵要转置求这个单元造成的误差和。可以求出偏差单位的误差，但在计算的时候可以不加，造成的影响不大。 $$假设λ0，即我们不做任何正则化处理时有：\\frac{∂}{∂Θ_{ij}^{(l)} } J(Θ)a_j^{(l)} δ_i^{l+1}$$上面式子中上下标的含义： 𝑙 代表目前所计算的是第几层。 𝑗 代表目前计算层中的激活单元的下标。 𝑖 代表下一层(l+1层)中误差单元的下标，是受到权重矩阵中第𝑖行影响的下一层中的误差单元的下标。 假设有m个训练样本，用表示误差矩阵，第 𝑙+1 层的第 𝑖 个激活单元受到第 𝑗个参数影响而导致的误差。 上面的 l 的范围感觉应该是1~l-1，因为误差矩阵是关于参数矩阵，而参数矩阵没有 L。 公式里的那个1m是乘以后面的和的。 梯度检验当我们对一个较为复杂的模型（例如神经网络）使用梯度下降算法时，可能会存在一些不容易察觉的错误，意味着，虽然代价看上去在不断减小，但最终的结果可能并不是最优解。 为了避免这样的问题，我们采取一种叫做梯度的数值检验方法。这种方法的思想是通过估计梯度值来检验我们计算的导数值是否真的是我们要求的。 对梯度的估计采用的方法是在代价函数上沿着切线的方向选择离两个非常近的点然后计算两个点的平均值用以估计梯度。即对于某个特定的 𝜃，我们计算出在 𝜃-𝜀 处和 𝜃+𝜀 的代价值（ 𝜀是一个非常小的值，通常选取 0.001，𝜀不要取太小，不然会出现数值问题），然后求两个代价的平均，用以估计在 𝜃处的代价值（用数值的方法计算近似的导数）。下面那张图的𝜃是一个实数。 更普遍的情况，𝜃是一个n维向量，它可能是神经网络参数等的展开形式。 最后我们还需要对通过反向传播方法计算出的偏导数进行检验。根据反向传播算法计算出来的偏导数存储在矩阵中，然后将其与上面的数值计算的方法计算出来的近似的梯度值进行比较，如果误差在几位小数之内就认为反向传播算法的实现是正确的，然后在接下来的训练过程中都不再使用这个验证程序，因为它的计算量很大，而反向传播是一种更为简单的计算方法。 步骤：DVec就是反向传播算出来的导数值，gradApprox是数值计算算出来的近似梯度值。 用数值方法计算导数是用来确定反向传播实现是否正确的方法，但是不止可以用来验证反向传播，也可以用来验证类似的复杂模型的梯度下降算法。 随机初始化任何优化算法都需要一些初始的参数。到目前为止我们都是初始所有参数为 0，这样的初始方法对于逻辑回归来说是可行的，但是对于神经网络来说是不可行的。如果我们令所有的初始参数都为 0，这将意味着我们第二层的所有激活单元都会有相同的值，算出来的误差值也都是相同的值，之后进行梯度下降后的值也都相同。同理，如果我们初始所有的参数都为一个非 0 的数，结果也是一样的。 为了解决这个问题，神经网络变量的初始化方式采用随机初始化，通常初始参数为正负𝜀之间接近于0的随机值，然后进行反向传播，执行梯度检查，使用梯度下降或者其它优化算法。 综合 应用机器学习的建议决定下一步做什么当我们运用训练好了的模型来预测未知数据的时候发现有较大的误差，我们下一步可以做什么？ 获得更多的训练实例通常是有效的，但代价较大，下面的方法也可能有效，可考虑先采用下面的几种方法。 1.尝试减少特征的数量；2.尝试获得更多的特征；3.尝试增加多项式特征；4.尝试减少正则化程度λ； 5.尝试增加正则化程度λ 我们不应该随机选择上面的某种方法来改进我们的算法，而是运用一些机器学习诊断法来帮助我们知道上面哪些方法对我们的算法是有效的。“诊断法”的意思是：这是一种测试法，你通过执行这种测试，能够深入了解某种算法到底是否有用。这通常也能够告诉你，要想改进一种算法的效果，什么样的尝试，才是有意义的。 评估一个假设如何判断一个假设函数是过拟合的呢？ 对于特征变量只有一个的简单例子，可以直接对假设函数h(x)进行画图，但对于特征变量不止一个的这种一般情况，还有像有很多特征变量的问题，想要通过画出假设函数来进行观察，就会变得很难甚至是不可能实现。 为了检验算法是否过拟合，我们将数据分成训练集和测试集，通常用 70%的数据作为训练集，用剩下 30%的数据作为测试集。很重要的一点是训练集和测试集均要含有各种类型的数据，通常我们要对数据进行“洗牌”，然后再分成训练集和测试集。 在通过训练集让我们的模型学习得出其参数后，对测试集运用该模型，我们有两种方式计算误差： 1.对于线性回归模型，我们利用测试集数据计算代价函数 J 2.对于逻辑回归模型，我们除了可以利用测试数据集来计算代价函数外，还可以计算误分类的比率（感觉就是准确率），也就是对每一个测试集实例计算，然后对结果求平均。 模型选择和交叉验证集假设我们要在 10 个不同次数的二项式模型之间进行选择： 虽然越高次数的多项式模型越能够适应我们的训练数据集，但是适应训练数据集并不代表着能推广至一般情况，我们应该选择一个更能适应一般情况的模型。我们需要使用交叉验证集来帮助选择模型。 即：使用 60%的数据作为训练集，使用 20%的数据作为交叉验证集，使用 20%的数据作为测试集。 模型选择的方法为： 使用训练集训练出 10 个模型 用 10 个模型分别对交叉验证集计算得出交叉验证误差（代价函数的值） 选取代价函数值最小的模型 用步骤 3 中选出的模型对测试集计算得出推广误差（代价函数的值） 诊断偏差和方差当一个学习算法的表现不理想时，多半是出现两种情况：要么是偏差比较大，要么是方差比较大。换句话说，出现的情况要么是欠拟合，要么是过拟合问题。 高偏差和高方差的问题基本上来说是欠拟合和过拟合的问题。 通常会通过将训练集和交叉验证集的代价函数误差与多项式的次数绘制在同一张图表上来帮助分析： 对于训练集，当多项式次数 𝑑 较小时，模型拟合程度更低，误差较大；随着 𝑑 的增长，拟合程度提高，误差减小。 对于交叉验证集，当 𝑑 较小时，模型拟合程度低，误差较大；但是随着 𝑑 的增长，误差呈现先减小后增大的趋势，转折点是我们的模型开始过拟合训练数据集的时候。 交叉验证集误差较大，如何判断是方差还是偏差呢？ 根据上面的图表可以知道： 训练集误差和交叉验证集误差近似时：偏差欠拟合 交叉验证集误差远大于训练集误差时：方差过拟合 正则化和偏差方差在训练模型的过程中，一般会使用一些正则化方法来防止过拟合。但是正则化的程度可能会太高或太小了，即我们在选择 λ 的值时也需要思考与刚才选择多项式模型次数类似的问题。 选择一系列的想要测试的 𝜆 值，通常是 0-10 之间的呈现 2 倍关系的值（如： 0,0.01,0.02,0.04,0.08,0.15,0.32,0.64,1.28,2.56,5.12,10共 12 个），同样把数据分为训练集、交叉验证集和测试集。 选择𝜆的方法为： 1.使用训练集训练出 12 个不同程度正则化的模型 2.用 12 个模型分别对交叉验证集计算的出交叉验证误差 3.选择得出交叉验证误差最小的模型 4.运用步骤 3 中选出模型对测试集计算得出推广误差，我们也可以同时将训练集和交叉验证集模型的代价函数误差与 λ 的值绘制在一张图表上： 在训练时，代价函数是有加上正则项的，而在后面计算训练集和交叉验证集的误差时是没有加上正则项的，因为λ越大，会导致正则项在训练时的代价函数中的比例越大，导致theta变小，拟合效果变差，所以训练集和交叉验证集的误差就会变大。 当 𝜆 较小时，训练集误差较小（过拟合）而交叉验证集误差较大，这对应着高方差问题。 随着 𝜆 的增加，训练集误差不断增加（欠拟合），而交叉验证集误差则是先减小后增加，这对应着高偏差问题。 学习曲线可以使用学习曲线来判断某一个学习算法是否处于偏差、方差问题，学习曲线是将训练集误差和交叉验证集误差作为训练集实例数量（ 𝑚）的函数绘制的图表，所以m一般都是一个常数，但我们需要自行对m进行取值，比如说取10，20，30等，然后绘制出曲线。即，如果我们有 100 行数据，我们从 1 行数据开始，逐渐学习更多行的数据。 绘制学习曲线，先绘制出 J(train)，然后再画出 J(cv)。 当训练较少行数据的时候，训练的模型将能够非常完美地适应较少的训练数据，但是训练出来的模型却不能很好地适应交叉验证集数据或测试集数据。在训练数据很少的情况下，即使使用了正则化，拟合的效果仍然会很好。随着训练集样本的增加，平均训练误差是逐渐增大的。 当学习算法处于高偏差欠拟合情形时，学习曲线如下，作为例子，用一条直线来适应下面的数据，可以看出，无论训练集有多么大，误差都不会有太大改观： 也就是说在高偏差欠拟合的情况下，增加数据到训练集不一定能有帮助。 当学习算法处于高方差情形时，假设使用一个非常高次的多项式模型，并且正则化非常小，可以看出，当交叉验证集误差远大于训练集误差时，往训练集增加更多数据可以提高模型的效果。虽然随着训练样本的增多， J(train)会越来越大，因为训练样本越多时，就越难与训练数据拟合得很好，但总体来说训练集误差还是很小。 因为函数对数据过拟合，所以交叉验证集误差会一直都很大，即便选择了一个比较合适得训练集样本数，所以交叉验证集和训练集误差之间始终会有一段很大的差距。但如果继续增大样本数的话，可以发现这两条线在相互靠近。 增大样本数 也就是说在高方差过拟合的情况下，增加更多数据到训练集可能可以提高算法效果。 决定下一步做什么1. 获得更多的训练实例——解决高方差 2. 尝试减少特征的数量——解决高方差 3. 尝试获得更多的特征——解决高偏差 4. 尝试增加多项式特征——解决高偏差 5. 尝试减少正则化程度 λ——解决高偏差 6. 尝试增加正则化程度 λ——解决高方差 神经网络的方差和偏差： 使用较小的神经网络，类似于参数较少的情况，容易导致高偏差和欠拟合，但计算代价较小。使用较大的神经网络，类似于参数较多的情况，容易导致高方差和过拟合，虽然计算代价比较大，但是可以通过正则化手段来调整而更加适应数据。 通常选择较大的神经网络并采用正则化处理会比采用较小的神经网络效果要好。 对于神经网络中的隐藏层的层数的选择，通常从一层开始逐渐增加层数，为了更好地作选择，可以把数据分为训练集、交叉验证集和测试集，针对不同隐藏层层数的神经网络训练神经网络， 然后选择交叉验证集代价最小的神经网络。 机器学习系统的设计以一个垃圾邮件分类器算法为例进行讨论。 为了解决这样一个问题，我们首先要做的决定是如何选择并表达特征向量𝑥。我们可以选择一个由 100 个最常出现在垃圾邮件中的词所构成的列表，根据这些词是否有在邮件中出现，来获得我们的特征向量（出现为 1，不出现为 0），尺寸为 100×1。 为了构建这个分类器算法，我们可以做很多事，例如： 收集更多的数据，让我们有更多的垃圾邮件和非垃圾邮件的样本 基于邮件的路由信息开发一系列复杂的特征 基于邮件的正文信息开发一系列复杂的特征，包括考虑截词的处理 为探测刻意的拼写错误（把 watch 写成 w4tch）开发复杂的算法 在上面这些选项中，非常难决定应该在哪一项上花费时间和精力，作出明智的选择，比随着感觉走要更好。当我们使用机器学习时，总是可以“头脑风暴”一下，想出一堆方法来试试。 误差分析如果你准备研究机器学习的东西，或者构造机器学习应用程序，最好的实践方法不是建立一个非常复杂的系统，拥有多么复杂的变量；而是构建一个简单的算法，这样你可以很快地实现它。 研究机器学习的问题时，先很快地把结果搞出来，即便运行得不完美，但是也把它运行一遍，最后通过交叉验证来检验数据。一旦做完，你可以画出学习曲线，通过画出学习曲线，以及检验误差，来找出你的算法是否有高偏差和高方差的问题，或者别的问题。在这样分析之后，再来决定用更多的数据训练，或者加入更多的特征变量是否有用。 因为我们并不能提前知道是否需要复杂的特征变量，或者是否需要更多的数据，还是别的什么。提前知道应该做什么，是非常难的，因为缺少证据，缺少学习曲线。因此，很难知道应该把时间花在什么地方来提高算法的表现。但是当实践一个非常简单即便不完美的方法时，就可以通过画出学习曲线来做出进一步的选择。 除了画学习曲线外还有一个方法就是进行误差分析，例如当我们在构造垃圾邮件分类器时，我会看一看我的交叉验证数据集，然后亲自看一看哪些邮件被算法错误地分类。因此，通过这些被算法错误分类的垃圾邮件与非垃圾邮件，你可以发现某些系统性的规律：什么类型的邮件总是被错误分类。经常地这样做之后，这个过程能启发你构造新的特征变量，或者告诉你：现在这个系统的短处，然后启发你如何去提高它。 具体一点就是，检验交叉验证集中我们的算法产生错误预测的所有邮件，看：是否能将这些邮件按照类分组。例如医药品垃圾邮件，仿冒品垃圾邮件或者密码窃取邮件等。然后看分类器对哪一组邮件的预测误差最大，并着手优化。思考怎样能改进分类器。例如，发现是否缺少某些特征，记下这些特征出现的次数。 误差分析并不总能帮助我们判断应该采取怎样的行动。有时我们需要尝试不同的模型，然后进行比较，在模型比较时，用数值来判断哪一个模型更好更有效，通常我们是看交叉验证集的误差。 因此，在构造学习算法的时候，总是会去尝试很多新的想法，实现出很多版本的学习算法，如果每一次实践新想法的时候，都要手动地检测这些例子，去看看是表现差还是表现好，那么这很难让你做出决定。但是通过一个量化的数值评估（那些代码里自己计算的准确度？），你可以看看这个数字，误差是变大还是变小了。你可以通过它更快地实践你的新想法，它基本上非常直观地告诉你：你的想法是提高了算法表现，还是让它变得更坏，这会大大提高你实践算法时的速度。 在交叉验证集上来实施误差分析 类偏斜的误差度量误差度量值：设定某个实数来评估你的学习算法，并衡量它的表现。 类偏斜情况表现为我们的训练集中有非常多的同一种类的实例，只有很少或没有其他类的实例。 例如我们希望用算法来预测癌症是否是恶性的，在我们的训练集中，只有 0.5%的实例是恶性肿瘤。假设我们编写一个非学习而来的算法，在所有情况下都预测肿瘤是良性的，那么误差只有 0.5%。然而我们通过训练而得到的神经网络算法却有 1%的误差。这时，误差的大小是不能视为评判算法效果的依据的。 我们将算法预测的结果分成四种情况： 正确肯定（ True Positive,TP）：预测为真，实际为真 正确否定（ True Negative,TN）：预测为假，实际为假 错误肯定（ False Positive,FP）：预测为真，实际为假 错误否定（ False Negative,FN）：预测为假，实际为真 查准率（Precision）TP(TP+FP)。例，在所有我们预测有恶性肿瘤的病人中，实际上有恶性肿瘤的病人的百分比，越高越好。 查全率（Recall）TP(TP+FN)。例，在所有实际上有恶性肿瘤的病人中，成功预测有恶性肿瘤的病人的百分比，越高越好。 对于刚才那个总是预测病人肿瘤为良性的算法，其查全率是 0。 查准率和查全率之间的权衡假设，我们的算法输出的结果在 0-1 之间，我们使用阀值 0.5 来预测真和假。 如果我们希望只在非常确信的情况下预测为真（肿瘤为恶性），即我们希望更高的查准率，我们可以使用比 0.5 更大的阀值，如 0.7， 0.9。这样做我们会减少错误预测病人为恶性肿瘤的情况，同时却会增加未能成功预测肿瘤为恶性的情况。 如果我们希望提高查全率，尽可能地让所有有可能是恶性肿瘤的病人都得到进一步地检查、诊断，我们可以使用比 0.5 更小的阀值，如 0.3。 可以将不同阀值情况下，查全率与查准率的关系绘制成图表，曲线的形状根据数据的不同而不同：threshould是临界值的意思 查准率-召回率曲线会有多种形状 有一个帮助我们选择这个阀值的方法。一种方法是计算 F1 值（ F1 Score），其计算公式为：$$F_1 Score:2 \\frac{PR}{P+R}$$我们选择使得 F1 值最高的阀值。 支持向量机优化目标在监督学习中，许多学习算法的性能都非常类似，因此，重要的不是该选择使用学习算法 A 还是学习算法 B，而更重要的是，应用这些算法时，表现情况通常依赖于你的水平。比如：你为学习算法所设计的特征量的选择，以及如何选择正则化参数，诸如此类的事。 与逻辑回归和神经网络相比，支持向量机，或者简称 SVM，在学习复杂的非线性方程时提供了一种更为清晰，更加强大的方式。 从逻辑回归开始来展示如何一点一点修改来得到本质上的支持向量机。 逻辑回归中一个训练样本所对应代价函数表达式： 当y1时，只有第一项起了作用。对第一项进行修改，得出SVM中将要使用的代价函数（粉色线），由两段直线组成，暂时不用考虑左侧直线的斜率，因为那个不重要，这个将要使用的代价函数是在y1的前提条件下的。新的代价函数叫作cost1(z) 当y0时，新的代价函数叫作cost0(z) 然后接下来开始构造支持向量机。 这是逻辑回归中所用到的代价函数 对于支持向量机来说，要将里面的两项进行替换： 但实际上，对于支持向量机来说，代价函数的书写会有所不同。首先要去掉1m这一项，去掉之后也会得出同样的theta最优值。 因为1𝑚 仅是个常量，因此，你知道在这个最小化问题中，无论前面是否有1𝑚 这一项，最终我所得到的最优值𝜃都是一样的。这里我的意思是，先给你举一个实例，假定有一最小化问题：即要求当取得最小值时的𝑢值，这时最小值为：当𝑢 5时取得最小值。 现在，如果我们想要将这个目标函数乘上常数 10，这里我的最小化问题就变成了：求使得10 × (𝑢 - 5)2 + 10最小的值𝑢，然而，使得这里最小的𝑢值仍为 5。因此将一些常数乘以你的最小化项，这并不会改变最小化该方程时得到𝑢值。因此，这里我所做的是删去常量𝑚。也相同的，我将目标函数乘上一个常量𝑚，并不会改变取得最小值时的𝜃值。 用A来表示不包括正则项的部分，也就是训练样本的代价，用B来表示不包括lamda的正则项。这就相当于我们想要最小化𝐴加上正则化参数𝜆乘以𝐵，𝐴 + 𝜆 × 𝐵 ，我们所做的是通过设置不同正则参数𝜆达到优化目的。这样，我们就能够权衡对应的项，即最小化𝐴，是使得训练样本拟合的更好。还是保证正则参数足够小，也即是对于 B 项而言。 但对于支持向量机，按照惯例，我们将使用一个不同的参数替换这里使用的𝜆来权衡这两项。就是第一项和第二项我们依照惯例使用一个不同的参数称为𝐶，同时改为优化目标， 𝐶 × 𝐴 + 𝐵因此，在逻辑回归中，如果给定𝜆，一个非常大的值，意味着给予 B 更大的权重。而这里，就对应于将𝐶 设定为非常小的值，那么，相应的将会给𝐵比给𝐴更大的权重。因此，这只是一种不同的方式来控制这种权衡或者一种不同的方法，即用参数来决定是更关心第一项的优化，还是更关心第二项的优化。当然你也可以把这里的参数𝐶 考虑成1𝜆，同 1𝜆所扮演的角色相同，并且这两个方程或这两个表达式并不相同，因为𝐶 1𝜆，但是也并不全是这样，如果当𝐶 1𝜆时，这两个优化目标应当得到相同的值，相同的最优值 𝜃。 因此，这就得到了在支持向量机中我们的整个优化目标函数。然后最小化这个目标函数，得到 SVM 学习到的参数𝐶。 有别于逻辑回归输出的概率，在这里，当最小化代价函数得到参数𝜃时，支持向量机会直接预测y的值等于1还是等于0 大边界的直观理解人们有时将支持向量机看作是大间距分类器。 这是支持向量机模型的代价函数，左边是关于𝑧的代价函数cos𝑡1(𝑧)，此函数用于正样本，而右边是关于𝑧的代价函数cos𝑡0(𝑧)，横轴表示𝑧，现在让我们考虑一下，最小化这些代价函数的必要条件是什么。如果你有一个正样本， 𝑦 1，则只有在𝑧 1时，代价函数cos𝑡1(𝑧)才等于 0。 换句话说，如果你有一个正样本，我们会希望𝜃𝑇𝑥1，反之，如果𝑦 0，它只有在𝑧 -1的区间里函数值为 0。 事实上，（可以放入逻辑回归问题中理解）如果有一个正样本𝑦 1，则其实我们仅仅要求𝜃𝑇𝑥大于等于 0，就能将该样本恰当分出，这是因为如果𝜃𝑇𝑥0 大的话，我们的模型代价函数值为 0，类似地，如果有一个负样本，则仅需要𝜃𝑇𝑥0 就会将负例正确分离，但是，支持向量机的要求更高，不仅仅要能正确分开输入的样本，即不仅仅要求𝜃𝑇𝑥0，我们需要的是比 0 值大很多，比如大于等于 1，我也想分离负例时比 0 小很多，比如我希望它小于等于-1，这就相当于在支持向量机中嵌入了一个额外的安全因子，或者说安全的间距因子。 在支持向量机中，这个因子会导致什么结果。接下来考虑一个特例，将这个常数𝐶设置成一个非常大的值。比如假设𝐶的值为 100000 或者其它非常大的数，然后来观察支持向量机会给出什么结果？ 如果 𝐶非常大，则最小化代价函数的时候，我们将会很希望找到一个使第一项为 0 的最优解，因为cost𝐶 × 𝐴 + 𝐵。因此，让我们尝试在代价项的第一项为 0 的情形下理解该优化问题。 输入一个训练样本标签为𝑦 1，想令第一项为 0，需要做的是找到一个𝜃，使得𝜃𝑇𝑥 1，类似地，对于一个训练样本，标签为𝑦 0，为了使cos𝑡0(𝑧) 函数的值为 0，我们需要𝜃𝑇𝑥 -1。因此，现在考虑优化问题。选择参数，使得第一项等于 0，因此这个函数的第一项为 0，因此是𝐶乘以 0 加上二分之一乘以第二项。这里第一项是𝐶乘以 0，因此可以将其删去。 这将遵从以下的约束：$$θ^T x^{(i)}1，如果 y^{(i)}是等于1 的;θ^T x^{(i)}-1，如果样本i是一个负样本$$具体而言，如果你考察这样一个数据集，其中有正样本，也有负样本，可以看到这个数据集是线性可分的。 粉色和绿色的决策边界仅仅是勉强分开，这些决策边界看起来都不是特别好的选择，支持向量机将会选择这个黑色的决策边界。 黑线看起来是更稳健的决策界。在分离正样本和负样本上它显得的更好。数学上来讲，这条黑线有更大的距离，这个距离叫做间距。 当画出这两条额外的蓝线，我们看到黑色的决策界和训练样本之间有更大的最短距离。然而粉线和蓝线离训练样本就非常近，在分离样本的时候就会比黑线表现差。因此，这个距离叫做支持向量机的间距，而这是支持向量机具有鲁棒性的原因，因为它努力用一个最大间距来分离样本。因此支持向量机有时被称为大间距分类器。 鲁棒性：指模型在面对数据中的噪声、异常值、干扰或环境变化时，仍能保持稳定预测性能的能力。也就是模型的“抗干扰”和“抗压”能力。 支持向量机模型的做法，即努力将正样本和负样本用最大的间距分开。 在上面将这个大间距分类器中的正则化因子常数𝐶设置的非常大，因此对这样的一个数据集，也许我们将选择这样的决策界，从而最大间距地分离开正样本和负样本。那么在让代价函数最小化的过程中，我们希望找出在𝑦 1和𝑦 0两种情况下都使得代价函数中左边的这一项尽量为零的参数。如果我们找到了这样的参数，则我们的最小化问题便转变成： 但是，当你使用大间距分类器的时候，你的学习算法会受异常点的影响。比如我们加入一个额外的正样本。 在这里，如果加了这个样本，为了将样本用最大间距分开，也许最终会得到一条类似粉色这样的决策界，仅仅基于一个异常值，仅仅基于一个样本，就将我的决策界从这条黑线变到这条粉线，这实在是不明智的。而如果正则化参数𝐶，设置的非常大，这事实上正是支持向量机将会做的。 **但如果将 C 设置的不要太大，则最终会得到这条黑线。当𝐶不是非常非常大的时候，它可以忽略掉一些异常点的影响，得到更好的决策界。 ** 数据如果不是线性可分的，支持向量机也会将它们恰当分开。 因此，大间距分类器的描述，仅仅是从直观上给出了正则化参数𝐶非常大的情形，同时，要提醒你𝐶的作用类似于1𝜆， 𝜆是我们之前使用过的正则化参数，因此： 𝐶 较大时，相当于 𝜆 较小，可能会导致过拟合，高方差。 𝐶 较小时，相当于 𝜆 较大，可能会导致低拟合，高偏差。 大边界分类背后的数学（ 选修）向量内积：有两个向量u和v，两个都是二维向量，也叫做向量𝑢和𝑣之间的内积。 除了这种计算方式外还有一种计算方式。 先把这两个向量画出来，向量𝑢即在横轴上，取值为某个𝑢1，而在纵轴上，高度是某个𝑢2作为𝑢的第二个分量。向量v也按同样的步骤画出来。 ∥𝑢∥表示𝑢的范数，即𝑢的长度，即向量𝑢的欧几里得长度。$$∥u∥\\sqrt{(u_1^2+u_2^2 )},这是向量𝑢的长度，它是一个实数。$$计算内积：将向量𝑣投影到向量𝑢上，做一个直角投影，或者说一个 90 度投影将其投影到𝑢上，接下来度量这条红线的长度。称这条红线的长度为𝑝，因此𝑝就是长度，或者说是向量𝑣投影到向量𝑢上的量。$$公式是u^T vp⬝∥u∥$$因为𝑢𝑇𝑣 𝑣𝑇𝑢。因此如果你将𝑢和𝑣交换位置，将𝑢投影到𝑣上，而不是将𝑣投影到𝑢上，然后做同样的计算，只是把𝑢和𝑣的位置交换一下，你事实上可以得到同样的结果。申明一点，在这个等式中𝑢的范数是一个实数， 𝑝也是一个实数，因此𝑢𝑇𝑣就是两个实数正常相乘。 𝑝事实上是有符号的，即它可能是正值，也可能是负值。 这种情况下的p就是负值 这是支持向量机模型中的目标函数，为了让它更容易分析，忽略掉截距，令𝜃0 0，将特征数𝑛置为 2，因此仅有两个特征𝑥1, 𝑥2，现在来看一下支持向量机的优化目标函数，这个式子可以写作：$$\\frac{1}{2} (θ_1^2+θ_2^2 )\\frac{1}{2} {(\\sqrt{θ_1^2+θ_2^2 })}^2$$后面括号里面的那一项是向量𝜃的范数，或者说是向量𝜃的长度,因此支持向量机做的全部事情，就是极小化参数向量𝜃范数的平方，或者说长度的平方。 深入理解𝜃Tx的含义，𝜃和𝑥(𝑖)就类似于𝑢和𝑣 。 看这个图，考察一个单一的训练样本，我有一个正样本在这里，用一个叉来表示这个样本𝑥(𝑖)，意思是在水平轴上取值为𝑥1(𝑖)，在竖直轴上取值为𝑥2(𝑖)，然后将参数向量也画上去，那么内积将会是什么？ 使用之前的计算方式就是将训练样本投影到参数向量𝜃，然后将投影的长度画成红色。𝑝(𝑖)用来表示这是第 𝑖个训练样本在参数向量𝜃上的投影。根据我们之前的内容，𝜃𝑇𝑥(𝑖)将会等于𝑝 乘以向量 𝜃 的长度或范数。这就等于𝜃1 ⋅ 𝑥1(𝑖) + 𝜃2 ⋅ 𝑥2(𝑖)。这两种方式是等价的，都可以用来计算𝜃和𝑥(𝑖)之间的内积。 这里表达的意思是：这个𝜃𝑇𝑥(𝑖) 1的约束是可以被𝑝(𝑖) ⋅ ∥𝜃∥ 1这个约束所代替的。因为𝜃𝑇𝑥(𝑖) 𝑝(𝑖) ⋅ ∥𝜃∥ ，将其写入我们的优化目标。前面说过优化函数可以写为 以上就是为什么支持向量机最终会找到大间距分类器的原因。因为它试图极大化这些𝑝(𝑖)的范数，它们是训练样本到决策边界的距离。最后一点，我们的推导自始至终使用了这个简化假设，就是参数𝜃0 0。 𝜃0 0的意思是我们让决策界通过原点。如果你令𝜃0不是 0 的话，含义就是你希望决策界不通过原点。即便𝜃0不等于 0，支持向量机仍然会找到正样本和负样本之间的大间距分隔。 核函数给 定 一 个 训 练 实 例 𝑥 ， 我 们 利 用 𝑥 的 各 个 特 征 与 我 们 预 先 选 定 的 地 标(landmarks)𝑙(1), 𝑙(2), 𝑙(3)的近似程度来选取新的特征𝑓1, 𝑓2, 𝑓3。$$例如：f_1similarity(x,l^{(1)})e^{(-\\frac{∥x-l^{(1)} ∥^2}{2σ^2 })}$$ $$其中∥x-l^{(1)} ∥^2∑_{j1}^n(x_j-l_j^{(1)})^2，为实例𝑥中所有特征与地标𝑙(1)之间的距离的平方的和。$$ 上例中的𝑠𝑖𝑚𝑖𝑙𝑎𝑟𝑖𝑡𝑦(𝑥, 𝑙(1))就是核函数，具体而言，这里是一个高斯核函数。这个函数与正态分布没什么实际上的关系，只是看上去像而已。 这些地标的作用是什么？如果一个训练实例𝑥与地标𝐿之间的距离近似于 0，则新特征 𝑓近似于，如果训练实例𝑥与地标𝐿之间距离较远，则𝑓近似于。 假设我们的训练实例含有两个特征[𝑥1 𝑥2]，给定地标𝑙(1)与不同的𝜎值，见下图： 图中水平面的坐标为 𝑥1， 𝑥2而垂直坐标轴代表𝑓。可以看出，只有当𝑥与𝑙(1)重合时𝑓才具有最大值。随着𝑥的改变𝑓值改变的速率受到𝜎2的控制。 如何选择地标？ 通常是根据训练集的数量选择地标的数量，即如果训练集中有𝑚个实例，则选取𝑚个地标，并且令:𝑙(1) 𝑥(1), 𝑙(2) 𝑥(2), . . . . . , 𝑙(𝑚) 𝑥(𝑚)。这样做的好处在于：现在得到的新特征是建立在原有特征与训练集中所有其他特征之间距离的基础之上的，即： 下面我们将核函数运用到支持向量机中，修改我们的支持向量机假设为： 给定𝑥，计算新特征𝑓，当𝜃𝑇𝑓 0 时，预测 𝑦 1，否则反之。 相应地修改代价函数为：，在计算这个的时候还需要做一些调整，用代替，其中𝑀是根据我们选择的核函数而不同的一个矩阵。这样做的原因是为了简化计算。 理论上讲，我们也可以在逻辑回归中使用核函数，但是上面使用 𝑀来简化计算的方法不适用于逻辑回归，因此计算将非常耗费时间。 逻辑回归的核心是建模样本术语某个类别的概率，输出是一个概率值（0到1之间），它本质上是概率模型。SVM的目标是找到一个几何间隔最大的超平面进行硬分类（每个样本只能被明确划分到一个类别，逻辑回归是软分类，最终分类取概率最高的类别），输出的是确定的类别标签（如+1-1），本质上是几何间隔最大化模型。 可以直接使用现有的软件包来最小化支持向量机的代价函数，但在使用这些软件包最小化我们的代价函数之前，我们通常需要编写核函数，并且如果我们使用高斯核函数，那么在使用之前进行特征缩放是非常必要的。 另外，支持向量机也可以不使用核函数，不使用核函数又称为线性核函数，当我们不采用非常复杂的函数，或者我们的训练集特征非常多而实例非常少的时候，可以采用这种不带核函数的支持向量机。 使用支持向量机在高斯核函数之外我们还有其他一些选择，如： 多项式核函数（ Polynomial Kernel） 字符串核函数（ String kernel） 卡方核函数（ chi-square kernel） 直方图交集核函数（ histogram intersection kernel）等等… 这些核函数的目标也都是根据训练集和地标之间的距离来构建新特征，这些核函数需要满足 Mercer’s 定理，才能被支持向量机的优化软件正确处理。 多类分类问题 假设我们利用之前介绍的一对多方法来解决一个多类分类问题。如果一共有𝑘个类，则我们需要𝑘个模型，以及𝑘个参数向量𝜃。我们同样也可以训练𝑘个支持向量机来解决多类分类问题。但是大多数支持向量机软件包都有内置的多类分类功能，我们只要直接使用即可。 尽管不写自己的 SVM 的优化软件，但是也需要做几件事： 1、是提出参数𝐶的选择。因为偏差方差在这方面的性质。 2、也需要选择内核参数或你想要使用的相似函数，其中一个选择是：选择不需要任何内核参数，没有内核参数的理念，也叫线性核函数。因此，如果有人说他使用了线性核的 SVM（支持向量机），这就意味这他使用了不带有核函数的 SVM（支持向量机）。 如何选择逻辑回归模型和支持向量机模型 𝑛为特征数， 𝑚为训练样本数。 (1)如果相较于𝑚而言， 𝑛要大许多，即训练集数据量不够支持我们训练一个复杂的非线性模型，我们选用逻辑回归模型（模型相对简单，可以通过正则化来强制减少有效特征数量或参数大小，进一步抵抗过拟合）或者不带核函数的支持向量机（本质上是找一个最大化边距的线性分割超平面）。 放弃学习复杂的非线性关系，专注于找到一个稳健的线性决策边界，首要目标是防止过拟合。 (2)如果𝑛较小，而且𝑚大小中等，例如𝑛在 1-1000 之间，而𝑚在 10-10000之间，使用高斯核函数的支持向量机。 (3)如果𝑛较小，而𝑚较大，例如𝑛在 1-1000 之间，而𝑚大于 50000，则使用支持向量机会非常慢（计算成本爆炸），解决方案是创造、增加更多的特征（生成原始特征的多项式组合），然后使用逻辑回归或不带核函数的支持向量机。 核心原则： **特征少 (n 小)**：更容易构建复杂的非线性模型而不过拟合（数据相对充足）。 **特征多 (n 大)**：使用复杂模型非常容易过拟合，需要简化模型或更多数据。 **样本少 (m 小)**：不足以支撑复杂模型训练，需要使用简单模型防止过拟合。 **样本多 (m 大)**：能支撑更复杂模型的训练，但有些复杂模型（如带核函数的SVM）会变得非常慢。 值得一提的是，神经网络在以上三种情况下都可能会有较好的表现，但是训练神经网络可能非常慢，选择支持向量机的原因主要在于它的代价函数是凸函数，不存在局部最小值。 当有非常非常大的训练集，且用高斯核函数的情况下，经常会做的是尝试手动地创建，拥有更多的特征变量，然后用逻辑回归或者不带核函数的支持向量机。 逻辑回归和不带核函数的支持向量机它们都是非常相似的算法，不管是逻辑回归还是不带核函数的 SVM，通常都会做相似的事情，并给出相似的结果。但是根据实现的情况，其中一个可能会比另一个更加有效。 神经网络使用于什么时候呢？ 对于所有的这些问题，对于所有的这些不同体系一个设计得很好的神经网络也很有可能会非常有效。有一个缺点是，或者说是有时可能不会使用神经网络的原因是：对于许多这样的问题，神经网络训练起来可能会特别慢。 SVM 是一种凸优化问题。因此，好的 SVM优化软件包总是会找到全局最小值，或者接近它的值。对于 SVM 你不需要担心局部最优。 不能确定需要使用哪种算法没关系，算法确实很重要。但是通常更加重要的是：你有多少数据，你有多熟练是否擅长做误差分析和排除学习算法，指出如何设定新的特征变量和找出其他能决定你学习算法的变量等方面。 聚类无监督学习：简介在非监督学习中，我们的数据没有附带任何标签，我们拿到的数据就是这样的： 在这里有一系列点，却没有标签。因此，训练集可以写成只有𝑥(1),𝑥(2)…..一直到𝑥(𝑚)，没有任何标签𝑦。 在非监督学习中，我们需要将一系列无标签的训练数据，输入到一个算法中，然后我们告诉这个算法，快去为我们找找这个数据的内在结构。图上的数据看起来可以分成两个分开的点集（称为簇），一个能够找到这些点集的算法（不只是找到簇，也可以是找到其他类型的结构或者其他的一些模式），就被称为聚类算法。 K-均值算法K-均值是最普及的聚类算法，算法接受一个未标记的数据集，然后将数据聚类成不同的组。 也可以使用这个算法进行图像压缩。 K-均值是一个迭代算法，假设我们想要将数据聚类成 n 个组，其方法为: 首先选择𝐾个随机的点，称为聚类中心； 对于数据集中的每一个数据，按照距离𝐾个中心点的距离，将其与距离最近的中心点关联起来，与同一个中心点关联的所有点聚成一类。 计算每一个组的平均值，将该组所关联的中心点移动到平均值的位置。 重复步骤 2-4 直至中心点不再变化。 下面是一个聚类示例： 用𝜇1,𝜇2,…,𝜇𝑘 来表示聚类中心，用𝑐(1),𝑐(2),…,𝑐(𝑚)来存储与第𝑖个实例数据最近的聚类中心的索引， K-均值算法的伪代码如下： Repeat for i = 1 to m c(i) := index (form 1 to K) of cluster centroid closest to x(i) for k = 1 to K μk := average (mean) of points assigned to cluster k 算法分为两个步骤，第一个 for 循环是赋值步骤，即：对于每一个样例𝑖，计算其应该属于的类。第二个 for 循环是聚类中心的移动，即：对于每一个类𝐾，重新计算该类的质心。 K-均值算法也可以很便利地用于将数据分为许多不同组，即使在没有非常明显区分的组群的情况下也可以。下图所示的数据集包含身高和体重两项特征构成的，利用 K-均值算法将数据分为三类，用于帮助确定将要生产的 T-恤衫的三种尺寸。（感觉是你想分成几类就选择几个随机点） 优化目标K-均值最小化问题，是要最小化所有的数据点与其所关联的聚类中心点之间的距离之和，因此 K-均值的代价函数（又称畸变函数 ）为：$$J(c^{(1)},…,c^{(m)},μ_1,…,μ_K)\\frac{1}{m} ∑_{i1}^m∥X^{(i)}-μ_{c^{(i)} } ∥^2,其中μ_{c^{(i)} }代表与x^{(i)}最近的聚类中心点。$$我们的的优化目标便是找出使得代价函数最小的 𝑐(1),𝑐(2),…,𝑐(𝑚)和𝜇1,𝜇2,…,𝜇𝑘： Repeat for i = 1 to m c(i) := index (form 1 to K) of cluster centroid closest to x(i) for k = 1 to K μk := average (mean) of points assigned to cluster k 根据这个代码可以看出，第一个循环是用于减小𝑐(𝑖)引起的代价，而第二个循环则是用于减小𝜇𝑖引起的代价。迭代的过程一定会是每一次迭代都在减小代价函数。 随机初始化在运行 K-均值算法的之前，我们首先要随机初始化所有的聚类中心点，下面介绍怎样做： 我们应该选择𝐾 𝑚，即聚类中心点的个数要小于所有训练集实例的数量 随机选择𝐾个训练实例，然后令𝐾个聚类中心分别与这𝐾个训练实例相等 K-均值的一个问题在于，它有可能会停留在一个局部最小值处，而这取决于初始化的情况。 为了解决这个问题，我们通常需要多次运行 K-均值算法，每一次都重新进行随机初始化，最后再比较多次运行 K-均值的结果，选择代价函数最小的结果。这种方法在𝐾较小的时候（ 2–10）还是可行的，但是如果𝐾较大，这么做也可能不会有明显地改善。 选择聚类数通常是需要根据不同的问题，人工进行选择的。选择的时候思考我们运用 K-均值算法聚类的动机是什么，然后选择能最好服务于该目的标聚类数。 “肘部法则” ：我们所需要做的是改变𝐾值，也就是聚类类别数目的总数。我们先用一个聚类来运行 K 均值聚类方法。这就意味着，所有的数据都会分到一个聚类里，然后计算成本函数或者计算畸变函数𝐽。 𝐾代表聚类数。 这是比较清晰的图： 这种模式，它的畸变值会迅速下降，从 1 到 2，从 2 到 3 之后，你会在 3 的时候达到一个肘点。在此之后，畸变值就下降的非常慢，看起来就像使用 3 个聚类来进行聚类是正确的，这是因为那个点是曲线的肘点，畸变值下降得很快， 𝐾 3之后就下降得很慢，那么我们就选𝐾 3。当你应用“肘部法则”的时候，如果你得到了一个像上面这样的图，那么这将是一种用来选择聚类个数的合理方法。 这是不明显的图，模拟两可： 参考资料：相似度距离计算，衡量指标1.相似度距离计算方法总结 (1). 闵可夫斯基距离 Minkowski（其中欧式距离： 𝑝 2)$$dist(X,Y)(∑_{i1}^n|x_i-y_i | ^p )^{\\frac{1}{p} }$$(2). 杰卡德相似系数(Jaccard$$J(A,B)\\frac{|A∩B|}{|A∪B|}$$(3). 余弦相似度(cosine similarity 𝑛维向量𝑥和𝑦的夹角记做𝜃，根据余弦定理，其余弦值为：$$cos(θ)\\frac{x^T y}{|x|⋅|y|}\\frac{∑_{i1}^n x_i y_i }{\\sqrt{∑_{i1}^n x_i^2 } \\sqrt{∑_{i1}^n y_i^2 } }$$ 没看懂这个 2.聚类的衡量指标 (1). 均一性： 𝑝 类似于精确率，一个簇中只包含一个类别的样本，则满足均一性。其实也可以认为就是正确率(每个聚簇中正确分类的样本数占该聚簇总样本数的比例和) (2). 完整性：𝑟 类似于召回率，同类别样本被归类到相同簇中，则满足完整性;(每个聚簇中正确分类的样本数占该类型的总样本数比例的和) (3). V-measure: 均一性和完整性的加权平均（这里的β是自己定义的吗？）$$V\\frac{(1+β^2)pr}{β^2p+r}$$(4). 轮廓系数 样本𝑖的轮廓系数： 𝑠(𝑖) 簇内不相似度:计算样本𝑖到同簇其它样本的平均距离为𝑎(𝑖)，应尽可能小。 簇间不相似度:计算样本𝑖到其它簇𝐶𝑗的所有样本的平均距离𝑏𝑖𝑗，应尽可能大。 轮廓系数𝑠(𝑖)值越接近 1 表示样本𝑖聚类越合理，越接近-1，表示样本𝑖应该分类到另外的簇中，近似为 0，表示样本𝑖应该在边界上;所有样本的𝑠(𝑖)的均值被成为聚类结果的轮廓系数$$s(i)\\frac{b(i)-a(i)}{\\max{a(i),b(i)} }$$ 降维动机一：数据压缩进行降维的原因之一是数据压缩。 数据压缩不仅允许我们压缩数据，因而使用较少的计算机内存或磁盘空间，它也让我们加快我们的学习算法。 降维是什么，举个例子，我们收集的数据集，有许多，许多特征，绘制两个在这里。 假设我们未知两个的特征： 𝑥1:长度：用厘米表示； 𝑥2：是用英寸表示同一物体的长度。 这个例子的意思是：假使我们要采用两种不同的仪器来测量一些东西的尺寸，其中一个仪器测量结果的单位是英寸，另一个仪器测量的结果是厘米，我们希望将测量的结果作为我们机器学习的特征。现在的问题的是，两种仪器对同一个东西测量的结果不完全相等（由于误差、精度等），而将两者都作为特征有些重复，因而，我们希望将这个二维的数据降至一维。 我们不想有高度冗余的特征。 像上面的图，画一条绿色的线，接下来测量各个点在这条绿色的线上的位置作为新的特征 z ，这样就将原来x的二位特征转化为了只需要用一个实数就能表示的特征。 接下来是将3D的特征转化维2D的，下图看不出来但途中的所有特征大致都在同一个平面上。 这样的处理过程可以被用于把任何维度的数据降到任何想要的维度，例如将 1000 维的特征降至 100 维。 动机二：数据可视化在许多机器学习问题中，如果我们能将数据可视化（前面的练习题中都是先将数据可视化再进行训练），我们便能寻找到一个更好的解决方案，降维可以帮助我们。 假使我们有有关于许多不同国家的数据，每一个特征向量都有 50 个特征（如 GDP，人均 GDP，平均寿命等）。如果要将这个 50 维的数据可视化是不可能的。使用降维的方法将其降至 2 维，我们便可以将其可视化了。假设将50个特征变为了两个特征z1、z2来描述。 这样做的问题在于，降维的算法只负责减少维数，新产生的特征的意义就必须由我们自己去发现了。 主成分分析问题主成分分析(PCA)是最常见的降维算法。 在 PCA 中，我们要做的是找到一个方向向量（这个找到的方向向量不管是正的还是负的都没关系，因为这两个向量都定义了同一条直线），当我们把所有的数据都投射到该向量上时，我们希望投射平均均方误差能尽可能地小。方向向量是一个经过原点的向量，而投射误差是从特征向量向该方向向量作垂线的长度。 主成分分析问题的描述：问题是要将𝑛维数据降至𝑘维，目标是找到向量𝑢(1),𝑢(2),…,𝑢(𝑘)使得总的投射误差最小。 正式的说，PCA做的是将数据进行投影，寻找k个向量对数据进行投影，进而最小化投影距离（也就是数据点和投影之后点的距离）。在下面这个例子中，就是想将点投影到二维平面上，所以投影误差就是这个点和投影到二维平面上的点的距离。 主成分分析与线性回归是两种不同的算法。主成分分析最小化的是投射误差，而线性回归尝试的是最小化预测误差。线性回归的目的是预测结果，而主成分分析不作任何预测。 PCA 将𝑛个特征降维到𝑘个，可以用来进行数据压缩，但 PCA要保证降维后，还要保证数据的特性损失最小。 PCA 技术的一大好处是对数据进行降维的处理。我们可以对新求出的“主元”向量的重要性进行排序（新特征按其所解释的原始数据方差大小从高到低排序（第一主成分包含最多信息）），根据需要取前面最重要的部分（通常满足累计方差贡献率85%），将后面的维数省去，可以达到降维从而简化模型或是对数据进行压缩的效果。同时最大程度的保持了原有数据的信息。 传统特征选择：直接删除部分原始特征列，可能丢失重要信息 PCA降维：用原特征线性组合构建信息更集中的新特征 累计方差贡献率是PCA降维中选择主成分数量的核心依据，表示前k个主成分所携带的原始数据信息量占比。$$第 i 个主成分（PC_i）的方差贡献率 \\frac{λ_i}{∑_{j1}^pλ_j}$$ λi：PCA求解的第 i 个特征值（代表该主成分的方差） p：原始特征维度总数 意义：PCᵢ 单独解释的原始数据变异比例 $$累计方差贡献率是∑_{i1}^k\\frac{λ_i}{∑_{j1}^pλ_j}$$ PCA 技术的一个很大的优点是，它是完全无参数限制的。在 PCA 的计算过程中完全不需要人为的设定参数或是根据任何经验模型对计算进行干预，最后的结果只与数据相关，与用户是独立的。 但是，这一点同时也可以看作是缺点。如果用户对观测对象有一定的先验知识，掌握了数据的一些特征，却无法通过参数化等方法对处理过程进行干预，可能会得不到预期的效果，效率也不高。 主成分分析算法PCA 减少𝑛维到𝑘维： 第一步是均值归一化。我们需要计算出所有特征的均值，然后令（这将使每个特征的均值为0)。如果特征是在不同的数量级上，我们还需要将其除以标准差 ，也就是（这就相当于前面的特征缩放）。 第二步是计算协方差矩阵 𝛴（大写希腊字母sigma）： ∑ ，xi 是n×1矩阵 对于一个数据集，协方差矩阵 C 的目标是描述不同特征之间的关系。 矩阵的对角线元素 C[i, i] 是第 i 个特征的方差。 非对角线元素 C[i, j] 是第 i 个特征和第 j 个特征的协方差。 因此，如果你的数据集有 n 个特征，那么协方差矩阵一定是一个 (n, n) 的方阵。 X 是一个 (m, n) 矩阵，其中 m 是样本数，n 是特征数，所以计算协方差矩阵为X.T * X（X是矩阵） 第三步是计算协方差矩阵𝛴的特征向量：在 Octave 里我们可以利用奇异值分解来求解， [U, S, V] svd(sigma)。 这会返回三个矩阵，而我们需要的只是第一个矩阵U。 在python中则是： U, S, V = np.linalg.svd(cov) # cov是协方差矩阵 上式中的𝑈是一个具有与数据之间最小投射误差的方向向量构成的矩阵。如果我们希望将数据从𝑛维降至𝑘维，我们只需要从𝑈中选取前𝑘个向量，获得一个𝑛 × 𝑘维度的矩阵，我们用𝑈𝑟𝑒𝑑𝑢𝑐𝑒表示，然后通过如下计算获得要求的新特征向量𝑧(𝑖):$$z^{(i)}U_{reduce}^T*x^{(i)}$$其中𝑥是𝑛 × 1维的，因此结果为𝑘 × 1维度。 PCA要做的是尝试找到一个线或面，把数据投影到这个线或面上，以便最小化平方投影误差。 选择主成分的数量PCA算法是将n维的变为k维的，这个k也叫做主成分的数字。 主要成分分析是减少投射的平均均方误差： 训练集的方差为：，所以总方差就是训练集中的平均长度，意思是，平均来说，我的训练样本距离全零向量的距离，或者说我的训练样本距离原点有多远。 我们希望在平均均方误差与训练集方差的比例尽可能小的情况下选择尽可能小的𝑘值。 如果我们希望这个比例小于 1%，就意味着原本数据的方差有 99%都保留下来了，如果我们选择保留 95%的方差，便能非常显著地降低模型中特征的维度了。 可以先令𝑘 1，然后进行主要成分分析，获得𝑈𝑟𝑒𝑑𝑢𝑐𝑒和𝑧，然后计算比例是否小于1%。如果不是的话再令𝑘 2，如此类推，直到找到可以使得比例小于 1%的最小𝑘 值（原因是各个特征之间通常情况存在某种相关性）。 这是一个比较低效的过程，吴恩达介绍的是用Octave简化这个过程，python的做法是 重建的压缩表示 PCA 算法，我们可能有一个这样的样本。如图中样本𝑥(1),𝑥(2)。我们做的是，我们把这些样本投射到图中这个一维平面。给定一个点𝑧(1)，我们怎么能回去这个原始的二维空间呢？$$x为2维，z为1维，zU_{reduce}^T x，相反的方程为：x_{appox}U_{reduce}⋅z，x_{appox}≈x$$ 这就是你从低维表示𝑧回到未压缩的表示𝑥，我们也把这个过程称为重建原始数据。 为什么进行恢复原始数据的操作后，数据和原始数据不一样？ 因为PCA是一种有损压缩技术。 在降维（投影）的过程中，我们为了用更少的维度来表示数据，主动地丢弃了一部分信息。因此，当我们试图从降维后的数据恢复时，这部分被丢弃的信息是无法找回的，所以恢复后的数据和原始数据不一样。 主成分分析法的应用建议 使用PCA来加速学习算法，可以将数据的维度减少5倍或者10倍，在保留较大方差的前提下，这样做几乎不影响性能、分类精度，而且通过较低的维度数据，算法会运行地很快。 使用PCA去防止过拟合不是很推荐，这是一种非常糟糕的应用，虽然它的效果可能会很好，但这不是一种很好的方式去处理过拟合问题，最好应该使用规则化来防止过拟合。 在使用PCA之前，应该考虑只使用原始数据去训练学习算法。 异常检测问题的动机这是机器学习算法的一个常见应用。这种算法的一个有趣之处在于：它虽然主要用于非监督学习问题，但从某些角度看，它又类似于一些监督学习问题。 什么是异常检测？ 假想你是一个飞机引擎制造商，当你生产的飞机引擎从生产线上流出时，你需要进行QA(质量控制测试)，而作为这个测试的一部分，你测量了飞机引擎的一些特征变量，比如引擎运转时产生的热量，或者引擎的振动等等。 这样一来，你就有了一个数据集，从𝑥(1)到𝑥(𝑚)，如果你生产了𝑚个引擎的话，你将这些数据绘制成图表，图里的每个点、每个叉，都是你的无标签数据。这样，异常检测问题可以定义如下：假设后来有一天，你有一个新的飞机引擎从生产线上流出，而你的新飞机引擎有特征变量𝑥𝑡𝑒𝑠𝑡。所谓的异常检测问题就是：我们希望知道这个新的飞机引擎是否有某种异常。 给定数据集，假使数据集是正常的，我们希望知道新的数据 𝑥𝑡𝑒𝑠𝑡是不是异常的，即这个测试数据不属于该组数据的几率。我们所构建的模型应该能根据该测试数据的位置告诉我们其属于一组数据的可能性 𝑝(𝑥)。 上图中，在蓝色圈内的数据属于该组数据的可能性较高，而越是偏远的数据，其属于该组数据的可能性就越低。 这种方法称为密度估计，表达如下： 模型𝑝(𝑥) 为我们计算其属于一组数据的可能性， 通过𝑝(𝑥) 𝜀检测非正常用户。 异常检测主要用来识别欺骗。可以根据这些特征构建一个模型，可以用这个模型来识别那些不符合该模式的用户或者物品啥的。 高斯分布高斯分布，也称为正态分布。$$如果我们认为变量 x 符合高斯分布 x∼N(μ,σ^2)则其概率密度函数为： p(x,μ,σ^2)\\frac{1}{\\sqrt{2π }σ} exp(\\frac{-(x-μ)^2}{2σ^2 })$$ $$μ和σ^2的计算方法:μ\\frac{1}{m} ∑_{i1}^mx^{(i)} ，σ^2\\frac{1}{m} ∑_{i1}^m( x^{(i)}-μ)^2$$ 样例： 注：机器学习中对于方差我们通常只除以𝑚而非统计学中的(𝑚 - 1)。这里顺便提一下，在实际使用中，到底是选择使用1𝑚还是1(𝑚 - 1)其实区别很小，只要你有一个还算大的训练集，在机器学习领域大部分人更习惯使用1𝑚这个版本的公式。这两个版本的公式在理论特性和数学特性上稍有不同，但是在实际使用中，他们的区别甚小，几乎可以忽略不计。 算法应用高斯分布开发异常检测算法。 对于给定的数据集 ，我们要针对每一个特征计算 𝜇 和 𝜎2 的估计值。 一旦我们获得了平均值和方差的估计值，给定新的一个训练实例，根据模型计算 𝑝(𝑥)：$$p(x)∏_{j1}^np(x_j;μ_j,σ_j^2)∏_{j1}^n \\frac{1}{\\sqrt{2π} σ_j} exp(\\frac{-{(x_j-μ_j) }^2}{2σ_j^2 })$$选择一个𝜀，将𝑝(𝑥) 𝜀作为判定边界，当𝑝(𝑥) 𝜀时预测数据为正常数据，否则为异常。 下图是一个由两个特征的训练集，以及特征的分布情况： 下面的三维图表表示的是密度估计函数， 𝑧轴为根据两个特征的值所估计𝑝(𝑥)值： 开发和评价一个异常检测系统异常检测算法是一个非监督学习算法，意味着我们无法根据结果变量 𝑦 的值来告诉我们数据是否真的是异常的。 但如果有一些带标签的数据能够指明哪些是异常样本，哪些是非异常样本，那么这就是我们要找的能够评价异常检测算法的标准算法。当我们开发一个异常检测系统时，我们从带标记（异常或正常）的数据着手，我们从其中选择一部分正常数据用于构建训练集，然后用剩下的正常数据和异常数据混合的数据构成交叉检验集和测试集。 异常检测算法的推导和评价方法如下： 例如：我们有 10000 台正常引擎的数据，有 20 台异常引擎（通常在20~50个）的数据。 我们这样分配数据： 6000 台正常引擎（可能也有一些异常数据被分到训练集中，但没什么关系）的数据作为训练集 2000 台正常引擎和 10 台异常引擎的数据作为交叉检验集 2000 台正常引擎和 10 台异常引擎的数据作为测试集 具体的评价方法如下： 根据训练集数据，我们估计特征的平均值和方差并构建𝑝(𝑥)函数 对交叉检验集，我们尝试使用不同的𝜀值作为阀值，并预测数据是否异常，根据 F1 值或者查准率与查全率的比例来选择 𝜀 选出 𝜀 后，针对测试集进行预测，计算异常检验系统的𝐹1值，或者查准率与查全率之比。 异常检测与监督学习对比对于一些数据，我们知道它们哪些是异常，哪些是正常的，为什么我们不用监督学习算法，逻辑回归或者神经网络从我们带标签的数据中直接学习，并预测 y 的值是1还是0。 下面的对比有助于选择采用监督学习还是异常检测： 异常检测 监督学习 非常少量的正向类（异常数据 y1）, 大量的负向类（y0) ，一般将这些正向类作为交叉验证集和测试集 同时有大量的正向类和负向类 许多不同种类的异常，非常难。根据非常 少量的正向类数据来训练算法。 有足够多的正向类实例，足够用于训练 算法，未来遇到的正向类实例可能与训练集中的非常近似。 未来遇到的异常可能与已掌握的异常、非常的不同。 例如： 欺诈行为检测 生产（例如飞机引擎）检测数据中心的计算机运行状况 例如：邮件过滤器 天气预报 肿瘤分类 在异常检测算法中，正例的数量很少，以至于对于一个学习算法来说，它无法从正例中学习到足够的知识，所以，我们应该采用大量的反例让它学习，学习关于反例，关于 x 的模型 p ，然后保留小数量的正例用于评估我们的算法，这些正例要么用于交叉验证集要么用于测试集。 另外，对于很多技术公司可能会遇到的一些问题，通常来说，正样本的数量很少，甚至有时候是 0，也就是说，出现了太多没见过的不同的异常类型（对于垃圾邮件问题，虽然垃圾邮件的类别很多，但数量同样很多，所以一般看作是监督学习问题），那么对于这些问题，通常应该使用的算法就是异常检测算法。 选择特征对于异常检测算法，我们使用的特征是至关重要的，下面谈谈如何选择特征： 异常检测假设特征符合高斯分布，如果数据的分布不是高斯分布，异常检测算法也能够工作，但是最好还是将数据转换成高斯分布，例如使用对数函数： 𝑥 𝑙𝑜𝑔(𝑥 + 𝑐)，其中 𝑐为非负常数； 或者， 𝑐为 0-1 之间的一个分数，等方法。 （在 python 中，通常用 np.log1p()函数， 𝑙𝑜𝑔1𝑝就是 𝑙𝑜𝑔(𝑥 + 1)，可以避免出现负数结果，反向函数就是 np.expm1()）这句还没搞懂怎么用。 如果数据不是高斯分布的，通常需要使用一些转换算法来对数据进行处理，使数据更像高斯分布。 这只是转换的一种方法，也有可能使log(x+1)或者使log(x+常数)或者x的n次方(0n1)等，目的是使数据分布更像高斯分布。 如何得到异常检测算法的特征变量？通常通过误差分析步骤。这跟前面监督学习的误差分析步骤是差不多的，先完整地训练出一个学习算法，然后在一组交叉验证集上验证算法，然后找出那些出错的样本，然后看看能不能找到一些其它的特征变量来帮助学习算法让它在交叉预测集中判断出错的样本中表现得更好。 在异常检测中，我们希望p(x)值对于正常样本来说是比较大的，而对异常样本来说值是很小的。 误差分析： 一个常见的问题是一些异常的数据可能也会有较高的𝑝(𝑥)值，因而被算法认为是正常的。这种情况下误差分析能够帮助我们，我们可以分析那些被算法错误预测为正常的数据，观察能否找出一些问题。我们可能能从问题中发现我们需要增加一些新的特征，增加这些新特征后获得的新算法能够帮助我们更好地进行异常检测。 绿色的x是异常样本，在只有x1特征时可以看出它的p(x)的值很大，所以现在就要再找出一个特征使它能和正常样本分开。 我们通常可以通过将一些相关的特征进行组合，来获得一些新的更好的特征（异常数据的该特征值异常地大或小）。 多元高斯分布（选修）假使我们有两个相关的特征，而且这两个特征的值域范围比较宽，这种情况下，一般的高斯分布模型可能不能很好地识别异常数据。其原因在于，一般的高斯分布模型尝试的是去同时抓住两个特征的偏差，因此创造出一个比较大的判定边界。 下图中是两个相关特征，洋红色的线（根据 ε 的不同其范围可大可小）是一般的高斯分布模型获得的判定边界，很明显绿色的 X 所代表的数据点很可能是异常值，但是其𝑝(𝑥)值却仍然在正常范围内。多元高斯分布将创建像图中蓝色曲线所示的判定边界。 使用多元高斯分布进行异常检测（ 选修）推荐系统问题形式化从一个例子开始定义推荐系统的问题。 假使我们是一个电影供应商，我们有 5 部电影和 4 个用户，我们要求用户为电影打分。 我们希望构建一个算法来预测他们每个人可能会给他们没看过的电影打多少分，并以此作为推荐的依据。 下面引入一些标记： 代表用户的数量 代表电影的数量 𝑟(𝑖, 𝑗) 如果用户 𝑗 给电影 𝑖 评过分则 𝑟(𝑖, 𝑗) 1 代表用户 𝑗 给电影 𝑖 的评分 𝑚𝑗代表用户 𝑗 评过分的电影的总数 基于内容的推荐系统在一个基于内容的推荐系统算法中，我们假设对于我们希望推荐的东西有一些数据，这些数据是有关这些东西的特征。 在我们的例子中，我们可以假设每部电影都有两个特征，如𝑥1代表电影的浪漫程度， 𝑥2代表电影的动作程度。 则每部电影都有一个特征向量，如𝑥(1)是第一部电影的特征向量为[0.9 0]。 下面我们要基于这些特征来构建一个推荐系统算法。 假设我们采用线性回归模型，我们可以针对每一个用户都训练一个线性回归模型，如𝜃(1)是第一个用户的模型的参数。 于是，我们有：$$θ^{(j)}用户 j 的参数向量，x^{(i)}电影 i 的特征向量$$ $$对于用户 j 和电影 i，我们预测评分为：(θ^{(j)} )^T x^{(i)}$$ 代价函数： 针对用户 𝑗，该线性回归模型的代价为预测误差的平方和，加上正则化项：$$\\underset{θ(j)}{min} \\frac{1}{2} \\underset{i:r(i,j)1}{∑}((θ^{(j)} )^T x^{(i)}-y^{(i,j)} )^2 +\\frac{λ}{2} ∑_{k1}^n(θ_k^{(j)} )^2$$其中 𝑖: 𝑟(𝑖, 𝑗)表示我们只计算那些用户 𝑗 评过分的电影。在一般的线性回归模型中，误差项和正则项应该都是乘以12𝑚，在这里我们将𝑚去掉。并且我们不对方差项𝜃0进行正则化处理。 上面的代价函数只是针对一个用户的，为了学习所有用户，我们将所有用户的代价函数求和：$$\\underset{θ^{(1)},…,θ^{(n_u)} }{min}\\frac{1}{2} ∑_{j1}^{n_u}\\underset{i:r(i,j)1}{∑}((θ^{(j)} )^T x^{(i)}-y^{(i,j)} )^2 +\\frac{λ}{2} ∑_{j1}^{n_u}∑_{k1}^n( θ_k^{(j)} )^2$$如果我们要用梯度下降法来求解最优解，我们计算代价函数的偏导数后得到梯度下降的更新公式为：$$θ_k^{(j)}:θ_k^{(j)}-α\\underset{i:r(i,j)1}{∑}((θ^{(j)} )^T x^{(i)}-y^{(i,j)})x_k^{(i)} (for k0)$$ $$θ_k^{(j)}:θ_k^{(j)}-α(\\underset{i:r(i,j)1}{∑}((θ^{(j)} )^T x^{(i)}-y^{(i,j)})x_k^{(i)}+λθ_k^{(j)}) (for k≠0)$$ 协同过滤这种方法能够自行学习所要使用的特征。 假设有一个数据集，部分数据如上图。我们可以知道假如要搜集像这样的数据，要让每一个人都看完每部电影再搜集他们觉得每部电影的浪漫指数或者动作指数啥的，很麻烦，而且通常还希望得到除了这两个特征之外的特征信息，那要怎么样才能得到这些特征信息。 那就转换一下问题，假设我们有以下数据集，且我们可以从用户那边得到相关参数： 那我们根据这些参数理论上可以推出每部电影的x1和x2值。 以第一部电影为例子，我们需要满足这些条件： 所以可以推出第一部电影的特征为（包括x0）： 将这一问题标准化到任意特征x(i)，相当于是x(i)变成了要求的参数，原本的参数变成了训练用的数据集：$$\\underset{x^{(1)},…,x^{(n_m)} }{min}\\frac{1}{2} ∑_{i1}^{n_m}\\underset{j:r(i,j)1}{∑}((θ^{(j)} )^T x^{(i)}-y^{(i,j)} )^2+\\frac{λ}{2} ∑_{i1}^{n_m}∑_{k1}^n( x_k^{(i)} )^2 $$但是如果我们既没有用户的参数，也没有电影的特征，这两种方法都不可行了。协同过滤算法可以同时学习这两者。 我们的优化目标便改为同时针对𝑥和𝜃进行。 从这个代价函数我们可以看出来，如果将x作为常量，那就详相当于，如果将theta作为常量，那就相当于 优化问题的目标是： 这个学习算法的前提是：，电影特征没有x01，那用户的参数也就没有theta0（也就是截距）了，所以这个学习算法中所求得的特征和theta都是n维向量。为什么要这样设置呢？因为我们现在是在学习所有特征，所以没有必要去将这个等于1的特征值固定死，因为如果算法真的需要一个特征永远为1的话，那它可以选择靠自己去获得1这个数值，可以选择将x1设置为1，所以没必要将原本1这个特征固定住。 对代价函数求偏导数的结果如下： 由于前提的存在，所以这边要对所有的参数theta和特征x做正则化，不需要区分出k0的情况。 注：在协同过滤从算法中，我们通常不使用方差项，如果需要的话，算法会自动学得。 协同过滤算法使用步骤如下： 初始 为一些随机小值 使用梯度下降算法最小化代价函数 在训练完算法后，我们预测为用户 𝑗 给电影 𝑖 的评分 通过这个学习过程获得的特征矩阵包含了有关电影的重要数据，这些数据不总是人能读懂的，但是我们可以用这些数据作为给用户推荐电影的依据。 例如，如果一位用户正在观看电影 𝑥(𝑖)，我们可以寻找另一部电影𝑥(𝑗)，依据两部电影的特征向量之间的距离的大小。 向量化：低秩矩阵分解有关该算法的向量化实现，以及有关该算法可以做的其他事情 。通过学习特征参数，来找到相关电影和产品。 举例子： 1.当给出一件产品时，你能否找到与之相关的其它产品。 2.一位用户最近看上一件产品，有没有其它相关的产品，你可以推荐给他。我将要做的是：实现一种选择的方法，写出协同过滤算法的预测情况。 我们有关于五部电影的数据集，我将要做的是，将这些用户的电影评分，进行分组并存到一个矩阵中。 我们有五部电影，以及四位用户，那么 这个矩阵 𝑌 就是一个 5 行 4 列的矩阵，它将这些电影的用户评分数据都存在矩阵里： 评分： 找到相关影片： 依据的是两部电影的特征向量之间的距离的大小。 因为已经对特征参数向量进行了学习，那么我们就可以来度量两部电影之间的相似性。例如说：电影 𝑖 有一个特征向量𝑥(𝑖)，你是否能找到一部不同的电影 𝑗，保证两部电影的特征向量之间的距离𝑥(𝑖)和𝑥(𝑗)很小，那就能很有力地表明电影𝑖和电影 𝑗 在某种程度上有相似。总结一下，当用户在看某部电影 𝑖 的时候，如果你想找 5 部与电影 i 非常相似的电影，为了能给用户推荐 5 部新电影，你需要做的是找出电影 𝑗，在这些不同的电影 j 中与我们要找的电影 𝑖 的距离最小，这样你就能给你的用户推荐几部不同的电影了。 推行工作上的细节：均值归一化 如果我们新增一个用户 Eve，并且 Eve 没有为任何电影评分，那么我们以什么为依据为 Eve 推荐电影呢？ 假如不做任何处理按原数据来学习那会有以下结果： 由于Eve没有为任何一部电影评分，所以theta5作用于最后一个正则项，这边假设特征数量为2，由于我们希望选择theta5使得最终的正则化项越小越好，所以最后theta5[0 0]，那也就会导致Eve的电影评分都为0，而这个电影评分是没有意义的，这个评分也说明Eve对任何一部电影都不感兴趣，所以也无法为她推荐电影。但均值归一化可以解决这个问题。 我们首先需要对结果 𝑌矩阵进行均值归一化处理，将每一个用户对某一部电影的评分减去所有用户对该电影评分的平均值： 然后我们利用这个新的 𝑌 矩阵来训练算法。 如果我们要用新训练出的算法来预测评分，则需要将平均值重新加回去，预测，对于 Eve，我们的新模型会认为她给每部电影的评分都是该电影的平均分，这样会更有意义一点。 大规模机器学习大型数据集的学习如果我们有一个低偏差的模型，增加数据集的规模可以帮助你获得更好的结果。 以线性回归模型为例，每一次梯度下降迭代，我们都需要计算训练集的误差的平方和，如果我们的学习算法需要有 20 次迭代，这便已经是非常大的计算代价。 首先应该做的事是去检查一个这么大规模的训练集是否真的必要，也许我们只用 1000个训练集也能获得较好的效果，我们可以绘制学习曲线来帮助判断。 随机梯度下降法如果我们一定需要一个大规模的训练集，我们可以尝试使用随机梯度下降法（ SGD） 来代替批量梯度下降法。 接下来的是以线性回归为例子，但随机梯度下降的思想也可以应用于其它学习算法，比如逻辑回归、神经网络或其它依靠梯度下降进行训练的算法。 在随机梯度下降法中，我们定义代价函数为一个单一训练实例的代价：$$cost(θ,(x^{(i)},y^{(i)} ))\\frac{1}{2} (h_θ (x^{(i)} )-y^{(i)} )^2$$随机梯度下降算法为：首先对训练集随机打乱（可以稍微快一点收敛），就是将所有m个训练样本重新排序，然后： 通常训练一次就够了，最多到10次 所以，随机梯度下降算法实际上就是扫描所有的训练样本，首先是第一组训练样本(x(1),y(1))，然后只根据这个训练样本对参数theta进行修改，完成上面的那个内层循环之后，转向第二个训练样本，然后对参数theta进行修改，……，以此类推直到完成所有训练样本。 随机梯度下降算法在每一次计算之后便更新参数 𝜃 ，而不需要首先将所有的训练集求和。 但是这样的算法存在的问题是，不是每一步都是朝着”正确”的方向迈出的。因此算法虽然会逐渐走向全局最小值的位置，但是可能无法站到那个最小值的那一点，而是在最小值点附近徘徊。一般使用随机梯度下降法也能得到一个很接近全局最小值的参数，对于实际应用的目的来说是足够用的。 小批量梯度下降小批量梯度下降算法是介于批量梯度下降算法和随机梯度下降算法之间的算法，每计算常数𝑏次训练实例，便更新一次参数 𝜃 。 一次使用b个样本。感觉应该是while循环，或者是for循环加步长step 下面是视频里的： 通常令 𝑏 在 2-100 之间。这样做的好处在于，我们可以用向量化的方式来循环𝑏个训练实例。 随机梯度下降收敛在批量梯度下降中，我们可以令代价函数 𝐽 为迭代次数的函数，绘制图表，根据图表来判断梯度下降是否收敛。但是，在大规模的训练集的情况下，这是不现实的，因为计算代价太大了。 在随机梯度下降中，我们在每一次更新 𝜃 之前都计算一次代价，然后每𝑥次迭代后，求出这𝑥次对训练实例计算代价的平均值，然后绘制这些平均值与𝑥次迭代的次数之间的函数图表。 当我们绘制这样的图表时，可能会得到一个颠簸不平但是不会明显减少的函数图像（如上面左下图中蓝线所示）。我们可以增加𝛼来使得函数更加平缓，也许便能看出下降的趋势了（如上面左下图中红线所示）；或者可能函数图表仍然是颠簸不平且不下降的（如洋红色线所示），那么我们的模型本身可能存在一些错误。 如果我们得到的曲线如上面右下方所示，不断地上升，那么我们可能会需要选择一个较小的学习率𝛼。 左上角的图可以很明显地看出来是在收敛，红色的线是采用了更小地学习率，因此可以看到它收敛的速度变慢了，但最后得到的效果可能更好。 我们也可以令学习率随着迭代次数的增加而减小，例如令：$$α\\frac{const1}{iterationNumber+const2}$$随着我们不断地靠近全局最小值，通过减小学习率，我们迫使算法收敛而非在最小值附近徘徊。 但是通常我们不需要这样做便能有非常好的效果了，对𝛼进行调整所耗费的计算通常不值得。 这种方法不需要定时地扫描整个训练集，来算出整个样本集的代价函数，而是只需要每次对最新 1000 个，或者多少个样本，求一下平均值。 在线学习一种新的大规模的机器学习机制，叫做在线学习机制，在线学习机制让我们可以模型化问题。 使用不同版本的在线学习机制算法，从大批的涌入又离开网站的用户身上进行学习。特别要提及的是，如果你有一个由连续的用户流引发的连续的数据流，进入你的网站，你能做的是使用一个在线学习机制，从数据流中学习用户的偏好，然后使用这些信息来优化一些关于网站的决策。 在线学习算法指的是对数据流而非离线的静态数据集的学习。 假使我们正在经营一家物流公司，每当一个用户询问从地点 A 至地点 B 的快递费用时，我们给用户一个报价，该用户可能选择接受（ 𝑦 1）或不接受（ 𝑦 0）。 现在，我们希望构建一个模型，来预测用户接受报价使用我们的物流服务的可能性。因此报价 是我们的一个特征，其他特征为距离，起始地点，目标地点以及特定的用户数据。模型的输出是:𝑝(𝑦 1)。 在线学习的算法与随机梯度下降算法有些类似，我们对单一的实例进行学习，而非对一个提前定义的训练集进行循环。 Repeat forever (as long as the website is running) Get (𝑥, 𝑦) corresponding to the current user 𝜃: = 𝜃𝑗 − 𝛼(ℎ𝜃(𝑥) − 𝑦)𝑥𝑗 (for 𝑗 = 0: 𝑛) 一旦对一个数据的学习完成了，我们便可以丢弃该数据，不需要再存储它了。 这种方式的好处在于，我们的算法可以很好的适应用户的倾向性，算法可以针对用户的当前行为不断地更新模型以适应该用户。 每次交互事件并不只产生一个数据集，例如，我们一次给用户提供 3 个物流选项，用户选择 2 项，我们实际上可以获得 3 个新的训练实例，因而我们的算法可以一次从 3 个实例中学习并更新模型。 我们所使用的这个算法与随机梯度下降算法非常类似，唯一的区别的是，我们不会使用一个固定的数据集，我们会做的是获取一个用户样本，从那个样本中学习，然后丢弃那个样本并继续下去。 在线学习的一个优点就是，如果你有一个变化的用户群，又或者你在尝试预测的事情，在缓慢变化，就像你的用户的品味在缓慢变化，这个在线学习算法，可以慢慢地调试你所学习到的假设，将其调节更新到最新的用户行为。 映射化简和数据并行如果我们用批量梯度下降算法来求解大规模数据集的最优解，我们需要对整个训练集进行循环，计算偏导数和代价，再求和，计算代价非常大。如果我们能够将我们的数据集分配给不多台计算机，让每一台计算机处理数据集的一个子集，然后我们将计算的结果汇总在求和。这样的方法叫做映射简化。 具体而言，如果任何学习算法能够表达为，对训练集的函数的求和，那么便能将这个任务分配给多台计算机（或者同一台计算机的不同 CPU 核心），以达到加速处理的目的。 应用实例：图片文字识别问题描述和流程图图像文字识别应用所作的事是，从一张给定的图片中识别文字。 为了完成这样的工作，需要采取如下步骤： 1.文字侦测（ Text detection） ——将图片上的文字与其他环境对象分离开来 2.字符切分（ Character segmentation） ——将文字分割成一个个单一的字符 3.字符分类（ Character classification） ——确定每一个字符是什么 可以用任务流程图来表达这个问题，每一项任务可以由一个单独的小队来负责解决。 滑动窗口滑动窗口是一项用来从图像中抽取对象的技术。假使我们需要在一张图片中识别行人，首先要做的是用许多固定尺寸的图片来训练一个能够准确识别行人的模型。然后我们用之前训练识别行人的模型时所采用的图片尺寸在我们要进行行人识别的图片上进行剪裁，然后将剪裁得到的切片交给模型，让模型判断是否为行人，然后在图片上滑动剪裁区域重新进行剪裁，将新剪裁的切片也交给模型进行判断，如此循环直至将图片全部检测完。 一旦完成后，我们按比例放大剪裁的区域，再以新的尺寸对图片进行剪裁，将新剪裁的切片按比例缩小至模型所采纳的尺寸，交给模型进行判断，如此循环。 滑动窗口技术也被用于文字识别，首先训练模型能够区分字符与非字符，然后，运用滑动窗口技术识别字符。 白色区域说明文本检测系统发现了文本。黑色区域说明没有文本。深浅不同不同的灰色区域对于分类器输出的概率，所以可以理解为它找到了文本但不大确定。 一旦完成了字符的识别，我们将识别得出的区域进行一些扩展，然后将重叠的区域进行合并。接着我们以宽高比作为过滤条件，过滤掉高度比宽度更大的区域（认为单词的长度通常比高度要大）。下图中绿色的区域是经过这些步骤后被认为是文字的区域，而红色的区域是被忽略的。 以上便是文字侦测阶段。 下一步是训练一个模型来完成将文字分割成一个个字符的任务，需要的训练集由单个字符的图片和两个相连字符之间的图片来训练模型。我们需要用有监督的学习学习算法，需要检查这些图像块并且尝试决定在图像块的中间是否存在两个字符的分割。 模型训练完后，我们仍然是使用滑动窗口技术来进行字符识别。 以上便是字符切分阶段。 最后一个阶段是字符分类阶段，利用神经网络、支持向量机或者逻辑回归算法训练一个分类器即可。 获取大量数据和人工数据以我们的文字识别应用为例，我们可以字体网站下载各种字体，然后利用这些不同的字体配上各种不同的随机背景图片创造出一些用于训练的实例，这让我们能够获得一个无限大的训练集。这是从零开始创造实例。 另一种方法是，利用已有的数据，然后对其进行修改，例如将已有的字符图片进行一些扭曲、旋转、模糊处理。只要我们认为实际数据有可能和经过这样处理后的数据类似，我们便可以用这样的方法来创造大量的数据。有关获得更多数据的几种方法： 1.人工数据合成 2.手动收集、标记数据 3.众包 上限分析：哪部分管道的接下去做在机器学习的应用中，我们通常需要通过几个步骤才能进行最终的预测，我们如何能够知道哪一部分最值得我们花时间和精力去改善呢？这个问题可以通过上限分析来回答。 回到我们的文字识别应用中，我们的流程图如下： 流程图中每一部分的输出都是下一部分的输入，上限分析中，我们选取一部分，手工提供 100%正确的输出结果，然后看应用的整体效果提升了多少。假使我们的例子中总体效果为 72%的正确率。 如果我们令文字侦测部分输出的结果 100%正确，发现系统的总体效果从 72%提高到了89%。这意味着我们很可能会希望投入时间精力来提高我们的文字侦测部分。 接着我们手动选择数据，让字符切分输出的结果 100%正确，发现系统的总体效果只提升了 1%，这意味着，我们的字符切分部分可能已经足够好了。 最后我们手工选择数据，让字符分类输出的结果 100%正确，系统的总体效果又提升了10%，这意味着我们可能也会应该投入更多的时间和精力来提高应用的总体表现。"},{"title":"真题技巧","path":"/2025/05/05/真题技巧/","content":"一个流程的优化，从两方面入手，第一它自己的数据状况，第二它所要求解的标准。 窗口不回退（左边界和右边界不回退） 类似于滑动窗口，从最左边的点开始向右移动，第一个点记作L，计算下一个点和第一个点的距离是否在绳子长度以内，在的话就是可以覆盖，找到能覆盖的最右边的点记作R，在这个范围内的点数就是可以覆盖的数量，这样子只需要遍历一边过去就行。 打表法当一道题目，输入是一个整数，输出也是一个整数时，可以先写一个特别傻的解法，然后分析一下值的输出规律，进而优化代码。 根据这个输出规律硬捏出代码，绝对是最优解，不要考虑是什么原理。当然不是所有题目都是这个特征，但可以解决4成的题目。 奇数肯定不行，先判断是否是奇数。 普通解法：先看最多可以用几个8类型的袋子，不能全用8类型的袋子的话就开始一个一个的减，看下剩下的能不能用6类型的袋子解决。 优化：利用最小公倍数，6和8的最小公倍数是24，那么当剩下的苹果数量大于24还不能被完全装入的时候，接下来就不需要继续试了，说明肯定不能正好装下。因为大于24的部分是刚开始只用8类型的袋子装时剩下的，被验证过最后不能全用6类型的袋子正好装下，所以剩下的就不用继续试了。假如说你剩下27个，那24的用6的袋子装完后，还剩下3个，而这3个是你之前试过不成功的；继续往下试的话就是剩下35个，去掉24剩下11个，这个也是24个之前试过不行的。 使用24还有一个原因是，24用8袋子装比6袋子要少，所以大于24的，里面的24肯定用8装更好，但我们接下来是都用6装的，所以就已经落后了，而一旦剩下的大于24那只用6装肯定不是最少的。 奇数的可以直接判断不行，所以只是用来展示一下原理。 最优解： 如何得出这个答案，先算100以内的所有苹果的解，然后会发现18开始以后都是有规律的。 有先手和后手两只动物吃草，每次只能吃4的某次方的草，给你个N代表一共有多少草，谁最先把草吃完谁赢（就是最后一口是谁吃的就是谁赢），请你返回谁会赢。 0份草的时候是后手赢，因为先手面对的是没有草的情况。 先手怎么试，先吃1份草，不能赢就先吃4，还不能就先吃16，这样试下去，有一次能赢就是先手赢。 最简单的办法： winner1(n-base)是后手面对的情况，是先手吃的子过程，如果winner1(n-base)返回的是后手赢，说明就是先手赢了，因为原本的后手在winner1(n-base)里是先手，而原本的先手就变成了后手。 防止溢出的意思是防止base超过int的范围。 接下来从0试到50，看下结果。 找到输出规律后，直接根据这个规律来写代码，不用关心数学原理。 预处理 基本思路：从左往右试，假设左边没有一个R，看下需要染几块，假设左边有一个R，有两个R……有n个R，分别算出各需要染色几块，然后选出最小的就行了。但这样需要一遍又一遍地遍历数组，时间复杂度较高。 下面的伪代码和题目刚好相反 所以就对原数组先进行预处理，注意，下面讲得是将左边染成G，右边染成R的思路，和题目相反。 由于要将左边全部变成G，那我们从左往右计算分别有几个R，几个R代表需要染几次，所以创建一个A数组代表0~i 的R数量。 要将右边全部变成R，那我们从右往左计算分别有几个G，几个G代表需要染几次，所以创建一个B数组代表n-1~i 的G数量。 这样子，再按基本思路解题就可以直接从A，B两个数组直接获取答案了。 先确定正方形，确定一个左上角点，然后枚举边长。 一个元素是边长为1的正方形。 然后要验证这个正方形的四条边是不是都是1，需要遍历4条边。 简化验证流程 right代表的是一个矩阵内，每一个位置包含这个位置在内，右方有多少个连续的1。 down代表的是任何一个位置包含这个位置在内，下方有多少个连续的1。 如何利用呢？假设你这个点位于（4，5），边长是3，那就先验证right中的这个点够不够3，等于和超过都算，再看down里的这个点够不够3，都够的话，那就跳转到右边的那个点和下方的那个点（图里画圈的），看右边的点的下方是否够连续的3个1（包括自己），看下面的点的右边是否够连续的三个1，这样就把验证过程变成O(1)级别的了，信息都在right和down里。 用二进制来拼。 首先，如何利用15的返回01的：让1、2返回0，4、5返回1，3的话就重新生成。 想要等概率返回17，先弄一个函数等概率返回06，然后加1就行了。 如何生成呢？首先3个二进制位可以返回0~7，而二进制是0和1，那就是我们上面的r01函数所做的事情，返回0和1，但3位二进制可以返回7怎么办，返回7的话就重新生成就好了。 那我再res0的时候重新生成，那res的范围不就是1~7了吗。 假如是一个1321的随机数生成器，要要这个随机生成3059的数，那就用1321的随机生成0和1（1316为0，1720为1，21重新生成），利用0和1拼出029然后加30就是3059了（这个需要5个二进制位，表示范围是031，大于29的重新生成）。 生成两个数，00和11都重新生成，将01定为0，10定为1，概率一样。 动态规划 可以分N种情况，从左树一个结点都没有到右树一个结点都没有，将这些情况下的个数都加起来就是答案。普遍情况是左树i 个结点，右树N-i-1个结点，那么这种情况的二叉树结构数量为F(i)*F(N-i-1)。F(N)代表的是节点个数为N个的时候有几种二叉树结构。 上面有个错误，应该是leftNumn-1。可以观察到这种题目肯定会有很多F(N)会重复用到，所以可以改为动态规划的方法。 关注宏观调度过程，不要关注局部怎么变 解题方法是在左上角和右下角各画一个框，只打印框里的，当两个框错过的时候就是打印完成的时候。 (a,b)：左上角，(c,d)：右下角 ac代表这是一条横线，bd代表这是一条竖线 如何用这个方法： 按照这个看的话，当你旋转的时候只会跟这个数字所在的那一圈有关，跟里面的完全没有关系。 我的想法是，一个正方形矩阵，左上角和右上角的度数肯定是90°，所以左上角肯定移到右上角，然后左上角右边位置移到右下角下面位置，就按这个规律转过去就可以了。 他的思路是将这一圈框四个数，左上角，右上角，左下角，右下角，然后顺时针进行交换，然后轮第二个数，也顺时针进行交换，感觉就是我的思路的实现版。这个思路保证变量是有限的且容易实现。 c是下面那一行的横坐标，上面给出来的四个点就是要进行交换的四个点。 如何调用： zigzag方式打印： 想出来了！：两个点A和B，刚开始都停留在左上角，A就一直往右走，不能走了往下走，B就一直往下走，不能走了往右走，每次只移动一步，然后打印这两个点之间的斜线，要么从左下向右上，要么从右上向左下。 栈和队列最小栈问题： 两个栈，一个是存储数据的，还有一个是最小栈，存储各个状态下的最小值，如上图，Data压进一个3，min里面没有数直接压进3；Data压进4，min只压进当前状态下的最小值，由于3比4小，所以继续压进3，这个比较可以直接从min栈顶取数；Data压入2，此时2比3小，所以min压入2；Data压入6，6大于2，所以min压入2。 使用两个栈实现队列结构 所有数据都直接进入push栈，用户想要弹出数据，如果此时pop栈中没有元素，那就将push中的全部元素倒入pop中，然后pop弹出。 记住两点：push要倒东西一次性倒完；如果pop中有元素的话push中的元素就不能倒进pop中。 使用队列实现栈结构： 准备两个队列，用户想存入数据的话就一直压入队列中，如果用户想弹出数据的话，那就将队列中的最后一个数留在原队列中，其它的压入另一个队列，然后原队列弹出，接下来着另一个队列就成为了要压入数据的队列。如果用户还想要弹出的话，那就重复前面的步骤。 动态规划的空间压缩技巧 位置依赖 一个动态规划模型，一个二维表，用户只想要右下角的值，里面的一个元素依赖于上方和左边的元素。在这张表最上面的那一行的元素只依赖于左边的元素，这张表的最左边的那一列的元素只依赖于它们上方的元素。 这种模型，不需要申请一整张二维表，只需要申请一个数组就可以了。 假设一个动态规划需要它上面一行多个的值怎么办？从右往左更新 一个位置既跟我左边的值有关又跟我上边的值有关，怎么更新？ 先更新第一个位置的f，然后把原位置的a用一个变量先存储起来，然后更新g，g更新完之后，变量需记住b，然后继续往下更新。 上面讲得都是先更新出第一行，然后依次往下更新。如果列很多怎么办，比如4*100万这种的。 先更新一列，然后从左往右依次更新 哪些题目不能使用这个技巧？ 一个点需要跳很远的位置，那就不能压缩。 假如只跳两行，那可以使用三个数组来求解，先分别求出0，1，2行的值，然后求解第3行时使用第0行的数组进行求解。 但如果一个点跳的太远了，那么可能需要的数组就会很多，那就没有那么划算了。 按照这个理论，三层的动态规划问题也可以解决。 第一行是要求的，第二，三行是依赖的位置。 洗衣机问题 这道题考两个点：一是靠猜，二是考你怎么更新。 有物品的机器每轮可以扔出一件物品，往左往右都可以。 只看一台机器，以这台机器为分界点，可以看出左边和右边分别是缺了或者多了多少物品。负数代表缺，正数代表多。 （1）左右两边都缺 那 i 这个机器至少需要经历25轮。所以只看一台机器，不管其它机器，两侧都缺的话，这台机器最少需要经历的轮数是两边的绝对值相加。左右皆正的话，在同一轮里，左边可以向右扔，右边可以向左扔。 将每个位置至少需要的轮数都求出来，那最大的轮数就是答案。 想到了，但不知道为什么是答案。 leftSum是左侧已经遍历过的累加和，i*avg是 i 位置的左侧需要的衣服。 这道问题和洗衣机问题很像，洗衣机问题只关注自己左右两侧的事，这道题只关注自己这一列可以放下多少水。 求解标准： 按照常理来说是要建立两个辅助数组，第一个辅助数组记录的是0i位置的最大值，第二个辅助数组记录的是in-1位置的最大值。 但最优解是不要辅助数组。重点是看瓶颈由谁决定，由较小的那方决定。 ALL记录的总水量，0位置和8位置肯定不会有水，max左记录的是左边已经遍历的最大值，max右记录的是右边已经遍历过的最大值，L和R是两个指针。 此时，已经可以求解R位置的水量了，因为max左max右，且左边还没遍历完它的最大值就已经是10了，所以max左的最小值肯定是目前的数，而max右代表着R位置右边的最大值，所以可以得出答案就是7-34。 注意：6位置的数据改变了。此时可以结算L位置的水量了。 max左较小就先结算L的水量，max右较小就先结算R的水量，两个一样大，L和R可以同时结算。 先求出全局最大值max，那当划分左右的时候，max在哪边哪边的最大值就是max，所以就分为了两种情况：max-max左，max-max右。而max-max左max-arr[0]，max-max右max-arr[n-1]。以左边为例，无论左边最大的数是谁，减arr[0]都是最好的，因为假如有数大于了arr[0]由于我们要差值最大，所以我们选择arr[0]，假如有数比arr[0]小，由于取得是最大值所以max左依旧等于arr[0]。 KMP 先看a，b是否长度一样，然后生成a+a的字符串，判断b是否是a+a的子串（easy）。 咖啡问题先给你一个数组arr，数组里每一个值都是正数，一个数代表一台咖啡机的工作效率，代表冲咖啡的时间，一个咖啡机一次只能处理一杯咖啡，arr中有几个数就说明有几台咖啡机，拿到咖啡后喝咖啡的时间为0，参数N代表喝咖啡的人数，每人只喝一杯，参数a代表只有一台洗咖啡杯的机器，这个机器用a的时间洗一个咖啡杯，一次只能洗一个杯子，参数b代表咖啡杯不洗能变干净的时间，一直到所有咖啡杯都洗干净至少需要多少时间。 假设有10个人，编号0~9，arr数组为[3,2,1]，先建立一个小根堆，小根堆中的元素为（时刻，冲咖啡的时间），代表在这个时刻咖啡机是可用的，按两个数值相加谁小谁排上面，也就是按结束时间的早晚排序的。 第0个人选择（0，2），记下，（0，2）转变为（2，2）扔回小根堆中。 第1个人选择（0，3），记下，（0，3）转变为（3，3），扔回小根堆，就按这个规律选择咖啡机。 在最下面得到的数组也就是每个人有洗咖啡杯需求的时间的数组，接下来就看要怎么安排使得洗咖啡杯的时间最短。每个人有两种选择，洗咖啡机和挥发，这是一个从左往右进行尝试的问题。 调用函数：process(drinks,a,b,0,0) drinks是每个人喝完咖啡的时间，index代表轮到第几个人开始洗，washLine是洗咖啡的机器在什么时间点有空。 斐波那契套路除了初始项之外，后面每一项都有严格的递归式的问题，那可以将时间复杂度变为logN。 斐波那契问题 这是线性代数的内容：这种式子它还存在着一个矩阵的式子，由于它最多只需要前两项，所以矩阵为二阶矩阵。 可以通过初始的几项将abcd求出来。 从而，可以得到以下结论： 那求斐波那契问题就转化为了求矩阵n次方的问题。 怎么求矩阵的n次方最快，先探索怎么求一个数的n次方最快。 先将次方转化为二进制形式，然后重点关注哪一位上是有1的。 假设t10，根据二进制每一位的值为t赋次方，哪一位上为1就乘以那一位的t的次方，上面的例子就是1，2，8，64为1，所以就要分别乘以t的1，2，8，64次方，可以算出等于75次方。一个数的n次方可以这样算，那同理矩阵也可以这样算。 假设t矩阵a，其它的同上，最后算结果的时候先乘以一个单位矩阵。 最后F(N)X+P，所以return res[0][0] + res[1][0] 两个矩阵m1、m2相乘的结果返回： 将这个规律进行推广，假设有下面的严格推导式： 必须给前5项作为初始项，所以矩阵为5阶矩阵。 由于初始几项可以自己算出来，所以就可以将这个5*5的矩阵算出来，算出来后就可以得出通式了。 有一个农场，它有母牛A，它只能生母牛，每年生一只母牛，小牛3年后成熟可以开始生育，问n年之后牛的数量。 规律是这个：因为，今年牛的数量去年牛的数量（不会死亡）+新生牛的数量（由于近三年新出生的小牛没成熟，不能生育，所以可以生育的是3年前的牛），所以会有一个3阶矩阵。 这种问题，只有矩阵和初始值会不一样，其它的都一样。 假设一个农场初始有一只兔子，一只兔子每年生两个，小兔子两年成熟，兔子寿命为5年。 打表法！ 然后你就会发现规律是斐波那契套路。 如果不用打表法，怎么发现规律是斐波那契套路。假设一个函数F(i)，意思是 i 长度的字符串，每个位置都可以为0或1，但 i 长度之前的位置的数必须为1。所以假如长度为8的话，那就需要调用F(7)，因为第一位必须为1，否则肯定不是达标字符串。 F(i)会等于什么，有两种情况，第一种是当 i 长度的字符串第一位为1时，那符合F函数的定义，所以会等于F(i-1)，第二种是当第一位为0时，那第二位必须为1，满足F函数定义，所以会等于F(i-2)。因此F(i) F(i-1) + F(i - 2)，斐波那契。 通过打表法发现规律最简单。 前缀树 例子，假设有以下几个目录： 建立一个前缀树： 根据深度优先遍历打印出来就可以了。重点是如何建立前缀树。 在java和python中\\需要转义才可以表达出来，但是在java中要按\\切割字符串就需要写成，但是在python中就只需要 注意这边使用的是有序表，因为要顺序输出，Java 的 TreeMapString, Node 会自动按键（文件夹名）的字母顺序排序。在 Python 中，标准的 dict 从 3.7+ 版本开始会保持插入顺序，但不会自动排序。为了模拟 TreeMap 的行为，我们在打印时对字典的键进行排序 (sorted(node.next_map.keys()))。 python实现： import collections # 1. Node 类的定义 class Node: def __init__(self, name: str): self.name = name self.next_map = def generate_folder_tree(folder_paths: list[str]) - Node: # head 是根节点，对应 Java 中的 new Node() head = Node() for path in folder_paths: # 按 \\ 分割路径，得到各级文件夹名 parts = path.split(\\\\) current_node = head for part in parts: if part not in current_node.next_map: current_node.next_map[part] = Node(part) current_node = current_node.next_map[part] return head def _print_process(node: Node, level: int): # 根节点 (level 0) 是一个虚拟节点，我们不打印它的名字 if level != 0: # 生成缩进字符串，每级缩进2个空格 indent = * (level - 1) print(findentnode.name) # 为了模拟 Java TreeMap 的排序行为，我们在遍历前对键进行排序 for key in sorted(node.next_map.keys()): next_node = node.next_map[key] _print_process(next_node, level + 1) def print_folder_tree(folder_paths: list[str]): 主函数，用于构建并打印文件夹结构树。 if not folder_paths: return # 根据路径字符串，把前缀树建立好，头节点为 head head = generate_folder_tree(folder_paths) # 打印 _print_process(head, 0) if __name__ == __main__: # 创建一个示例路径列表 paths = [ a\\\\b\\\\c, a\\\\b\\\\d, a\\\\c\\\\e, b\\\\c\\\\f, a\\\\c\\\\z ] print(文件夹结构:) print_folder_tree(paths) 上述代码用到了类型提示 或 类型注解，即def __init__(self, name: str):里的**name: str**正是类型提示的核心部分，name 是参数的名称。: str 是对这个参数的 “提示” 或 “注解”。它告诉阅读代码的人：“我期望 name 这个参数应该是一个字符串 (str) 类型。” 在def generate_folder_tree(folder_paths: list[str]) - Node:中，除了类型提示外，**- Node**是一个返回值类型提示，箭头 - 后面的部分用来注解函数的返回值类型。告诉我们：“这个函数执行完毕后，预计会返回一个 Node 类型的对象。” 自己写函数的话不需要这样写。 二叉树套路 最后返回2节点。 要转换的话，每部分分别返回头和尾： 左边部分的尾指向x，x的left指向左边部分的尾；右边部分的头指向x，x的right指向右边部分的头，最后返回左边部分的头和右边部分的尾作为x的头和尾。 下面的是要求返回最大搜索二叉子树的头结点。要是比较的两个搜索二叉子树的节点个数一样这边返回一个就行。 以x开头的树，最大搜索二叉子树有两种情况，和x有关，和x无关。 与x有关的后面两个条件是，左maxx，右minx。最终答案如果3）成立那就是3），不然就是1）或2）。 判断有可能性3的两个if条件是： 假设答案法 这道题目的流程是，cur代表的是和，初值为0。cur按顺序从头开始叠加，每当cur刚加完一个数后，如果cur0，max更新，如果cur0，设置cur0，max不更新。 以上面那个例子就是:cur3，max3；cur5,max5；cur4，5和4比较，5比较大，max不变；cur8,max8；cur-10，max不比较，cur0；cur4max，不更新；一直算下去，最后max13。 为什么这样做？ 这个流程在数组没有正数的情况下也是对的。 假设椭圆形区域的数组既是这个数组中累加和最大的又是所有满足最大累加和子数组中最长的那个数组，在上面的例子中就是[1,1,1,1]。 假设椭圆形区域的开头是 i ，最后一个下标是 j ，那会有以下性质： 1）从 i 到end(endj)的区域的和都大于等于0 2）任何一个开头累加到i-1位置的和必小于0 面对这道题应该先假设答案，假设答案的时候发现设置什么样的流程可以将你这个答案找到，而且设计的这个流程时间复杂度要尽量低。 例子： 解这道题的流程是：必须包含0行且只包含0行，最大子矩阵和是多少；必须包含0，1行，且只包含0，1行，最大子矩阵和是多少；……；必须包含2行，且只包含2行，最大子矩阵和是多少。 那每一次情况要怎么求？ 0~0：就是只有一行数据，按上面那道题的解法来就可以了。 0~1：两行数据，同一列的数据相加，会得到这些数据-12，12，1，7，现在又变成只有一行数据了，那接下来就按上面的解法就行了。 求出来的答案再找出对应的矩阵就可以了： 看到子矩阵问题就先想子数组是怎么办的，如果子数组的问题解决了，那就看能不能用压缩的方式将子矩阵的问题变成压缩之后子数组的问题。 贪心 ‘X’位置不能放灯。 既然’X’位置不能放灯，那可不可以遍历，找到连续的’.’，三个三个一组求需要灯的数量。 根据 i 位置是什么进行分类：1）i 位置是’X’，那不放灯； ​ 2）i 位置是’.’，那要看i+1位置，（1）i+1位置是’X’，那灯放在 i 位置（2）i+1位置是’.’，那灯就放在i+1位置 index = index+3解决的就是2）（2）中情况，原本是在 index 位置直接放灯，但如果下一位置也是’.’的话，那就再下一位置放灯，因为灯会影响到左中右三个位置，所以让灯放在index+1位置，那index+2位置就不用考虑了，接下来直接考虑index+3就行了。 先建立词频表。 接下来从头开始遍历字符串，遍历一个字符就在词频表中相对应的词频-1，当词频表中有一个为0时暂停，此时划定了一个范围，在例子中是a的词频为0了。这个划定的范围的意思是如果在这个范围内只留一个字符，剩下内容全删掉，能够保证不会有某种字符缺的范围。在这个范围内选择ASCII码最小的，在例子中选择在1位置的字符，那接下来就是将1前面的字符全部删掉，然后将剩下范围内的a全部删掉，最后得到bcbbct。 接下来再建立词频表。 重复上面的步骤，最后就可以得到答案。 递增子序列问题子序列，从左往右，可以不连续。 dp数组：子序列必须以arr[i]结尾的情况下，最长递增子序列的长度。 dp[3]：由于arr[3]的值是6，左边比它小的数有3、1、2，那哪个比较好，因为2的数量比较多，所以选择dp[2]，然后加一。 这个动态规划的方法的时间复杂度为O(n^2)，接下来有探讨时间复杂度为O(n*logn)的。 dp数组的含义和上面的还是一样的。 ends数组：刚开始全部都是无效区，如果一个位置在无效区中，认为它没有含义。如果一个位置在有效区里，那就有含义了，含义是所有长度为i+1的递增子序列中最小结尾是什么值。 ends[0]3，无效区缩小，为什么后面还是无效区，因为没有长度为2、3、4、5、6的递增子序列，此时递增子序列是{3}，长度为1，最小值是3，所以ends[0]3。 接下来遍历到arr[1]2，然后在ends的有效区里二分地找大于2的最左的位置，那就是3，然后用2代替3。 为什么要这样代替呢？因为2的出现导致现在有两个递增子序列，没有形成长度为2的递增子序列，所以此时长度为1的递增子序列中最小结尾的值是2，所以2更新3。 那如何确认dp值呢？在ends数组中找到2连同自己在内左侧有几个数，一个数，所以dp值为1。 接下里是4，在ends的有效区中二分地找大于4的最左的位置，没找到，那就要扩充有效区，因为4的出现开始出现长度为2的递增子序列了。 计算数字n能否被3整除有三种方法： 其中第二种方法和第三种方法是等效的，所以采用第三种方法。 视频讲得是，判断10能否被3整除，就是看1+0能否被3整除，那么看1+0能否被3整除不就相当于10能否被3整除，这是一个等价命题。还有一个例子就是判断123能否被3整除看的是1+2+3能否被3整除，那1+2+3能否被3整除就相当于看123能否被3整除。 按照我的理解的话就是，例如12345678910，正常来说是算1+2+3+4+5+6+7+8+9+1+0，但如果1+2+3+4+5+6+7+8+9可以被3整除，那么后面再加上一个可以被3整除的数n的话，那么和也是能被3整除的，如果加上的n是不能被3整除的数的话，因为n不能被3整除，所以将n拆解开的和m也不能被3整除，那么原本加m的和也就不能被3整除，所以会等价于1+2+3+4+5+6+7+8+9+10。 in place 算法 数组要按照这个规律排序，就是在 i 位置上放置的数的大小是i+1，达不到的话就说明缺少了i+1 假设5位置上放的是16，那我要将16放到15这个位置上，那会有以下几种情况： 1）15位置上放的就是16，那就不需要移动了 2）15位置上放的不是16，那就将16移动到15位置上，然后寻找15位置上的数应该放到哪里，一直这样下去，直到达成第一种情况 0位置上放的是3，所以要放到2位置上，2位置上放的是1，所以先将1拿出来，3放到2上，然后寻找1的位置，1要放到0上，就是回到了初始点。那么当回到0的时候就直到这个循环已经结束了，所以接下来就轮到了1位置。 递归跑不完，人为地用平凡解规定边界 上面题目没写全，初始人气值start也是偶数。 很多题目，限制条件是不全的，所以就需要自己去寻找一些边界条件，去找一些业务上的优化，通过平凡解的答案去规定限制条件。寻找base case条件。 根据题目我们可以知道，由于start和end都是偶数，所以start肯定可以通过一直加2来达到end，所以可以求出一个答案，这就是一个平凡解（看着像剪枝里的上界条件，那本算法课本里的）。所以当递归过程中求的币数大于这个答案时，那就可以不用继续了，因为肯定不是最优解。这就是找一个平凡解，人为地给递归增加限制（剪枝函数？）。 上面这种使用平凡解的优化是通用。 第二种优化（这种优化不具备通用性）：像这道题，有可能是人气超过end后不断地-2，然后得到最优解，那就是要规定最远能到达哪里，最远只能到达2*end的地方。 你可以继续从题目中寻找限制条件，但这道题只需要这两个条件就好了。 limitCoin是一个平凡解。aim是固定参数。 图的宽度优先遍历 给出的依赖关系其实是后序关系，就是这个活动做完后还需要去做什么活动。 这道题准确地来说应该是图的反向遍历。 为图的每一个节点都建一个专属的有序表，map的信息是，key代表这个节点到最后一个节点所需要的天数，value代表的是这个节点到最后一个节点所能获得的钱，这个有序表必须遵循天数增加钱也增加的规律。 从最后一个节点F开始，建立{5,1000}，然后找到它的前置节点，建立相对应的有序表，到达A节点的时候可以发现它有3个后置节点，所以它对应的有序表中就会有3条信息，因为要遵循天数增加钱也增加的规律，所以淘汰掉{12,1040}。最后要将各个节点对应的有序表合并到一个大表中，依旧遵循上面的规律。 通过这张大表可以任意查询在某一个天数内获得的最大收益。 这个查询操作可以通过python中的bisect来查询。 看到子串和子数组的问题就想每个位置结尾会怎么样 按照上面的方法算，左括号count++，右括号count–，在过程中count的最大值就是深度。 给你一个由左括号和右括号组成的字符串，请你找到最长的有效括号子串。 有效的意思是，在这段字符串中任何左括号都有与之配对的右括号。 计算出以这个字符串中的每个字符结尾的情况下，最长的有效括号子串是多长，每个位置都计算出一个值，那答案就在其中。按照这个思路的话，这就变成了一个dp问题。 由于必须是有效括号子串，所以当以左括号结尾是肯定是无效的，所以直接记作0. 要计算i 位置上的最大长度是是多少，先看一下i-1位置上的最大长度是多少，假如这个位置上的答案是4，那就看包括这个位置往前的4个字符的左边p位置是不是左括号（或者不考虑当前位置，在当前位置直接往前推4个位置，看那个位置上的是不是左括号），如果是左括号的话，那i 位置上的至少是6，不是的话就是0. 为什么至少是6呢？因为可能以p-1位置结尾的也有有效子串，而它们是相连的，所以要算上p-1位置的，而且只需要再加上这一段的长度，再往前就不需要考虑，因为如果再往前还有有效子串的话，那p-1位置的长度就会改变，所以不需要考虑，上面考虑是因为我在前一个字符结尾的基础上又添加了一对括号，扩充了，所以需要考虑，而这个是没扩充的，是已经计算完的。 dp[0]肯定等于0，所以直接跳过。 1）假设 i 位置是a，那么往左推一定不能推到a出现的位置； 2）i-1结尾的时候它能推出来的最长无重复子串的位置是i-4，那么推 i 位置的最长无重复子串的位置时肯定不会超过i-4，那么就看i-4更近还是第一种情况的最远位置最近，哪一个更近哪一个就是答案； i-1位置的瓶颈是7，i 位置的瓶颈是i-5位置的 e ，所以它的瓶颈是5，两种情况5更近，所以 i 位置的答案就是5。 当 i 位置的瓶颈大于i-1位置时，此时的答案就是i-1位置的瓶颈+1。 为什么代码里面是求max，因为pre和map的value值代表的是位置，哪一个位置更大不就说明哪一个位置更近。 边境距离问题常考，例子不多，之后去搜一些。 i 和 j 代表的不是位置，而是前缀长度。 dp[i][j]代表的是str1[0i]编辑成str2[0j]的最小代价。 str[0]就说明str的前缀长度为0，是一个空串。 先填写第一列和第一行，由于str1[0]是空串，所以编辑为str2[j]时代价都是插入代价的倍数；因为str2[0]是空串，所以str1[i]变为str2[0]时的代价都是删除代价的倍数。 要从str1[0i-1]变为str2[0j-1]，不管最后一个字符是什么样的都存在以下路径： 第一条路径是将str1[0i-2]编辑成str2[0j-1]然后删去str1[i-1]，这个时候代价就等于dp[i-1][j]+del(删除代价)。 第二条路径是将str1[0i-1]编辑成str2[0j-2]然后加上str2[j-1]，这个时候代价就等于dp[i][j-1]+add(插入代价)。 第三种可能性是将str1[0i-2]编辑成str2[0j-2]然后将str1[i-1]替换成str2[j-1]，这个时候代价会等于dp[i-1][j-1]+replace。 第四种可能性，当str1[i-1]str2[j-1]时，代价会等于dp[i-1][j-1]。 dp的方向是从左往右，从上往下。 先看可能性3和可能性4谁先胜出，然后再和可能性1、可能性2比较。 题目 括号要成对出现。只需用一个变量count从左往右遍历就行，ANS代表至少要添加的括号数。 如果缺右括号的话那直接在最左侧加就行了，所以如果count大于0可以等最后处理，但在这个过程中如果小于0的话需要立即处理（因为这种情况”）（“需要的是两个括号而不是零个），那就是ANS++，count归零。最后答案是ANS值再加上count。 要求去重数字对，所以（0，2）只记录一次。 直接利用HashSet存储上面的数组，然后遍历查询，答案用非递减的方式记录，遍到0的时候找2，3的时候找5…… 两个平均值一样的时候没法进行magic操作，两个平均值不一样的话不能从小的平均值中取数到大的平均值中，所以只能从大的拿数到小的里面。 平均值可能是小数，但你取的数只能是整数。 从左上角开始遍历查找的话复杂度非常大，所以根据这个二维数组的特点，我们从右上角开始查找，假如查找7的话，由于10大于7，那么它这一列就不用考虑了，左移继续判断，到达5时发现5比7小，所以左边肯定都小于7不用考虑，向下查找，一直到9，9大于7，所以左移，找到7。当查找的范围越界时说明该数组中不包含这个数，按照这种方法最多查找（行数+列数）次。 有一个二维数组，每一行数，0肯定在1的左边，返回哪行的“1”最多，如果最多的“1”有多行的话，一起返回，比如下面那个例子，没有最后一行的话，就要返回2、3。 思路和上一题一样，从右上角开始，用list来记录答案。 先用map统计它们出现的次数，然后可以直接用大根堆排序，但这样比较浪费空间，所以可以用小根堆排序，小根堆的大小始终设定为两个，一旦超过就弹出，直到大小变为两个。 扩展：要实现一个结构，这个结构可以接收字符串，用户可以随时调用一个函数，这个函数是用来显式目前的top K的，这个时候就不能使用原办法了，因为代价太大了。 要解决问题就要实现图片里的三个结构，堆位置map： key是字符串，value是这个字符串在堆里的位置，如果不在堆里记作-1。 下面的图中，堆是按次数排序的，堆的大小为3。 判断词频表中的元素能不能进入堆了，要看堆有没有满，没满的话直接放。 D不在堆里面，所以位置标-1。 堆里面元素更新的过程就是先弹出，在插入，然后heapify，这几个方法就是算法那个笔记堆的知识里面的。 heap是小根堆，index代表此时堆的大小，nodeIndexMap是元素在堆里的位置，strNodeMap是词频表。 preIndex代表在堆上的位置，curNode代表这个str是哪个Node。 遍历数组，寻找三种数，奇数，4的倍数的偶数，不是4的倍数的偶数。 使用有序表解决，我觉得使用优先队列也能解决，但没有有序表好。 先按难度从小到大排列，然后根据难度分组，同一难度的只保留钱最多的，然后再判断每个工作是否随着难度的提高钱也会增多，不是的去掉，最后留下来的就是一个难度从小到大，钱不断变多的序列。 里面有用到**floorKey()**，第一次看见它的使用。 业务题，看看就行，不通用。 要将合法字符串转化为int类型的数字时，使用负数接着，就是不管字符串是正是负，转化为int类型刚开始全是负数，因为负数表示的范围比正数大1，如果要表示的是负数的最小值，那负数不越界，但刚开始用正数的话就会越界。 为什么cur’0’-str[i]，因为是用负数接着的，下面是直接加上cur，所以cur得为负的。 判断溢出的时候，第一个条件是判断乘10后会不会溢出，第二个条件是在乘10不会溢出的条件下判断加上cur会不会溢出。 从小到大，从简单到复杂。 coding问题，业务题。 下面的代码不是上面题目的答案，上面题目十下面代码的简单版本的题目。上面题目规定“11”念“一十一”，但下面是根据百位上是否有数字来判断“11”念“十一”还是“一十一”。 先搞定1~9。 因为有个“十”位，所以接下来搞定1~99。 百位 千位 拼“万” 拼“亿” 遍历数组肯定可以求出来，有没有更快的。 一直往左走，求深度。 接下来要关注的是根节点的右子树的最左节点有没有到达最后一层。 （1）如果到达了最后一层，那根节点的左子树肯定是满二叉树，然后接下来就看右树有多少节点，因为右树也是完全二叉树，所以递归就行； （2）如果没有到达最后一层，那右子树肯定是满二叉树，那接下来就看左子树，左子树肯定是完全二叉树，所以递归就行。 相当于有多少种加括号的方式可以得到答案。一个范围尝试的模型。 假设每一个二元运算都是最后结合的。f 函数的意思是从L到R的字符串范围内可以得到desire的方法数。 可以分为4种情况，1）1位置的并运算最后； 2）3位置的亦或最后； 3）5位置的或运算最后； 4）7位置的并运算最后 所以大流程就是枚举这个字符串中的所有逻辑符号，都假设它们是最后结合的。那具体到一个逻辑符号的时候，你后面的流程是什么。 T代表的是True，假设 i 位置是并运算要达到True，那两边都得达到True才行，所以最后的答案是a*b。 要将上述代码转化为动态规划，有3个可变参数，所以分为两种二维表，一张为True表，一张为False表。 先进行初始化，条件是RL，L和R位置上不会是逻辑符号。 主要的难点在利用for循环跳过不需要求的点。看不懂的话就用上面的例子试一下。 动态规划是为递归返回值服务的，所以递归函数不填的东西动态规划都不要去碰。 输出的是1，2，27（每行一个数字） 记住：它是升序字符串，所以没有‘ba’这种的。 实现两个函数，f(N)：长度为N的子序列有多少个；g(char,len)：以char字符开头，长度为len的子序列有多少个。 例子的长度为3，所以长度为1，2的子序列肯定都排在它前面，所以第一步就是先加上长度为1和长度为2的子序列的个数。 第二步，由于这个字符串开头是d，所以以a、b、c开头的字符串都排在它前面，所以就先加上以这3个字符开头长度为3的子序列个数。 接下来是第二个字符，由于第一个字符是’d’，又要求是升序，所以接下来就是要加上以e、f、g、h、i 开头长度为2的子序列个数。 由于第二个字符是’j’，根据上一步的思路，继续加上相对应的子序列个数就能得出答案了。 底部","tags":["算法"]},{"title":"算法","path":"/2025/01/21/算法/","content":"排序亦或运算无进位相加 （1）a ^ 0 a；(2)a ^ a 0；(3)a ^ b b ^ a；(4)a ^ b ^ c a ^ (b ^ c) 一个数组中存在两个出现奇数次的数a和b，其它数的出现次数均为偶数次，如何找出这两个数。 将这个数组全部亦或后得到的数是a ^ b的结果，假设这个结果二进制表达式的第八位为1，则说明a和b第八位上的数不同，那么就可以将这些数分成第八位为0和第八位为1的，两组分别亦或后得到的两个数就是a和b。 上述代码存在错误，应该修改为：(cur rightone) 0。 对24行代码进行解析。 ~：取反，：与运算。 插入排序分成两部分，左边有序，右边无序，将右边无序的元素一个一个地插入有序的左边。 i 和 j 必须不同，排序结果是升序。 二分法无序也可以二分。 （2）t值要更新 （3） 局部最小定义：0位置上的数比1位置的要小，n-1位置上的数比n-2位置上的数要小，i 位置上的数比 i-1和 i+1的要小。 若不懂看视频1、的一小时48分左右。 归并排序分成左右两部分进行排序，左边和右边分别排序完后合并在一起。递归算法。 暴力解很容易。 例子：1，3，4，2，5 转换原理：求小和，1的右边有四个数比1大，所以加4个1，3的右边有两个数比3大，所以加2个3，以此类推，要加1个4，1个2，0个5，小和为16。和右边进行比对，和归并排序中的merge有相似之处，可以改变merge来解决这个问题。 在归并排序的过程中利用merge方法进行小和计算。 1和3：13，所以小和有一个1； 1，3和4：1，34，所以小和加上一个1和一个3； 2和5：25，加上一个2； 1，3，4和2，5：对1进行判断的时候，因为左右两边都是排好序的，所以1小于2时代表右边两个数都比1大，所以要加上2个1，这个可 以根据右边的索引判断要加几个。 为了实现根据索引判断要加几个，必须进行排序。这个方法和归并排序很大的不同在于两数相等时必须先拷贝右组。 小和问题是求右边有多少个数比它大，逆序对问题是求右边有多少个数比它小。 快速排序 问题一： 荷兰国旗问题： 快排1.0：以数组的最后一个数作为标志值，小于这个数的全放在左边，大于这个数的放在右边（从倒数第二个位置开始放），最后将该数组的最后一个数也就是标志值与大于区域的第一个数交换位置，那么这个数的位置就固定下来了。接下来就是左右两个区域分别取该部分的最后一个数作为标志值重复前面的过程。 标志值为5，大于5的区域的第一个数是6，两数交换位置。 快排2.0：相比于上面，这边多划分一个区域就是等于区域，相当于是荷兰国旗问题的思路，原理和1.0差不多，最后将最后一个数也就是标志值和大于区域的第一个数交换，那中间的就全是相同的数了，一次性搞定一部分，比1.0快一点，大于和小于区域按照同样思路做递归。 快排3.0：不是取数组的最后一个数，而是在数组中随机取一个数作为标志值，然后将这个数和数组最右侧的数交换，接下来步骤和上面的一样。 swap是自己写的交换函数。 partition的功能就是返回两个数据，相等的值的左边界和右边界，存储在一个数组中返回，该数组的大小肯定是2。 堆排序基础和移动堆结构：形状是满二叉树，大根堆：每个节点的值都是以它为头结点的整棵树中的最大值，小根堆刚好相反。 优先级队列结构就是堆结构。 原数组为空时不断存入数据如何形成大根堆：一个空数组，heapsize 0，存入一个数据，heapsize++，在存入一个数据时，将该数据和自己的父节点的数据进行比较，若小于父节点则不变，大于父节点就和父节点交换位置，然后和父节点的父节点比较，直到父节点大于该数据或者成为头结点也就是索引等于0时停止。后续继续存入数据则按照该规律进行排序，最后得出的数组就是大根堆。 原本是大根堆，去除最大的数也就是头结点后，如何保持大根堆：去掉头结点后，将数组中的最后一个数调到头结点，heapsize–，相当于最后一个位置不储存数据了，然后头结点的两个子节点取最大值，若最大值大于头结点则交换，否则结束。若有交换，交换后假设该值在头结点的左孩子上，则该孩子节点的两个子节点取最大值并和该节点比较，直到最大值小于该节点的值或者没有孩子后结束。 下面代码可以表示去除任意一个节点，并将最后一个数据调到这个位置后进行的操作。 left + 1 heapSize arr[left + 1] arr[left]这句话是if的条件 用户随意挑选一个数据进行更改如何保持大根堆：先进行heapInsert，再进行heapify。 排序堆排序1.0：假设原始数据是3，5，9，4，6，7，0；先将它变成大根堆，相当于是用户一个一个给你数据，然后开始堆排序，就是跟上面的往上移动一样，先3，后5，一直到0，最后大根堆是9，6，7，3，4，5，0，heapSize7。这个时候取出头结点，将堆的最后一个位置移到头结点，heapSize–，heapSize6说明将最后一个点剥离出去了，头结点此时值为0，heapify，重新变成大根堆。然后再取出头结点，将堆的最后一个移到头结点，heapSize–，重复之前的过程。当heapSize0时停止。 堆排序2.0：用户给原始数据，直接从最后一个开始往前进行heapify将其变为大根堆，这个方法在将数据变为大根堆时时间复杂度更小，但总体时间复杂度不变，不过运行速度会更快一点。 优先队列结构——默认小根堆 假设k6且是小根堆的话，说明最小值一定在前7个数中，因为每个数的移动距离不会超过6，所以将前7个数排序变为小根堆，头结点一定是最小值，将头结点取出，将第八个数放到头结点上，heapify使其重新变为小根堆，取出头结点，按这个规律一直取下去，最后完成排序。 下面是优先队列结构的简单运用： 不传任何东西，默认小根堆进行处理。 输出结果为3，4，4，8，9，10 poll()方法，弹出并移除数据。 当题目只要求输入一个数据再输出一个数据时使用优先队列结构，若有什么复杂的操作或者想要以较小的代价排序的话必须自己手写堆。 大根堆和小根堆配合。 第一个数直接进大根堆。 第三条的意思是（较大size的根堆的大小 - 较小size的根堆的大小）大于等于2，则从较大根堆移动一个数到较小根堆。大根堆较大的话，就是大根堆堆顶弹出进小根堆；小根堆较大的话，就是小根堆的堆顶弹出进大根堆。 偶数个，两数相加除以2；奇数个，两个根堆中的一个。 比较器 o1.id - o2.id 0，第一个参数o1排前面；0时第二个参数o2排前面；=0无所谓前后。 o2.id - o1.id 0，第一个参数o1排前面；0时第二个参数o2排前面；=0无所谓前后。 例子： 如果不提前写比较器的话，也可以选择匿名内部类的方法 Arrays.sort(students,new Comparator() @Override public int compare(Object o1, Object o2) int i1 = (Integer) o1; int i2 = (Integer) o2; return i1 - i2; ) 用于优先序列上： new AComp()是一个实现了Comparator的一个类。 现在输出是从大到小的顺序。 桶排序不基于两数比较的排序。 计数排序在数比较小的时候用，比如计算员工年龄排序，创建一个大小为200的数组，几岁就在索引几++，最后输出排序结果的时候按数组里存储的数输出，比如17的数据时3，就输出三个17. 基数排序假设原始数据是17，13，25，100，72；首先最大是三位数，所以全部数据补成三位数为017，013，025，100，072。 然后创建10个桶，名字分别为0，1，2，~，9。 首先按照个位数将各个数据按照顺序扔到桶里再依次倒出。 然后按照十位数将各个数据按照顺序扔到桶里再依次倒出。 最后按照百位数将各个数据按照顺序扔到桶里再依次倒出。 下面的代码是优化过的，比较抽象，可以打草稿 digit表示最大的值有几个十进制位。 蓝色的代表以10为基底，是不会变的。 总结 一般选择快排，能用快排就用快排，快排虽然空间复杂度高，但实际上它的常数项低，跑得最快。 有空间限制，很容易就超出空间了，就使用堆排。 需要用到稳定性的时候，使用归并。 链表哈希表hashSet，hashMap 有序表 性能比哈希表差一点。 6、7不是哈希表是有序表，图里面写错了。 不是基础类型的必须提供比较器。 链表题该种题目都要分成面试和笔试来做。 其他题 笔试：设计一个栈，将链表存进去，根据先进后出的特性和链表比对。 面试： 快慢指针：两个指针，快指针一次走两步，慢指针一次走一步，当快指针到达最后一个时，慢指针刚好到一半。 初始： 中： 当慢指针来到中点位置的时候，往下遍历，将后面的逆序，3指向空，头尾分别用一个指针记住，然后A和B一起往中间走，一步步比对，若全都一样则为回文数，如果有一个先到空，就停止。 最后： 在返回最终结果true和false之前，将链表恢复，然后输出结果。（其实也可以不用管） 笔试：准备一个Node型的数组，将链表存进去，然后进行排序，排完序后按顺序串起来就可以了。 面试： 六个变量：大于区域的头和尾：sH和sT；等于区域的头和尾：eH和eT；小于区域的头和尾：bH和bT。 记得考虑空指针问题。 若申请额外空间： 第一步：使用哈希表，key对应老节点，value对应新节点，就直接将老结点copy过去就好了。 第二步：利用map的get()方法创建连接方式 不使用哈希表： 先创建克隆结点，将克隆结点直接串在原节点后面，克隆结点指向原结点的下一个结点，先不管rand。 然后一对一对的遍历，根据原结点的rand的next填充克隆结点的rand。 最后更改next，使得新老链表分离出来。 找相交结点 相交就是共用结点的意思，两个结点的内存地址一样。 先思考一个函数如何实现一个可能有环的链表，有环的话返回第一个入环的结点，否则返回空的功能。 创建一个Set用来存储Node结点，遇到一个Node时，先判断Set中是否包含该Node，没有的话就添加进Set，然后继续遍历下一个Node，如果Set中包含了该Node，说明这就是第一个入环的结点。 快慢指针方法： 刚开始快慢指针都在头结点，快指针走两步，慢指针走一步。 如果有环的话，快指针和慢指针肯定会在环中相遇，且不会超过两圈（因为快指针的速度是慢指针的两倍）。 当相遇的时候，快指针回到开头，慢指针不动，接下来两个指针每次分别都只走一步，它俩最后一定会在入环第一个结点相遇。 对于找公共交点的这道题目，给我们两个链表，这两个链表分别调用上面这个函数，就能找到这两个链表各自的第一个入环结点。 先用getLoopNode方法判断是否有环。 loop1和loop2代表第一个链表和第二个链表的第一个入环结点。 （1）若是两个无环链表，两个相交的话，后面的部分肯定是公共部分。 先求各自的end结点和长度。 先判断end1和end2是否相等，若不相等则说明没有相交。如果相等的话，它们是相交部分的最后一个结点，那相交部分的第一个结点怎么找？链表1长度为100，先走20步，然后链表2从头结点出发，跟着走，它俩一定会在第一个相交结点处相遇。（因为相交之后的公共部分长度一样，所以长的链表先走差值部，然后短链表再走，那它们就会在第一个相交结点处相遇） （2）不可能相交 （3）都有环。 第二种情况和无环情况解法是一样的。 区分第一种和第三种：loop1继续往下，loop2不动，若loop1可以和loop2相遇，则是第三种，否则是第一种。若是第一种则无相交，返回null，若是第三种，则返回loop1和loop2都可以。 上面都是方法函数，这道题的主函数如下： 基础提升比如说输入40亿个数，要找出出现次数最多的那个数，要求空间小。可以使用哈希函数算出个个数的哈希码，然后%100，有一百个组，先进行分类，然后选出个数最多的那个组再进行查找，这样用的空间就少了。 去看java中关于哈希函数的内容。 利用两张哈希表来解决，哈希表的操作的时间复杂度都是O(1)，不过是比较大的常数时间。 一表：value,index，二表：index,value，假设输入26个字母 假如删除的时候就直接删除，例如删除C，则两张表上面会出现空区域，那么当删除的数据很多的时候，空区域就会很多，那么随机返回任何一个key的时候可能就需要尝试很多次，所以不能直接删除，要将删除后的空洞填上。办法就是删除数据后拿最后一条记录补上这个空洞，然后删除最后一条记录，size–。 布隆过滤器只有add、check功能，要求占用内存小。 一般是用来做黑名单系统的，比如一个浏览器，将一部分假如黑名单中，那么这部分就不能被访问到，使用hashset记录的话，占用空间过大。可以使用bit类型的数组来记录，这样占用的空间就很少。 使用int数组来表示bit数组，一个int占8B，32个bit，所以按理来说arr[0]可以表示031的状态，arr[1]就可以表示3263的状态。 numIndex是在int数组中的索引，bitIndex代表的是在arr[numIndex]的32位中是哪一位。 上面是思路，布隆过滤器就是，比如一个字符串，通过n个哈希函数分别算出值然后%m，根据最后的结果将值变为1，查询一个字符串是不是在里面的时候，也是利用这些哈希函数进行相同的操作最后取出n个值，这n个值中有一个值不是1那它就不在里面。 布隆过滤器会存在错误，就是会将不应该进入黑名单中的人拉入黑名单，这是因为m有限，可能会发生冲突，然后恰好全都为1。 题目 设计一个infect函数，作用就是碰到1将那一片1都变成2，几次infect就是几个岛。 N:宽，M:长，res:岛的数量。 字典序排列算法从小到大寻找下一个字典序排列： 从右向左找到第一个 i，使得 P[i] P[i+1]。如果找不到这样的 i，说明当前排列已经是最大的，下一个排列就是最小的排列（或者说，没有更大的排列了）。 从右向左找到第一个 j，使得 P[j] P[i]。 交换 P[i] 和 P[j]。 将 P[i+1] 到末尾的元素反转。 对于上面这道题，它其实就是简单的排列组合，不要想复杂了，比如1 2 3 4 5 6 7 8 9 10，最大的数是10 9 8 7 6 5 4 3 2 1，而不是9开头的。 def next_permutation(arr): n = len(arr) k = -1 for i in range(n - 2, -1, -1): if int(arr[i]) int(arr[i + 1]): k = i break # 下面这一步的含义是循环，就是当当前的数为最大数时，下一个需要出现的数就是最小数，在这题是不会出现这种情况的，不过可以了解一下 if k == -1: arr.sort(key=lambda x: int(x)) return arr l = -1 for i in range(n - 1, k, -1): if int(arr[k]) int(arr[i]): l = i break arr[k], arr[l] = arr[l], arr[k] arr[k + 1:] = arr[k + 1:][::-1] return arr n = int(input()) m = int(input()) initial = input().split() for _ in range(m): initial = next_permutation(initial) print( .join(initial)) 二叉树 和c语言中的不大一样，因为java中没有指针这个定义。 把数据结构看一遍。 使用递归和非递归方法实现二叉树的遍历， 栈先序遍历： Stack类继承自Vector类，上面的push(E e)是Stack类的专门方法，用于将元素压入栈顶，add(E e)是Vector的方法，在Stack中没有重写，不过可以达到和push相同的效果。 后序遍历： 按照头右左的顺序将结点入栈，然后将弹出的结点压入另一个栈中，最后输出这个栈，结果就是左右头。 中序遍历： 二叉树相关概念及其实现判断 1、搜索二叉树就是左子树的值小于根的值，右子树的值大于根的值。 通过改写中序遍历来解决 2、 这边解题的思路是利用宽度遍历来判断。 3、较麻烦的做法就是先求最大深度和总结点数，然后根据这俩之间的数学关系判断。 二叉树解题套路在可以向左子树要信息，可以向右子树要信息的情况下怎么解决题目。 这个套路可以解决一切树型DP（动态规划）的问题。 以第四题为例子。 4、 先列出可能性：一棵树是平衡二叉树说明它的左右子树都是平衡二叉树且第三个条件。 可能性固定后，整理需要左右子树给你提供什么样的信息。 从上面可以看出左右子树所需要的信息是一样，都是是否是平衡二叉树以及高度是多少，递归套路。 在写的时候总是默认左子树给你一个信息，然后右子树给你一个信息，接着继续写如何利用这两个信息（返回的这两个信息包含了子树需要返回给你的全部信息，把它们当作都是有实值的）。最后一步肯定是返回你需要的信息，那么获得左右子树提供的信息后要写的就是如何利用这两个信息来得到你需要返回的信息。 接下来以这个思路解决一下第一题。 可能性：左子树是搜索二叉树，右子树是搜索二叉树，左子树的最大值小于该点的值，右子树的最小值大于该点的值。 将这个可能性弄成一个全集。 提供信息：左子树要提供是否是二叉树，以及它的最大值；右子树要提供是否是二叉树，以及它的最小值。 现在要提供的信息不一样，但递归套路要求对每个结点的要求是一样的才叫递归，所以返回这棵树是否是二叉树以及它的最大最小值。 第三题 while o2 set1意思是接下来就是不断寻找o2的父节点并对比是否在set1中，如果存在那就是最低公共祖先。 上面的方法好理解但时间和空间复杂度较高，下面的代码更好但较难理解。 这道题目会有以下几种情况（LCA代表最低公共祖先）： 第二种情况： 1）x有右树的时候，x的后继节点一定是右树的最左结点； 2） x不断地往上找，当找到一个结点是它父亲的左孩子时，这个结点的父亲就是x的后继节点，因为在中序遍历时，x一定是左树上最后一个打印的结点。 但是在中序遍历中肯定会有一个结点它没有后继节点，就是在中序遍历时最后一个打印的结点，所以返回null。 就是null用特殊字符表示，一个结点的结束用下划线就行。先序，中序，后序道理都一样。 树形dp套路（补充） d到c 的距离为4。 x是头结点。上图的最大距离在左树且不经过x。 很多题目都是根据头结点参与不参与来分类的。 由上面的分类可以知道需要子树提供什么信息：子树的高和子树的最大距离。 二叉树的递归套路是建立在如果我可以向左树和右树获取信息的情况下，我该如何求解我的答案有哪些可能性。 图表示模板 表示图的方法有很多，背好自己平时表达图的方式的算法模板，将遇到的新的图的表达方式转化为自己平时用的表达方式，再代入算法模板。 Node是原本的点，包含这个点的所有消息，Integer存储的是点所对应的编号，nodes就是点集合，edges是边集合。 value：自己的数据项（value前面的数据类型是具体情况具体分析）；in：入度；out：出度；nexts：代表由这个点发散出去的边所连接的点，它的直接邻居；edges：属于这个点的边有哪些。 weight：权值 算法可以去看数据结构中图的相关算法。 应该是深度优先遍历。 从边的角度生成最小生成树。 最好使用并查集来实现，效率高，下面算法没有使用并查集，感觉不如数据结构里实现得简单。 利用上面得方法根据原理就可以得出具体实现了。 下面的实现是并查集方法。 从点的角度思考生成最小生成树。 上面的代码会将一条边重复放进优先队列中去，但不会影响结果，因为这条边所连接的点已经放进Set中了，会被排掉，只会增加常数处理时间。 for循环是为了解决出现森林的情况。若已经说明不会出现森林，则不需要for循环。 寻找最短路径。 getMinDistanceAndUnselectedNode(distanceMap,selectedNodes)代表的是要从distanceMap中挑选一个最小的记录，但这个最小记录不能是已经选过的，也就是这条记录不能在selectedNodes里。 N皇后问题 按行来深度优先遍历。 前缀树 前缀树的结点定义： pass代表经过这个点几次，end代表这个点作为结尾几次，前缀树以一个空结点开始。 上面只准备了26条路，如果路径数量很多的话，可以用哈希表来表示，key代表有哪条路，value就代表通过这条路走向的结点。如果想要路径有序，那就使用有序表(TreeMap)。 建立一个前缀树： root代表根结点，根结点的p值代表有多少个字符串。或者理解成由多少个字符串以空作为前缀，而任何字符串都以空作为前缀。而如果加入空串的话，根结点的pass++，end++。 删除功能： 在java中，只要让头结点为空，使得后面的数据无法被找到，那么jdk会自动帮你释放空间。 查询功能： 贪心算法局部-整体 贪心算法的题目代码一般都不长。 ![屏幕截图 2025-02-06 202653](..sourceimgs${fiilname}屏幕截图 2025-02-06 202653.png) 哪个会议结束时间早就先安排谁。 堆和排序是最经常使用的技巧。 哈夫曼树，easy。 peek() 用于查看队列头部元素，不会移除。 如果队列为空，peek() 返回 null。 poll() 用于取出队列头部元素，并将其从队列中移除。 暴力递归 数据结构书里递归那部分有讲过。 将 i 个目标从from移动到to上面去。 每个字符都有两种可能，要或者不要。 最后一个是空。 printtList，打印当前列表。自己补充printList和copyList方法。 第一个：例：abc-abc,acb,bac,bca,cab,cba 解决第二个问题，排列里要求不重复，就是将上述代码中的注释部分去掉，变成： visit代表某一个字符试没试过。就比如说abca，当在试的时候，交换第一个位置，第一个a使得visit[0]true，那么当来到最后一个a的时候，由于visit[0]true，所以就不会将它与第一个位置互换。 如果不使用这个，直接对result进行去重，比如说变成set类型，也可以，但时间会比上面的代码长，因为上面的代码遇到重复字符就不试了，而set则是将字符存进result里才会去重。时间复杂度没有变化，但常数时间变了。 f 代表先手拿牌，s 代表后手拿牌。为什么s 返回的是最小值，因为当你拿完牌后轮对手抓，对手一定会给你留接下来所有策略里值最小的，所以就返回最小值；当对手拿完牌后，对于剩下的牌你是先手，所以min里面是先手。 为什么win1有一个后手拿牌：因为当你后手的时候，一定是别人取走了两个先手里最好的那个先手，所以你只能取两个先手中较差的那个，后手拿牌不一定输。 竟然后手已经比先手差了为什么还要比较，而不是win1直接返回先手。当数量为偶数个的时候，先手比必赢，但数量为奇数个的时候就不一定了，比如：1，3，1。 依旧是从左往右尝试。 分成这俩部分，前面是固定下来的。当i 位置为0时，它不能与任何的匹配，那就返回0；当i 不为0时，1）i 固定，i+1及后面的再判断；2）当i 上的数字是3~9，只能做一个决定就是i 固定；如果是1或2，那要么i 固定，当i 为1时，要么i 固定或者和i+1当作一个整体，当i 为2时，要么i 固定或者当 i+1 位置上的数小于7时可以一起看作一个整体。 从左往右尝试，i 要或者i 不要。 并查集相当于一个图状结构，查找函数就是查找两个元素的根节点是不是同一个元素，是的话就在同一个集合，否则相反。 两个函数： 1、boolean 类型的，查找两个元素是不是在同一个类型； 2、void 类型，将两个集合合并。元素少的集合挂在元素多的哪个集合下面。 下面的并查集相关算法适合比较复杂的元素，而比较简单的元素适合可以数组来表示，这个可以去看天梯赛题目的那道题，关于城市沦陷的题目。 elementMap 相当于是自己一个元素对应这个元素自己的集合，就是每个元素当都建立一个自己的集合。 fatherMap 就是每个元素的集合的父节点是谁。 sizeMap 储存的是每个集合里面有多少个元素。 这边的findHead方法最后会将这条路径上的所有结点都直接指向代表节点。 带权并查集注意值的变化，在Find函数里面，要注意在更新父节点的时候也要更新权值。 输入： 5 3 3 1 5 15 4 5 9 2 3 5 1 5 1 3 1 2 输出： 15 6 UNKNOWN import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.StreamTokenizer; //带权并查集 public class Main public static int[] father; //记录根节点 public static long[] value; //value[i]代表i到其根节点的路径长度 public static StreamTokenizer st=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); public static void main(String[] args) throws IOException int N=nextInt(); //数组长度 int M=nextInt(); //已知的部分和数量 int Q=nextInt(); //询问的部分和数量 father=new int[N+1]; value=new long[N+1]; init(N); for(int i=0;iM;i++) int left=nextInt(); int right=nextInt(); long s=nextLong(); left--; union(left,right,s); for(int i=0;iQ;i++) int left=nextInt(); int right=nextInt(); left--; int leftFather=find(left); int rightFather=find(right); if(leftFather==rightFather) System.out.println(value[left]-value[right]); else System.out.println(UNKNOWN); public static void init(int n) for(int i=0;i=n;i++) father[i]=i; //带权并查集得到查找操作 public static int find(int x) if(father[x]==x) return x; else int tmp=father[x]; father[x]=find(father[x]); value[x]+=value[tmp]; return father[x]; //带权并查集合并操作 public static void union(int left,int right,long s) int leftFather = find(left); int rightFather= find(right); if(leftFather!=rightFather) //让小根节点指向大根节点 int min=Math.min(leftFather,rightFather); int max=Math.max(leftFather,rightFather); father[min]=max; value[min]=Math.abs(-value[left]+value[right]+s); public static int nextInt() throws IOException st.nextToken(); return (int)st.nval; public static long nextLong() throws IOException st.nextToken(); return (long) st.nval; KMP算法我记得数据结构里有这个，可以去看一下。 i1是在str1中比对的位置，i2是在str2中比对的位置。 求解next[]数组（next值的含义是从头开始的字符串和i 位置的前缀一样的最大字符个数）： 求i 位置的next值为多少，那就看i-1位置的next值为多少，假设为n，接下来就看str2[n]是否等于str2[i -1]，如果等于的话，那么next[i]n+1；如果不相等的话： 因为next[i-1]8，所以接下来跳转到str2[next[8]]，看它是否和i-1位置的相等，还不相等的话，根据上图跳转到str2[next[3]]，看是否相等，不相等的话因为已经到头了，所以next[i]0。如果哪一个等于的话，那next[i]那个位置的next值加一。 cn是和i-1的字符比对的索引。 Manacher算法 扩充原字符串：在原字符串的两侧和每个字符的中间都添加一个特殊字符（不要求是原字符串中没有出现的）。 然后接下来在扩充字符串上面寻找最大回文子串的长度，就是以一个字符为中心向左右两边扩充比对，最后每个字符都可以得到以它为中心的回文子串的长度，最后将这个长度 2 得到的答案都是原字符串的回文子串的长度之一。这个方法不会漏掉原字符串中回文子串为偶数个时的答案。 R是回文子串的最大右边界，R只会增大，初始值为-1； C是记录最大右边界时那个回文子串的中心索引。 接下来优化寻找最大回文子串的过程： 1）当作为中心的索引超过R时，没有任何优化，就直接往两边扩寻找回文子串，记得更新R和C； 2）来到的点在最大回文右边界也就是R中时， i’ 是i 关于C的对称点，L是以C为中心的回文区域的左边界。 回文半径（该点的最大回文子串的长度2），回文区域（该点的回文子串索引区域） 2）1、i’ 点的回文区域在[L,R]（没有压线情况）中时，i 点的回文半径就等于i’ 点的回文半径。 下面举例所用的字符串自己在脑海中加上特殊字符。 2）2、i’ 的回文区域有一部分已经在[L,R]外面了，i 的回文区域就是[R’,R]，R’是R关于i 的对称点，L’是L关于i’ 的对称点。 2）3、压线：i’的回文区域与L压线，这种情况有一部分是你不需要验证的，从R+1位置开始继续比对。 循环中第一次求的pArr[i]是至少不用验证的区域半径。 max-1就是原字符串中最大回文字符串的长度，不用想为什么，证明出来的。 这个方法不仅可以解决回文子串的问题，回文半径数组的信息可以帮你解决很多回文问题。 滑动窗口 窗口：L和R是窗口的左右边界，刚开始的时候都在最左边，只能往右边移动，L不能超过R。 创建一个双端队列，里面存储的是索引，里面是按大小排序的，头是最大值，尾是最小值。 R移动：开始的时候R向右移动，依次存进3、2，接下来要存进4，因为这个双端队列的特殊性，4要排在头不能排在比它小的数后面，所以要依次弹出2、3，弹出的数不去找回，然后存进4。要严格保证单调性 L移动：L向右移动时，要把L前面的数弹出队列，如下面的例子，L前面的索引是0，那就看队列的头存储的索引是不是小于等于0，是的话删除，检查下一个头，不是的话就不用弹出了。 窗口存储的是在依次过期的情况下成为最大值的可能性，当你要存进去一个比队列的部分数要大的值时，说明这些值不可能成为最大值了，所以弹出。 下面的例子，原本队列中有存储5，当你再存进去一个5时，要把前面的那个5弹出去，因为新加进去的5比前面那个5晚过期，前面那个5再也没机会成为最大值了，留一个5就够了。 上面的方法复杂度为O(N)。 上面讲得窗口时R和L随时前进任意值的情况，而这道题要求的是前进固定的值，更加简单。 最小值同理，和上面的反过来。 下面的是针对这道题实现的代码，作用是形成一个窗口。 单调栈 下面讲得是，想要知道一个数组中的每个数，左边离它最近比它大的和右边离它最近比它大的数分别是谁。 0-5：索引0上的5。栈中依旧只放下标。 接下来要向栈中放入6，不能改变栈的单调性，所以要弹出数据。弹出数据的话，那么关于这个数的相关信息就开始生成了。 首先弹出2，左边离它最近比它大的数就是它下面压着的数，右边离它最近比它大的数就是当前要存进栈中的数据。 假如没有那个7（数，下面讲的都是索引），那么栈中最后会剩下3个数，进入清算阶段。依次弹出栈中的数据，例如，先弹出6，左边离它最近比它大的数是它下面压着的5，由于此时没有新入栈的，所以右边离它最近比它大的数就无。栈底的3，都是无。 时间复杂度O(N)。 这道题的数组是正数数组。 假设当前子数组必须包含当前数，且当前数必须是子数组中的最小值。 步骤：1、以5为最小值，A最大的是5本身为1个数组； ​ 2、以3为最小值，此时有两个子数组[3]和[5,3]，A最大的是[5,3]； ​ 3、以1为最小值，最大的是整个数组…… ​ 依次这样下去 为什么说这道题是单调栈呢：因为每个数，它最左边离它最近比它小的数是它不能扩的位置，最右边离它最近比它小的数是它不能扩的位置，这就是单调栈的原理。 5，3，2，1，6，7，8，4 小-大 进0 0；进1，-0（-1，1） 1；进2，-1(-1,2) 2; 进3，-2(-1,3) 3；进4，5，6 3，4，5，6；进7，-6(5,7)，-5(4,7)，-4(3,7) 3，7；清算：-7(3,8)，-3(-1,8) 大数据题目（资源限制类题目） 范围内搜索（位图） 1）布隆过滤器，也就是利用整型数组来存储数据，每一位代表一个数，一个int可以代表32个数。这个大概需要500多MB 进阶题目： 2）假如要求3KB呢。先将3KB变成整型数组，算下需要多少个int，那就是30004750（4是一个int的大小），然后算2的多少次方最接近750，是2的9次方也就是512。由于需要算的范围是2的31次方减1，这个刚好可以被512整除，因为（2的32次方-1）有2的32次方个数2的9次方 可以整除，就是刚好可以被划分成大小相等的512份，每份的数为8388608个。接下来，就是以这个为划分，arr[0]代表08388608，arr[1]代表8388608 ，将每个数除以8388608得到索引，然后arr[索引]++，全部遍历完后找到arr[]中没有达到8388608的数组，在它代表的范围中继续遍历。就是说有一个数组没有到达8388608，那么就在这个数组代表的范围上继续分成512份。然后继续遍历这40亿个数，不在这个范围上的就不要了，在这个范围上的就是这512个区间细分，继续寻找没有达标的那一个数组。然后按上面的方法继续寻找，随着范围越来越小，最后就会锁定没有出现的数。 3）假如要求1KB，那就10004，找最接近这个数的2的次方。然后按第二种方法来寻找。 4）只能申请有限几个变量。先将些数据二分，如果满的话，那两边的数量应该都是2的31次方除以2，找到没有满的那一边继续二分，最后就可以找到这个数了。 普通： 1）利用哈希函数做分流。 2）位图的升级：用两位来表示一个数的状态。 补充：范围查找 因为要寻找中位数，那从arr[0]加到arr[n]，当和等于20亿的时候，就找到中位数所在的范围了。 假如你加到499是18亿，加上500是23亿，超过了20亿，那么接下来就是在arr[500]上寻找第2亿个数就行了，将大块变成小块按前面的范围搜索方法继续查找，最后就可以找出来了。 二维堆 普通问题：利用布隆过滤器或者算URL的哈希码来解决。 补充：没听懂。但讲得方法是将原本的数据分成一个个小文件，利用大根堆给每个小文件的词汇搜索量进行排序，然后再建立一个大堆，将每个堆的第一个扔进大堆中，然后选大堆中的第一个弹出，找到这个元素原本是哪个堆的，将那个堆中的这个元素弹出，然后再将这个堆的第一个元素扔进大堆中进行排序，周而复始直到数量达标。由于是堆，所以调整代价低。 这种方法叫作二维堆，是堆上堆的结构。 暴力递归-动态规划整体脉络是要找尝试的方法。 基本优化：优化后时间复杂度会降低 上面的下面用例子来解释。 题目：有一个机器人在1~N的格子上移动，每次只能移动到附近的格子，不能超过1或者N，题目给出K步，和开始的位置S，结束的位置E，问经过K步移动到E共有几种方法。 接下来要改进这个方法 通过这张图可以发现f(2,2)的值跟它前面的情况没有关系，之前的决定不影响f(2,2)的结果，这样的情况就可以进行忆化搜索改进（不用考虑位置依赖关系），就是建立一个缓存存储各情况的最后结果，但碰到相同的情况时可以直接得到值。 上面代码应该有问题，f2里面调用的函数应该不是f1而是f2。 接下来进行严格表结构改进（考虑位置依赖）。 先画一张二维表（cur为横轴，rest为竖轴），根据的是f1函数。这张二维表就是f1的所有可能情况。 上述S2,E4,K4。 由walkWays1得知我们需要的是4，2位置的值，由f1函数的basecase可以得知(0,4)位置的值为1，其它都为0. 不可能到达0列，所以全为叉。 由f1的第二种和第三种情况可以知道1列的值依赖于它的右上角，就是等于右上角的值，而5列的值依赖于它的左上角。 最后一种情况，由f1可知，它的值它的右上角加上左上角的值。 所以根据上述规律可以得出(4,2)位置的值。 下一题 一个数组，里面的都是每个硬币的面值，要找达到目标值所需的最少硬币数。 忆化搜索改进： dp数组代表的是递归方法的所有可能性，-1代表无效解，0是一个答案，那就用-2来代表还没算过。 严格表结构改进： 根据初级算法来画这个表。 根据这个表先设置初始值。 先这样子，中间空白位置还要填充。 上面的意思是，现在位置在(5,2)已经拿了5块钱，现在在索引2的位置，如果要拿5块钱的话，接下来就会到达(0,3)位置，不拿的话就会处于(5,3)位置。 从这个可以得知，位于中间的位置依赖的是它的左下方或者下方的位置，所以填的位置应该是从左往右，每个格子都依赖它的左下角，整体从下往上，这是计算动态规划表格子的顺序。 每一个格子的逻辑和刚开始的那个初级递归函数是一样的，所以对于每个格子的处理可以将那个递归函数直接拷贝过来再进行一些处理就行。由于处理顺序是从下往上的，所以在计算这个格子的值时可以直接去下面那一行的值，将递归调用的过程变成动态规划表取值的过程，拷贝过去后注意边界和越界条件。 完整代码为： 变成严格表位置依赖的方法： 1、分析可变参数的变化范围，一个参数一维表，两个参数二维表，三个参数三维表； 2、标出你要计算的终止位置； 3、标出不要计算直接出答案的位置； 4、推普遍的位置是如何依赖其它位置的； 5、推出严格表是从哪些格子推到哪些格子，最终来到终止位置。 顺序定了后，具体怎么求把递归所求的东西拷贝过去，递归改动态规划表求值的过程就结束了。 题目 f 代表先手拿牌，s 代表后手拿牌。 画出初始二维表 这两个函数是相互套的，要算普遍位置的位置依赖的话就需要同时用到两张表。 f 的对角线可以帮助s 求1的那条对角线，s 的对角线可以帮助f 求1的那条对角线，这样互相求就可以得到最后答案了。看不懂就琢磨原函数。 题目是：给你一个正数数组，数组中没有重复值，假如这个数组中的数代表的是货币面值，每个货币有任意张，给你一个目标值，问组成这个目标值的方法数是多少。 接下里画二维表 画位置依赖，这个举例用的是一块钱的 这个是5块的 状态DP(哈密顿路径) public class Main static boolean[][] gragh; public static void main(String[] args) solve(); // System.out.println(881012367360); public static void solve() gragh = new boolean[22][22]; for (int i = 1; i = 21; i++) for (int j = 1; j = 21; j++) if (gcd(i, j) == 1) gragh[i][j] = true; int tot = 1 22; long[][] dp = new long[tot][22]; dp[2][1] = 1;//从 1 出发、只访问了 1，最后停在 1，方案数是 1 //状态转移部分 for (int S = 2; S = tot - 2; S++) //枚举所有可能的访问状态 S，S 是一个整数，二进制表示哪些点被访问过。 for (int i = 2; i = 21; i++) //从第二个点开始算，因为第一个点已经访问了， // 这个代表的是j-i的路线数=到达i的路线总数，而我们从1出发，所以算的话从2开始 if (((S i) 1) == 1) //枚举状态 S 的倒数第二个点（上一步是哪个点 j 到了 i） for (int j = 1; j = 21; j++) if (gragh[i][j] (((S ^ (1 i)) j) 1) == 1) dp[S][i] += dp[S ^ (1 i)][j]; long ans = 0; for (int i = 2; i = 21; i++) ans += dp[tot - 2][i]; System.out.println(ans); public static int gcd(int num1, int num2) if (num2 == 0) return num1; else return gcd(num2, num1 % num2); 这段代码是一个 状态压缩动态规划（DP） 的实现，用于统计从节点 1 出发，经过所有 21 个互不相同、两两互质的节点的一种路径总数（即在互质图中求哈密顿路径数量）。","tags":["算法"]},{"title":"寒假字节青训营","path":"/2025/01/15/寒假字节青训营/","content":"SQL Optimizer解析optimizer是优化器。 大数据体系与SQL处理流程 Parser Analyser和Logical Plan 算子只是操作说明，没有具体的实现。 left-deep tree：每个JOIN的右边必须是scan（就是读取一张表）。 查询优化 Physical Plan和Executor Plan Fragment只包含了完整执行计划的一部分，完整执行计划拆分成多个Plan Fragment。 拆分执行计划后，每个节点之间靠Shuffle算子来连接。（后面会介绍） 每个节点会增加一个Executor，似乎是提升运行速度。 常见优化查询分类 第一种：按照遍历树的顺序 第二种：根据优化的方法 RBO根据规则优化，重写查询。 RBO R是一个表，p1,p2,p3……pn是条件 优化规则 列裁剪（尽可能减少数据）：从上往下扫描，找出这个执行计划中需要的列（感觉就是元素），一直到最后的SCAN，就是只读取需要的列，其他的不要，减少IO交换。 WHERE里面的那些表达式就是谓词。 将谓词尽可能地往前推和往下推，尽早地过滤掉一些不必要的数据。 利用一些表达式的等价关系和过滤条件，可以推导出新的过滤条件。 16分钟，没听懂。 在运行的时候，从右边获取新的条件运用到左边进行读取。 CBO概念： 统计信息： 原始表统计信息可以SCAN出来，中间算子的统计信息需要进行推导，所以叫作推导统计信息。 统计信息的收集方式： 第一种在执行时如果遇到数据更新啥的，会导致速度较慢；第二种因为是手动执行的，所以收集到的数据可能会比较旧，因为需要手动执行后数据才会更新。 统计信息推导原则： Filter Selectivity，选择率 动态规划方法就是将寻找整体最优解问题分成寻找局部最优解问题，然后不断地通过局部的最优解得到全局的最优解。 流批OLAP一体的Flink引擎介绍Apache Flink概述诞生背景 优势Flink是流式计算的一个框架。 开源生态 Flink整体架构Flink分层架构 不管是SQL描述还是DataStream还是pfFlink描述，在执行引擎层都会转化为一个统一的抽象的DAG图，它是一个逻辑的表达方式。 状态存储层：State Backend；然后上面的三层都是执行引擎层。 Flink总体架构 DataFlowGraph就是DAG的一个图。 代码全部都是写在Program code那边，不管是java还是python 什么的，然后经过一些处理转化为DataFlow的一个graph，就是DAG的一张图。Client端会将用户数据处理逻辑转化为DAG的一张图，然后Client端会将这张图提交给JM。JM会将它简化为一个具体的物理执行图，并且JM根据物理执行图对应的任务将对应的Task调用到TM中。 JobMaster是申请资源(slot)的。 Client端提交作业，Dispatcher拉几个JobMaster，JobMaster向ResourceManager申请资源，上图中两个TM向ResourceManager申请注册，注册完毕后代表此时资源中有两个TM可以调用，那JM如果申请调用两个TM的话就可以调用了。 示例 第一步是弄一个环境变量，要从哪里读入数据，addSource里面填的是地址，要从哪里读。 map就是一个一对一的解析处理，这边处理的是一行数据。一行语句中是有空格的，而这个parse语句就可以根据这个空格把这条语句拆开，这边就是拆成了一个Event的格式。 keyBy是将想同的数据弄到一块，将数据分发到Task上，apply是对数据做什么处理。 最后是将数据写到某个地方。 为什么map到keyBy会有那么多线，因为map处理后的数据会在keyBy中处理根据它处理的哈希值进行分配，所以map处理的数据可能会到keyBy1也有可能会到keyBy2。 这是逻辑执行图-可以执行并发的一个执行图。 source也叫operator或者task。 可以将source和map嵌在一起执行，因为不用经过keyBy分配，所以source读完一条数据后紧接着就可以调用map进行处理，可以在同一个线程中进行。什么算子可以嵌在一起是有判断条件的，可以去官网查看。 每个TM里面可以有多少个slot是用户自己定义的，每个slot在TM里面都是有一个单独的线程的。 Flink如何做到流批一体化背景 流批一体的Scheduler层 LAZY等上游资源处理完之后可以用上游处理完的资源去处理下游。 12个task一起调度，不是16个。 A有两个并发，B有两个，C有四个，D有四个，B的要平均传输到两个C中，C要传输到4个D中。 BLOCKING：A产生的数据不会立马传给B，数据不是实时传输的，中间需要先落盘，就是存到磁盘中，这样子在A1执行完后B1可以从磁盘中读取数据，这样子A1可以先执行，执行完后释放资源，然后执行B1。 PLIPELINED：A产生的数据直接传给B，中间不落盘，直接走到内存，就是A1的数据可能先存到内存中，然后发给B1后内存就释放掉了。最后还是需要12个task的资源，这个作业才能整体运行起来。 流批一体的Shuffle Service层 涉及到上下游的数据交换就是一个shuffle。 流作业中如果task销毁了，那么shuffle也没了，而批的不会。 Flink架构优化流批OLAP业务场景概述 Flink如何支持OLAP场景需要有一定基础，建议之后再看。"},{"path":"/2025/01/14/青训营/","content":"1、凯阳 2、 3、结营证书获取 4、大项目 （1）简易流计算系统设计 参考看3 （2）简易分布式爬虫系统实现"},{"path":"/2025/01/07/蓝桥/","content":"1、刷历年真题 2、 学习路线，蓝桥官网上有 3、基础做对70%，一等奖水平 4、 后面数字代表难度，A组那边的都是比较难的。 5、计算题概率低，时间要放在基础上。 6、 7、"},{"title":"数据清洗","path":"/2024/10/08/数据清洗/","content":"什么是数据清洗 数据清洗就是将“脏数据”变为“干净的数据”。 清洗流程： 数据的读写-数据的探索与描述-数据简单处理-（重复值的处理-缺失值的处理-异常值的处理-文本字符串的处理-时间格式序列的处理）（后面这五个不是一定要按照这个顺序） 环境搭建 markdown形式，写笔记就要遵循markdown的要求，不然不能实现。 如果你在运行 Jupyter Notebook 的过程中重启或中断了内核，所有的导入和变量都会被清空。此时你需要重新运行导入语句。 numpy模块创建数组array()可以将numpy当作一维或多维的数组，重在于数值运算，多用于大型、多维数组上执行的数值运算。 Object代表的是数据源；dtype代表的是某种数据类型，代表的是数据源的数据的类型，如果不写的话，那数据源的数据的类型就默认为它传入是什么类型就是什么类型。 想要打印某个变量的值不需要写print，直接写变量名就好了。 创建数组用的是创建列表的语法，但是因为是数组，所以元素类型是相同的，不能像列表那样可以存放不同的数据类型。 优先级：字符串浮点型整数 frombuffer()，可转化字符串numpy.frombuffer 用于实现动态数组。 numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。 numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0) 注意：buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。 buffer\t可以是任意对象，会以流的形式读入。 dtype\t返回数组的数据类型，可选 count\t读取的数据数量，默认为-1，读取所有数据。 offset\t读取的起始位置，默认为0。 dtype=S1 表示固定长度的字符串，其中 S1 代表每个元素是 1 字节的字符串（即单个字符）。 S1 → 每个元素是 1 字节（1 个字符），Sx → 其中 x 是字符串的最大长度 empty() 存储图片 plt.read(7.jpg) 读取图片数据后会将数据存储在一个numpy数组中，单引号里面填写图片路径。 import matplotlib.pyplot as plt img_arr = plt.imread(./7.jpg) #数组中装载的就是图片内容 plt.imshow(img_arr) #将numpy数组进行可视化展示 这个图片展示单从内容上讲，不如前面那个方法。 img_arr = img_arr - 100 #数组名减去一个数代表这个数组里的全部数据都减去那个数 zero(),ones(),linspace(),arange(),random系列 以上几个方法都是创建数组的。 zero()代表初始数据为0，ones()代表初始数据为1；不是linespace，是linspace。 numpy.zeros(shape, dtype = float, order = C) shape\t数组形状 dtype\t数据类型，可选，默认为浮点数 order\tC 用于 C 的行数组，或者 F 用于 FORTRAN 的列数组 np.zeros(shape = (3,4)) # shape代表的是要创建的数组大小，(3,4)就是三行四列 numpy.ones(shape, dtype = None, order = C)默认为浮点数 “size”不一定要写。 np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) start\t序列的起始值 stop\t序列的终止值，如果endpoint为true，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 endpoint\t该值为 true 时，数列中包含stop值，反之不包含，默认是True。 retstep\t如果为 True 时，生成的数组中会显示间距，反之不显示。 dtype\tndarray 的数据类型 np.linspace(start, stop, num) 的作用是生成一个从 start 到 stop（包括 start 和 stop）的等差数列，包含 num 个元素。np.linspace(0, 100, num=20) 生成的是一个等差数列，从 0 到 100 之间均匀分布 20 个点，包括起点 0 和终点 100。在生成等差数列时，我们需要确定每两个相邻数之间的间隔。希望生成 20 个数，但实际上这个数列可以理解为有 19 个间隔，因为 20 个数之间只有 19 个间隔。间隔长度为(100 - 0) (20 - 1) ≈ 5.26315789。 np.arange(10,50,step)，step，步长。numpy.arange(start, stop, step, dtype) np.random.randint(start,end,size)，产生一个size大小的DataFrame，元素是start到end的随机数。 np.random.random(size)，生成的是size大小范围0-1的DataFrame，可以指定索引。 logspace()np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None) base 参数意思是取对数的时候 log 的下标。 start\t序列的起始值为：base ** start stop\t序列的终止值为：base ** stop。如果endpoint为true，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 endpoint\t该值为 true 时，数列中中包含stop值，反之不包含，默认是True。 base\t对数 log 的底数。 dtype\tndarray 的数据类型 numpy数组的常用属性shape,ndim,size,dtype 数组名.shape返回的是数组的形状。 数组名.ndim返回的是数组的维度。 数组名.size返回的是数组的元素个数。 数组名.dtype返回的是数组的元素类型。 dtype(变量)返回的是变量的类型。 numpy的索引和切片操作索引索引操作和列表的索引操作时一样的。 整数数组索引：指使用一个数组来访问另一个数组的元素。这个数组中的每个元素都是目标数组中某个维度上的索引值。 行索引和列索引是配对的。[0,1,2]用来选择行索引，[0,1,0]用来选择列索引。 x[[0,1,2],[0,1,0]]等于x[0,0],x[1,1],x[2,0] 按照上面那样整数索引以二维数组的形式输入，最后输出结果也是二维数组。 但如果y = x[[0,0,3,3],[0,2,0,2]] ，最后就会输出一维数组 a[1:3, [1,2]]先选择 行 1 到 2，再选 列 1、2，得到的是一个子矩阵。 a[[1,2], [1,2]]选取的是 (1,1) 和 (2,2) 位置 的元素，得到的是一个一维数组。 那怎么取第1，3，5行的第2，4，6列的数据呢？ 1、使用np.ix_() import numpy as np # 创建 8×8 的数组 a = np.arange(64).reshape(8, 8) # 选取第 1、3、5 行 第 2、4、6 列 rows = [1, 3, 5] # 行索引 cols = [2, 4, 6] # 列索引 result = a[np.ix_(rows, cols)] print(result) 2、直接使用 [:, :] 进行花式索引 result = a[[1, 3, 5], :][:, [2, 4, 6]] print(result) a[[1, 3, 5], :] → 先取出第 1、3、5 行，包含所有列。 [:, [2, 4, 6]] → 再在选出的子矩阵中取出第 2、4、6 列。 切片一维数组： 冒号 : 的解释：如果只放置一个参数，如 **[2]**，将返回与该索引相对应的单个元素。如果为 **[2:]**，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 **[2:7]**，那么则提取两个索引(不包括停止索引)之间的项。 二维数组： [1:]从索引为1的切割到底。 切片还可以包括省略号 …，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。 在 NumPy 中，...（省略号）用于表示多个冒号（:），它的作用是自动匹配剩余的维度，以便简化索引操作。 将图片进行左右翻转，就是该图片的行不变，列倒置。 图片上下翻转，就是图片的行倒置，列不变。 上述关于图片的各种操作就是关于图片的numpy数组的操作。 广播（Broaddcast）广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式。 如果两个数组 a 和 b 形状相同，即满足 a.shape b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。 当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。 迭代数组NumPy 迭代器对象 numpy.nditer 提供了一种灵活访问一个或者多个数组元素的方式。 np.nditer(a) 是 NumPy 提供的多维数组迭代器，可以逐元素访问 a。 适用于任何维度的数组，而不需要手动写多层 for 循环。 按行优先（C 方式）依次访问数组中的元素。 **print(x)**：打印变量 x（这里是 NumPy 数组中的元素）。 end=, ：指定打印结尾的字符，原本print()默认是换行 ，但这里改为 , （逗号+空格），所以输出在同一行，并且元素之间用 , 分隔。 控制遍历顺序： for x in np.nditer(a, order=F):Fortran order，即是列序优先； for x in np.nditer(a.T, order=C):C order，即是行序优先； 将x[...]=2*x 修改为x=2*x就不能修改原数组了。 x[...] 表示 x 仍然是 a 数组的视图（view）。 x[...] = 不会改变 x 本身的引用，而是修改它所指向的内存中的值。 x = 2 * x 和 x[...] = 2 * x 的关键区别在于： x[...] = 操作的是 x 所指向的原数组。 x = 创建了一个新的 Python 变量，而不是修改原数组的内存。 在 NumPy 中，视图（view） 是指共享相同数据但具有不同形状或表示方式的数组。视图不会创建新的数据副本，而是引用原始数组的内存，因此修改视图的数据会影响原数组，反之亦然。 如果两个数组是可广播的，nditer 组合对象能够同时迭代它们。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）。 数组操作修改数组形状**数组名.reshape(行，列)**：重新制定形状。一维-多维；多维-一维。 reshape(12**,**)和reshape(12)都代表12个元素的一维数组；但是reshape(,12)会报错，不代表1列的数组。 变形前后的元素数量要一样。 numpy.ndarray.flat 是一个数组元素迭代器。不用使用迭代数组也可以一个一个输出元素。 numpy.ndarray.flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，返回的始终是一维数组。 ndarray.flatten(order=C)，order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。 numpy.ravel() 展平的数组元素，顺序通常是”C风格”，返回的是数组视图（view），修改会影响原始数组。 ndarray.ravel(order=C)，用法和flatten一样，也是返回一维数组。 翻转数组 后面两个想看自己去菜鸟看。 numpy.ndarray.T 类似 numpy.transpose 级联操作（同一维度）将多个numpy数组进行横向或纵向的拼接。 import numpy as np arr = np.array([1,2,3]) arr2 = np.array([4,5,6]) np.concatenate((arr,arr2),axis = 0) import numpy as np arr3 = np.random.randint(0,10,size = [2,3]) arr4 = np.random.randint(0,10,size = [2,3]) arr5 = np.concatenate((arr3,arr4),axis = 0) arr5 np.concatenate((要拼接的数组),axis = 如何拼接) numpy.concatenate((a1, a2, ...), axis)，a1, a2, ...：相同类型的数组，axis默认为0 对一维数组来说，只有axis 0，代表横向拼接。对二维数组来说，axis 0 ：纵向(y轴)拼接；axis 1：横向(x轴)拼接。对三维数组来说，在承接二维的基础上，axis 2，就是z轴上的拼接。 级联的两个数组维度一样但行列不同怎么办？ 在行相同列不同的情况上，可以横向拼接，不能纵向拼接；在行不同列相同的情况下，可以纵向拼接，不能横向拼接。 可以用于图片的拼接上。 分割数组 numpy.split(ary, indices_or_sections, axis) ary：被分割的数组 indices_or_sections：如果是一个整数，就用该数平均切分（需要刚好可以平分成这个数量），如果是一个数组，为沿轴切分的位置（左开右闭） axis：设置沿着哪个方向进行切分，默认为 0，横向切分，即水平方向。为 1 时，纵向切分，即竖直方向。 横向分割的意思是假如用一把刀来切分，分割的时候刀是沿水平方向移动的，刀口和竖直方向平行。 axis 为 0 时在水平方向分割，axis 为 1 时在垂直方向分割。 numpy.hsplit 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。 numpy.vsplit 沿着垂直轴分割，其分割方式与hsplit用法相同。 数组元素的添加和删除 numpy.resize(arr, shape)，如果新数组大小大于原始大小，则包含原始数组中的元素的副本。可以想象成原数组的元素一个一个循环填进新数组中。 import numpy as np a = np.array([[1,2,3],[4,5,6]]) print (第一个数组：) print (a) print ( ) print (第一个数组的形状：) print (a.shape) print ( ) b = np.resize(a, (3,2)) print (第二个数组：) print (b) print ( ) print (第二个数组的形状：) print (b.shape) print ( ) # 要注意 a 的第一行在 b 中重复出现，因为尺寸变大了 print (修改第二个数组的大小：) b = np.resize(a,(3,3)) print (b) 若是b = np.resize(a,(2,2,2))则输出 numpy.append 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError。 numpy.append(arr, values, axis=None) arr：输入数组 values：要向arr添加的值，需要和arr形状相同（除了要添加的轴） axis：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。 numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。 函数会在指定位置（或位置数组）插入给定的值或数组，然后返回新的数组。被插入的元素可以是标量值，也可以是数组。需要注意的是，插入操作会返回一个新的数组，而不会改变原始数组。 numpy.insert(arr, obj, values, axis) arr：输入数组 obj：在其之前插入值的索引 values：要插入的值 axis：沿着它插入的轴，如果未提供，则输入数组会被展开 import numpy as np a = np.array([[1,2],[3,4],[5,6]]) print (第一个数组：) print (a) print ( ) print (未传递 Axis 参数。 在删除之前输入数组会被展开。) print (np.insert(a,3,[11,12])) print ( ) print (传递了 Axis 参数。 会广播值数组来配输入数组。) print (沿轴 0 广播：) print (np.insert(a,1,[11],axis = 0)) print ( ) print (沿轴 1 广播：) print (np.insert(a,1,11,axis = 1)) 当axis0时，以行为单位进行插入；当axis1是，以列为单位进行插入。 要实现广播数组进行插入的前提这个数组可以广播。 numpy.delete 函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。 Numpy.delete(arr, obj, axis) arr：输入数组 obj：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组 axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开 numpy.unique 函数用于去除数组中的重复元素。 numpy.unique(arr, return_index, return_inverse, return_counts) arr：输入数组，如果不是一维数组则会展开 return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储 return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储 return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数 这个函数返回的去重后的数组同时也完成了排序。 import numpy as np a = np.array([5,2,6,2,7,5,6,8,2,9]) print (第一个数组：) print (a) print ( ) print (第一个数组的去重值：) u = np.unique(a) print (u) print ( ) print (去重数组的索引数组：) u,indices = np.unique(a, return_index = True) print (indices) print ( ) print (我们可以看到每个和原数组下标对应的数值：) print (a) print ( ) print (去重数组的下标：) u,indices = np.unique(a,return_inverse = True) print (u) print ( ) print (下标为：) print (indices) print ( ) print (使用下标重构原数组：) print (u[indices]) print ( ) print (返回去重元素的重复数量：) u,indices = np.unique(a,return_counts = True) print (u) print (indices) 为什么u,indices = np.unique(a, return_index = True)可以同时给两个赋值且值还不同？ 因为此时这个函数会返回去重后的数组 u（按排序后的唯一值），返回 indices，它是原数组中每个唯一值第一次出现的索引。它会同时返回两个值，这是python函数中的多返回值机制，如 常用的函数算术函数sum,max,min,mean 数组名.sum()：求出该数组所有元素的和。数组名.sum(axis = 0/1)：每列或每行的和。 np.sum([数据源],axis = 0/1) 后面几个函数的用法和sum一样。 mean求的是算术平均值。 NumPy 算术函数包含简单的加减乘除: add()，subtract()，multiply() 和 **divide()**。 需要注意的是数组必须具有相同的形状或符合数组广播规则。 numpy.reciprocal() 函数返回参数逐元素的倒数。如 14 倒数为 41。 numpy.power() 函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。 如果第二个元素只有一个数的话，那第一个元素的全部数的幂就是第二个元素的值。 numpy.mod() 计算输入数组中相应元素的相除后的余数。 函数 numpy.remainder() 也产生相同的结果。 numpy.mod(被除数，除数) 数学函数 sin，对数组的每个元素都求sin。()里面也可以直接指定一个数，如：np.sin(2.5) 这些函数计算使用的都是弧度制，所以要将角度转化为弧度就要通过乘 pi180 转化为弧度。 import numpy as np a = np.array([0,30,45,60,90]) print (不同角度的正弦值：) # 通过乘 pi/180 转化为弧度 print (np.sin(a*np.pi/180)) print ( ) ​ arcsin，arccos，和 arctan 函数返回给定角度的 sin，cos 和 tan 的反三角函数，但这三个函数返回的不是角度而是弧度。这些函数的结果可以通过 numpy.degrees() 函数将弧度转换为角度。 import numpy as np a = np.array([0,30,45,60,90]) print (含有正弦值的数组：) sin = np.sin(a*np.pi/180) print (sin) print ( ) print (计算角度的反正弦，返回值以弧度为单位：) inv = np.arcsin(sin) print (inv) print ( ) print (通过转化为角度制来检查结果：) print (np.degrees(inv)) print ( ) 当decimal为负数的时候，四舍五入的位置开始向左移动。 numpy.floor() 返回小于或者等于指定表达式的最大整数，即向下取整。 numpy.ceil() 返回大于或者等于指定表达式的最小整数，即向上取整。 这两个函数参数就是数组。 amin和amax的操作和上面的min和max是一样的。 np,ptp(数组,axis) # arr.std() arr5 = np.array([[1,2,3],[4,5,6],[7,8,9]]) print(arr5.std()) print(arr5[1].std()) 方差和标准差用法一样。 统计函数numpy.amin() 用于计算数组中的元素沿指定轴的最小值。 numpy.amin(a, axis=None, out=None, keepdims=no value, initial=no value, where=no value) a: 输入的数组，可以是一个NumPy数组或类似数组的对象。 axis: 可选参数，用于指定在哪个轴上计算最小值。如果不提供此参数，则返回整个数组的最小值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴。 out: 可选参数，用于指定结果的存储位置。 keepdims: 可选参数，如果为True，将保持结果数组的维度数目与输入数组相同。如果为False（默认值），则会去除计算后维度为1的轴。 initial: 可选参数，用于指定一个初始值，然后在数组的元素上计算最小值。 where: 可选参数，一个布尔数组，用于指定仅考虑满足条件的元素。 initial部分是提供一个初始值，防止使用这个函数是遇到空数组导致报错，假如是空数组的话，那最后会返回initial的值。 numpy.amax() 用于计算数组中的元素沿指定轴的最大值。 numpy.amax(a, axis=None, out=None, keepdims=no value, initial=no value, where=no value) import numpy as np a = np.array([[3,7,5],[8,4,3],[2,4,9]]) print (我们的数组是：) print (a) print ( ) print (调用 amin() 函数：) print (np.amin(a,1)) print ( ) print (再次调用 amin() 函数：) print (np.amin(a,0)) print ( ) print (调用 amax() 函数：) print (np.amax(a)) print ( ) print (再次调用 amax() 函数：) print (np.amax(a, axis = 0)) numpy.ptp() 函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。 numpy.ptp(a, axis=None, out=None, keepdims=no value, where=no value) a: 输入的数组，可以是一个 NumPy 数组或类似数组的对象。 axis: 可选参数，用于指定在哪个轴上计算峰-峰值。如果不提供此参数，则返回整个数组的峰-峰值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴。 out: 可选参数，用于指定结果的存储位置。 keepdims: 可选参数，如果为 True，将保持结果数组的维度数目与输入数组相同。如果为 False（默认值），则会去除计算后维度为1的轴。 where: 可选参数，一个布尔数组，用于指定仅考虑满足条件的元素。 百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 numpy.percentile(a, q, axis) a: 输入数组 q: 要计算的百分位数，在 0 ~ 100 之间 axis: 沿着它计算百分位数的轴 第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。 举个例子：高等院校的入学考试成绩经常以百分位数的形式报告。比如，假设某个考生在入学考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。 这里的 p 70。 numpy.median() 函数用于计算数组 a 中元素的中位数（中值）。也可以使用percentile函数，当百分位数为50就可以。 numpy.median(a, axis=None, out=None, overwrite_input=False, keepdims=no value) overwrite_input: 可选参数，如果为True，则允许在计算中使用输入数组的内存。这可能会在某些情况下提高性能，但可能会修改输入数组的内容。 算术平均值：numpy.mean(a, axis=None, dtype=None, out=None, keepdims=no value) 标准差：numpy.std(ndarry) 方差：numpy.var(ndarry) numpy.average() 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。 加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。 考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。 加权平均值 = (1*4+2*3+3*2+4*1)/(4+3+2+1) numpy.average(a, axis=None, weights=None, returned=False) a: 输入的数组，可以是一个 NumPy 数组或类似数组的对象。 axis: 可选参数，用于指定在哪个轴上计算加权平均值。如果不提供此参数，则计算整个数组的加权平均值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴。 weights: 可选参数，用于指定对应数据点的权重。如果不提供权重数组，则默认为等权重。 returned: 可选参数，如果为True，将同时返回加权平均值和权重总和。 排序，条件筛选函数numpy.sort() 函数返回输入数组的排序副本。 numpy.sort(a, axis, kind, order) a: 要排序的数组 axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis0 按列排序，axis1 按行排序 kind: 默认为’quicksort’（快速排序） order: 如果数组包含字段，则是要排序的字段 可以通过控制order的内容来控制排序。 import numpy as np a = np.array([[3,7],[9,1]]) print (我们的数组是：) print (a) print ( ) print (调用 sort() 函数：) print (np.sort(a)) print ( ) print (按列排序：) print (np.sort(a, axis = 0)) print ( ) # 在 sort 函数中排序字段 dt = np.dtype([(name, S10),(age, int)]) a = np.array([(raju,21),(anil,25),(ravi, 17), (amar,27)], dtype = dt) print (我们的数组是：) print (a) print ( ) print (按 name 排序：) print (np.sort(a, order = name)) numpy.argsort() 函数返回的是数组值从小到大的索引值。 import numpy as np x = np.array([3, 1, 2]) print (我们的数组是：) print (x) print ( ) print (对 x 调用 argsort() 函数：) y = np.argsort(x) print (y) print ( ) print (以排序后的顺序重构原数组：) print (x[y]) argsort()函数也可以用于多维数组，假如用于二维数组的话，如下图： 为什么是要在列方向上进行排序呢？因为返回的索引是每一行里各个元素的列索引，axis1就代表要按照 y 提供的列索引顺序对每一行进行重排。 numpy.lexsort() 用于对多个序列进行排序。返回的也是索引。 把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。 这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。 nm[i] + , + dv[i] 会拼接成字符串。 因为使用了列表推导式，所以print里面的方括号不能去掉。 numpy.argmax() 和 numpy.argmin()函数分别沿给定轴返回最大和最小元素的索引，没给 axis 赋值的话返回的索引是原数组张开后的索引，想要直接用的话需要将原数组张开后(flatten)调用，这两个函数的参数是(ndarry,axis)。 numpy.nonzero() 函数返回输入数组中非零元素的索引。 numpy.where() 函数返回输入数组中满足给定条件的元素的索引。 numpy.extract() 函数根据某个条件从数组中抽取元素，返回满条件的元素。 矩阵操作 np.matrixlib.identity(6)没有这个功能了。 推荐直接用 np.identity(6)或者np.eye(6)来创建单位矩阵，6 代表矩阵大小，6行6列。 转置矩阵 T arr.T np.eye(3).T 矩阵相乘 numpy.dot(a,b,out None) a：ndarray数组；b：ndarray数组 Pandasnumpy处理数值型的数据，pandas处理数值型之外的数据。 Series基本 Series(数据源，索引，数据类型) from pandas import Series a = Series(data = [1,2,3,four]) #a = Series([1,2,3,four]) a 没有写index的，序号就默认为“0，1，2，3……” pandas.Series(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False) data：Series 的数据部分，可以是列表、数组、字典、标量值等。如果不提供此参数，则创建一个空的 Series。 index：Series 的索引部分，用于对数据进行标记。可以是列表、数组、索引对象等。如果不提供此参数，则创建一个默认的整数索引。 dtype：指定 Series 的数据类型。可以是 NumPy 的数据类型，例如 np.int64、np.float64 等。如果不提供此参数，则根据数据自动推断数据类型。 name：Series 的名称，用于标识 Series 对象。如果提供了此参数，则创建的 Series 对象将具有指定的名称。 copy：是否复制数据。默认为 False，表示不复制数据。如果设置为 True，则复制输入的数据。 fastpath：是否启用快速路径。默认为 False。启用快速路径可能会在某些情况下提高性能。 通过Series对象建立Series： 可以指定这个Series对象的名称。 括号里面只能写data，不能用其他的，或者直接不写，只需将数据传入就行。 定义索引后依旧可以使用默认索引。 使用字典充当数据源 索引和切片的使用与前面的差不多。 不过切片会一起显示前面的序号，索引不会。 shape和size和前面的一样，分别显示形状和个数。 dtype返回的是数据类型，返回Object说明Series也只能存储同一种类型的数据。 常用方法 上面的后四个表示加减乘除，可以使用上面的方法来进行，也可以直接使用运算符。 head()显示前几个数据，默认是5，可以指定要显示的个数，如：s.head(3)，表示显示前三个数据。 tail()就是显示后几个数据。 s.unique()，输出去重后的数据，变成一维数组输出。 notnull()就是判断不为空值。 NaN和null还是有区别的，后面会讲。 Series的运算法则：索引一致的元素进行算术运算否则补空。 import pandas as pd # 创建 Series data = [1, 2, 3, 4, 5, 6] index = [a, b, c, d, e, f] s = pd.Series(data, index=index) 输出： del是直接在Series里删除的，会修改原数据；drop则不会修改原数据。 可以使用numpy的函数。 DataFrame基本DataFrame是由多个Series组成的。 创建：pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) data：DataFrame 的数据部分，可以是字典、二维数组、Series、DataFrame 或其他可转换为 DataFrame 的对象。如果不提供此参数，则创建一个空的 DataFrame。 copy：是否复制数据。默认为 False，表示不复制数据。如果设置为 True，则复制输入的数据。 字典中的key变为列索引，既然已经有列索引了，那后面就只需要指定行索引（index）就可以了。 ​ 定义行号和列号的方法：字典定义列号，index定义行号 import pandas as pd df = pd.DataFrame(A: [11, 21, 31], B: [12, 22, 32], C: [13, 23, 33], index=[ONE, TWO, THREE]) print(df) # A B C # ONE 11 12 13 # TWO 21 22 23 # THREE 31 32 33 或 from pandas import DataFrame df = DataFrame(data = [[1,2,3],[1,2,3]],index = [a,b],columns = [d,e,f]) df index和columns的位置没规定。 基本属性values，columns，index，shape values返回的是DataFrame里的数据（去除了行号和列号的表格） index返回所有行号，colums返回的是所有列号。 索引操作df[d] # 取单列，中括号中的只能填列号，不能填行号 df[[d,e]] # 取多列 注意取多列有俩中括号。 # iloc：用于取隐式索引（就是没有自己取规定行号是什么，是默认的行号），若是显式索引（不是默认的）用这个会报错 # loc：用于取显式索引，也可以用于隐式 df.loc[a] # 取单行 df.loc[[a,b]] # 取多行 # loc[行,列] 切片操作 切片操作中中括号里填的是行号，与索引操作相反，iloc和loc的限制与索引的一样，里面填的内容和numpy切片的一样，前面表示行，后面表示列。 df[:-1] # 表示的是删去最后一行 df.iloc[:-1] # 表示的也是删去最后一行 DataFrame的运算和Series的运算一样。 关于运算操作如果不懂的话可以看df大杀器之索引和切片的17分钟左右。 附加操作，时间类型的转化pd.to_datatime(数据源) 将某一列设置为行索引：df.set_index(该列的名字)，不会改变原数据。 应用部分方法还有好多在下面依次出现。 取数据，存数据，csv文件原DataFrame不会改变，若是pd.to_datatime(数据源,inplace = True)原始数据就会改变。 excel文件 drop 在drop()中，axis1代表列（特例，一般都表示行），和numpy里的相反。 布尔值取数据上面那个语句是个判断语句，最后输出布尔值。 只会输出为True的那行，False的那行不会输出。 shift，计算df[close].shift(1)\t代表的是df的close这一列的数据集体下移一位，就是原本第一行的close的数据下移到第二行的close位置。 df[close].shift(-1)是集体上移一位。 df[2010-01:2020-02]只有时间索引才可以这么切。 resample 这里的数据没有错，只是前面的索引错了。 “M”代表的是月份，所以resample(‘M’)代表的就是根据月份进行重新取样，first就是第一行。 resv那边乘的应该是1000。 上面的new_df[close][-1]在现在这个版本已经不行了。 Pandas CSVCSV（Comma-Separated Values，逗号分隔值，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。 Pandas Excel 语法中的参数非常多，需要的话自己去菜鸟查询。 read_excel 默认读取第一个表单（sheet_name0），假设 data.xlsx 文件中只有一个表单，读取后的数据会存储在一个 DataFrame 中。 如果 data.xlsx 文件中有多个表单，可以通过指定 sheet_name 来读取特定表单的数据，例如 pd.read_excel(data.xlsx, sheet_name=Sheet1)。 ExcelFile - 加载 Excel 文件。 ExcelFile 是一个用于读取 Excel 文件的类，它可以处理多个表单，并在不重新打开文件的情况下访问其中的数据。 想要使用上述方法，需要先加载Excel文件，然后才能使用sheet_names等。 ExcelWriter 是 pandas 提供的一个类，用于将 DataFrame 或 Series 对象写入 Excel 文件。使用 ExcelWriter，你可以在一个 Excel 文件中写入多个工作表，并且可以更灵活地控制写入过程。 pandas.ExcelWriter(path, engine=None, date_format=None, datetime_format=None, mode=w, storage_options=None, if_sheet_exists=None, engine_kwargs=None) path：这是必需的参数，指定了要写入的 Excel 文件的路径、URL 或文件对象。可以是本地文件路径、远程存储路径（如 S3）、URL 链接或已打开的文件对象。 engine：这是一个可选参数，用于指定写入 Excel 文件的引擎。如果为 None，则 pandas 会自动选择一个可用的引擎（默认优先选择 openpyxl，如果不可用则选择其他可用引擎）。常见的引擎包括 openpyxl（用于 .xlsx 文件）、xlsxwriter（提供高级格式化和图表功能）、odf（用于 OpenDocument 格式如 .ods）等。 date_format：这是一个可选参数，指定写入 Excel 文件中日期的格式字符串，例如 YYYY-MM-DD。 datetime_format：这是一个可选参数，指定写入 Excel 文件中日期时间对象的格式字符串，例如 YYYY-MM-DD HH:MM:SS。 mode：这是一个可选参数，默认为 w，表示写入模式。如果设置为 a，则表示追加模式，向现有文件中添加数据（仅支持部分引擎，如 openpyxl）。 storage_options：这是一个可选参数，用于指定与存储后端连接的额外选项，例如认证信息、访问权限等，适用于写入远程存储（如 S3、GCS）。 if_sheet_exists：这是一个可选参数，默认为 error，指定如果工作表已经存在时的行为。选项包括 error（抛出错误）、new（创建一个新工作表）、replace（替换现有工作表的内容）、overlay（在现有工作表上覆盖写入）。 engine_kwargs：这是一个可选参数，用于传递给引擎的其他关键字参数。这些参数会传递给相应引擎的函数，例如 xlsxwriter.Workbook(file, **engine_kwargs) 或 openpyxl.Workbook(**engine_kwargs) 等。 Pandas常用函数 # 从 SQL 数据库中读取数据 import sqlite3 conn = sqlite3.connect(database.db) df = pd.read_sql(SELECT * FROM table_name, conn) 缺失值的清洗缺失值原始数据中会存在缺失值（空值） 有两种丢失数据：None，np.nan(NaN) 两种丢失数据区别： 浮点型的空加任意值都等于空，None加值会报错。 在pandas中如果遇到None形式的空值，pandas会将其强转为NaN类型的空值。 pandas处理空值的操作判断空值：isnull,notnull，any,all 删除：dropna 覆盖：fillna 删除方式1：对空值进行过滤（删除空值所在的行数据） 技术：isnull,notnull,any,all 一、 要用true和false来显示筛选数据的时候记住使用的是loc而不是iloc。 all是用来监测false的，如果某一行中都是True则返回True，有一个False就返回False。 需要和notnull搭配 二、 这个没有进行删除，只是显示出现了筛选，只显示True的。 方式2：dropna：可以直接将缺失的行或列进行删除 下面这个最简单，但前面的也要会 df.dropna(axis = 0) # 删除缺失值所在的行 df.dropna(axis = 1) # 删除缺失值所在的列 覆盖 先向前填充再向后填充。 df.fillna(value = n) # 空值都被n覆盖 一般情况都选择删除而不是覆盖，删除的成本高才选择覆盖。 df.fillna(method = ffill,axis) # 向前填充 df.fillna(method = bfill,axis) # 向后填充 # axis = 1,水平方向的填充 # axis = 0,竖直方向的填充 重复值和异常值的清洗重复值使用drop_duplicates keep=first代表的是保留重复数据第一次出现的那行。keep=last保留最后一次出现的。keep=false代表把所有重复行数据删掉。 不写的话默认等于first。 异常值没有专用的函数就是用上面学到的方法，配合给的条件进行处理。 “**~**”：这个符号代表取反。 DataFrame的级联操作和合并操作这个级联操作行列不同也可以进行，就是补空值。 级联操作pd.concat pd.append（不能用） concat进行横向或纵向的拼接 外连接：join’outer’，当没写的时候默认为外连接，就是普通连接，补空值。 内连接：join’inner’，只连接索引相同的。 想要保留输完整性则使用外连接。 append版本2.0以上被废除 合并操作 级联对应的是表格，对表格的拼接；合并对应的是数据，对数据的合并与整合。 合并一次只能合并两张表。 如果两张表大部分的索引都一样那就做级联；如果只有局部的索引一样或者都不一样就用合并。 下面说的几对几合并是一个表格里的数据对另一个表格里的数据是否一一对应。 一对一合并 pd.merge(df3,df4,on = employee) on 后面写的是合并条件，基于这个合并条件进行合并。如果不写的话，它就会将两张表中共有的列作为合并条件进行合并。 一对多合并 多对多合并 howmerge方法里有个参数值叫作how，它默认为inner，也就是去除了空值所在的行，当赋值为outer时，空值所在的行就是出现，这里的空值出现是因为两个表中有不能对应的地方，这些地方就会为空值，而不是可以起到删除空值的作用。 这个时候代表的时内连接和外连接。 要保证合并数据的完整性的话就要使用outer。 默认为inner： 赋值为outer： 还有左连接和右连接。 how ‘left’ 时代表的是左连接，就是保留左表的数据；how ‘right’ 时代表的是右连接，保留右表的数据。 key的规范化当有多个列名称相同时，需要用on 来指定哪一个列作为key，配合suffixes指定冲突列名。 on 当有列冲突而不去管时，此时merge会将相同的列一起作为key来合并。 on 指定一列 当两张表没有可进行连接的列时，可使用left_on和right_on手动指定merge中的左右两边哪一列作为连接的列。 没有相同列的表。 应用info,unique info() 返回的是这组数据的原始信息。 将布尔值作为行索引后取出对应的行数据，abb_pop.loc[abb_pop[state].isnull()] 这个在里面的输出是一个DataFrame，所以可以把这个整体看成是一个原始数据表，所以要取出这个表中的列数据是就可以直接 [] ，变为abb_pop.loc[abb_pop[state].isnull()][state/region]。 s.unique()，输出去重后的数据，变成一维数组输出。 query query() 函数专门针对DataFrame做条件查询。不用这个函数的话也可以使用条件判断语句。 原本数据里面没有’midu’这一列，但赋值一下就相当于是添加了。 sort sort_values是对值进行排序，sort_index是对索引排序。 ascending默认为True，是升序；False是降序。 替换操作 to_replace代表要替换的元素，value代表替换成的元素，第三个是inplace，用法和前面的一样。replace(to_replace,value,inplace) pandas高级操作映射概念：创建一个映射关系列表，把values元素和一个特定的字符串或者标签绑定（给一个元素提供不同的表现形式）。 那接下来就可以使用这个标签来表示这元素了。 map是Series的方法，只能通过Series调用。 def 关键字代表自定义一个函数。 排序实现的随机抽样take() 和 np.random.permutation() take和drop一样，1表示列，0表示行 上面这是打乱列。 在打乱列的基础上再打乱行，然后再取样，那就是随机取样了。 分组聚合数据分类处理核心： groupby()函数，groups属性查看分组情况。 mean()函数只能对数值型数据进行处理，所以没对颜色求均值，这个mean()因为没指定对象，所以同时对price和weight进行求平均值。 只对价格求平均值。 想要将对应的平均重量赋给对应的颜色后面，直接添加添加不了，那就是给color分别绑定对应的重量，也就是映射。 map()里面放的是映射关系表，映射关系表就是字典。 to_dict()：Series的方法，将Series转化为字典，而df.groupby(by = color)[weight].mean()返回的正好是Series。 没看懂那个函数是怎么用的。 transform()返回的是经过映射的结果，但apply()返回的不是经过映射的结果，经过映射的可以直接汇总到原本的数据中。","tags":["大数据"]},{"title":"实战题目","path":"/2024/10/05/实战题目/","content":"寻找两数之和（运用哈希表）import java.util.HashMap; import java.util.Map; class Solution public int[] twoSum(int[] nums, int target) // 创建一个哈希表，用于存储数组中的值及其对应的索引 MapInteger, Integer hashtable = new HashMapInteger, Integer(); // 遍历数组 nums for (int i = 0; i nums.length; ++i) // 检查哈希表中是否存在一个数，使其与当前数的和等于目标值 if (hashtable.containsKey(target - nums[i])) // 如果存在，返回这个数的索引和当前数的索引 return new int[]hashtable.get(target - nums[i]), i; // 如果不存在，将当前数及其索引存入哈希表 hashtable.put(nums[i], i); // 如果没有找到满足条件的两个数，返回一个空数组 return new int[0]; 1、 MapInteger, Integer hashtable = new HashMapInteger, Integer(); 声明了一个叫作hashtable的变量，它的类型是MapInteger, Integer。Map是一个接口，它定义了键值对的集合，其中每个键最多只能映射到一个值。这意味着hashtable将引用一个Map对象，并且这个Map键和值都是Integer类型（存储整数类型的键和值），同时创建了一个新的HashMap对象，并将其赋值给hashtable变量。new HashMapInteger, Integer()调用了HashMap类的无参数构造函数，创建了一个空的HashMap对象，其中Integer指定了键和值的类型。 2、hashtable.containsKey(target - nums[i])，检查哈希表中是否存在一个数（查找的是特征值）。 3、hashtable.get(target - nums[i])，返回这个数的索引（返回存储的内容）。 4、hashtable.put(nums[i], i);，将当前数及其索引存入哈希表，nums[i]应该是特征值，数据结构书里有讲，i 是存储的值。 基本数据类型和String之间的转化 String string = faogaig; string.length(); string.length()就是这个字符串的长度。 要提取这个字符串里的字符的话就用string.charAt(int num)。 进制转化 方法三：递归 将String类型的数（比如说二进制，四进制等）转化为Long类型的数怎么转化 long decimalValue = Long.parseLong(aStr, base);//base代表的是此时atr的进制，aStr是要转化的字符串，如10111001011 import java.util.ArrayList; import java.util.List; import java.util.Scanner; public class Main1 public static void main(String[] args) Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); // n = 1000 int[] bases = 2, 4, 8, 16; for (int i = 0; i n; i++) // A_i 的长度可能达到 30 String aStr = scanner.next(); // B_i = 10^9, 使用 long 是一种安全的做法 long bVal = scanner.nextLong(); ListLong solutions = new ArrayList(); for (int base : bases) try // 关键点： // 1. Long.parseLong 可以处理长达63位的二进制数，对于本题足够。 // 2. 如果 aStr 包含对当前 base 无效的字符 (如 A in base 8), 会抛出 NumberFormatException。 // 3. 如果转换后的数值超过 Long.MAX_VALUE (约 9*10^18), 也会抛出 NumberFormatException。 // 由于任何解都必须 = 10^9, 这种溢出的情况自然被排除，正是我们想要的。 long decimalValue = Long.parseLong(aStr, base); // 检查转换后的值是否满足 = B_i 的约束 if (decimalValue = bVal) solutions.add(decimalValue); catch (NumberFormatException e) // 捕捉所有转换异常，静默处理，继续尝试下一个进制。 // 根据解的数量进行判断 if (solutions.size() == 1) System.out.println(solutions.get(0)); else // 0个解或多于1个解，都输出-1 System.out.println(-1); scanner.close(); 随机数（seed）题目的主要信息： 每次运行程序时，输入一个随机种子，产生一个[1,6]之间的随机整数 具体做法： 输入的随机种子不是随机数，但是会用该随机种子进行算法。因此在Random类中seed是一个参数，用于生成伪随机数，因为范围是1-6，但是伪随机数生成是0~n-1，因此末尾需要再加1. import java.util.Random; import java.util.Scanner; public class Main public static void main(String[] args) Scanner scanner = new Scanner(System.in); while (scanner.hasNextInt()) int seed = scanner.nextInt(); //输入随机数种子 Random random = new Random(seed); //用随机种子进行随机算法 System.out.println(random.nextInt(6) + 1); //随机生成1-6地数字 最短路径，dijkstra+优先队列import java.util.*; public class c static class Edge int to; // 目标城市 int length; // 路径长度 Edge(int to, int length) this.to = to; this.length = length; static class State int city; // 当前城市 int totalRescue; // 当前能召集的救援队数量 int pathLength; // 当前路径长度 State(int city, int totalRescue, int pathLength) this.city = city; this.totalRescue = totalRescue; this.pathLength = pathLength; public static void main(String[] args) Scanner scanner = new Scanner(System.in); // 读取输入 int N = scanner.nextInt(); // 城市个数 int M = scanner.nextInt(); // 快速道路的条数 int S = scanner.nextInt(); // 出发地 int D = scanner.nextInt(); // 目的地 int[] rescueTeams = new int[N]; // 各城市的救援队数 for (int i = 0; i N; i++) rescueTeams[i] = scanner.nextInt(); // 构建图 ListListEdge graph = new ArrayList(); for (int i = 0; i N; i++) graph.add(new ArrayList()); for (int i = 0; i M; i++) int u = scanner.nextInt(); int v = scanner.nextInt(); int length = scanner.nextInt(); graph.get(u).add(new Edge(v, length)); graph.get(v).add(new Edge(u, length)); // 因为是双向道路 // 调用 Dijkstra 算法 dijkstra(S, D, rescueTeams, graph); scanner.close(); private static void dijkstra(int start, int end, int[] rescueTeams, ListListEdge graph) int N = graph.size(); int[] minDist = new int[N]; // 记录到各城市的最短路径长度 Arrays.fill(minDist, Integer.MAX_VALUE); minDist[start] = 0; // 记录从起点到各点的救援队数量 int[] maxRescue = new int[N]; maxRescue[start] = rescueTeams[start]; // 记录路径 int[] previous = new int[N]; Arrays.fill(previous, -1); // 使用优先队列 PriorityQueueState pq = new PriorityQueue(Comparator.comparingInt(a - a.pathLength)); pq.add(new State(start, rescueTeams[start], 0)); while (!pq.isEmpty()) State current = pq.poll(); // 如果当前城市是目的地，结束 if (current.city == end) break; for (Edge edge : graph.get(current.city)) int nextCity = edge.to; int newDist = current.pathLength + edge.length; int newRescue = current.totalRescue + rescueTeams[nextCity]; // 更新最短路径和救援队数量 if (newDist minDist[nextCity] || (newDist == minDist[nextCity] newRescue maxRescue[nextCity])) minDist[nextCity] = newDist; maxRescue[nextCity] = newRescue; previous[nextCity] = current.city; pq.add(new State(nextCity, newRescue, newDist)); // 输出结果 System.out.println(minDist[end] + + maxRescue[end]); // 输出路径 ListInteger path = new ArrayList(); for (int at = end; at != -1; at = previous[at]) path.add(at); Collections.reverse(path); // 反转路径 // 打印路径 for (int city : path) System.out.print(city + ); PriorityQueueState pq = new PriorityQueue(Comparator.comparingInt(a - a.pathLength));这句话什么意思 这句话的意思是创建一个优先队列 pq，该队列将按照元素的路径长度进行排序。以下是详细解释： 具体含义 **PriorityQueueState**：这部分表示我们在创建一个优先队列，队列中的元素类型是 State。State 是一个自定义的类，通常包含一些信息，比如当前城市、可召集的救援队数量和当前路径长度。 **new PriorityQueue(...)**：这是 Java 中用于创建一个优先队列的构造函数。 **Comparator.comparingInt(a - a.pathLength)**： Comparator.comparingInt(...) 是一个静态方法，用于生成一个比较器，这个比较器用于比较两个整数值。 a - a.pathLength 是一个 lambda 表达式，它表示从 State 对象 a 中提取 pathLength 属性进行比较。 整体作用 结合起来，这行代码的作用是创建一个优先队列 pq，并定义了该队列的排序规则为：当我们从队列中取出元素时，优先取出路径长度最短的 State 对象。 例子 假设有多个 State 对象，它们的 pathLength 分别是 5、3 和 8。当我们将这些对象加入优先队列后，优先队列将会保证在取出元素时，首先取出的将是 pathLength 最小的对象（即 pathLength 为 3 的对象）。 pq.poll()有什么用 pq.poll() 的作用是从优先队列 pq 中获取并移除优先级最高的元素（在这里是路径长度最短的 State 对象）。具体来说： 详细说明 获取元素：poll() 方法返回队列中优先级最高的元素。如果队列为空，则返回 null。 移除元素：与 peek() 方法不同，poll() 不仅返回这个元素，还会将其从队列中移除。这意味着之后再调用 poll() 时，将不会再得到这个元素。 优先队列的特点：在优先队列中，元素的顺序是根据它们的优先级来决定的。在 Dijkstra 算法中，优先级通常是路径长度，路径长度越短的元素优先级越高。 应用场景 在 Dijkstra 算法中，使用 pq.poll() 来获取当前已知的最短路径的节点（即离起点最近的节点），并继续探索从这个节点出发的其他可能的路径。通过这种方式，算法能逐步找到从起点到各个节点的最短路径。 示例 假设优先队列中有以下 State 对象： State(城市 1, 路径长度 3) State(城市 2, 路径长度 1) State(城市 3, 路径长度 5) 调用 pq.poll() 将返回路径长度为 1 的对象（城市 2），同时将其从队列中移除。下次调用 poll() 时，将返回路径长度为 3 的对象（城市 1）。 容易理解的： import java.util.Scanner; public class Main private static int[] dis,w,pre,num,weight; private static boolean[] vis; private static int n,m,s,d; private static int[][] G; public static void main(String[] args) Scanner sc = new Scanner(System.in); n = sc.nextInt();m = sc.nextInt(); s = sc.nextInt();d = sc.nextInt(); dis = new int[n];vis = new boolean[n];w=new int[n];pre=new int[n];num=new int[n]; weight = new int[n]; G = new int[n][n];//邻接矩阵 for(int i = 0; in; i++) weight[i] = sc.nextInt(); dis[i] = 1000;//设起点到达各点的最短距离 for(int i = 0; in; i++) for(int j = 0; jn; j++) if(i != j) G[i][j] = 1000; for(int i = 0; im; i++) int a = sc.nextInt();int b = sc.nextInt();int c = sc.nextInt(); G[a][b] = c; G[b][a] = c; Dijkstra(s); System.out.println( num[d]+ +w[d]); dfs(s,d); System.out.println(); private static void dfs(int s,int v) if(s == v) System.out.print(s); return; dfs(s,pre[v]); System.out.print( +v); private static void Dijkstra(int s) dis[s] = 0;//将起点到达自身的距离修改为0； num[s] = 1;//最短路径条数初始化为1； w[s] = weight[s];//救援队数目修改为起点城市的救援队数目 for (int i = 0; in; i++) int u = -1,min = 1000; for(int j = 0; jn; j++) if(!vis[j] dis[j] min) min = dis[j]; u = j; if(u == -1)return; vis[u] = true; for(int v = 0; vn; v++) if(!vis[v] G[u][v] != 1000 dis[u] + G[u][v] dis[v]) dis[v] = dis[u] + G[u][v]; w[v] = w[u]+weight[v]; num[v] = num[u]; pre[v] = u; else if(!vis[v] G[u][v] != 1000 dis[u] + G[u][v] == dis[v]) num[v] += num[u];//最短距离相同时路径条数累加 if(w[v] w[u]+weight[v]) w[v] = w[u]+weight[v]; pre[v] = u; 上面两种方法结合起来的答案，通过的测试最多： import java.util.*; public class Main static class Edge int now; // 目前所在的城市 int length; // 路径长度 Edge(int now, int length) this.now = now; this.length = length; private static int[] previous ; public static void main(String[] args) Scanner scanner = new Scanner(System.in); // 读取输入 int N = scanner.nextInt(); // 城市个数 int M = scanner.nextInt(); // 快速道路的条数 int S = scanner.nextInt(); // 出发地 int D = scanner.nextInt(); // 目的地 int[] rescueTeams = new int[N]; // 各城市的救援队数 // 记录路径 previous = new int[N]; Arrays.fill(previous, -1); for (int i = 0; i N; i++) rescueTeams[i] = scanner.nextInt(); // 构建图 int[][] graph = new int[N][N]; for(int i = 0;i N;i ++) Arrays.fill(graph[i],Integer.MAX_VALUE); for (int i = 0; i M; i++) int u = scanner.nextInt(); int v = scanner.nextInt(); int length = scanner.nextInt(); graph[u][v] = length; graph[v][u] = length; // 因为是双向道路 // 调用 Dijkstra 算法 dijkstra(S, D, rescueTeams, graph); dfs(S,D); private static void dfs(int s,int v) if(s == v) System.out.print(s); return; dfs(s,previous[v]); System.out.print( +v); private static void dijkstra(int start, int end, int[] rescueTeams, int[][] graph) int N = graph.length; int[] min = new int[N]; // 记录到各城市的最短路径长度 int[] nums = new int[N];//记录最短路径数量，初始值设为1 Arrays.fill(nums,1); boolean[] visit = new boolean[N]; Arrays.fill(min, Integer.MAX_VALUE); min[start] = 0; // 记录从起点到各点的救援队数量 int[] maxRescue = new int[N]; maxRescue[start] = rescueTeams[start]; // 使用优先队列 PriorityQueueEdge minDist = new PriorityQueue(Comparator.comparingInt(a - a.length)); minDist.add(new Edge(start,0)); while (!minDist.isEmpty()) Edge current = minDist.poll(); // 如果当前城市是目的地，结束 if (current.now == end) break; int now = current.now; visit[now] = true; for (int v = 0;v N;v ++) // 更新最短路径和救援队数量 if(!visit[v] graph[now][v] != Integer.MAX_VALUE graph[now][v] + min[now] min[v]) min[v] = graph[now][v] + min[now]; maxRescue[v] = maxRescue[now] + rescueTeams[v]; previous[v] = now; minDist.add(new Edge(v,min[v])); nums[v] = nums[now]; else if(!visit[v] graph[now][v] != Integer.MAX_VALUE graph[now][v] + min[now] == min[v]) nums[v] += nums[now]; if(maxRescue[now] + rescueTeams[v] maxRescue[v]) maxRescue[v] = maxRescue[now] + rescueTeams[v]; previous[v] = now; // 输出结果 System.out.println(nums[end] + + maxRescue[end]); 比较1、范围小明正在设计一台打点计数器，该计数器可以接受多个递增的数字范围，并对这些范围内的每个唯一数字打点。如果多个范围之间有重叠，计数器将合并这些范围并只对每个唯一数字打一次点。小明需要你帮助他计算，在给定的多组数字范围内，计数器会打多少个点。 例如，给定三个数字范围 [1, 4], [7, 10], 和 [3, 5]，计数器首先将这些范围合并，变成 [1, 5] 和 [7, 10]，然后计算这两个范围内共有多少个唯一数字，即从 1 到 5 有 5 个数字，从 7 到 10 有 4 个数字，共打 9 个点。 import java.util.*; public class Main public static int solution(int[][] inputArray) // Step 1: 按范围起点排序 Arrays.sort(inputArray, Comparator.comparingInt(a - a[0])); // Step 2: 合并范围 Listint[] mergedRanges = new ArrayList(); int[] currentRange = inputArray[0]; for (int i = 1; i inputArray.length; i++) int[] nextRange = inputArray[i]; // 如果当前范围与下一个范围有重叠或相邻 if (currentRange[1] = nextRange[0] - 1) // 更新当前范围的终点为两者较大的终点 currentRange[1] = Math.max(currentRange[1], nextRange[1]); else // 否则，当前范围结束，加入结果 mergedRanges.add(currentRange); currentRange = nextRange; // 添加最后一个范围 mergedRanges.add(currentRange); // Step 3: 计算合并后范围内的总数字数量 int totalPoints = 0; for (int[] range : mergedRanges) totalPoints += range[1] - range[0] + 1; return totalPoints; public static void main(String[] args) // 测试用例 int[][] testArray1 = 1, 4, 7, 10, 3, 5; int[][] testArray2 = 1, 2, 6, 10, 11, 15; int[][] testArray3 = 1, 3, 2, 5, 4, 8; System.out.println(solution(testArray1) == 9); // [1, 5], [7, 10] = 5 + 4 = 9 System.out.println(solution(testArray2) == 12); // [1, 2], [6, 10], [11, 15] = 2 + 5 + 5 = 12 System.out.println(solution(testArray3) == 8); // [1, 8] = 8 里面的Comparator.comparingInt(a - a[0]) 是 Java 中用于创建比较器的一种简洁方式，用于比较对象（如数组、对象等）的某个整数字段或属性。 Comparator.comparingInt() 是 Java 8 引入的一种简洁创建比较器的方式，用于比较整数值。 a - a[0] 是一个 Lambda 表达式，表示取 a 的第一个元素（索引为 0）作为比较的依据。 完整功能是：按数组的第一个元素升序排序。 Comparator.comparingInt(a - a[0]) 的功能等价于： list.sort(new Comparatorint[]() @Override public int compare(int[] o1, int[] o2) return Integer.compare(o1[0], o2[0]); ); 2、 *一个元素有多个属性就想到构造类* *构造类用来存相应的属性可以重新定义一下排序的方法即compareTo()方法* 3、StringBuilder当 List 或其他集合（如 Set）中存储的是 StringBuilder 对象时，可能会出现错误判断，这是因为 StringBuilder 的 默认比较机制 并不基于内容，而是基于对象引用。 StringBuilder 的比较机制 StringBuilder 类没有重写 equals() 方法和 hashCode() 方法。 其默认实现继承自 Object，比较的是对象的内存地址，而不是内容。 错误场景 当你将 StringBuilder 添加到集合（如 List 或 Set）中，集合内部会使用 equals() 方法来判断元素是否相等。如果两个 StringBuilder 的内容相同，但它们是不同的对象引用，则会被认为是不同的元素。 输入StreamTokenizer不能和Scanner混合使用。 StreamTokenizer 是 Java 中的一个类，专门用于解析输入流，将其分割为“标记”（token）。这些标记可以是数字、单词（字符串）或单个字符。StreamTokenizer 将空白字符（如空格、制表符、换行符）作为分隔符，不会返回它们。 基本用法1、创建 StreamTokenizer 对象，传入 Reader 类型的输入源（通常使用 BufferedReader）。 2、使用 StreamTokenizer.nextToken() 来获取下一个标记（token）。 3、根据标记类型（数字、字符串或其他）处理数据。 主要方法和字段方法 nextToken() - 解析输入流中的下一个标记。 - 返回标记的类型，并将其存储在 `ttype` 字段中。 2. ``` pushBack() - 将最近解析的标记退回到流中，供后续重新处理。 字段 ttype - 表示当前标记的类型： - `StreamTokenizer.TT_NUMBER`：标记是数字。 - `StreamTokenizer.TT_WORD`：标记是单词（字符串）。 - 单个字符的 ASCII 值：标记是符号或单字符。 - `StreamTokenizer.TT_EOF`：到达输入流的末尾。 2. ``` nval - 当 `ttype` 为 `TT_NUMBER` 时，`nval` 保存解析的数字值（`double` 类型）。 sval - 当 `ttype` 为 `TT_WORD` 时，`sval` 保存解析的字符串。 **数据得先解析，才能取出来，就是得先nextToken()，才能通过nval和sval取出。** BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer tokenizer = new StreamTokenizer(reader); tokenizer.nextToken(); int n = tokenizer.nval; # 假设输入的是数字 **记得`throws IOException`** ### 示例 1、简单的数字和单词解析 import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader reader new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer tokenizer new StreamTokenizer(reader); System.out.println(请输入内容（例如：123 Hello 456）：); while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) if (tokenizer.ttype == StreamTokenizer.TT_NUMBER) System.out.println(数字: + tokenizer.nval); else if (tokenizer.ttype == StreamTokenizer.TT_WORD) System.out.println(单词: + tokenizer.sval); else System.out.println(字符: + (char) tokenizer.ttype); } 2：解析一组整数和操作符 import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader reader new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer tokenizer new StreamTokenizer(reader); System.out.println(请输入表达式（例如：1 + 2 - 3）：); while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) if (tokenizer.ttype == StreamTokenizer.TT_NUMBER) System.out.print((int) tokenizer.nval + ); else if (tokenizer.ttype == + || tokenizer.ttype == -) System.out.print((char) tokenizer.ttype + ); } 3：解析带换行符的多行输入 import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader reader new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer tokenizer new StreamTokenizer(reader); System.out.println(请输入多行内容（输入END结束）：); while (true) tokenizer.nextToken(); if (tokenizer.ttype == StreamTokenizer.TT_WORD END.equals(tokenizer.sval)) break; else if (tokenizer.ttype == StreamTokenizer.TT_NUMBER) System.out.println(数字: + tokenizer.nval); else if (tokenizer.ttype == StreamTokenizer.TT_WORD) System.out.println(单词: + tokenizer.sval); } ## BufferedReader `BufferedReader.readLine()` 会直接读取一整行**字符串**，直到遇到换行符 (` `) 或回车换行符 (`\\r `)。 换行符本身不会包含在读取的结果中，因此返回的字符串已经是干净的数据。 换行符自动被跳过，不需要显式处理，不像**nextLine()**方法。 BufferedReader ins new BufferedReader(new InputStreamReader(System.in));String str ins.readLine(); # 建立二叉树 根据中序遍历（b）和后序遍历（f）建立二叉树。 import java.io.*;import java.util.HashMap; public class Main{ public static class Node{ int value; Node left; Node right; public Node(int value){ this.value value; } } public static Node buildTree(int[] f,int[] b,int fStart,int fEnd,int bStart,int bEnd,HashMapInteger,Integer hm){ if(fStart fEnd || bStart bEnd) return null; int num f[fEnd]; Node root new Node(num); int bIndex hm.get(num); int left bIndex - bStart; root.left buildTree(f,b,fStart,fStart + left - 1,bStart,bIndex - 1,hm); root.right buildTree(f,b,fStart + left, fEnd - 1,bIndex + 1,bEnd,hm); return root; } public static void main(String[] args) throws IOException{ BufferedReader bfr new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer st new StreamTokenizer(bfr); st.nextToken(); int n (int)st.nval; int[] f new int[n]; int[] b new int[n]; for(int i 0;i n;i ++) { st.nextToken(); f[i] (int) st.nval; } for(int i 0;i n;i ++) { st.nextToken(); b[i] (int) st.nval; } HashMapInteger,Integer hm new HashMap(); int order 0; for(int i : b) { hm.put(i, order); order ++; } Node root buildTree(f,b,0,f.length - 1,0,b.length - 1,hm); }} # 中心扩展法查找最长对称子串长度 对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定`Is PATTAP symmetric?`，最长对称子串为`s PATTAP s`，于是你应该输出11。 import java.util.Scanner; public class Main { 中心扩展法查找最长对称子串长度 public static int longestSymmetricSubstring(char[] chars) { int maxLength 0; for (int i 0; i chars.length; i++) { 以单个字符为中心扩展 maxLength Math.max(maxLength, expandAroundCenter(chars, i, i)); 以两个相邻字符为中心扩展 maxLength Math.max(maxLength, expandAroundCenter(chars, i, i + 1)); } return maxLength; } // 中心扩展方法 private static int expandAroundCenter(char[] chars, int left, int right) while (left = 0 right chars.length chars[left] == chars[right]) left--; right++; // 返回扩展后的回文子串长度 return right - left - 1; public static void main(String[] args) Scanner input = new Scanner(System.in); String str = input.nextLine(); char[] chars = str.toCharArray(); int maxLength = longestSymmetricSubstring(chars); System.out.println(maxLength); } # 判断两个字符串（可以循环比对）的最大公共子串的长度 public class Main { public static int maxPublic(StringBuilder sb1,StringBuilder sb2,int m) { int maxL 0; int[][] lens new int[m + 1][m + 1]; for(int i 1;i m;i ++) { for(int j 1;j m;j ++) { if(sb1.charAt(i - 1) sb2.charAt(j - 1)) lens[i][j] lens[i - 1][j - 1] + 1; lens[i][j] 表示：sb1 前 i 个字符 和 sb2 前 j 个字符 所能形成的最长公共子串的长度。 如果 sb1[i-1] sb2[j-1]（即当前字符匹配）：lens[i][j]lens[i−1][j−1]+1 继承前一个位置的状态 lens[i-1][j-1]，然后 +1。 else lens[i][j] 0; maxL Math.max(maxL,lens[i][j]); if(maxL m 2) return m 2; } } return maxL; } public static void main(String[] args) { Scanner input new Scanner(System.in); int n input.nextInt();字符串数量 int m input.nextInt();每个字符串的长度 input.nextLine();消除换行符 String[] strs new String[n]; for(int i 0;i n;i ++) strs[i] input.nextLine(); for(int i 0;i n;i ++) { StringBuilder sb1 new StringBuilder(strs[i]); sb1.append(sb1); for(int j i + 1;j n;j ++) { StringBuilder sb2 new StringBuilder(strs[j]); sb2.append(sb2); maxPublic(sb1, sb2, 2 * m) } } }} # 在java中如何快速判断两个List集合中是否有相同的元素 速度上并没有提升多少，只是写的简单。 **方法 1：使用 `retainAll` 方法** `retainAll` 是 `Collection` 接口中的方法，它会保留集合中与另一个集合相同的元素。 import java.util.ArrayList;import java.util.List; public class Main { public static void main(String[] args) { List list1 new ArrayList(); list1.add(“A”); list1.add(“B”); list1.add(“C”); ListString list2 = new ArrayList(); list2.add(C); list2.add(D); list2.add(E); // 复制 list1，避免修改原始数据 ListString tempList = new ArrayList(list1); tempList.retainAll(list2); if (!tempList.isEmpty()) System.out.println(两个 List 有相同的元素); else System.out.println(两个 List 没有相同的元素); } **方法 2：使用 `Collections.disjoint` 方法** `Collections.disjoint` 方法直接判断两个集合是否没有共同的元素。如果返回 `true`，表示没有共同元素；否则有。 import java.util.*; public class Main { public static void main(String[] args) { List list1 Arrays.asList(“A”, “B”, “C”); List list2 Arrays.asList(“C”, “D”, “E”); if (!Collections.disjoint(list1, list2)) System.out.println(两个 List 有相同的元素); else System.out.println(两个 List 没有相同的元素); } # 图，割点 战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。 输入格式： 输入在第一行给出两个整数N（0 N ≤ 500）和M（≤ 5000），分别为城市个数（于是默认城市从0到N-1编号）和连接两城市的通路条数。随后M行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数K和随后的K个被攻占的城市的编号。 注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。 输出格式： 对每个被攻占的城市，如果它会改变整个国家的连通性，则输出Red Alert: City k is lost!，其中k是该城市的编号；否则只输出City k is lost.即可。如果该国失去了最后一个城市，则增加一行输出Game Over.。 import java.util.Scanner; public class Main { static int N,M,K ; static int[][] Maps;统计初始联通数量 static int[] f;重置根节点数组 static int[] falg;判断城市是否被攻占 public static void init() { for (int i 0; i f.length; i++) { f[i] i; } } public static int find(int x) if(x!=f[x]) f[x] = find(f[x]); return f[x]; public static void unite(int a,int b) int x = find(a); int y = find(b); if(x!=y) f[x] = y; public static void main(String[] args) // TODO Auto-generated method stub Scanner scan = new Scanner(System.in); int N = scan.nextInt(); int M = scan.nextInt(); Maps = new int[M][2]; f = new int[N]; falg = new int[N]; init(); for (int i = 0; i M; i++) Maps[i][0] = scan.nextInt(); Maps[i][1] = scan.nextInt(); unite(Maps[i][0],Maps[i][1]); int count = 0;//统计攻占前的联通城市数量 for (int i = 0; i f.length; i++) if(f[i]==i) count++; K = scan.nextInt(); int n = K; while(K--0) init(); int k = scan.nextInt(); falg[k] = 1; for (int i = 0; i M; i++) int a = Maps[i][0]; int b = Maps[i][1]; if(falg[a]==1 || falg[b]==1)continue; if(k!=ak!=b)unite(a, b); int sum = 0; for (int i = 0; i N; i++) if(f[i]==i)sum++; //因为删掉该城市 这个城市也是一个单独的连通块 所以当前连通块之前连通块+这个城市 说明删掉该城市 会改变图的连通性 if(sumcount+1) System.out.printf(Red Alert: City %d is lost! ,k); else System.out.printf(City %d is lost. ,k); count=sum;//更新连通块 if(N==n)System.out.printf(Game Over.); } # 阶乘 img src=../source/imgs/$fiilname/image-20250323154250243.png alt=image-20250323154250243 style=zoom:50%; / import java.util.Scanner; public class Main { public static void main(String[] args) { 下面举例说明为什么要将nums[]中最小的元素作为因子初始值 3！ 6 4！ 24 5！ 120 和为150 必是 3！的倍数！ 因为 4！5！都是3！的倍数，所以加起来肯定也是 (min) 3！的倍数 所以应该找出数组最小值作为初始的sum，再一个一个往上找 比如上面这个例子，需要有 4个3！才能进化为 4！，由于只有一个 3！所以不能往上找了，break退出，答案就是3 Scanner sc new Scanner(System.in); int n sc.nextInt(); long[] nums new long[n]; long min Long.MAX_VALUE; for (int i 0; i nums.length; i++) { nums[i] sc.nextLong(); min Math.min(min, nums[i]); } long sum min; sum为nums[]中的最小值 long num 0; num为nums[]中值为sum的数量 while (true) { 如下文注释：num在上个循环中是18，sum 在上个循环中 8更新为9 根据 18 * 8！ 2 * 9 * 8！ 2 * 9！可知此次循环的 num 要更新为 18 9 2 num num sum; for (int i 0; i nums.length; i++) { if (nums[i] sum) { num++; } } 如果sum的数量（num）等于sum+1的倍数，则可以将其逻辑上将这num个sum合成为（sum+1）的阶乘。 形象化： sum 2 num 3 3个2 2+2+2 sum+1 3 3 3的倍数， 3个2合成为3的阶乘 18(num)个8！(sum) 18 * 8！ 2 * 9 * 8！ 2 * 9！ sum的数量18 sum+19 的倍数 if (num % (sum + 1) 0 num ! 0) { sum++; } else break; } System.out.println(sum); }} # 数学 ![image-20250404103236386](../source/imgs/$fiilname/image-20250404103236386.png) 用这种方式求斜率k和截距b可以避免小数精度的影响，特别是截距b，如果就直接用k来求的话，会因为精度问题导致原本应该相同的b而不同。这种求b的方式叫做点斜式。 ![image-20250406213554281](../source/imgs/$fiilname/image-20250406213554281.png) img src=../source/imgs/$fiilname/uid1525433-20240412-1712919046696.png alt=图片描述 style=zoom:67%; / ![image-20250406214405360](../source/imgs/$fiilname/image-20250406214405360.png) 寻找条件减少暴力的数量。 ![image-20250406215602462](../source/imgs/$fiilname/image-20250406215602462.png) ------ 有一个 *n*×*m* 方格的棋盘，矩形的总数量为img src=../source/imgs/$fiilname/image-20250904172413877.png alt=image-20250904172413877 style=zoom:20%; /. 原因： - 棋盘有 n 行，因此有 n+1 条水平线（包括上边界和下边界）。选择两条不同的水平线的方式是组合数img src=../source/imgs/$fiilname/image-20250904172510512.png alt=image-20250904172510512 style=zoom:50%; / - 棋盘有 m 列，因此有 m+1 条垂直线（包括左边界和右边界）。选择两条不同的垂直线的方式是组合数img src=../source/imgs/$fiilname/image-20250904172545506.png alt=image-20250904172545506 style=zoom:50%; / - 每个矩形由一对水平线和一对垂直线唯一确定，因此总矩形个数是水平线选择数和垂直线选择数的乘积：img src=../source/imgs/$fiilname/image-20250904172609188.png alt=image-20250904172609188 style=zoom:50%; / **矩形数**=**正方形数**+**长方形数** # 快速幂和高精度乘法 初始化全局变量，Python中不需要固定大小的数组，列表可以动态扩展n 0a [0] * 1010 # 模拟数组，存储每个位上的数字res [0] * 1010 # 模拟数组，存储每个位上的数字cnt 0 # Python中不常用这种方式来记录长度，通常直接用 len() 或保持一个实际的长度变量 设置一个最大处理的位数，Python实际上可以处理任意长度MAX_DIGITS 500 def multiply1(): # 高精度乘法模板1 (res res * a) “”” 实现高精度乘法 res res * a。 res 存储第一个乘数，a 存储第二个乘数。结果存储回 res。 “”” tmp [0] * (MAX_DIGITS * 2) # 乘积的位数可能翻倍，所以需要更大的临时空间 # 执行小学乘法，每一位与每一位相乘 for i in range(MAX_DIGITS): if res[i] == 0 and i 0 and all(x == 0 for x in res[i:]): # 优化：如果res的当前位及其之后都是0，则不再需要计算 break for j in range(MAX_DIGITS): if a[j] == 0 and j 0 and all(x == 0 for x in a[j:]): # 优化：如果a的当前位及其之后都是0，则不再需要计算 break tmp[i + j] += res[i] * a[j] # 处理进位 t = 0 for i in range(len(tmp)): # 遍历tmp的有效长度 tmp[i] += t res[i] = tmp[i] % 10 # 当前位取余 t = tmp[i] // 10 # 进位 # 更新 res 的实际长度，如果需要的话 # Python中通常不需要手动管理长度，因为可以动态获取 len() def multiply2(): # 高精度乘法模板2 (a a * a) “”” 实现高精度乘法 a a * a。 a 存储第一个乘数和第二个乘数。结果存储回 a。 “”” tmp [0] * (MAX_DIGITS * 2) # 乘积的位数可能翻倍，所以需要更大的临时空间 # 执行小学乘法，每一位与每一位相乘 for i in range(MAX_DIGITS): if a[i] == 0 and i 0 and all(x == 0 for x in a[i:]): break for j in range(MAX_DIGITS): if a[j] == 0 and j 0 and all(x == 0 for x in a[j:]): break tmp[i + j] += a[i] * a[j] # 处理进位 t = 0 for i in range(len(tmp)): # 遍历tmp的有效长度 tmp[i] += t a[i] = tmp[i] % 10 # 当前位取余 t = tmp[i] // 10 # 进位 # 更新 a 的实际长度，如果需要的话 def quick_pow(p): # 快速幂 “”” 实现快速幂算法，计算 2^p。 结果存储在全局变量 res 中。 “”” global res, a # 声明将修改全局变量 # 初始化：res = 1 (最终结果)，a = 2 (底数) # Python中列表的反转，res[0]是最低位 res = [0] * (MAX_DIGITS + 1) # 增加一位以防溢出 a = [0] * (MAX_DIGITS + 1) # 增加一位以防溢出 res[0] = 1 a[0] = 2 # 快速幂主循环 while p 0: if p 1: # 如果 p 的当前最低位是 1 (p % 2 == 1) multiply1() # res = res * a (将当前的 a 乘到结果中) multiply2() # a = a * a (a 自乘，准备下一轮迭代) p = 1 # p 右移一位 (p = p // 2) # 调整 res 的长度，去掉高位的0 global cnt cnt = len(res) - 1 while cnt = 0 and res[cnt] == 0: cnt -= 1 cnt += 1 # 实际的位数 # 打印结果 (逆序打印，因为最低位在前面) # print(2^, original_p, = , end=) # if cnt == 0: # 如果结果是0，例如 2^负数 这种情况，虽然快速幂没有考虑负数 # print(0) # else: # for i in range(cnt - 1, -1, -1): # print(res[i], end=) # print() 示例调用quick_pow(10) # 计算 2^10 **高精度乘法解释** **什么是高精度乘法？** 高精度乘法是指当两个数字非常大，以至于它们的乘积超出了标准数据类型（如 int, long long 等）所能表示的范围时，我们需要一种方法来精确计算它们的乘积。通常，我们会将大数存储在数组或列表中，每个元素代表大数的一个位。 **实现原理 (以 multiply1 为例，res = res \\* a)：** 1. **存储方式：** 在C++和Python代码中，大数被存储在数组（或列表）中。res[0] 和 a[0] 存储的是个位，res[1] 和 a[1] 存储的是十位，以此类推。这种“低位在前”的存储方式方便进行乘法计算和进位处理。 - 例如，数字 123 存储为 [3, 2, 1]。 2. **初始化临时结果：** 创建一个足够大的临时数组 tmp（乘积的位数最多是两个乘数位数之和），并初始化为0。 3. **逐位相乘 (模拟小学乘法)：** - 我们遍历 res 的每一位 res[i] 和 a 的每一位 a[j]。 - 将 res[i] * a[j] 的结果加到 tmp[i + j] 上。 - **为什么是 tmp[i + j]？** 因为当个位 res[0] 乘以个位 a[0] 时，结果是 tmp[0]（个位）；当 res[1]（十位）乘以 a[0]（个位）时，结果是 tmp[1]（十位）；当 res[1]（十位）乘以 a[1]（十位）时，结果是 tmp[2]（百位）。这与我们手算乘法时错位相加的原理是完全一致的。 4. **处理进位：** - 在完成所有逐位相乘后，tmp 数组的每个位置上可能存储了不止一位的数字（例如，3 * 4 = 12，tmp[0] 可能是 12）。 - 从 tmp[0] 开始遍历，将当前位 tmp[i] 加上前一位的进位 t。 - res[i] = (tmp[i] + t) % 10：当前位的结果是 tmp[i] 和进位之和的个位。 - t = (tmp[i] + t) // 10：计算新的进位，用于下一位的处理。 - 这个过程确保了每一位都只存储一个数字，并将多余的进位传递给下一位。 **优化：** 在Python代码中，我增加了一些 if res[i] == 0 ... 的判断。如果一个数的当前位以及所有更高位都是0，那么再往后乘就没有意义了，可以提前退出循环，提高效率。这在C++的数组操作中也常见，但Python列表的 all() 操作可能会有额外的开销，主要为了语义上的清晰。 **快速幂解释** **什么是快速幂？** 快速幂是一种在 O(log n) 时间复杂度内计算 a^b 的算法，而不是传统的 O(n) 时间复杂度。它利用了指数的二进制表示来显著减少乘法操作的次数。 **实现原理 (以计算 2^p 为例)：** 1. **二进制分解：** 任何一个正整数 p 都可以被表示成二进制形式。例如，p = 10（十进制）是 1010（二进制）。 这意味着 10 = 8 + 2。 所以 2^10 = 2^(8 + 2) = 2^8 * 2^2。 2. **迭代过程：** - **初始化：** - res (result) 初始化为 1 (任何数的 0 次方都是 1)。 - a (base) 初始化为我们要计算的底数，这里是 2。 - p 是指数。 - **循环判断 p 的最低位：** - while p 0:：循环直到指数 p 变为 0。 - if p 1:：这是一个位运算，等价于 if p % 2 == 1，判断 p 的当前最低位是否为 1。 - 如果为 1，说明当前这一项 a^(2^k) 存在于 2^p 的分解中，所以我们需要将当前的 a 乘到结果 res 中。在代码中就是 multiply1() (即 res = res * a)。 - multiply2()：无论 p 的最低位是 0 还是 1，我们都需要将底数 a 自乘（即 a = a * a）。这是因为在下一次循环中，a 将代表 a 的平方（如果当前 a 是 2^1，下次就是 2^2；如果当前 a 是 2^2，下次就是 2^4，以此类推）。 - p = 1:：这是一个位运算，等价于 p = p // 2，将 p 右移一位，相当于除以 2，以便检查下一位。 快速幂思想运用在矩阵乘法上：可以看《真题技巧》的“斐波那契套路”。上面的高精度乘法有两个模板是给下面的快速幂服务的，其实思路都一样。 img src=../source/imgs/$fiilname/image-20250903190737136.png alt=image-20250903190737136 style=zoom:50%; / import math def multiply1(res, a): temp [0] * 1010 for i in range(500): for j in range(500): temp[i + j] + res[i] * a[j] t 0 for i in range(500): temp[i] + t res[i] temp[i] % 10 t temp[i] 10 return res def multiply2(a): temp [0] * 1010 for i in range(500): for j in range(500): temp[i + j] + a[i] * a[j] t 0 for i in range(500): temp[i] + t a[i] temp[i] % 10 t temp[i] 10 return a def quick_pow(p): res [0] * 501 a [0] * 501 res[0] 1 a[0] 2 while p ! 0: if p 1: res multiply1(res, a) a multiply2(a) p 1 return res n int(input())length int(n * math.log10(2) + 1)print(length) result_array quick_pow(n) result_array[0] - 1 cnt 0for i in range(499, -1, -1): if cnt 50: print() cnt 0 print(result_array[i], end””) cnt + 1print()","tags":["算法"]},{"title":"数据结构1","path":"/2024/10/05/数据结构1/","content":"绪论基本概念和术语逻辑结构 存储结构 在存储当前元素的时候顺便存储了下个元素的地址 接下来两个了解就可以 数据类型和抽象数据类型数据类型是一组性质相同的值的集合以及定义于这个值集合上的一组操作的总称。数据类型值的集合+值集合上的一组操作。 在定义一个变量的数据类型的时候也规定了它值的范围以及能进行的操作。 抽象数据类型就是一个概念 例子： 因为要返回C本身，所以前面加上 assigh是构建虚数 小结： 抽象数据类型的表示与实现 抽象数据类型利用处理器里已存在的数据类型来说明新的结构，用已经实现的操作来组合形成新的操作。 例如： 算法和算法分析 时间复杂度，求得时候只考虑算法中的基本操作执行的次数 若T(n)函数可以分解为T1(n)和T2(n)两个函数，则可以利用加法和乘法法则 空间复杂度 线性表定义和特点 这里面的数据a[i]只是一个抽象的符号，其具体含义在不同情况下可以不同。 同一线性表中的元素必定是具有相同特性，数据元素间的关系是线性关系，1-1的 线性表属于顺序存储结构，而顺序存储结构存在问题：存储空间分配不灵活，运算的空间复杂度高。 线性表有两种基本的存储结构：顺序存储结构和链式存储结构。 类型（抽象数据类型）定义 线性表的顺序表示顺序表示就是顺序存储结构 存储的时候不能改变它们的顺序，存储的空间也要是连续的，中间没有空出的存储单元。 存储线性表的一个模板（上面那个） 例子：存储多项式 c++中传地址的方式——引用类型作参数 从另一个角度说，i 和j 的地址是一样的，所以i 改变j 也会改变。 m是对a的引用，n是对b的引用，所以对m和n的操作就是对a和b的操作。这种方式比传指针要简单。 上面的那些红色字迹不用管，这题的期望值就是4。 线性表的链式表示 部分术语 双链表一个存储前驱的指针，一个存储后继的指针 头结点是额外附加的一个节点，有时会出现，所以链表的存储结构有两种形式：一种是有头结点的一种是没有的。 顺序表是随机存储，链表是顺序存取。 单链表 Lnode和*LinkList都是类型名，Lnode *a相当于LinkList a。 常用的是前两个 因为要直接改变L的值，所以用L。 销毁，c用free那前面就要用mallloc，c++用delete那前面就要用new 第2的那个算法，和上面计算个数的算法不一样，用这个算法计算表长（即没有ji-1这个条件）会多出一个。然后当j1时，它所记得这个1代表的是首元结点，此时指针指向第一个结点，所以从另一个角度看，可以认为这个算法就是寻找第j 个结点 。这个算法中pL而不是pL-next，是因为这样，当我们找到第j 个结点的时候，p 此时就指向这个结点，而不是这个下一个结点。并且这个算法同时也可以解决插入在最后面的情况，例如：表长为5，要插入在第六个结点，此时，j 值最多为6，所以，p 可以等于第5个结点，此时j 也等于5，p 也不为空，若p 为空，则说明要插入位置大于表长+1，是错的。 妙 也叫前插法，都接在头结点后面。 因为尾插法是在最后一项后面插入的，所以要多设一个变量来存储最后一项的信息；二头插法是从头开始插入的，已经有一个L存储了，所以不需要额外的一个变量。 循环链表 用尾指针表示循环链表更好。 两个链表合并： 注意最后return的是Tb 双向链表 双向单链表的头结点的prior为空 三种表的时间效率比较 双向循环链表牺牲空间换取时间 顺序表和链表的比较 线性表的应用 出循环的条件是pa或者pb为空，最后一项都输完了。 本方法不需要额外的空间，只需修改指针就可以了，所以空间复杂度为O(1)。 稀疏多项式相加 最后因为所有项都到Pa里了，Pb没有用 了，所以要释放Pb的头结点。 栈和队列栈和队列是限定插入和删除只能在表的“端点”进行的线性表。 栈，简称LIFO结构，插入新元素只能插入在表尾，删除元素也是从表尾开始。——后进先出 队列，插入新元素在表尾，删除元素从表头开始。——先进先出 栈是解决封闭对应问题的有效方法。 定义和特点栈： 可以一边入栈一边出栈，只要入栈顺序没变就行。 队列： 例子一、进制转化（栈） 二、括号匹配的检验（栈） 在外面的括号要晚匹配，在里面的括号要先匹配，相当于栈的后进先出。 三、表达式求值（栈） 后面会详细讲 接下来介绍的算法是有运算符优先级确定运算顺序的对表达式求值算法——算符优先算法 四、舞伴问题（队列） 栈的表示和实现 n0的时候叫做空栈 顺序栈 栈中的元素个数仍可以用top-base来算，其实top和base也可以是整型变量。 只要将top指针指向base指针，不管中间有哪些值，就是为空。 第一步delete是把数组回归内存了（base相当于是数组名），红色的几句是把结构体里的元素设置为空了。 top指针下移后，top所指的元素是否有值就无所谓了，不需要将其清除或者其他操作。 为什么要先减，因为top指针比存储的位置大1。 链栈 an里面存储的是前驱元素，不是后继元素，它的方向是从n-1的，和单链表的相反。（感觉方向没啥区别） 如果多一个头结点的话，那操作更加麻烦。 指针方向由上往下的话，那插入元素就相当于是头插法，因为S指向的是首元结点。 栈与递归 后调用的先返回，符合栈的特点，所以多个函数的嵌套就可以用栈来实现。 fact是一个用来计算阶层的函数。 在递归的过程中，由高级语言的系统自动生成一个栈存储相关数据。 递归的时间效率不高 一般情况下还是用递归 队列的表示和操作的实现 循环顺序队 不可以继续入队，会越界 链队 入队只能从队尾输入 但Q.front为空的时候才会跳出循环。 串，数组和广义表 串感觉就是字符串 应该是b 在d 中的位置是：5。 串相等：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。 所有的空串都是相等的。 类型定义和存储结构 串中元素的逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构。 顺序存储结构——顺序串；链式存储结构——链串。 一般不用ch[0]，这样可以为后面的算法带来简便。 存储数值的那个部分叫做块，如图。 串的模式匹配算法 BF算法BF，暴力破解法 返回第一个字符的序号 为什么i1，因为它存储时从1开始存的，0的位置没有存储。j应该是而不是 KMP算法 j 前面的字符，不包括j 本身。 其他情况就是j 前面的字符和从头开始的字符没有匹配的情况。 为什么j 会等于1呢，因为模式串存储也是从1 开始，0 并不存储。 为什么if 条件里面会有j0，因为当不匹配且当时j1的时候（也就是模式串第一位就不匹配），j 才会等于0，接下来主串和模式串都要往后移一位再继续比较，所以i++,j++。 下面是求next的 next值的改进-nextvalue next是一个一个慢慢比对过去，naxtvalue是一步到位。 例如：比对到第5位，原本第五位的next为2，那就将第五位的字符与第二位的字符比对，相同，则暂时为第二位字符的next值，然后第二位继续和第一位比，若相同就按照前面一部继续，不相同那 nextvalue 就等于第二位的next了。就是说因为第五位和第二位是相同的，所以第二位肯定不匹配，那就相当于jnext[2]了，接着假如next[2]这个位置的字符和第五位的又一样，那肯定也不能匹配，那就继续从这位的next继续比对，知道和第五位不同的位置停下来，那接下来就是要从这个位置开始比较最划算，那nextvalue就等于这个位置。或者就是第五位字符和第二位比对，相同就为第二位的nextvalue，不相同则nextvalue 等于next。 数组 L是一个存储元素的字节数，不乘L那求得就是这个元素前面有多少个元素，乘了那就是前面所占的空间。（不加a的话，a应该是首元素地址） 特殊矩阵的压缩存储 节省空间 对称矩阵对应存储到一维数组当中 an1的存储位置：(1+2+3+…+n-1)+(1-1)n(n-1)2 三角矩阵 存储方法和确认位置的方法和上面那个差不多，下三角矩阵ij是因为一行的除了常数c外的个数等于i 值，而要找三角里的元素，那j 肯定是i 的。上三角矩阵+1是因为对角线上的元素不是常数c。 对角矩阵 图中有三条对角线，所以是三对角矩阵。 稀疏矩阵 顺序存储结构 链式存储结构 上面和旁边的那个head存的是头指针。 广义表就是扩展的线性表，线性表里的每个元素都是同一种类型的，但是广义表里的不一定是。 线性表是特殊的广义表。 原子就是单一元素 表尾可以是空表。 第六种叫做递归的广义表；第五种直接用广义表的名字C和D，拥有共同的定义，叫做共享广义表 树和二叉树定义树 树是由根和子树组成的。 树是n个结点的有限集，树的定义是一个递归的定义。 凹入越深代表层次越低 结点的度既是它子树的个数又是它后继结点的个数又是它分支的个数。 这个树的度是3。 B,C,D为A的孩子，A就是B,C,D的双亲；双亲和孩子就是线性表里的前驱和后继。 拥有共同双亲的结点叫做兄弟。 树的深度（高度）：树中结点的最大层次。 这棵树的深度是4。 有序树：树中结点的各子树从左往右有次序（最左边的为第一个孩子）。（就是T1,T2,T3是一棵树，T1,T3,T2是另一棵树） 无序树：树中结点的各子树无次序。（T1,T2,T3和T2,T1,T3是同一棵树） 二叉树普通树若不转化为二叉树，则运算很难实现。 所有的树都可以和二叉树相互转化。 二叉树不是有序树，两个概念 二叉树的性质和存储结构性质1、在二叉树的第i 层上至多有2^(i-1)个结点(i1)，至少有1个结点。 2、深度为k的二叉树至多有2^k-1个结点(k1)，至少有k个结点。 n为结点数，边就是圈起来的那个，度为1的结点数是n1。 下面的两个式子相等即可以求出该结论。 重要的是分析过程，总边数那一行，左边的式子是从下往上分析，右边那个是从上往下分析，分析的都是边和结点之间的关系。 最后由最后两个式子可以推出性质3的结论。 两种特殊形式的二叉树满二叉树 满二叉树在同样深度的二叉树中结点个数和叶子结点个数最多。 完全二叉树 为什么第三个图形是非完全二叉树，因为第三个图形中的第6个结点没有对应满二叉树中的第六个结点，并且非完全里的第六个结点占据的是满二叉树里的第7个结点的位置。 在满二叉树中，从最后一个结点开始，连续地去掉任意个结点，即是一棵完全二叉树。 层次最大的两层就是最后一层和倒数第二层。 性质（4，5，关于完全二叉树的） 那个特殊符号代表的是取整 存储结构顺序存储结构 TElemType 代表的是数组里面要存储的元素（最好去看一下typedef后加数组的情况的解释）。 此时定义完的bt 代表一个数组，可以存储MAXSTIZE 个元素。 存储不是满二叉树的情况 缺点和前面的都差不多。 适用与满二叉树和完全二叉树。 链式存储结构二叉链表 三叉链表（便于寻找双亲） 遍历二叉树和线索二叉树遍历二叉树三种遍历方法依次遍历二叉树的三个组成部分就是遍历了整个二叉树。 D:根结点；L:左子树；R:右子树。 采用递归的方法遍历。 中序和后序遍历道理一样。 若题目要求将中缀表达式转化为后缀表达式，可以先将中缀表达式化作树的形式，然后再转化为后缀表达式。 若只知道先序和后序则不可以确认一棵二叉树。 判断完左右子树后，继续分析判断根和左右子树，直到左右子树中的一个 元素为空或为1，即可以判断元素位置。 后序遍历先左右后根，所以根位于最后，可以从后往前看。 上面两种题型都要先确定根 二叉树的遍历算法递归算法先序遍历 用二叉链表实现 T是指针。 visit(T)可直接替换为对根节点进行的操作。 中序遍历 后序遍历 紫色线路为算法的访问路径 非递归算法 因为是中序遍历，所以在遍历过程中，碰到根结点要先存储起来，等到第二次遍历到的时候在输出，符合栈的思想，所以要建立一个栈来存储根结点。 重点是理清先后关系。 TRUE为1 ，FALSE 为0 。 指针变量q用来存储栈里面弹出的根结点的值。 二叉树的层次遍历 入队 出队 a a b f b f c d f c d g c d g d g e g e h e h h 从队列中出一个结点然后将它的左右子树结点入队。 和二叉树的非递归算法有点类似 应用二叉树的建立 若输入的二叉树的结点中没有包含空结点，那根据这些结点所建立的二叉树不唯一，若将空结点一起输入，那建立的二叉树就是唯一的。 复制二叉树 计算二叉树的深度 计算某一子树的深度时，若mn则任意一个加一都会等于该子树的深度。 计算二叉树的结点数量 线索二叉树 结点的前驱和后继结点不是看树里的结点来判断的，而是看它的遍历顺序来判断。 这是中序遍历的线索二叉树 树和森林 树的存储结构双亲表示法 r 代表根结点的位置，n 代表数量。 孩子链表 特点：找孩子容易，找双亲难。 链表里的数据部分存储的是孩子结点的下标。 如何克服缺点，将双亲表示法和孩子链表相结合，在双亲结点中再添加一个空间用来存储该结点的双亲所在位置的下标。 孩子兄弟表示法（常用） 找双亲困难，但可以根据需要再添加一个指针域用来指向它的双亲结点。 树和二叉树的转化由于树和二叉树都可以用二叉链表作存储结构，则以二叉链表为媒介可以导出数和二叉树之间的对应关系。 一棵树的二叉链表是唯一的，而它对应的二叉树也是唯一的。 同一个二叉链表，左右指针域解释为孩子、兄弟则是树的存储方式，解释为左右子树，则是二叉树的存储形式。 森林与二叉树的转化与树和二叉树的转化类似 树和森林的遍历 第一棵树遍历完之后，剩下的第三部分继续看成森林，然后再分成三部分，继续遍历。 哈夫曼树及其应用基本概念 哈夫曼树的效率最高 结点数目相同的二叉树中，路径最短的不一定是完全二叉树。 树的度是树中各结点的度中的最大值。 权值较小的离根远，较大的离根近。 具有相同带权结点的哈夫曼树不唯一。 构造算法贪心算法：先挑权值小的叶子结点构造哈夫曼树。 Ti是只有一个带权为wi的根结点。 根据刚开始的举例，哈夫曼树中的结点为空的应该是判断条件。 哈夫曼树的结点的度为0或2，没有为1的。 n-1各新结点都是度为2的结点。 使用数组进存储时因为在后面给结点赋双亲结点和左右子树时比较容易。 初始状态，构造n个子树。 完成第一次循环，删除两个结点就是给两个结点的双亲结点赋值。 所以判断剩余结点的条件就是双亲结点是否为0. 哈夫曼树的应用——哈夫曼编码 每个字母都用固定长度的空间来存储，比较浪费。 因此让出现次数较多的字母用较少的空间来存储，可以减少浪费。 任意一个字符的编码都不是另一个字符的前缀，而哈夫曼树只有叶子结点有值，所以利用哈夫曼树进行编码可以避免出现重码。 解码采用暴力破解法（我觉得），但其实不是。 每个叶子结点的编码不用经过其它需要翻译的字符的结点，所以不会出现一个字符的编码是另一个字符的前缀的情况。 cd数组是用来暂时存储寻找字符的编码过程中的编码，从倒数第二个也就是第5位开始存储。 HC数组是用来存储字符编码的。 文件的编码和解码"},{"title":"C语言","path":"/2024/10/05/C语言-0/","content":"size和strlen 若先定义了一个字符数组却没有直接赋值，那么后面再直接赋值即B是不行的；采用A一个个输入可以；只能用C进行赋值。 在字符数组中，sizeof会将’\\0’计算在数组大小里面；strlen 则不会。 指针类函数指针 指针数组是数组，存储的是指针。 例：int arr[10]{0}; 整型数组，数组用来存放整型(int) int* parr[4]; //指针数组，数组用来存放整型指针(int *) []的优先级大于* 用法一：存储一些变量的地址 用法二：用来存储数组的头地址 数组指针是指针，存储的是数组的地址。 int arr[10] arr和arr的输出结果相同。但是arr表示的是一整个数组首元素的地址，而不是数组单个首元素的地址，所以arr+1，逃过的是整个数组的大小；arr表示的是数组首元素的地址，所以arr+1代表的是跳过一个元素。 用法一：用来表示一维数组 （1）第一种输出方式 解引用：指针被解除引用就是它所指向的变量了，解引用的操作符是’*’。 例如某指针变量p，解引用就是*p，也就是p所指向的变量了。 （2）第二种输出方式 用法二：处理二维数组，较经常使用，用于此比较简单 看课本去 c预处理器预处理器后面不需要“；” 某种程度上”#define”后面的名称相当于函数名称，再后面的东西相当于函数体 这些宏不能被修改，DATE和TIME得用%s。每个两侧是两个下划线。 \\一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符“\\”，然后就可以换行继续写了。可以参考下面的程序 使用“#”即可输出a,b且不需要定义a和b。message_for有点像函数，但从某种程度上比函数方便。 “#”不能在程序中使用 defined()预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。 参数化的宏可以用来写函数 在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。 使用#define含参时，参数括号很重要 算数转化 常用的算术转换不适用于赋值运算符、逻辑运算符 和 ||。 对于赋值运算符，如 “”，它并不执行算术转换。如果一个变量是 int 类型，而另一个变量是 double 类型，那么它们之间进行赋值运算时，double 类型的值不会被转换成 int 类型，而是直接将 double 类型的值赋给 int 类型的变量。 对于逻辑运算符 “” 和 “||”，C 语言中也没有进行算术转换。这两个运算符只对真和假进行逻辑判断，而不是进行算术运算。因此，无论表达式两边的值是什么类型，都不会进行算术转换。 例： #includestdio.h int main() int a = 5; double b = 3.14; // 赋值运算不执行算术转换 a = b; // a 的值现在是 3.14，而不是 3 // 逻辑运算符也不执行算术转换 if (a b) // 这里不会试图比较两个数的数值大小，而是直接比较它们的类型和值 printf(a is greater than b); 文件读写fopen函数用来打开文件，基本语法格式：FILE *fopen( const char *filename, const char *mode ); 在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个： `#include stdio.h` `int main() ` `FILE *fp;` `char c;` `fp = fopen(test.txt, r); // 打开名为test.txt的文件，以只读方式打开` `if (fp == NULL) // 如果打开文件失败` `printf(Failed to open file. );` `return 1;` `` `while ((c = fgetc(fp)) != EOF) // 从文件中读取一个字符，直到文件末尾` `printf(%c, c); // 输出读取到的字符` `` `fclose(fp); // 关闭文件` `return 0;` `` fclose函数关闭文件，基本语法格式：int fputc( int c, FILE *fp ); 如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。 写入文件将字符写入文件中：**int fputc( int c, FILE *fp )**;函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。 将字符串写入文件中：**int fputs( const char *s, FILE *fp )**;函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。 也可以使用 int fprintf(FILE *fp,const char *format, …) 函数把一个字符串写入到文件中。 `#include stdio.h` `int main()` `` `FILE *fp = NULL;` `fp = fopen(/tmp/test.txt, w+);` `fprintf(fp, This is testing for fprintf... );` `fputs(This is testing for fputs... , fp);` `fclose(fp);` `` 当上面的代码被编译和执行时，它会在 tmp 目录中创建一个新的文件 test.txt，并使用两个不同的函数写入两行。接下来让我们来读取这个文件。 读取文件读取单个字符：int fgetc( FILE * fp ); 读取字符串：char *fgets( char *buf, int n, FILE *fp );函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf（比如字符数组），并在最后追加一个 null 字符来终止字符串。如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘ ’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。 您也可以使用 int fscanf(FILE *fp, const char *format, …) 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。 递归先找递归出口；相当于while循环，没有符合出口条件就继续递归。 与直接的语句(如while循环)相比，递归函数会耗费更多的运行时间，并且要占用大量的栈空间。 采用递归方法来解决问题，必须符合以下三个条件： 1、可以把要解决的问题转化为一个新问题，而这个新的问题的解决方法仍与原来的解决方法相同，只是所处理的对象有规律地递增或递减。 说明：解决问题的方法相同，调用函数的参数每次不同（有规律的递增或递减），如果没有规律也就不能适用递归调用。 2、可以应用这个转化过程使问题得到解决。 说明：使用其他的办法比较麻烦或很难解决，而使用递归的方法可以很好地解决问题。 3、必定要有一个明确的结束递归的条件。 说明：一定要能够在适当的地方结束递归调用。不然可能导致系统崩溃。 深度优先遍历 题目：将一个正整数N分解成几个正整数相加，可以有多种分解方法，例如76+1，75+2，75+1+1，…。编程求出正整数N的所有整数分解式子。 输入格式： 每个输入包含一个测试用例，即正整数N (0N≤30)。 输出格式： 按递增顺序输出N的所有整数分解式子。递增顺序是指：对于两个分解序列N1{n1,n2,⋯}和N2{m1,m2,⋯}，若存在i使得n1m1,⋯,n**im**i，但是n**i+1m**i+1,则N1序列必定在N2序列之前输出。每个式子由小到大相加，式子间用分号隔开，且每输出4个式子后换行。 输入样例： 7 输出样例： 7=1+1+1+1+1+1+1;7=1+1+1+1+1+2;7=1+1+1+1+3;7=1+1+1+2+2 7=1+1+1+4;7=1+1+2+3;7=1+1+5;7=1+2+2+2 7=1+2+4;7=1+3+3;7=1+6;7=2+2+3 7=2+5;7=3+4;7=7 a[0]1-a[1]1-a[2]1-index3 ​ -a[1]2-index2 a[0]2-无法继续，递归没有出口就不用理会 a[0]3-index1 #include stdio.h int part[30]=0; int n,cout=0; void divide(int sub,int min,int m) if(sub==0) printf(%d=%d,n,part[0]); for(int i=1;im;i++) printf(+%d,part[i]); if(part[0]==n);//为了让最后一个输出没有分号 else if(cout3) cout++; printf(;); else cout=0; printf( ); else for(int i=min;i=sub;i++) part[m]=i; min=i; divide(sub-min,min,m+1); int main() int num; scanf(%d,num); n=num; divide(num,1,0); return 0; 可变参数定义一个函数，函数可以接受可变数量的参数. 常用的宏有： **va_start(ap, last_arg)**：初始化可变参数列表。ap 是一个 va_list 类型的变量，last_arg 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 ap 指向可变参数列表中的第一个参数。 **va_arg(ap, type)**：获取可变参数列表中的下一个参数。ap 是一个 va_list 类型的变量，type 是下一个参数的类型。该宏返回类型为 type 的值，并将 ap 指向下一个参数。 **va_end(ap)**：结束可变参数列表的访问。ap 是一个 va_list 类型的变量。该宏将 ap 置为 NULL。 `#include stdio.h` `#include stdarg.h` `double average(int num,...)` `` va_list valist; double sum = 0.0; int i; /* 为 num 个参数初始化 valist */ va_start(valist, num); /* 访问所有赋给 valist 的参数 */ for (i = 0; i num; i++) sum += va_arg(valist, int); /* 清理为 valist 保留的内存 */ va_end(valist); return sum/num; `` `int main()` `` `printf(Average of 2, 3, 4, 5 = %f , average(4, 2,3,4,5));` `printf(Average of 5, 10, 15 = %f , average(3, 5,10,15));` `` 输出结果为：Average of 2, 3, 4, 5 3.500000 Average of 5, 10, 15 10.000000 内存管理 malloc的内存空间不会初始化，值是未知的，calloc的内存空间会被初始化为0 realloc里面如果那个数组原本的空间为0的话，那realloc的功能相当于malloc 但是，如果您预先不知道需要存储的文本长度，例如您想存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示： 上面的程序也可以使用 calloc() 来编写，只需要把 malloc 替换为 calloc 即可，如下所示： calloc(200, sizeof(char)); 重新调整内存的大小 当上面的代码被编译和执行时，它会产生下列结果： Name = Zara Ali Description: Zara ali a DPS student.She is in class 10th 您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。 申请二维数组的空间方法一：二级指针 地址是连续的 方法二：数组指针 方法三：一维数组模拟二维数组 一般使用第一种和第二种方法，如果以指针为参数传递到一个函数一个二维数组要用方法一，方法二会报错。但是方法二简洁，然后用完要释放。 排序算法冒泡排序选择排序冒泡排序里，j0; #includestdio.h int main() int a[5]=3,1,7,5,4; int i,j,t; for(i=1;i5;i++) for(j=0;j5;j++) if(a[j]a[j+1]) t=a[j]; a[j]=a[j+1]; a[j+1]=t; for(i=0;i5;i++) printf(%d,a[i]); return 0; 选择排序： #includestdio.h int main() int a[5]=3,1,7,5,4; int i,j,t; for(i=0;i4;i++) for(j=i;j5;j++) if(a[j]a[i]) t=a[i]; a[i]=a[j]; a[j]=t; for(i=0;i5;i++) printf(%d ,a[i]); return 0; 插入排序 #includestdio.h void insertion_sort(int a[], int len) int i,t,temp; for(t=1;tlen;t++) temp=a[t]; for(i=t;i=0;i--) if(a[i-1]temp) a[i]=a[i-1]; else a[i]=temp; break; int main() int arr[] = 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ; int len = (int) sizeof(arr) / sizeof(*arr); insertion_sort(arr, len); int i; for (i = 0; i len; i++) printf(%d ,arr[i]); return 0; 归并排序稳定，速度快，适合大数据量的排序 #includestdio.h #includestdlib.h void printA(int* arr,int len) for(int i=0;ilen;i++) printf(%d ,arr[i]); printf( ); void merge(int* arr,int left,int mid,int right) int i=left; int j=mid; int* temp=(int*)malloc((right-left)*4); int index=0; while(imidjright) if(arr[i]arr[j]) temp[index]=arr[i]; i++; else temp[index]=arr[j]; j++; index++; while(imid) temp[index]=arr[i]; index++; i++; while(jright) temp[index]=arr[j]; index++; j++; for(int i=0;iindex;i++) arr[left+i]=temp[i]; free(temp); void mergeSort(int* arr,int left,int right) if(right-left=1) return; int mid=(left+right)/2; mergeSort(arr,left,mid); mergeSort(arr,mid,right); merge(arr,left,mid,right); int main() int* arr1=(int*)malloc(4*4); arr1[0]=10; arr1[1]=9; arr1[2]=8; arr1[3]=7; mergeSort(arr1,0,4); printA(arr1,4); return 0; 快速排序还没写 亦或异或运算符”∧”也称XOR运算符。它的规则是若参加运算的两个二进位同号，则结果为0（假）；异号则为1（真）。即 0∧0＝0，0∧1＝1， 1^01，1∧1＝0。 相同为0，不相同为1 运算 说明0 ^ 00,0 ^ 11，0亦或任何数，其结果任何数1 ^ 01,1 ^ 10，1亦或任何数，其结果任何数取反x ^ x0 任何数异或自己，等于把自己置0 常见用途: （1）使特定位翻转 比如：01111010，想使其低4位翻转，即1变为0，0变为1。可以将它与00001111进行∧运算，即 ​ 0111 1010 ​ 0000 1111 结果： 0111 0101 结果值的低4位正好是原数低4位的翻转。要使哪几位翻转就将与其∧运算的该几位置为1即可。这是因为原数中值为1的位与1进行∧运算得0，原数中的位值0与1进行∧运算的结果得1。 (2)实现两个值的交换 通过按位异或运算，可以实现两个值的交换，而不必使用临时变量。例如交换两个整数a3，b4的值，可通过下列语句实现： a＝a∧b;b＝b∧a;aa∧b; 0011 —a 3 0100 —b 4 -———- 0111—-a 7 0100—-b 4 -———- 0011—–b 3 0111——a 7 0100—-a 3 （3）还可以找到一组数内只出现一次的数，只需要把所有数一起做异或运算如：1 2 3 4 5 1 2 3 4 因为1^10，2^20，3^30，4^40，5^05 又异或满足交换律和结合律 1^2^3^4^5^1^2^3^45 所以5只出现了一次 strtok函数strtok 函数是 C 语言中用于分割字符串的函数。它在字符串中查找特定的分隔符，并将字符串分割成多个子字符串。以下是一些简单的 strtok 函数的例子： 一、基本使用 #include stdio.h #include string.h int main() char str[] = apple,orange,banana; char *token = strtok(str, ,); while (token != NULL) printf(%s , token); token = strtok(NULL, ,); return 0; 二、使用不同分隔符 #include stdio.h #include string.h int main() char str[] = apple orange:banana; char *token = strtok(str, :); while (token != NULL) printf(%s , token); token = strtok(NULL, :); return 0; 三、处理多个连续分隔符 #include stdio.h #include string.h int main() char str[] = apple,,orange,,banana; char *token = strtok(str, ,); while (token != NULL) printf(%s , token); token = strtok(NULL, ,); return 0; 输出： apple orange banana 请注意，strtok 函数在每次调用时会修改原始字符串，用 NULL 作为第一个参数来继续处理相同的字符串。 实例斐波那契数列#include stdio.h int main() int i, n, t1 = 0, t2 = 1, nextTerm; printf(输出几项: ); scanf(%d, n); printf(斐波那契数列: ); for (i = 1; i = n; ++i) printf(%d, , t1); nextTerm = t1 + t2; t1 = t2; t2 = nextTerm; return 0; 金字塔型图案使用字母 #include stdio.h int main() int i, j; char input, alphabet = A; printf(输入大写字母: ); scanf(%c,input); for(i=1; i = (input-A+1); ++i) for(j=1;j=i;++j) printf(%c, alphabet); ++alphabet; printf( ); return 0; 金字塔 #include stdio.h int main() int i, space, rows, k=0; printf(Enter number of rows: ); scanf(%d,rows); for(i=1; i=rows; ++i, k=0) for(space=1; space=rows-i; ++space) printf( ); while(k != 2*i-1) printf(* ); ++k; printf( ); return 0; space1比较巧妙，直接代表中间的那个“*”；但是k难一点 菱形可扩展 #include stdio.h int main() int i,j,k; for(i=0;i=3;i++) for(j=0;j=2-i;j++) printf( ); for(k=0;k=2*i;k++) printf(*); printf( ); for(i=0;i=2;i++) for(j=0;j=i;j++) printf( ); for(k=0;k=4-2*i;k++) printf(*); printf( ); 二进制转化为十进制#include stdio.h #include math.h int convertBinaryToDecimal(long long n); int main() long long n; printf(输入一个二进制数: ); scanf(%lld, n); printf(二进制数 %lld 转换为十进制为 %d, n, convertBinaryToDecimal(n)); return 0; int convertBinaryToDecimal(long long n) int decimalNumber = 0, i = 0, remainder; while (n!=0) remainder = n%10; n /= 10; decimalNumber += remainder*pow(2,i); ++i; return decimalNumber; 重点是pow的运用 @字符串的翻转#include stdio.h void reverseSentence(); int main() printf(输入一个字符串: ); reverseSentence(); return 0; void reverseSentence() char c; scanf(%c, c); if( c != ) reverseSentence(); printf(%c,c); 很巧妙，也可以用来翻转一串数字 矩阵转化for(i=0; ir; ++i) for(j=0; jc; ++j) transpose[j][i]= a[i][j]; 删除字符串中的特殊字符可以推广 #includestdio.h int main() char line[150]; int i, j; printf(输入一个字符串: ); fgets(line, (sizeof line / sizeof line[0]), stdin);//输入字符串 //gets(line); for(i = 0; line[i] != \\0; ++i) while (!( (line[i] = a line[i] = z) || (line[i] = A line[i] = Z) || line[i] == \\0) ) for(j = i; line[j] != \\0; ++j) line[j] = line[j+1]; line[j] = \\0; printf(输出: ); puts(line); return 0; 注意while循环里的条件 里面输入字符串是用fgets函数（看之后的笔记，估计得用stdin才能输入字符串到数组中），也可以用gets函数 fgets函数C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。 下面是 fgets() 函数的声明。 char *fgets(char *str, int n, FILE *stream) 参数 str – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。 n – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。 stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。 查找字符在字符串中出现的次数#include stdio.h int main(){ char str[1000], ch; int i, frequency 0; printf(“输入字符串: “); fgets(str, (sizeof str sizeof str[0]), stdin); printf(“输入要查找的字符: “); scanf(“%c”,ch); for(i 0; str[i] ! ‘\\0’; ++i) { if(ch str[i]) ++frequency; } printf(“字符 %c 在字符串中出现的次数为 %d”, ch, frequency); return 0;} 用这个if条件可以不需要输入要输多少或者判断字符串长度 约瑟夫生者死者小游戏（continue,逻辑）30 个人在一条船上，超载，需要 15 人下船。 于是人们排成一队，排队的位置即为他们的编号。 报数，从 1 开始，数到 9 的人下船。 如此循环，直到船上仅剩 15 人为止，问都有哪些编号的人下船了呢？ #includestdio.h int c = 0; int i = 1; int j = 0; int a[30] = 0 ; int b[30] = 0 ; int main() while (i=31) if (i == 31) i = 1; else if (c == 15) break; else if (b[i] != 0) i++; continue; else j++; if (j != 9) i++; continue; else b[i] = 1; a[i] = j;//可有可无 j = 0; printf(第%d号下船了 , i); i++; c++; continue的用法,但是这题用continue反而加大了难度。直接一个if就可以了。 经典1、将一个正整数分解质因数 #includestdio.h int main() int n,i; printf(请输入整数：); scanf(%d,n); printf(%d=,n); for(i=2;i=n;i++) while(n%i==0) printf(%d,i); n/=i; if(n!=1) printf(*); printf( ); return 0; 2、辗转相除法求两数的最大公约数和最小公倍数 #includestdio.h int main() int a,b,t,r,n; printf(请输入两个数字： ); scanf(%d %d,a,b); if(ab) t=b;b=a;a=t; r=a%b; n=a*b; while(r!=0) a=b; b=r; r=a%b; printf(这两个数的最大公约数是%d，最小公倍数是%d ,b,n/b); return 0; 3、 题目一、 你的程序要读入一行文本，其中以空格分隔为若干个单词，以.结束。你要输出每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如its算一个单词，长度为4。注意，行中可能出现连续的空格；最后的.不计算在内。 输入格式： 输入在一行中给出一行文本，以.结束 输出格式： 在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。 输入样例： Its great to see you here. 输出样例： 4 5 2 3 3 4 方法一.我自己的，比较规矩，不奇特 #includestdio.h #includestring.h int main() char sentence[1000]; int i,j=0,num[100]=0,len,m=0; gets(sentence); len=strlen(sentence); for(i=0;ilen;i++) if(sentence[i]!= ) if(sentence[i]!=.) num[j]++; m=1; else break; if(sentence[i]== m==1) j++; m=0; for(i=0;i=j;i++) if(num[i]==0) break; printf(%d,num[i]); if(i!=jm!=0) printf( ); return 0; 方法二：新奇，简单 #includestdio.h #includestring.h int main() int i=0,t = 0; int k = 0; int s[20] = 0 ; char arr[20]; while (1) scanf(%s, arr); t = strlen(arr); if (arr[t - 1] == .) t = t-1; s[i]=t; break; s[i]=t; i++; for(i=0;i20;i++) if (s[i] == 0) break; printf(%d, s[i]); return 0; @2、输入一个整数（位数不超过9位）代表一个人民币值（单位为元），请转换成财务要求的大写中文格式。如23108元，转换后变成“贰万叁仟壹百零捌”元。为了简化输出，用小写英文字母a-j顺序代表大写数字0-9，用S、B、Q、W、Y分别代表拾、百、仟、万、亿。于是23108元应被转换输出为“cWdQbBai”元。 输入格式： 输入在一行中给出一个不超过9位的非负整数。 输出格式： 在一行中输出转换后的结果。注意“零”的用法必须符合中文习惯。 输入样例1： 813227345 输出样例1： iYbQdBcScWhQdBeSf 输入样例2： 6900 输出样例2： gQjB 方法一 123456a[0]6a[1]5a[2]4a[3]3a[4]2a[5]1 数不超过9位，则最大位亿。用数组将每一位数分解储存，然后遍历。因为十、百、千在千位、百位、十位、千万位、百万位、十万位都要输出一次。所以要余4， 如果余数为0，则是个位、万位或者亿位不需要输出。 如果余数为1，则是十位或者十万位，需要输出S。 如果余数为2，则是百位或者百万位，需要输出B。 如果余数为3，则是千位或者千万位，需要输出Q。 如果遍历的数为0，根据实际情况不管多少0只输出一个。 如果遍历的数不为0，则进行上述余4，判断余数。 如果数最大为亿，则输出Y 如果是千万、百万、十万位、则要输出W #includestdio.h int main() int n,count=0; int num[10]=0; //用于存放数字的每一位，要初始化为0，不然会错 scanf(%d,n); while(n) //分解数字的各个位数 num[count++]=n%10; n/=10; for(int i=count-1;i=0;i--) if(num[i]!=0) //不为 0 switch(i%4) //十、百、千 是四个一循环 //如果余数为 0 根据实际则不用没有后面的 case 0: printf(%c,num[i]+a); break; case 1: printf(%cS,num[i]+a); break; case 2: printf(%cB,num[i]+a); break; case 3: printf(%cQ,num[i]+a); break; //用于输出数字中间有多个 0 的情况，这种情况只输出一个 0 else if(num[i]==0num[i-1]!=0i0) printf(%c,num[i]+a); if(i==8) //上亿的数输出 Y printf(Y); //如果上十万、百万、千万、亿的则输出 W else if(i==4(num[4]+num[5]+num[6]+num[7])0) printf(W); if(count==0) //如果数为 0 则输出 a printf(a); return 0; 方法二 #include stdio.h void f(int k); void g(int k); int main() int num; int i; scanf(%d,num); if(num==0) printf(a); int buf[10]=0; int cnt=0; do buf[cnt++]=num%10;//个位数存入数组 num/=10;//sum值改变 while(num!=0); for(int i=cnt-1;i=0;i--) if(buf[i]!=0) f(buf[i]); g(i); if(buf[i]==0(i==8||i==4)) g(i); if(buf[i]==0(i==2||i==6)buf[i-2]!=0) f(0); if(buf[i]==0(i==1||i==5)buf[i-1]!=0) f(0); return 0; void f(int k) switch (k) case 0:printf(a); break; case 1:printf(b); break; case 2:printf(c); break; case 3:printf(d); break; case 4:printf(e); break; case 5:printf(f); break; case 6:printf(g); break; case 7:printf(h); break; case 8:printf(i); break; case 9:printf(j); break; void g(int k) switch (k) case 1:printf(S); break; case 2:printf(B); break; case 3:printf(Q); break; case 4:printf(W); break; case 5:printf(S); break; case 6:printf(B); break; case 7:printf(Q); break; case 8:printf(Y); break; case 9:printf(S); break; 3、用亦或寻找单身狗数一、只有一个单身狗数 4、本题要求实现一个打印非负整数阶乘的函数。函数接口定义： void Print_Factorial ( const int N ); 其中N是用户传入的参数，其值不超过1000。如果N是非负整数，则该函数必须在一行中打印出N!的值，否则打印“Invalid input”。 裁判测试程序样例： #include stdio.h void Print_Factorial ( const int N ); int main() int N; scanf(%d, N); Print_Factorial(N); return 0; /* 你的代码将被嵌在这里 */ 输入样例： 15 输出样例： 1307674368000 void Print_Factorial(int N) int a[3000]; int temp,num,digit; //temp：每一位的结果 num:进位 digit：结果的位数 int i,j; a[0]=1; digit=1; //从第1位开始 if(N=0) for(i=2;i=N;i++) for(j=0;jdigit;j++) temp=a[j]*i+num; a[j]=temp%10; //把当前位的数字存入数字 num=temp/10; //向前面一位进位 while(num) //当现有位数算完，仍有进位，则数组需扩大 a[digit]=num%10; num/=10; digit++; for(i=digit-1;i=0;i--) printf(%d,a[i]); else printf(Invalid input); 5、这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数x，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字s，表示x乘以s是一个光棍，第二个数字n是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。 提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除x为止。但难点在于，s可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。 输入格式： 输入在一行中给出一个不以5结尾的正奇数x（1000）。 输出格式： 在一行中输出相应的最小的s和n，其间以1个空格分隔。 输入样例： 31 输出样例： 3584229390681 15 #includestdio.h #includemath.h int main() int N; scanf(%d,N); int i,x,n; i=1,n=N,x=1; while(n/10) n/=10; x+=pow(10,i); i++; if(N==x) printf(1 %d ,i); return 0; x+=pow(10,i); //比N多一位的光棍数 while(x%N) printf(%d,x/N); x=(x%N)*10+1; i++; printf(%d %d ,x/N,i+1); return 0; 6、 本题要求你实现一个稍微更值钱一点的 AI 英文问答程序，规则是： 无论用户说什么，首先把对方说的话在一行中原样打印出来； 消除原文中多余空格：把相邻单词间的多个空格换成 1 个空格，把行首尾的空格全部删掉，把标点符号前面的空格删掉； 把原文中所有大写英文字母变成小写，除了 I； 把原文中所有独立的 can you、could you 对应地换成 I can、I could—— 这里“独立”是指被空格或标点符号分隔开的单词； 把原文中所有独立的 I 和 me 换成 you； 把原文中所有的问号 ? 换成惊叹号 !； 在一行中输出替换后的句子作为 AI 的回答。 输入格式： 输入首先在第一行给出不超过 10 的正整数 N，随后 N 行，每行给出一句不超过 1000 个字符的、以回车结尾的用户的对话，对话为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。 输出格式： 按题面要求输出，每个 AI 的回答前要加上 AI: 和一个空格。 输入样例： 6 Hello ? Good to chat with you can you speak Chinese? Really? Could you show me 5 What Is this prime? I,don t know 输出样例： Hello ? AI: hello! Good to chat with you AI: good to chat with you can you speak Chinese? AI: I can speak chinese! Really? AI: really! Could you show me 5 AI: I could show you 5 What Is this prime? I,don t know AI: what Is this prime! you,dont know 答案： #includestdio.h #includestring.h #includectype.h #define len 10000 void substitute(char a[][len],char* q,char* t1,char* r1,int i); void dele(char a[][len],int i) int j=0; int k=0; int count=0; char temp[]= ; /*把行首的空格全部删掉*/ count=strlen(a[i]); for(;;) if(a[i][j]== ) j++; else break; for(k=0;j=count;j++) a[i][k++]=a[i][j]; /*把相邻单词间的多个空格换成 1 个空格*/ for(;;) if(strstr(a[i],temp)!=NULL) for(j=(strstr(a[i],temp)-a[i]);jcount;++j) a[i][j]=a[i][j+1]; else break; /*把标点符号前面的空格删掉*/ j=0; for(;jcount;++j) if(ispunct(a[i][j+1])!=0a[i][j]==32) for(k=j;kcount;++k) a[i][k]=a[i][k+1]; --j; /*把行尾的空格全部删掉*/ for(;;) count=strlen(a[i]); if(a[i][count-1]==32) a[i][count-1]=0; else break; return; /*把原文中所有独立的can you could you 对应地换成 I can、I could—— 这里“独立”是指被空格或标点符号分隔开的单词,把原文中所有独立的 I 和 me 换成 you*/ void replace(char a[][len],int i) char t1[]=can you; char t2[]=could you; char r1[]=i can; char r2[]=i could; int j=0; char t3[]=I; char t4[]=me; char r3[]=you; char *q=a[i]; /*can you*/ substitute(a,a[i],t1,r1,i); /*could you*/ substitute(a,a[i],t2,r2,i); /*I*/ substitute(a,a[i],t3,r3,i); /*me*/ substitute(a,a[i],t4,r3,i); /* i变成I*/ while(strstr(a[i],r1)!=NULL) q=strstr(a[i],r1); *q=I; /* i变成I*/ while(strstr(a[i],r2)!=NULL) q=strstr(a[i],r2); *q=I; /*感叹号替换*/ for(j=0;a[i][j]!=0;++j) if(a[i][j]==?) a[i][j]=!; return; /*把原文中所有大写英文字母变成小写，除了 I；把原文中所有的问号 ? 换成惊叹号 !；*/ void lower(char a[][len],int i) int j=0,cout; cout=strlen(a[i]); /*变小写*/ for(j=0;jcout;++j) if(a[i][j]!=I) a[i][j]=tolower(a[i][j]); return; void substitute(char a[][len],char* q,char* t1,char* r1,int i) char temp1[len]=0; int leap=0; int count=0; leap=strlen(t1); for(;;) if(strstr(q,t1)!=NULL) q=strstr(q,t1); if((isalnum(*(q-1))!=0q!=a[i])||isalnum(*(q+leap))!=0) q=q+leap; else count=q-a[i]; strncpy(temp1,a[i],count); strcat(temp1,r1); strcat(temp1,q+leap); strcpy(a[i],temp1); memset(temp1,0,len); else break; return; int main(void) char a[11][len]=0; int i=0; int n=0; scanf(%d,n); getchar(); for(i=0;in;++i) gets(a[i]); for(i=0;in;++i) printf(%s ,a[i]); dele(a,i); lower(a,i); replace(a,i); printf(AI: %s ,a[i]); return 0; 为什么要先变小写再替换呢？ 因为英文句子中的首字母要大写，所以can I会变成Can I，按理来说此时应该回答you can的，但是C为大写，不能识别，所以要先转化为小写。 qstrstr(q,t1);为什么括号里面是q呢？ 如果是a[i]的话，那每次q赋值都会从首地址开始找，若符合了if条件，那就会陷入无限循环中，且时间消耗也会更多，所以为q 更加合理。 题目经验1.遇到超过范围的数可以当作字符处理 #includestdio.h int main() int count[10]=0; char a; while((a=getchar())!= ) count[a-0]++; for(int i=0;i10;i++) if(count[i]!=0) printf(%d:%d ,i,count[i]); return 0; 可以处理1000位及以下的数；getchar的用法很巧妙 2、 每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。 输入格式： 输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：准考证号 试机座位号 考试座位号。其中准考证号由 16 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。 考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。 输出格式： 对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。 输入样例： 4 3310120150912233 2 4 3310120150912119 4 1 3310120150912126 1 3 3310120150912002 3 2 2 3 4 输出样例： 3310120150912002 2 3310120150912119 1 #includestdio.h struct stu char zhun[17]; int sj,ks; ; int main() struct stu a[1001]; int i,N,M; scanf(%d,N); for(i=0;iN;i++) scanf(%s %d %d,a[0].zhun,a[0].sj ,a[0].ks ); a[a[0].sj]=a[0]; scanf(%d,N); for(i=0;iN;i++) scanf(%d,M); printf(%s %d ,a[M].zhun ,a[M].ks ); return 0; struct结构可以直接赋值，但是数组不行 for循环里直接输入数字，就可以不用在创建一个数组，更加直接，效率更高 程序里面给struct结构的值赋值的仔细看 **3. **intchar a[2][10][ [‘h’,’e’,’l’,’l’,’o’], [‘w’,’o’,’r’,’l’,’d’] ]; 像a[1][8】这种没有存储字母的，里面存的是’0’,可以输出，%c,%d都可以，所以可以用”if a【i】【j】0”来判断当前这行的有效字符是否已经输完。 4、 printf(%d=%d,i,a[0]); for(n=1;n=k;n++) printf(+%d,a[n]); printf( ); 5、两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。 #include stdio.h int main() char i,j,k; for(i=x;i=z;i++) for(j=x;j=z;j++) if(i!=j) for(k=x;k=z;k++) if(i!=kj!=k) if(i!=xk!=xk!=z) printf(顺序为：a--%c\\tb--%c\\tc--%c ,i,j,k); return 0; 6、两个字符数组若字符串没有完全占满数组，则后面空出来的两个数组剩余部分都相同。 因此要注意该程序里的mt. 题目：输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。 输入格式： 输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。 输出格式： 在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。 输入样例： Tomcat is a male ccatat cat 输出样例： Tom is a male #includestdio.h #includestring.h int main() char a[81],b[81],i=0,t,m=0,len,c,n=1; gets(a); gets(b); t=strlen(b); len=strlen(a); while(n) n=0; for(i=0;i=len;i++) m=0; if(a[i]==b[m]) c=i; while(a[c]==b[m]mt) c++;m++; if(m==t) n=1; for(i;i=len;i++) a[i]=a[i+t]; break; printf(%s,a); return 0; 7、思想，旋转数组，逆置的思想 第一种：写函数，相对简单一点 第二种：不写函数，稍微麻烦一点，但不难 8、存储字符串里的单词，字符串以回车结束 #includestdio.h int main() char list[5][5],c; int i=0; do scanf(%s,list[i++]); c=getchar();//用c来存单词间的空格 while(c!= );//此循环用于存储句子 i--; for(i=0;i5;i++) printf(%s ,list[i]); return 0; 8、\tgets 函数在读取字符串的时候会将“回车”读取为’\\0’并存入数组中，所以在设置数组长度的时候最好为它预留空间，不然可能会出错。 9、在读取数字之后，scanf 会读取到换行符，然后将其留在输入缓冲区中。然后下一个 scanf 会读取这个换行符，因为 “%c” 格式可以读取空白字符（包括空格、制表符和换行符）。这导致了不希望的结果。 解决方法是在 “%c” 前添加一个空格，这样可以跳过空白字符。 10、把行尾的空格全部删掉 for(;;) count=strlen(a[i]); if(a[i][count-1]==32) a[i][count-1]=0; else break; 新的函数 strstr ispunct strncpy memset memset函数可以给整型数组统一赋值0或1，其他的很有可能会出错。 tolowertoupper小写转大写，用法和tolower一样 a[i][j]=tolower(a[i][j]); strncat strtok 返回值(这个返回值应该是对的，其他的看不大懂) 该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。 #include string.h #include stdio.h int main () char str[80] = This is - www.runoob.com - website; const char s[2] = -; char *token; /* 获取第一个子字符串 */ token = strtok(str, s); /* 继续获取其他的子字符串 */ while( token != NULL ) printf( %s , token ); token = strtok(NULL, s); return(0); 结果： This is www.runoob.com website islower头文件：stype.h 一些网上的笔记1、 2、 3、 4、移位操作符 5、 6、","tags":["语言"]},{"title":"Java","path":"/2024/10/05/Java-1/","content":"输出一个源文件中最多只能有一个 public 类，其它类的个数不限。 创建类就是class 后加 “类名字 {} ; ” 就可以了。 public class Hello //编写一个 main 方法 public static void main(String[] args) System.out.println(韩顺平教育 hello); 两个println之间会自动跳行，如果输出用的是print则和c语言中的printf一样。 对代码的相关说明1. public class Hello 表示 Hello 是一个类,是一个 public 公有的类2. Hello{ } 表示一个类的开始和结束3. public static void main(String[] args) 表示一个主方法,即我们程序的入口4. main() {} 表示方法的开始和结束5. System.out.println(“hello,world“); 表示输出”hello,world“到屏幕 6. ;表示语句结束 public static void main(String[] args)相当于int main()。 public class Dog //一个源文件中最多只能有一个 public 类。其它类的个数不限，也可以将 main 方法写在非 public 类中， //然后指定运行非 public 类，这样入口方法就是非 public 的 main 方法 public static void main(String[] args) System.out.println(hello, 小狗狗~); public class ChangeChar //编写一个 main 方法 public static void main(String[] args) int n=2; int m=5; int sum = n + m; System.out.println(sum); 输出变量不用双引号，然后就跟c语言里一样，不能一次性输出两个变量。 里面定义sum，它的第一轮运算（不包括赋值）必须在定义后面接着，像上面那样，但之后的运算就和以前一样了。 转义字符在控制台，输入 tab 键，可以实现命令补全 \\t ：一个制表位，实现对齐的功能 ：换行符 \\\\ ：一个\\ \\ :一个 \\ ：一个 \\r :一个回车 (r前面的好像输不出来) 变量public class Var02 //编写一个 main 方法 public static void main(String[] args) //记录人的信息 int age = 30; double score = 88.9; char gender = 男; String name = king; //输出信息, 快捷键 System.out.println(人的信息如下:); System.out.println(name); System.out.println(age); System.out.println(score); System.out.println(gender); 输出变量不用加双引号，且两句println中自带换行；另外，可以直接命名字符串为一个变量了，string 变量名”字符串”。 String类型的变量可以直接这样赋值：s1new String(“abc”)，数组的赋值用法。 char后面可以加汉字了。 变量在同一个作用域中不能重名，但不同的可以。 “+”的使用 注意是左右两项，然后从左到右，但是加括号可以改变运算顺序。 数据类型 整数 浮点型 细节:如果是直接查询得的的小数或者直接赋值，是可以判断相等 public class FloatDetail //编写一个 main 方法 public static void main(String[] args) //Java 的浮点型常量(具体值)默认为 double 型，声明 float 型常量，须后加‘f’或‘F //float num1 = 1.1; //对不对?错误 float num2 = 1.1F; //对的 double num3 = 1.1; //对 double num4 = 1.1f; //对 //十进制数形式：如：5.12 512.0f .512 (必须有小数点） double num5 = .123; //等价 0.123 System.out.println(num5); //科学计数法形式:如：5.12e2 [5.12 * 10 的 2 次方 ] 5.12E-2 [] System.out.println(5.12e2);//512.0 System.out.println(5.12E-2);//0.0512 //通常情况下，应该使用 double 型，因为它比 float 型更精确。 //[举例说明]double num9 = 2.1234567851;float num10 = 2.1234567851F; double num9 = 2.1234567851; float num10 = 2.1234567851F; System.out.println(num9); System.out.println(num10); //浮点数使用陷阱: 2.7 和 8.1 / 3 比较 //看看一段代码 double num11 = 2.7; double num12 = 2.7; //8.1 / 3; //2.7 System.out.println(num11);//2.7 System.out.println(num12);//接近 2.7 的一个小数，而不是 2.7 //得到一个重要的使用点: 当我们对运算结果是小数的进行相等判断是，要小心 //应该是以两个数的差值的绝对值，在某个精度范围类判断 if( num11 == num12) System.out.println(num11 == num12 相等); //正确的写法 , ctrl + / 注释快捷键, 再次输入就取消注释 if(Math.abs(num11 - num12) 0.000001 ) System.out.println(差值非常小，到我的规定精度，认为相等...); //细节:如果是直接查询得的的小数或者直接赋值，是可以判断相等 字符型字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符我们用字符串 String。 Java里的字符对应的是 Unicode 码。 public class CharDetail //编写一个 main 方法 public static void main(String[] args) //在 java 中，char 的本质是一个整数，在默认输出时，是 unicode 码对应的字符 //要输出对应的数字，可以(int)字符 char c1 = 97; System.out.println(c1); // a char c2 = a; //输出a 对应的 数字 System.out.println((int)c2); char c3 = 韩; System.out.println((int)c3);//38889 char c4 = 38889; System.out.println(c4);//韩 //char 类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码. System.out.println(a + 10);//107 //课堂小测试 char c5 = b + 1;//98+1== 99 System.out.println((int)c5); //99 System.out.println(c5); //99-对应的字符-编码表 ASCII(规定好的)=c 布尔类型 boolean 查看类的使用方法 基本数据类型转化自动类型转化 public class AutoConvertDetail //编写一个 main 方法 public static void main(String[] args) //细节 1： 有多种类型的数据混合运算时， //系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算 int n1 = 10; //ok //float d1 = n1 + 1.1;//错误 n1 + 1.1 = 结果类型是 double //double d1 = n1 + 1.1;//对 n1 + 1.1 = 结果类型是 double float d1 = n1 + 1.1F;//对 n1 + 1.1 = 结果类型是 float //细节 2: 当我们把精度(容量)大 的数据类型赋值给精度(容量)小 的数据类型时， //就会报错，反之就会进行自动类型转换。 // //int n2 = 1.1;//错误 double - int //细节 3: (byte, short) 和 char 之间不会相互自动转换 //当把具体数赋给 byte 时，(1)先判断该数是否在 byte 范围内，如果是就可以 byte b1 = 10; //对 , -128-127 // int n2 = 1; //n2 是 int // byte b2 = n2; //错误，原因： 如果是变量赋值，判断类型 // // char c1 = b1; //错误， 原因 byte 不能自动转成 char // // //细节 4: byte，short，char 他们三者可以计算，在计算时首先转换为 int 类型 byte b2 = 1; byte b3 = 2; short s1 = 1; //short s2 = b2 + s1;//错, b2 + s1 = int int s2 = b2 + s1;//对, b2 + s1 = int //byte b4 = b2 + b3; //错误: b2 + b3 = int // //boolean 不参与转换 boolean pass = true; //int num100 = pass;// boolean 不参与类型的自动转换 //自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型 //看一道题 byte b4 = 1; short s3 = 100; int num200 = 1; float num300 = 1.1F; double num500 = b4 + s3 + num200 + num300; //float - double int n1 = 10; //ok //float d1 = n1 + 1.1;//错误 n1 + 1.1 = 结果类型是 double 因为数字1.1没有定义数据类型，所以默认为double型。 强制类型转化在将容量大的数据类型转化为容量小的数据类型时需要用到，可能会造成精度降低或溢出，和c语言中一样。 第4点在上面自动类型转化有提到。 基本数据类型和String类型的转化 public class StringToBasic //编写一个 main 方法 public static void main(String[] args) //基本数据类型-String int n1 = 100; float f1 = 1.1F; double d1 = 4.5; boolean b1 = true; String s1 = n1 + ; String s2 = f1 + ; String s3 = d1 + ; String s4 = b1 + ; System.out.println(s1 + + s2 + + s3 + + s4); //System.out.println(s1 + s2 + s3 + s4);这样输出字符串之间没有空格 //String-对应的基本数据类型 String s5 = 123; //会在 OOP 讲对象和方法的时候回详细 //解读 使用 基本数据类型对应的包装类，的相应方法，得到基本数据类型 int num1 = Integer.parseInt(s5); double num2 = Double.parseDouble(s5); float num3 = Float.parseFloat(s5); long num4 = Long.parseLong(s5); byte num5 = Byte.parseByte(s5); boolean b = Boolean.parseBoolean(true); short num6 = Short.parseShort(s5); System.out.println(===================); System.out.println(num1);//123 System.out.println(num2);//123.0 System.out.println(num3);//123.0 System.out.println(num4);//123 System.out.println(num5);//123 System.out.println(num6);//123 System.out.println(b);//true //怎么把字符串转成字符 char - 含义是指 把字符串的第一个字符得到 //解读 s5.charAt(0) 得到 s5 字符串的第一个字符 1 System.out.println(s5.charAt(0)); 数据类型转化完后直接输出也可以。 System.out.println(s1); 在将 String 类型转成基本数据类型时，要确保String类型可以转化为有效的数据，比如 我们可以把 “123” , 转成一 个整数，但是不能把 “hello” 转成一个整数。 运算符算术运算符 “”也有点不同，相除的数中要有小数结果才会是小数，其他与c语言一样。 class ArithmeticOperator //编写一个 main 方法 public static void main(String[] args) // /使用 System.out.println(10 / 4); //从数学来看是 2.5, java 中 2 System.out.println(10.0 / 4); //java 是 2.5 // 注释快捷键 ctrl + /, 再次输入 ctrl + / 取消注释 double d = 10 / 4;//java 中 10 / 4 = 2, 2=2.0 System.out.println(d);// 是 2.0 // % 取模 ,取余 // 在 % 的本质 看一个公式!!!! a % b = a - a / b * b // -10 % 3 = -10 - (-10) / 3 * 3 = -10 + 9 = -1 // 10 % -3 = 10 - 10 / (-3) * (-3) = 10 - 9 = 1 // -10 % -3 = (-10) - (-10) / (-3) * (-3) = -10 + 9 = -1 System.out.println(10 % 3); //1 System.out.println(-10 % 3); // -1 System.out.println(10 % -3); //1 System.out.println(-10 % -3);//-1 double d = 10 / 4;//java 中 10 / 4 = 2, 2=2.0 % 的本质看一个公式!!!! a % b a - a b * b 关系运算符关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false。 逻辑运算符 （1）对于**短路与**而言，如果第一个条件为 false ,后面的条件不再判断 ，效率高。 ​ 对于**逻辑与**而言，如果第一个条件为 false ,后面的条件仍然会判断，效率低。 （2）||短路或：如果第一个条件为 true， 则第二个条件不会判断，最终结果为 true，效率高。 ​ | 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低。 三元运算符条件表达式 ? 表达式 1**:** 表达式 2**;**运算规则： 1. 如果条件表达式为 true，运算后的结果是表达式 1； 2. 如果条件表达式为 false，运算后的结果是表达式 2； //三元运算符细节 public class TernaryOperatorDetail //编写一个 main 方法 public static void main(String[] args) //表达式 1 和表达式 2 要为可以赋给接收变量的类型 //(或可以自动转换/或者强制转换) int a = 3; int b = 8; int c = a b ? (int)1.1 : (int)3.4;//可以的 double d = a b ? a : b + 3;//可以的，满足 int - double double d a b ? a : b + 3;可以的，满足 int - double 其他 标识符命名规范 1) 包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm 2) 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰] 比如： TankShotGame 3) 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小 驼峰， 简称 驼峰法] 比如： tankShotGame 4) 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 比如 ：定义一个所得税率 TAX_RATE 位运算符程序控制结构if+普通输入变量import java.util.Scanner;//导入 //if 的快速入门 public class If01 //编写一个 main 方法 public static void main(String[] args) //编写一个程序,可以输入人的年龄,如果该同志的年龄大于 18 岁, //则输出 你年龄大于 18,要对自己的行为负责,送入监狱 // //思路分析 //1. 接收输入的年龄, 应该定义一个 Scanner 对象 //2. 把年龄保存到一个变量 int age //3. 使用 if 判断，输出对应信息 //应该定义一个 Scanner 对象 Scanner myScanner = new Scanner(System.in); System.out.println(请输入年龄); //把年龄保存到一个变量 int age int age = myScanner.nextInt(); //使用 if 判断，输出对应信息 if(age 18) System.out.println(你年龄大于 18,要对自己的行为负责,送入监狱); System.out.println(程序继续...); 导入语句需要放在开头。 Scanner myScanner = new Scanner(System.in); myScanner可以替换成别的对象名字，然后下面的也要一起替换。 例： import java.util.Scanner; public class test public static void main(String[] args) Scanner two = new Scanner(System.in); int age =two.nextInt(); System.out.println(age); switch+输入字符第一种：switch用法和c 语言一样。 返回值不包括小数，但包括字符串。 第二种： switch(num) case 1 - System.out.println(春暖花开); case 2 - System.out.println(夏日凉风); case 3 - System.out.println(秋月盈盈); case 4 - System.out.println(冬雪皑皑); default - System.out.println(季节输入非法.); 第三种： for和c 一样 while和do while一样 breakpublic class ForExercise public static void main(String[] args) Scanner myScanner = new Scanner(System.in); String name; String passwd; int chance = 3; //登录一次 ，就减少一次 for( int i = 1; i = 3; i++) //3 次登录机会 System.out.println(请输入名字); name = myScanner.next(); System.out.println(请输入密码); passwd = myScanner.next(); //比较输入的名字和密码是否正确 //补充说明字符串 的内容 比较 使用的 方法 equals if(丁真.equals(name) 666.equals(passwd)) System.out.println(恭喜你，登录成功~); break; //登录的机会就减少一次 chance--; System.out.println(你还有 + chance + 次登录机会); equal方法目前只知道用来比较字符串。 格式：a字符串.equals(b字符串) equals()不能用于判断基本数据类型的变量。 x变量为基本数据类型，不能使用equals，比较的是引用类型的对象。 引用类型是 Java 语言中用户自定义的类型，包括类、接口、数组等。引用类型的对象是可变的，可以被修改。 equals针对的比较对象是引用类型， 在Java中Object对象是所有对象的父类，所以每个类都会有个equals的方法。 continue(1) continue 语句用于结束本次循环，继续执行下一次循环。 (2) continue 语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 , 这个和前面的标签的 使用的规则一样. 标签的使用 break label1 跳出label1。 若continue后面不加标签则和c 语言中的用法一样。 数组，排序，查找数组赋值class ForExercise public static void main(String[] args) double[] hens = 3, 5, 1, 3.4, 2, 50, 7.8, 88.8,1.1,5.6,100; System.out.println(===使用数组解决===); double totalWeight = 0; for( int i = 0; i hens.length; i++) //System.out.println(第 + (i+1) + 个元素的值= + hens[i]); totalWeight += hens[i]; System.out.println(总体重= + totalWeight + 平均体重= + (totalWeight / hens.length) ); 一、 直接给一个数组赋值 double[] hens = 3, 5, 1, 3.4, 2, 50, 7.8, 88.8,1.1,5.6,100; double hens[] = 3, 5, 1, 3.4, 2, 50, 7.8, 88.8,1.1,5.6,100; 第二个也可以但会发出警报，不规范，最好用第一个。 二、 第四种不一定要给数组赋初值，只要规定它的大小就可以了。 使用方法和c语言一样。 最好用int[] a int数组里面不能赋值字符串，所以第一行不行。 public class ArrayExercise01 //编写一个 main 方法 public static void main(String[] args) /* 创建一个 char 类型的 26 个元素的数组，分别 放置A-Z。 使用 for 循环访问所有元素并打印出来。 提示：char 类型数据运算 A+1 - B 思路分析 1. 定义一个 数组 char[] chars = new char[26] 2. 因为 A + 1 = B 类推，所以老师使用 for 来赋值 3. 使用 for 循环访问所有元素 */ char[] chars = new char[26]; for( int i = 0; i chars.length; i++) //循环 26 次 //chars 是 char[] //chars[i] 是 char chars[i] = (char)(A + i); //A + i 是 int , 需要强制转换 //循环输出 System.out.println(===chars 数组===); for( int i = 0; i chars.length; i++) //循环 26 次 System.out.print(chars[i] + ); chars[i] = (char)(A + i); //A + i 是 int , 需要强制转换 这步和c语言中的不一样，需要强制转化，不然会出问题。char可以自动转化为int，但是int 不能自动转化char。但是如果是chars[i]97+i；就不需要强制转化，输出也是字符。 里面定义了数组chars，而chars.length就表示这个数组的长度，不用赋值。 class ForExercise public static void main(String[] args) int[] scores = 88,99,100,92; int i; int[] number; number = scores; for(i=0;i4;i++) System.out.println(number[i]); 两个数组名可以直接相等，赋的值是地址，也就是number现在指向的就是scores数组，所以修改number数组里的值，scores数组里的值也会发生变化。number = scores;这句话的意思是让number指向scores的数据空间。 复制数组arraycopy () 原数组的起始索引代表开始复制的地方，目标数组的起始索引代表开始替代的地方，起始索引是数组中的下标值。 copyOfRange需要引入，import java.util.Arrays; Arrays.copyOfRange(int[] original, int from, int to)方法 ——- 拷贝从from(包括)到to(不包括)位置的数组 target Arrays.copyOfRange(source2,0,source2.length); target——目标数组，source2——要复制的数组。 copyOf需要引入，import java.util.Arrays; Arrays.copyOf(int[] original, int newLength)方法 ——- 截断或扩充数组（补0） target Arrays.copyOf(source2, source2.length); target——目标数组，source2——要复制的数组。 添加扩容do int[] arrNew = new int[arr.length + 1]; for(int i = 0; i arr.length; i++) arrNew[i] = arr[i]; System.out.println(请输入你要添加的元素); int addNum = myScanner.nextInt(); //把 addNum 赋给 arrNew 最后一个元素 arrNew[arrNew.length - 1] = addNum; //让 arr 指向 arrNew arr = arrNew; //输出 arr 看看效果 System.out.println(====arr 扩容后元素情况====); for(int i = 0; i arr.length; i++) System.out.print(arr[i] + \\t); //问用户是否继续 System.out.println(是否继续添加 y/n); char key = myScanner.next().charAt(0); if( key == n) //如果输入 n ,就结束 break; while(true); int[] arrNew = new int[arr.length + 1];这句话虽然在循环当中数组名不变，但是会给它赋予新的空间，应该会导致这个数组变成一个新的数组，可参考数据结构里的赋值情况。 排序查找String[] names = 白眉鹰王, 金毛狮王, 紫衫龙王, 青翼蝠王; Scanner myScanner = new Scanner(System.in); System.out.println(请输入名字); String findName = myScanner.next(); //遍历数组，逐一比较，如果有，则提示信息，并退出 //这里老师给大家一个编程思想/技巧, 一个经典的方法 int index = -1; for(int i = 0; i names.length; i++) //比较 字符串比较 equals, 如果要找到名字就是当前元素 if(findName.equals(names[i])) System.out.println(恭喜你找到 + findName); System.out.println(下标为= + i); //把 i 保存到 index index = i; break;//退出 if(index == -1) //没有找到 System.out.println(sorry ,没有找到 + findName); 这边比较字符串可直接使用equals。 二维数组int[][] arr = 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0 ; System.out.println(二维数组的元素个数= + arr.length); //(2) 二维数组的每个元素是一维数组, 所以如果需要得到每个一维数组的值 // 还需要再次遍历 //(3) 如果我们要访问第 (i+1)个一维数组的第 j+1 个值 arr[i][j]; // 举例 访问 3, =》 他是第 3 个一维数组的第 4 个值 arr[2][3] System.out.println(第 3 个一维数组的第 4 个值= + arr[2][3]); //3 //输出二维图形 for(int i = 0; i arr.length; i++) //遍历二维数组的每个元素 //遍历二维数组的每个元素(数组) //老韩解读 //1. arr[i] 表示 二维数组的第 i+1 个元素 比如 arr[0]：二维数组的第一个元素 //2. arr[i].length 得到 对应的 每个一维数组的长度 for(int j = 0; j arr[i].length; j++) System.out.print(arr[i][j] + ); //输出了一维数组 System.out.println();//换行 System.out.println();//换行 System.out.println(二维数组的元素个数= + arr.length); //(2) 二维数组的每个元素是一维数组, 所以如果需要得到每个一维数组的值 // 还需要再次遍历 arr.length代表的是二维数组中第一层的元素个数，也就是里面一维数组的个数。 arr[i].length代表的是二维数组中的第 i+1 个一维数组中的元素个数。 初始化 第二种相当于是二维数组里的每个元素单独赋值，不过这边用的是“（）”而不是“{}”。 动态初始化，当列数不确定时 public class ForExercise public static void main(String[] args) int[][] arr = new int[3][]; for(int i = 0; i arr.length; i++) //遍历 arr 每个一维数组 //给每个一维数组开空间 new //如果没有给一维数组 new ,那么 arr[i]就是 null arr[i] = new int[i + 1]; //遍历一维数组，并给一维数组的每个元素赋值 for(int j = 0; j arr[i].length; j++) arr[i][j] = i + 1;//赋值 System.out.println(=====arr 元素=====); //遍历 arr 输出 for(int i = 0; i arr.length; i++) //输出 arr 的每个一维数组 for(int j = 0; j arr[i].length; j++) System.out.print(arr[i][j] + ); System.out.println();//换行 二维数组的行数必须确认，列数可暂时不规定。 二维数组中的每个一维数组的空间大小可以不相同。 面向对象编程（基础）类与对象引入class ForExercise public static void main(String[] args) Cat cat1 = new Cat(); cat1.name = 小白; cat1.age = 3; cat1.color = 白色; cat1.weight = 10; //创建了第二只猫，并赋给 cat2 //cat2 也是一个对象(猫对象) Cat cat2 = new Cat(); cat2.name = 小花; cat2.age = 100; cat2.color = 花色; cat2.weight = 20; //怎么访问对象的属性呢 System.out.println(第 1 只猫信息 + cat1.name + + cat1.age + + cat1.color + + cat1.weight); System.out.println(第 2 只猫信息 + cat2.name + + cat2.age + + cat2.color + + cat2.weight); class Cat //属性/成员变量 String name; //名字 int age; //年龄 String color; //颜色 double weight; //体重 //行为 //1. new Cat() 创建一只猫(猫对象) //2. Cat cat1 = new Cat(); 把创建的猫赋给 cat1 //cat1就是一个对象 对于Cat这个类的定义在程序的前面或者后面都可以，位置没有规定，只要有定义就可以。 cat1只是对象名，new Cat()创建的对象空间（数据）才是真正的对象。 类与对象的关系 属性成员变量字段（1）从概念或叫法上看： 成员变量 属性 field(字段) （即 成员变量是用来表示属性的，授课中，统一叫 属性)。 （2）属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)。 就是类的定义里的那些量。 有默认值，public啥的参考c++（我觉得）。 class Person //四个属性 int age; String name; double sal; boolean isPass; 这个赋值跟数组那边的指向那个数组类似，这边修改p2里的值，p1里的值也会发生变化。 即p2.age=12这句话可以改变p2里的age但不能改变p1里的age。 类和对象的内存分配 字符串属于常量 成员方法引入即函数 class ForExercise public static void main(String[] args) //方法使用 //1. 方法写好后，如果不去调用(使用)，不会输出 //2. 先创建对象 ,然后调用方法即可 Person p1 = new Person(); p1.speak(); //调用方法 p1.cal01(); //调用 cal01 方法 p1.cal02(5); //调用 cal02 方法，同时给 n = 5 p1.cal02(10); //调用 cal02 方法，同时给 n = 10 //调用 getSum 方法，同时 num1=10, num2=20 //把 方法 getSum 返回的值，赋给 变量 returnRes int returnRes = p1.getSum(10, 20); System.out.println(getSum 方法返回的值= + returnRes); class Person String name; int age; //方法(成员方法) //添加 speak 成员方法,输出 “我是一个好人” //老韩解读 //1. public 表示方法是公开 //2. void ： 表示方法没有返回值 //3. speak() : speak 是方法名， () 形参列表 //4. 方法体，可以写我们要执行的代码 //5. System.out.println(我是一个好人); 表示我们的方法就是输出一句话 public void speak() System.out.println(我是一个好人); //添加 cal01 成员方法,可以计算从 1+..+1000 的结果 public void cal01() //循环完成 int res = 0; for(int i = 1; i = 1000; i++) res += i; System.out.println(cal01 方法 计算结果= + res); //添加 cal02 成员方法,该方法可以接收一个数 n，计算从 1+..+n 的结果 //老韩解读 //1. (int n) 形参列表， 表示当前有一个形参 n, 可以接收用户输入 public void cal02(int n) //循环完成 int res = 0; for(int i = 1; i = n; i++) res += i; System.out.println(cal02 方法 计算结果= + res); //添加 getSum 成员方法,可以计算两个数的和 //老韩解读 //1. public 表示方法是公开的 //2. int :表示方法执行后，返回一个 int 值 //3. getSum 方法名 //4. (int num1, int num2) 形参列表，2 个形参，可以接收用户传入的两个数 //5. return res; 表示把 res 的值， 返回 public int getSum(int num1, int num2) int res = num1 + num2; return res; 类里面的函数和c++里的一样要加上public啥的。 方法，接收一个二维数组 //方法，接收一个二维数组 public void printArr(int[][] map) System.out.println(=======); //对传入的 map 数组进行遍历输出 for(int i = 0; i map.length; i++) for(int j = 0; j map[i].length; j++) System.out.print(map[i][j] + _); System.out.println(); 方法，返回一个数组 想要同时返回多个值，那就选择返回数组。返回的应该是数组地址。 int[] res = a.getSumAndSub(1, 4); public int[] getSumAndSub(int n1, int n2) int[] resArr = new int[2]; // resArr[0] = n1 + n2; resArr[1] = n1 - n2; return resArr; //2. 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象) //细节: 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型 的参数 byte b1 = 1; byte b2 = 2; a.getSumAndSub(b1, b2);//byte - int //a.getSumAndSub(1.1, 1.8);//double -int(×) 注意事项参数列表中的数，如果输入的数和定义的类型不同，但是可以自动转化也可以。 //细节: 方法不能嵌套定义 public void f4() //错误 // public void f5() // class A //同一个类中的方法调用：直接调用即可 // public void print(int n) System.out.println(print()方法被调用 n= + n); public void sayOk() //sayOk 调用 print(直接调用即可) print(10); System.out.println(继续执行 sayOK()~~~); //跨类中的方法 A 类调用 B 类方法：需要通过对象名调用 public void m1() //创建 B 对象, 然后在调用方法即可 System.out.println(m1() 方法被调用); B b = new B(); b.hi(); System.out.println(m1() 继续执行:)); class B public void hi() System.out.println(B 类中的 hi()被执行); 跨类中的方法 A 类调用 B 类方法要先在A类中创建B对象，然后通过”对象名.方法名“调用。 成员方法传参机制大部分和c语言中的形参，实参关系一样。 B 类中编写一个方法 test200，可以接收一个 Person(age,sal)对象，在方法中修改该对象属性，看看原来的对象是否变化？会变化. class ForExercise public static void main(String[] args) B b=new B(); Person p = new Person(); p.name = jack; p.age = 10; b.test200(p); //测试题, 如果 test200 执行的是 p = null ,下面的结果是 10 //测试题, 如果 test200 执行的是 p = new Person();..., 下面输出的是 10 System.out.println(main 的 p.age= + p.age);//10000 class Person String name; int age; class B public void test200(Person p) p.age = 10000; //修改对象属性 //思考 //p = new Person(); //p.name = tom; //p.age = 99; //思考 //p = null; 在成员方法中直接修改传进来的对象属性，则外面的对象属性也会一起变化； 第二个是建立一个新的对象，相当于给p赋一个新的地址而不是通过p去修改属性，所以外面的p不会变化，就像c语言中想要修改传进函数中的地址时，需要双指针int** a这时候*a代表的时地址，通过修改*a才能改变外面的int *a； 第三个给p赋null原理和第二个一样。 public void test200(Person p) Person p2 = new Person(); p2 = p; p2.age = 10000; 这种方法（地址的传递）也会改变p中的值。 方法重载java 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致！ 形参列表不一致的意思是形参数量不一样或者是数量一样的情况下形参类型不一样。 案例： 类：MyCalculator 方法：calculate calculate(int n1, int n2) 两个整数的和 calculate(int n1, double n2) 一个整数，一个 double 的和 calculate(double n2, int n1)一个 double ,一个 Int 和 calculate(int n1, int n2,int n3)三个 int 的和 若只是一个方法的访问修饰符不同，则第二个方法相当于是第一个方法的重复而不是重载。 可变参数java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法，就可以通过可变参数实现。 语法：访问修饰符 返回类型 方法名(数据类型… 形参名) { } 例子： 类 HspMethod，方法 sum 【可以计算 2 个数的和，3 个数的和 ， 4. 5， 。。】 这题可以一个个利用方法重载写方法，或者利用可变参数。 方法名称相同，功能相同, 参数个数不同- 使用可变参数优化 class B //可以计算 2 个数的和，3 个数的和 ， 4. 5， 。。 //1. int... 表示接受的是可变参数，类型是 int ,即可以接收多个 int(0-多) //2. 使用可变参数时，可以当做数组来使用 即 nums 可以当做数组 //3. 遍历 nums 求和即可 public int sum(int... nums) //System.out.println(接收的参数个数= + nums.length); int res = 0; for(int i = 0; i nums.length; i++) res += nums[i]; return res; nums.length代表的是可变参数的个数； HspMethod m = new HspMethod(); System.out.println(m.sum(1, 5, 100)); //106 System.out.println(m.sum(1,19)); //20 调用还是像之前一样，方法里的nums并不需要出现在调用时的参数列表中。 class VarParameterDetail //编写一个 main 方法 public static void main(String[] args) //细节: 可变参数的实参可以为数组 int[] arr = 1, 2, 3; T t1 = new T(); t1.f1(arr); class T public void f1(int... nums) System.out.println(长度= + nums.length); //细节: 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后 public void f2(String str, double... nums) //细节: 一个形参列表中只能出现一个可变参数 //下面的写法是错的. // public void f3(int... nums1, double... nums2) // 使用可变参数时，可以当做数组来使用——scores[i] class VarParameterExercise //编写一个 main 方法 public static void main(String[] args) HspMethod hm = new HspMethod(); System.out.println(hm.showScore(milan , 90.1, 80.0 )); System.out.println(hm.showScore(terry , 90.1, 80.0,10,30.5,70 )); class HspMethod /* 有三个方法，分别实现返回姓名和两门课成绩(总分)， 返回姓名和三门课成绩(总分)，返回姓名和五门课成绩（总分）。 封装成一个可变参数的方法 */ //分析 1. 方法名 showScore 2. 形参(String ,double... ) 3. 返回 String //听课小伙伴，老师要求必须自己动手写 public String showScore(String name ,double... scores ) double totalScore = 0; for(int i = 0; i scores.length; i++) totalScore += scores[i]; return name + 有 +scores.length + 门课的成绩总分为= + totalScore; return name + 有 +scores.length + 门课的成绩总分为= + totalScore; 返回一个字符串。 作用域 这边的全局变量指的是在一个类中可以随便用的变量，而局部变量指的是在这个类中的方法中定义的变量，出了这个方法就不能使用。 修饰符就是public啥的 构造方法构造器前面我们在创建人类的对象时，是先把一个对象创建好后，再给他的年龄和姓名属性赋值，如 果现在我要求，在创建人类的对象时，就直接指定这个对象的年龄和姓名，该怎么做? 这时就可以使用构造器。 class VarParameterExercise //编写一个 main 方法 public static void main(String[] args) //当我们 new 一个对象时，直接通过构造器指定名字和年龄 Person p1 = new Person(smith, 80); System.out.println(p1 的信息如下); System.out.println(p1 对象 name= + p1.name);//smith System.out.println(p1 对象 age= + p1.age);//80 //在创建人类的对象时，就直接指定这个对象的年龄和姓名 // class Person String name; int age; //构造器 //老韩解读 //1. 构造器没有返回值, 也不能写 void //2. 构造器的名称和类 Person 一样 //3. (String pName, int pAge) 是构造器形参列表，规则和成员方法一样 public Person(String pName, int pAge) System.out.println(构造器被调用~~ 完成对象的属性初始化); name = pName; age = pAge; 构造器没有返回值, 也不能写 void Person p1 new Person(“smith”, 80); Person p1 = new Person();这种形式现在就会报错了，除非显式表达一下，在下面。 构造器也可以重载 class Dog //如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器(也叫默认构造器) //使用 javap 指令 反编译看看 /* 默认构造器 Dog() */ //一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器， //除非显式的定义一下,即: Dog() 写 (这点很重要) // public Dog(String dName) //... Dog() //显式的定义一下 无参构造器 无参构造器的结构体可以添加程序，如age3; 对象创建的流程分析看不懂，基础不牢，等老师讲吧 就是后台程序的运行顺序 this关键字初始理解+hashcodeclass VarParameterExercise public static void main(String[] args) Dog dog1 = new Dog(大壮, 3); System.out.println(dog1 的 hashcode= + dog1.hashCode()); //dog1 调用了 info()方法 dog1.info(); System.out.println(============); Dog dog2 = new Dog(大黄, 2); System.out.println(dog2 的 hashcode= + dog2.hashCode()); dog2.info(); class Dog //类 String name; int age; // public Dog(String dName, int dAge)//构造器 // name = dName; // age = dAge; // //如果我们构造器的形参，能够直接写成属性名，就更好了 //但是出现了一个问题，根据变量的作用域原则 //构造器的 name 是局部变量，而不是属性 //构造器的 age 是局部变量，而不是属性 //== 引出 this 关键字来解决 public Dog(String name, int age)//构造器 //this.name 就是当前对象的属性 name this.name = name; //this.age 就是当前对象的属性 age this.age = age; System.out.println(this.hashCode= + this.hashCode()); public void info()//成员方法,输出属性 x 信息 System.out.println(this.hashCode= + this.hashCode()); System.out.println(name + \\t + age + \\t); 据我的理解，构造器里的name是局部变量，而this.name是属性的name。 this后面加的应该是属性，因为this.dName是错误的 dog1.info() 方法和 dog1.hashCode() 中两者返回的哈希码是一样的，而哈希码表示的是这个东西的存储位置，因此这里的调用都针对同一个 Dog 对象 dog1。 this.name.hashCode输出的是属性中name的哈希码；不同对象里的name的哈希码是不同的；name是String类的，所以有哈希码。 在构造器中，name 被赋值为 dName，即 name = dName;。 然后，this.name 和 dName 都引用同一个字符串对象，因为在 Java 中字符串是不可变的，并且字符串的 hashCode() 方法是基于字符串内容计算的。 String 类的 hashCode() 方法返回的是基于字符串内容计算出的哈希码，而不是对象的内存地址。 因此，如果两个字符串对象的内容相同（如 this.name 和 dName 在这个上下文中），它们的 hashCode() 返回值也是相同的。 System.out.println(this.hashCode= + this.age.hashCode()); 这句话是错误的，因为 this.age 是一个基本数据类型 int，而基本数据类型 int 没有 hashCode() 方法。hashCode() 是 Object 类的方法，只有对象类型才有这个方法，而基本数据类型是没有的。 在这个 Dog 类的代码示例中，System.out.println(this.hashCode= + this.hashCode()); 被用来输出当前 Dog 对象的哈希码。哈希码是一个整数，用于唯一标识对象的引用，在某种程度上表示对象在内存中的位置。 要理解 System.out.println(this.hashCode= + this.hashCode()); 的作用以及输出什么，我们可以分几个部分来分析： this.hashCode() 的作用: this 关键字指的是当前对象的引用。 hashCode() 是 Object 类的一个方法，返回一个哈希码值，通常不同对象的哈希码值是不同的，除非 hashCode() 方法被重写。 在构造器中的 System.out.println(this.hashCode= + this.hashCode());: 当创建一个新的 Dog 对象时，这个构造器会被调用。 this.hashCode() 会输出当前 Dog 对象的哈希码，帮助我们确认当前对象的内存地址（可以理解为对象的唯一标识）。 在 info 方法中的 System.out.println(this.hashCode= + this.hashCode());: 当调用 info 方法时，this.hashCode() 会再次输出当前对象的哈希码。 这样可以确认调用 info 方法的对象是哪个，验证 Dog 对象的哈希码。 深入理解this小结：简单的说就是哪个对象被调用，this就代表哪个对象。 switch (key) case 1: this.detail(); break; case 2: this.income(); break; case 3: this.pay(); break; case 4: this.exit(); break; default: System.out.println(输入有误，请重新选择！); 通过这样用this，可以调用这个类中的方法。 注意和细节 class VarParameterExercise public static void main(String[] args) Person p1 = new Person(mary, 20); Person p2 = new Person(mary, 20); System.out.println(p1 和 p2 比较的结果= + p1.compareTo(p2)); /* 定义 Person 类，里面有 name、age 属性，并提供 compareTo 比较方法， 用于判断是否和另一个人相等，提供测试类 TestPerson 用于测试, 名字和年龄完全一样，就返回 true, 否则返回 false */ class Person String name; int age; //构造器 public Person(String name, int age) this.name = name; this.age = age; //compareTo 比较方法 public boolean compareTo(Person p) //名字和年龄完全一样 // if(this.name.equals(p.name) this.age == p.age) // return true; // else // return false; // return this.name.equals(p.name) this.age == p.age; return this.name.equals(p.name) this.age == p.age;里面的this指的是调用这个函数的对象。 上面第四点：例子： 为 Rectangle 类编写一个带参数的构造方法，通过用户给出的长、宽创建矩形对象，再 编写一个默认的构造方法，在该方法中调用有参数的构造方法 面向对象编程（中级）IDEA常用快捷键 删除当前行, 默认是 ctrl + Y 自己配置 ctrl + d 复制当前行, 自己配置 ctrl + alt + 向下光标 补全代码 alt + 添加注释和取消注释 ctrl + 【第一次是添加注释，第二次是取消注释】 导入该行需要的类 先配置 auto import , 然后使用 alt+enter 即可 快速格式化代码 ctrl + alt + L 快速运行程序 自己定义 alt + R 生成构造器等 alt + insert [提高开发效率] 查看一个类的层级关系 ctrl + H [学习继承后，非常有用] 将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用] 自动的分配变量名 , 通过 在后面加 .var [老师最喜欢的] 还有很多其它的快捷键… control + O 在子类中重写方法。 一个普通类实现接口,就必须将该接口的所有方法都实现,可以使用 alt+enter （得先将光标放于该类上）来解决。 包基础知识 引入包 package com.hspedu.pkg; import java.util.Arrays; //注意: //老韩建议：我们需要使用到哪个类，就导入哪个类即可，不建议使用 *导入 //import java.util.Scanner; 表示只会引入 java.util 包下的 Scanner //import java.util.*;//表示将 java.util 包下的所有类都引入(导入) public class Import public static void main(String[] args) //使用系统提供 Arrays 完成 数组排序 int[] arr = -1, 20, 2, 13, 3; //比如对其进行排序 //传统方法是，自己编写排序(冒泡) //系统是提供了相关的类，可以方便完成 Arrays Arrays.sort(arr); //输出排序结果 for (int i = 0; i arr.length; i++) System.out.print(arr[i] + \\t); sort排序、collections、Integer升序排序：首先要引入Arrays包，import java.util.Arrays; 输出应该是[5,2,9,1,3] 降序排序：在引入Arrays包的基础上，再引入Collections,import java.util.Collections; 注意事项 访问修饰符 由继承得到的类叫作子类。 package com.hspedu.modifier; public class A //四个属性,分别使用不同的访问修饰符来修饰 public int n1 = 100; protected int n2 = 200; int n3 = 300; private int n4 = 400; public void m1() //在同一类中，可以访问 public protected 默认 private 修饰属性和方法 System.out.println(n1= + n1 + n2= + n2 + n3= + n3 + n4= + n4); protected void m2() void m3() private void m4() public void hi() //在同一类中，可以访问 public protected 默认 private 修饰属性和方法 m1(); m2(); m3(); m4(); package com.hspedu.modifier; public class B public void say() A a = new A(); //在同一个包下，可以访问 public , protected 和 默认修饰属性或方法,不能访问 private 属性或方法 System.out.println(n1= + a.n1 + n2= + a.n2 + n3= + a.n3 ); a.m1(); a.m2(); a.m3(); //a.m4(); 错误的 package com.hspedu.modifier; public class Test public static void main(String[] args) A a = new A (); a.m1(); B b = new B(); b.say(); //只有 默认和 public 可以修饰类 class Tiger 封装面向对象编程有三大特征：封装、继承和多态。 package com.hspedu.encap; public class a public static void main(String[] args) Person person = new Person(); person.setName(韩顺平); person.setAge(30); person.setSalary(30000); System.out.println(person.info()); System.out.println(person.getSalary()); //如果我们自己使用构造器指定属性 Person smith = new Person(smith, 80, 50000); System.out.println(====smith 的信息======); System.out.println(smith.info()); /* 那么在 java 中如何实现这种类似的控制呢? 请大家看一个小程序(com.hspedu.encap: Encapsulation01.java), 不能随便查看人的年龄,工资等隐私，并对设置的年龄进行合理的验证。年龄合理就设置，否则给默认 年龄, 必须在 1-120, 年龄， 工资不能直接查看 ， name 的长度在 2-6 字符 之间 */ class Person public String name; //名字公开 private int age; //age 私有化 private double salary; //.. public void say(int n,String name) //构造器 alt+insert public Person() //有三个属性的构造器 public Person(String name, int age, double salary) // this.name = name; // this.age = age; // this.salary = salary; //我们可以将 set 方法写在构造器中，这样仍然可以验证 setName(name); setAge(age); setSalary(salary); //自己写 setXxx 和 getXxx 太慢，我们使用快捷键 //然后根据要求来完善我们的代码. public String getName() return name; public void setName(String name) //加入对数据的校验,相当于增加了业务逻辑 if(name.length() = 2 name.length() =6 ) this.name = name; else System.out.println(名字的长度不对，需要(2-6)个字符，默认名字); this.name = 无名人; public int getAge() return age; public void setAge(int age) //判断 if(age = 1 age = 120) //如果是合理范围 this.age = age; else System.out.println(你设置年龄不对，需要在 (1-120), 给默认年龄 18 ); this.age = 18;//给一个默认年龄 public double getSalary() //可以这里增加对当前对象的权限判断 return salary; public void setSalary(double salary) this.salary = salary; //写一个方法，返回属性信息 public String info() return 信息为 name= + name + age= + age + 薪水= + salary; smith.age = 70;//错误，因为是private,所以得用特定的方法去访问或者修改这个属性，即setName 继承基础 ​\t继承可以跨包进行。 父类中private的属性子类不能直接使用。 package com.hspedu.extend_.improve_; //父类,是 Pupil 和 Graduate 的父类 public class Student //共有属性 public String name; public int age; private double score;//成绩 //共有的方法 public void setScore(double score) this.score = score; public void showInfo() System.out.println(学生名 + name + 年龄 + age + 成绩 + score); package com.hspedu.extend_.improve_; //让 Pupil 继承 Student 类 public class Pupil extends Student public void testing() System.out.println(小学生 + name + 正在考小学数学..); package com.hspedu.extend_.improve_; public class Graduate extends Student public void testing() //和 Pupil 不一样 System.out.println(大学生 + name + 正在考大学数学..); 若和上面三个处于同一个包中，以下两句可以省略 import com.hspedu.extend_.improve_.Graduate; import com.hspedu.extend_.improve_.Pupil; package com.hspedu.extend_.improve_; import com.hspedu.extend_.improve_.Graduate; import com.hspedu.extend_.improve_.Pupil; public class Extends01 public static void main(String[] args) com.hspedu.extend_.improve_.Pupil pupil = new Pupil(); pupil.name = 银角大王~; pupil.age = 11; pupil.testing(); pupil.setScore(50); pupil.showInfo(); System.out.println(=======); com.hspedu.extend_.improve_.Graduate graduate = new Graduate(); graduate.name = 金角大王~; graduate.age = 23; graduate.testing(); graduate.setScore(80); graduate.showInfo(); 已经引进了Pupil包，import com.hspedu.extend_.improve_.Pupil;，那下面的com.hspedu.extend_.improve_.Pupil pupil = new Pupil();可以变成Pupil pupil = new Pupil();，Graduate那个也是一样的道理。 像之前的Scanner，原本的Scanner input = new Scanner(System.in)也可以写作java.util.Scanner input = new Scanner(System.in)。 由于上面的类定义都是public，所以也可以在别的包中使用： 这个所处的包 import com.hspedu.extend_.improve_.Graduate; import com.hspedu.extend_.improve_.Pupil; public class a public static void main(String[] args) com.hspedu.extend_.improve_.Pupil pupil = new Pupil(); pupil.name = 银角大王~; pupil.age = 11; pupil.testing(); pupil.setScore(50); pupil.showInfo(); System.out.println(=======); com.hspedu.extend_.improve_.Graduate graduate = new Graduate(); graduate.name = 金角大王~; graduate.age = 23; graduate.testing(); graduate.setScore(80); graduate.showInfo(); import com.hspedu.extend_.improve_.Graduate; import com.hspedu.extend_.improve_.Pupil; 这两句不可以省略了，但下面的com.hspedu.extend_.improve_.Pupil pupil = new Pupil();在引入类后就可以变成Pupil pupil = new Pupil();了。 深入讨论 父类没有提供无参构造器但也没提供有参构造器的时候，仍然是默认调用父类的无参构造器。 上面的看下面的例子都能懂，调用子类构造器，会从最顶级的父类一直往下调用，直到你调用的这个子类的构造器为止。不懂可运行下面程序。 package com.hspedu.extend_; public class TopBase //父类是 Object public TopBase() //super(); Object 的无参构造器 System.out.println(构造器 TopBase() 被调用...);//1 package com.hspedu.extend_; public class Base extends TopBase //父类 //4 个属性 public int n1 = 100; protected int n2 = 200; int n3 = 300; private int n4 = 400; public Base() //无参构造器 System.out.println(父类 Base()构造器被调用....); public Base(String name, int age) //有参构造器 //默认 super() System.out.println(父类 Base(String name, int age)构造器被调用....); public Base(String name) //有参构造器 System.out.println(父类 Base(String name)构造器被调用....); //父类提供一个 public 的方法,返回了 n4 public int getN4() return n4; public void test100() System.out.println(test100); protected void test200() System.out.println(test200); void test300() System.out.println(test300); private void test400() System.out.println(test400); //call public void callTest400() test400(); package com.hspedu.extend_; import java.util.Arrays; //输入 ctrl + H 可以看到类的继承关系 public class Sub extends Base //子类 public Sub(String name, int age) //1. 老师要调用父类的无参构造器, 如下或者 什么都不写,默认就是调用 super() //super();//父类的无参构造器 //2. 老师要调用父类的 Base(String name) 构造器 //super(hsp); //3. 老师要调用父类的 Base(String name, int age) 构造器 super(king, 20); //细节： super 在使用时，必须放在构造器第一行 //细节: super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器 //this() 不能再使用了 System.out.println(子类 Sub(String name, int age)构造器被调用....); public Sub() //无参构造器 //super(); //默认调用父类的无参构造器 super(smith, 10); System.out.println(子类 Sub()构造器被调用....); //当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器 public Sub(String name) super(tom, 30); //do nothing... System.out.println(子类 Sub(String name)构造器被调用....); public void sayOk() //子类方法 //非私有的属性和方法可以在子类直接访问 //但是私有属性和方法不能在子类直接访问 System.out.println(n1 + + n2 + + n3); test100(); test200(); test300(); //test400();错误 //要通过父类提供公共的方法去访问 System.out.println(n4= + getN4()); callTest400();// package com.hspedu.extend_; public class ExtendsDetail public static void main(String[] args) // System.out.println(===第 1 个对象====); // Sub sub = new Sub(); //创建了子类对象 sub // System.out.println(===第 2 个对象====); // Sub sub2 = new Sub(jack); //创建了子类对象 sub2 System.out.println(===第 3 对象====); Sub sub3 = new Sub(king, 10); //创建了子类对象 sub3 sub3.sayOk(); //sub.sayOk(); super 本质分析 /** * 讲解继承的本质 */ public class a public static void main(String[] args) Son son = new Son();//内存的布局 //?- 这时请大家注意，要按照查找关系来返回信息 //(1) 首先看子类是否有该属性 //(2) 如果子类有这个属性，并且可以访问，则返回信息 //(3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..) //(4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object... System.out.println(son.name);//返回就是大头儿子 //System.out.println(son.getAge());//返回的就是 39 System.out.println(son.hobby);//返回的就是旅游 class GrandPa //爷类 String name = 大头爷爷; String hobby = 旅游; class Father extends GrandPa //父类 String name = 大头爸爸; private int age = 39; public int getAge() return age; class Son extends Father //子类 String name = 大头儿子; 看起来应该是从小到大，或者说遵循就近原则。 super关键字super 代表父类的引用，用于访问父类的属性、方法、构造器 有的知识看前面的super。 super 的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用 super 去访问爷爷类的成员； 如果多个基类(上级类)中都有同名的成员，使用 super 访问遵循就近原则。A-B-C cal方法就是该子类或其父类中的一个方法。 找 cal 方法时(cal() 和 this.cal())，顺序是: (1)先找本类，如果有，则调用 (2)如果没有，则找父类(如果有，并可以调用，则调用) (3)如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类 提示：如果查找方法的过程中，找到了，但是不能访问， 则报错, cannot access；父类和爷类都有但是父类的不能访问，也会报错，因为遵循就近原则。 如果查找方法的过程中，没有找到，则提示方法不存在 this.cal(); //等价 cal 找 cal 方法(super.call()) 的顺序是直接查找父类，其他的规则一样 n1是该子类或其父类的一个属性。 n1 和 this.n1 查找的规则是 (1) 先找本类，如果有，则调用 (2) 如果没有，则找父类(如果有，并可以调用，则调用) (3) 如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类 提示：如果查找属性的过程中，找到了，但是不能访问， 则报错, cannot access 如果查找属性的过程中，没有找到，则提示属性不存在 找 n1 (super.n1) 的顺序是直接查找父类属性，其他的规则一样 super和this的区别 方法重写覆盖 细节: 子类方法的返回类型和父类方法返回类型一样， 或者是父类返回类型的子类 注意事项和细节 多态基础介绍：方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。 具体表现： （1）方法的多态：重写和重载 （2）对象的多态： package com.hspedu.poly_.objectpoly_; public class Animal public void cry() System.out.println(Animal cry() 动物在叫....); package com.hspedu.poly_.objectpoly_; public class Cat extends Animal public void cry() System.out.println(Cat cry() 小猫喵喵叫...); package com.hspedu.poly_.objectpoly_; public class Dog extends Animal public void cry() System.out.println(Dog cry() 小狗汪汪叫...); package com.hspedu.poly_.objectpoly_; public class PolyObject public static void main(String[] args) //体验对象多态特点 //animal 编译类型就是 Animal , 运行类型 Dog Animal animal = new Dog(); //因为运行时 , 执行到改行时，animal 运行类型是 Dog,所以 cry 就是 Dog 的 cry animal.cry(); //小狗汪汪叫 //animal 编译类型 Animal,运行类型就是 Cat animal = new Cat(); animal.cry(); //小猫喵喵叫 多态的前提是：两个对象(类)存在继承关系。 向上和向下转型多态的向上转型 不能调用子类中的特有成员就是说明调用的是对父类中的方法进行重写的。 向上转型也可以这么写： Cat cat = new Cat(); Animal animal = cat; 多态向下转型 也可以 父类类型 引用名 （父类类型）父类引用，不过这样没啥用，使用方式还是和没转化前的一样，只能调用父类的东西。 package com.hspedu.poly_.detail_; public class Animal String name = 动物; int age = 10; public void sleep() System.out.println(睡); public void run() System.out.println(跑); public void eat() System.out.println(吃); public void show() System.out.println(hello,你好); package com.hspedu.poly_.detail_; public class Cat extends Animal public void eat()//方法重写 System.out.println(猫吃鱼); public void catchMouse()//Cat 特有方法 System.out.println(猫抓老鼠); package com.hspedu.poly_.detail_; public class Dog extends Animal //Dog 是 Animal 的子类 package com.hspedu.poly_.detail_; public class PolyDetail public static void main(String[] args) //向上转型: 父类的引用指向了子类的对象 //语法：父类类型引用名 = new 子类类型(); Animal animal = new Cat(); Object obj = new Cat();//可以吗? 可以 Object 也是 Cat 的父类 //向上转型调用方法的规则如下: //(1)可以调用父类中的所有成员(需遵守访问权限) //(2)但是不能调用子类的特有的成员 //(#)因为在编译阶段，能调用哪些成员,是由编译类型来决定的 //animal.catchMouse();错误 //(4)最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法 //，然后调用，规则我前面我们讲的方法调用规则一致。 animal.eat();//猫吃鱼.. animal.run();//跑 animal.show();//hello,你好 animal.sleep();//睡 //老师希望，可以调用 Cat 的 catchMouse 方法 //多态的向下转型 //(1)语法：子类类型 引用名 =（子类类型）父类引用; //问一个问题? cat 的编译类型 Cat,运行类型是 Cat Cat cat = (Cat) animal; cat.catchMouse();//猫抓老鼠 //(2)要求父类的引用必须指向的是当前目标类型的对象 Dog dog = (Dog) animal; //可以吗？不可以 System.out.println(ok~~); 属性没有重写之说,属性的值看编译类型 package com.hspedu.poly_.detail_; public class PolyDetail02 public static void main(String[] args) //属性没有重写之说！属性的值看编译类型 Base base = new Sub();//向上转型 System.out.println(base.count);// ？ 看编译类型 10 Sub sub = new Sub(); System.out.println(sub.count);//? 20 class Base //父类 int count = 10;//属性 class Sub extends Base //子类 int count = 20;//属性 instanceof 比较操作符，用于判断对象的运行类型是否为 XX 类型（后面的那个类型）或 XX 类型的子类型， 对象名 instanceof 类型名。 public class c public static void main(String[] args) BB bb = new BB(); System.out.println(bb instanceof BB);// true System.out.println(bb instanceof AA);// true //aa 编译类型 AA, 运行类型是 BB //BB 是 AA 子类 AA aa = new BB(); System.out.println(aa instanceof AA);//true System.out.println(aa instanceof BB);//true Object obj = new Object(); System.out.println(obj instanceof AA);//false String str = hello; //System.out.println(str instanceof AA);这句是错的,AA是一个类，str只是一个属性 System.out.println(str instanceof Object);//true class AA //父类 class BB extends AA //子类 动态绑定机制 应用多态数组多态数组 ： 数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。 应用实例:现有一个继承结构如下：要求创建 1 个 Person 对象、2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组 中，并调用每个对象 say 方法. package com.hspedu.pkg; public class Person //父类 private String name; private int age; public Person(String name, int age) this.name = name; this.age = age; public String getName() return name; public void setName(String name) this.name = name; public int getAge() return age; public void setAge(int age) this.age = age; public String say() //返回名字和年龄 return name + \\t + age; package com.hspedu.pkg; public class Student extends Person private double score; public Student(String name, int age, double score) super(name, age); this.score = score; public double getScore() return score; public void setScore(double score) this.score = score; //重写父类 say @Override public String say() return 学生 + super.say() + score= + score; //特有的方法 public void study() System.out.println(学生 + getName() + 正在学 java...); package com.hspedu.pkg; public class Teacher extends Person private double salary; public Teacher(String name, int age, double salary) super(name,age); this.salary = salary; public double getSalary() return salary; public void setSalary(double salary) this.salary = salary; //写重写父类的 say 方法 @Override public String say() return 老师 + super.say() + salary= + salary; //特有方法 public void teach() System.out.println(老师 + getName() + 正在讲 java 课程...); package com.hspedu.pkg; public class PloyArray public static void main(String[] args) //应用实例:现有一个继承结构如下：要求创建 1 个 Person 对象、 // 2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组中，并调用每个对象 say 方法 Person[] persons = new Person[5]; persons[0] = new Person(jack, 20); persons[1] = new Student(mary, 18, 100); persons[2] = new Student(smith, 19, 30.1); persons[3] = new Teacher(scott, 30, 20000); persons[4] = new Teacher(king, 50, 25000); //循环遍历多态数组，调用 say for (int i = 0; i persons.length; i++) //老师提示: person[i] 编译类型是 Person ,运行类型是是根据实际情况由 JVM 来判断 System.out.println(persons[i].say());//动态绑定机制 //这里大家聪明. 使用 类型判断 + 向下转型. if (persons[i] instanceof Student) //判断 person[i] 的运行类型是不是 Student Student student = (Student) persons[i];//向下转型 student.study(); //小伙伴也可以使用一条语句 ((Student)persons[i]).study(); else if (persons[i] instanceof Teacher) Teacher teacher = (Teacher) persons[i]; teacher.teach(); else if (persons[i] instanceof Person) //System.out.println(你的类型有误, 请自己检查...); else System.out.println(你的类型有误, 请自己检查...); @Override：是一个伪代码，表示重写父类的方法，可以当作注释使用。 为什么要先判断Student：因为Student最小，先判断Teacher的话，运行类型是Student也可以通过。 Student student = (Student) persons[i];//向下转型 student.study(); //小伙伴也可以使用一条语句 ((Student)persons[i]).study(); 多态参数 package com.hspedu.poly_.polyparameter_; public class Employee private String name; private double salary; public Employee(String name, double salary) this.name = name; this.salary = salary; //得到年工资的方法 public double getAnnual() return 12 * salary; public String getName() return name; public void setName(String name) this.name = name; public double getSalary() return salary; public void setSalary(double salary) this.salary = salary;\\ package com.hspedu.poly_.polyparameter_; public class Manager extends Employee private double bonus; public Manager(String name, double salary, double bonus) super(name, salary); this.bonus = bonus; public double getBonus() return bonus; public void setBonus(double bonus) this.bonus = bonus; public void manage() System.out.println(经理 + getName() + is managing); //重写获取年薪方法 @Override public double getAnnual() return super.getAnnual() + bonus; package com.hspedu.poly_.polyparameter_; public class Worker extends Employee public Worker(String name, double salary) super(name, salary); public void work() System.out.println(普通员工 + getName() + is working); @Override public double getAnnual() //因为普通员工没有其它收入，则直接调用父类方法 return super.getAnnual(); package com.hspedu.poly_.polyparameter_; public class PloyParameter public static void main(String[] args) Worker tom = new Worker(tom, 2500); Manager milan = new Manager(milan, 5000, 200000); PloyParameter ployParameter = new PloyParameter(); ployParameter.showEmpAnnual(tom); ployParameter.showEmpAnnual(milan); ployParameter.testWork(tom); ployParameter.testWork(milan); //showEmpAnnual(Employee e) //实现获取任何员工对象的年工资,并在 main 方法中调用该方法 [e.getAnnual()] public void showEmpAnnual(Employee e) System.out.println(e.getAnnual());//动态绑定机制. //添加一个方法，testWork,如果是普通员工，则调用 work 方法，如果是经理，则调用 manage 方法 public void testWork(Employee e) if(e instanceof Worker) ((Worker) e).work();//有向下转型操作 else if(e instanceof Manager) ((Manager) e).manage();//有向下转型操作 else System.out.println(不做处理...); 在主类中创建方法，然后要调用的话，需要先创建一个主类的对象，再通过这个对象进行调用。如果创建的是静态方法就不用先创建对象了，可以直接调用。 PloyParameter ployParameter = new PloyParameter(); ployParameter.showEmpAnnual(tom); Object类详解equals方法 若是 对象1 equals 对象2，则是判断这两个对象的地址是否一样。 重写equals方法，就是直接在自己定义的类里面直接写就好了。 Person_ p1 = new Person_(); p1.name = hspedu; Person_ p2 = new Person_(); p2.name = hspedu; System.out.println(p1==p2); //False System.out.println(p1.name .equals( p2.name));//T System.out.println(p1.equals(p2));//False hashCode 方法 5 个小结: 1) 提高具有哈希结构的容器的效率！ 2) 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！ 3) 两个引用，如果指向的是不同对象，则哈希值是不一样的 4) 哈希值主要根据地址号来的！， 不能完全将哈希值等价于地址。 5) 后面在集合，中 hashCode 如果需要的话，也会重写, 在讲解集合时，老韩在说如何重写 hashCode() 对象名.hashCode()，输出该对象的哈希码。 toString 方法感觉没啥大用。 1) 基本介绍 默认返回：全类名+@+哈希值的十六进制，【查看 Object 的 toString 方法】 子类往往重写 toString 方法，用于返回对象的属性信息 2) 重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式. 3) 当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用monster.toString() public class c public static void main(String[] args) /* Object 的 toString() 源码 (1)getClass().getName() 类的全类名(包名+类名 ) (2)Integer.toHexString(hashCode()) 将对象的 hashCode 值转成 16 进制字符串 public String toString() return getClass().getName() + @ + Integer.toHexString(hashCode()); */ Monster monster = new Monster(小妖怪, 巡山的, 1000); System.out.println(monster.toString() + hashcode= + monster.hashCode()); System.out.println(==当直接输出一个对象时，toString 方法会被默认的调用==); System.out.println(monster); //等价 monster.toString() class Monster private String name; private String job; private double sal; public Monster(String name, String job, double sal) this.name = name; this.job = job; this.sal = sal; //重写 toString 方法, 输出对象的属性 //使用快捷键即可 alt+insert - toString @Override public String toString() //重写后，一般是把对象的属性值输出，当然程序员也可以自己定制 return Monster + name= + name + \\ + , job= + job + \\ + , sal= + sal + ; 当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用monster.toString() System.out.println(monster.toString() + hashcode= + monster.hashCode()); 相当于 System.out.println(monster + hashcode= + monster.hashCode()); 面向对象编程（高级）类变量和类方法类变量 就是静态变量全局变量，不过它是在类里面定义的。 public class c public static void main(String[] args) Child child1 = new Child(白骨精); child1.join(); //count++; child1.count++; Child child2 = new Child(狐狸精); child2.join(); //count++; child2.count++; Child child3 = new Child(老鼠精); child3.join(); //count++; child3.count++; //=========== //类变量，可以通过类名来访问 System.out.println(共有 + Child.count + 小孩加入了游戏...); //下面的代码输出什么? System.out.println(child1.count= + child1.count);//3 System.out.println(child2.count= + child2.count);//3 System.out.println(child3.count= + child3.count);//3 class Child //类 private String name; //定义一个变量 count ,是一个类变量(静态变量) static 静态 //该变量最大的特点就是会被 Child 类的所有的对象实例共享 public static int count = 0; public Child(String name) this.name = name; public void join() System.out.println(name + 加入了游戏..); 说明：类变量是随着类的加载而创建，所以即使没有创建对象实例也可以访问。 public class VisitStatic public static void main(String[] args) //类名.类变量名 //说明：类变量是随着类的加载而创建，所以即使没有创建对象实例也可以访问 System.out.println(A.name); A a = new A(); //通过对象名.类变量名 System.out.println(a.name= + a.name); class A //类变量 //类变量的访问，必须遵守 相关的访问权限. public static String name = 韩顺平教育; //普通属性/普通成员变量/非静态属性/非静态成员变量/实例变量 private int num = 10; 访问类变量 类方法 public class c public static void main(String[] args) //创建 2 个学生对象，叫学费 Stu tom = new Stu(tom); //tom.payFee(100); Stu.payFee(100);//对不对?对 Stu mary = new Stu(mary); //mary.payFee(200); Stu.payFee(200);//对 //输出当前收到的总学费 Stu.showFee();//300 //如果我们希望不创建实例，也可以调用某个方法(即当做工具来使用) //这时，把方法做成静态方法时非常合适 System.out.println(9 开平方的结果是= + Math.sqrt(9)); System.out.println(MyTools.calSum(10, 30)); //开发自己的工具类时，可以将方法做成静态的，方便调用 class MyTools //求出两个数的和 public static double calSum(double n1, double n2) return n1 + n2; //可以写出很多这样的工具方法... class Stu private String name;//普通成员 //定义一个静态变量，来累积学生的学费 private static double fee = 0; public Stu(String name) this.name = name; //说明 //1. 当方法使用了 static 修饰后，该方法就是静态方法 //2. 静态方法就可以访问静态属性/变量 public static void payFee(double fee) Stu.fee += fee;//累积到 public static void showFee() System.out.println(总学费有: + Stu.fee); System.out.println(9 开平方的结果是= + Math.sqrt(9)); Math.pow(double a,double b)；Math.sqrt(double a) 上面都不需要引入类，可以直接使用。 注意事项和细节 小结：记住两句话 (1) 静态方法，只能访问静态成员 (2) 非静态方法，可以访问所有的成员 (3) 在编写代码时，仍然要遵守访问权限规则。 理解main方法语法 在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性； 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。 public class Main01 //静态的变量/属性 private static String name = 韩顺平教育; //非静态的变量/属性 private int n1 = 10000; //静态方法 public static void hi() System.out.println(Main01 的 hi 方法); //非静态方法 public void cry() System.out.println(Main01 的 cry 方法); public static void main(String[] args) //可以直接使用 name //1. 静态方法 main 可以访问本类的静态成员 System.out.println(name= + name); hi(); //2. 静态方法 main 不可以访问本类的非静态成员 //System.out.println(n1= + n1);//错误 //cry(); //3. 静态方法 main 要访问本类的非静态成员，需要先创建对象 , 再调用即可 Main01 main01 = new Main01(); System.out.println(main01.n1);//ok main01.cry(); 代码块 代码块调用的顺序优先于构造器，这样当我们不管调用哪个构造器，创建对象，都会先调用代码块的内容。 System.out.println(电影屏幕打开...); System.out.println(广告开始...); System.out.println(电影正是开始...); ; 细节： public class c public static void main(String[] args) //类被加载的情况举例 //1. 创建对象实例时(new) // AA aa = new AA(); //2. 创建子类对象实例，父类也会被加载, 而且，父类先被加载，子类后被加载 // AA aa2 = new AA(); //3. 使用类的静态成员时(静态属性，静态方法) // System.out.println(Cat.n1); //static 代码块，是在类加载时，执行的，而且只会执行一次. // DD dd = new DD(); // DD dd1 = new DD(); //普通的代码块，在创建对象实例时，会被隐式的调用。 // 被创建一次，就会调用一次。 // 如果只是使用类的静态成员时，普通代码块并不会执行 System.out.println(DD.n1);//8888, 静态模块块一定会执行 class DD public static int n1 = 8888;//静态属性 //静态代码块 static System.out.println(DD 的静态代码 1 被执行...);// //普通代码块, 在 new 对象时，被调用，而且是每创建一个对象，就调用一次 //可以这样简单的，理解 普通代码块是构造器的补充 System.out.println(DD 的普通代码块...); class Animal //静态代码块 static System.out.println(Animal 的静态代码 1 被执行...);// class Cat extends Animal public static int n1 = 999;//静态属性 //静态代码块 static System.out.println(Cat 的静态代码 1 被执行...);// class BB //静态代码块 static System.out.println(BB 的静态代码 1 被执行...);//1 class AA extends BB //静态代码块 static System.out.println(AA 的静态代码 1 被执行...);//2 如果只是使用类的静态成员时，普通代码块并不会执行，但是静态模块会执行。 创建子类对象实例，父类也会被加载, 而且，父类先被加载，子类后被加载。 为什么父类会先被加载，因为子类需要父类先创立子类才是完整的，是继承父类的，所以也是先调用父类的静态代码块、静态属性初始化，再调用子类的静态代码块、静态属性初始化。（下面有说明） public class c public static void main(String[] args) A a = new A();// (1) A 静态代码块 01 (2) getN1 被调用...(3)A 普通代码块 01(4)getN2 被调用...(5)A() 构造器被调用 class A //普通代码块 System.out.println(A 普通代码块 01); private int n2 = getN2();//普通属性的初始化 static //静态代码块 System.out.println(A 静态代码块 01); //静态属性的初始化 private static int n1 = getN1(); public static int getN1() System.out.println(getN1 被调用...); return 100; public int getN2() //普通方法/非静态方法 System.out.println(getN2 被调用...); return 200; //无参构造器 public A() System.out.println(A() 构造器被调用); 静态相关的代码块，属性初始化，在类加载的时候就执行完毕了，是早于构造器和普通代码块的。 public class c public static void main(String[] args) new BBB();//(1)AAA 的普通代码块(2)AAA() 构造器被调用(3)BBB 的普通代码块(4)BBB() 构造器被调用 class AAA //父类 Object static System.out.println(AAA的静态代码块...); System.out.println(AAA 的普通代码块); public AAA() //(1)super() //(2)调用本类的普通代码块 System.out.println(AAA() 构造器被调用....); class BBB extends AAA static System.out.println(BBB的静态代码块...); System.out.println(BBB 的普通代码块...); public BBB() //(1)super() //(2)调用本类的普通代码块 System.out.println(BBB() 构造器被调用....); 单例设计模式什么是设计模式： 什么是单例模式： 饿汉式单例模式： public class c public static void main(String[] args) // GirlFriend xh = new GirlFriend(小红); // GirlFriend xb = new GirlFriend(小白); //通过方法可以获取对象 GirlFriend instance = GirlFriend.getInstance(); System.out.println(instance); GirlFriend instance2 = GirlFriend.getInstance(); System.out.println(instance2); System.out.println(instance == instance2);//T //System.out.println(GirlFriend.n1); //... //有一个类， GirlFriend //只能有一个女朋友 class GirlFriend private String name; //public static int n1 = 100; //为了能够在静态方法中，返回 gf 对象，需要将其修饰为 static //對象，通常是重量級的對象, 餓漢式可能造成創建了對象，但是沒有使用. private static GirlFriend gf = new GirlFriend(小红红); //如何保障我们只能创建一个 GirlFriend 对象 //步骤[单例模式-饿汉式] //1. 将构造器私有化 //2. 在类的内部直接创建对象(该对象是 static) //3. 提供一个公共的 static 方法，返回 gf 对象 private GirlFriend(String name) System.out.println(構造器被調用.); this.name = name; public static GirlFriend getInstance() return gf; @Override public String toString() return GirlFriend + name= + name + \\ + ; 当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用monster.toString()。 System.out.println(instance == instance2);//T 这句说明第二次返回的gf和第一次返回的是同一个，说明了是单例。 懒汉式单例模式： public class c public static void main(String[] args) //new Cat(大黃); //System.out.println(Cat.n1); Cat instance = Cat.getInstance(); System.out.println(instance); //再次調用 getInstance Cat instance2 = Cat.getInstance(); System.out.println(instance2); System.out.println(instance == instance2);//T //希望在程序運行過程中，只能創建一個 Cat 對象 //使用單例模式 class Cat private String name; public static int n1 = 999; private static Cat cat ; //默認是 null //步驟 //1.仍然構造器私有化 //2.定義一個 static 靜態屬性對象 //3.提供一個 public 的 static 方法，可以返回一個 Cat 對象 //4.懶漢式，只有當用戶使用 getInstance 時，才返回 cat 對象, 後面再次調用時，會返回上次創建的 cat 對象 // 從而保證了單例 private Cat(String name) System.out.println(構造器調用...); this.name = name; public static Cat getInstance() if(cat == null) //如果還沒有創建 cat 對象 cat = new Cat(小可愛); return cat; @Override public String toString() return Cat + name= + name + \\ + ; 饿汉式和懒汉式的区别： final关键字 final class A { } public final void hi() {} public final double TAX_RATE 0.08;常量 public static final double TAX_RATE 99.9; //当不希望某个局部变量被修改，可以使用 final 修饰 class F public void cry() //这时，NUM 也称为 局部常量 final double NUM = 0.01; //NUM = 0.9; System.out.println(NUM= + NUM); class AA /* 1. 定义时：如 public final double TAX_RATE=0.08; 2. 在构造器中 3. 在代码块中 */ public final double TAX_RATE = 0.08;//1.定义时赋值 public final double TAX_RATE2 ; public final double TAX_RATE3 ; public AA() //构造器中赋值 TAX_RATE2 = 1.1; //在代码块赋值 TAX_RATE3 = 8.8; 抽象类 abstract class Animal private String name; public Animal(String name) this.name = name; //思考：这里 eat 这里你实现了，其实没有什么意义 //即： 父类方法不确定性的问题 //=== 考虑将该方法设计为抽象(abstract)方法 //=== 所谓抽象方法就是没有实现的方法 //=== 所谓没有实现就是指，没有方法体 //=== 当一个类中存在抽象方法时，需要将该类声明为 abstract 类 //=== 一般来说，抽象类会被继承，有其子类来实现抽象方法. public abstract void eat() ; 注意事项和细节： public class AbstractDetail01 public static void main(String[] args) //抽象类，不能被实例化 //new A(); //抽象类不一定要包含 abstract 方法。也就是说,抽象类可以没有 abstract 方法 //，还可以有实现的方法。 abstract class A public void hi() System.out.println(hi); //如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为 abstract 类 abstract class E public abstract void hi(); abstract class F extends E class G extends E @Override public void hi() //这里相等于 G 子类实现了父类 E 的抽象方法，所谓实现方法，就是有方法体 实现就是有方法体就可以了，方法体为空也可以。 在子类中实现抽象方法的时候，方法的访问修饰符、类型等不变。 抽象类最佳实践-模板设计模式抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板。 能解决的问题： abstract class Template //抽象类-模板设计模式 public abstract void job();//抽象方法 public void calculateTime() //实现方法，调用 job 方法 //得到开始的时间 long start = System.currentTimeMillis(); job(); //动态绑定机制 //得的结束的时间 long end = System.currentTimeMillis(); System.out.println(任务执行时间 + (end - start)); class AA extends Template //计算任务 //1+....+ 800000 @Override public void job() //实现 Template 的抽象方法 job long num = 0; for (long i = 1; i = 800000; i++) num += i; class BB extends Template public void job() //这里也去，重写了 Template 的 job 方法 long num = 0; for (long i = 1; i = 80000; i++) num *= i; public class c public static void main(String[] args) AA aa = new AA(); aa.calculateTime(); //这里还是需要有良好的 OOP 基础，对多态 BB bb = new BB(); bb.calculateTime(); 为什么 aa.calculateTime()，计算的是AA里的job运行时间而不是父类里的job。 当 calculateTime()方法内部调用 job() 方法时，Java 虚拟机根据对象的实际类型也就是运行类型（AA 或 BB）来决定调用哪个 job() 方法。因此，aa.calculateTime() 调用的是 AA 类中的 job() 方法，而 bb.calculateTime() 调用的是 BB 类中的 job() 方法。 这是多态性的一个关键点：方法调用在运行时根据对象的实际类型绑定。 简而言之，这是因为 Java 的动态绑定机制确保在运行时调用的是子类的实现，而不是父类的声明。 接口基础interface UsbInterface //接口 //规定接口的相关方法,老师规定的.即规范... public void start(); public void stop(); class Camera implements UsbInterface//实现接口,就是把接口方法实现 @Override public void start() System.out.println(相机开始工作...); @Override public void stop() System.out.println(相机停止工作....); //Phone 类 实现 UsbInterface //解读 1. 即 Phone 类需要实现 sbInterface 接口 规定/声明的方法 class Phone implements UsbInterface @Override public void start() System.out.println(手机开始工作...); @Override public void stop() System.out.println(手机停止工作.....); 不难，重点是何时使用接口。 注意事项和细节： interface IA void say();//修饰符 public protected 默认 private void hi(); class Cat implements IA @Override public void say() @Override public void hi() abstract class Tiger implements IA 一个普通类实现接口,就必须将该接口的所有方法都实现,可以使用 alt+enter （得先将光标放于该类上）来解决。 public class InterfaceDetail02 public static void main(String[] args) //老韩证明 接口中的属性,是 public static final System.out.println(IB.n1);//说明 n1 就是 static //IB.n1 = 30; 说明 n1 是 final interface IB //接口中的属性,只能是 final 的，而且是 public static final 修饰符 int n1 = 10; //等价 public static final int n1 = 10; void hi(); interface IC void say(); //接口不能继承其它的类,但是可以继承多个别的接口 interface ID extends IB,IC //接口的修饰符 只能是 public 和默认，这点和类的修饰符是一样的 interface IE //一个类同时可以实现多个接口 class Pig implements IB,IC @Override public void hi() @Override public void say() 接口与继承接口的静态方法不能被子接口继承，也不被实现类继承。接口的默认方法 可以被子接口和子类继承。 接口也可以继承另一个接口，上面就有例子。 public class ExtendsVsInterface public static void main(String[] args) LittleMonkey wuKong = new LittleMonkey(悟空); wuKong.climbing(); wuKong.swimming(); wuKong.flying(); //猴子 class Monkey private String name; public Monkey(String name) this.name = name; public void climbing() System.out.println(name + 会爬树...); public String getName() return name; //接口 interface Fishable void swimming(); interface Birdable void flying(); //继承 //小结: 当子类继承了父类，就自动的拥有父类的功能 // 如果子类需要扩展功能，可以通过实现接口的方式扩展. // 可以理解 实现接口 是 对 java 单继承机制的一种补充. class LittleMonkey extends Monkey implements Fishable,Birdable public LittleMonkey(String name) super(name); @Override public void swimming() System.out.println(getName() + 通过学习，可以像鱼儿一样游泳...); @Override public void flying() System.out.println(getName() + 通过学习，可以像鸟儿一样飞翔...); 一个类可以同时继承和实现多个接口：class LittleMonkey extends Monkey implements Fishable,Birdable 接口的多态特性目前看到的，除了多态参数，其它多态可以的接口也可以，比如多态数组、向上、向下转型啥的。 向上转型： public class InterfacePolyParameter public static void main(String[] args) //接口的多态体现 //接口类型的变量 if01 可以指向 实现了 IF 接口类的对象实例 IF if01 = new Monster(); if01 = new Car(); //继承体现的多态 //父类类型的变量 a 可以指向 继承 AAA 的子类的对象实例 AAA a = new BBB(); a = new CCC(); interface IF class Monster implements IF class Car implements IF class AAA class BBB extends AAA class CCC extends AAA 接口类型数组，向下转型： public class InterfacePolyArr public static void main(String[] args) //多态数组 - 接口类型数组 Usb[] usbs = new Usb[2]; usbs[0] = new Phone_(); usbs[1] = new Camera_(); /* 给 Usb 数组中，存放 Phone 和 相机对象，Phone 类还有一个特有的方法 call（）， 请遍历 Usb 数组，如果是 Phone 对象，除了调用 Usb 接口定义的方法外， 还需要调用 Phone 特有方法 call */ for(int i = 0; i usbs.length; i++) usbs[i].work();//动态绑定.. //和前面一样，我们仍然需要进行类型的向下转型 if(usbs[i] instanceof Phone_) //判断他的运行类型是 Phone_ ((Phone_) usbs[i]).call(); interface Usb void work(); class Phone_ implements Usb public void call() System.out.println(手机可以打电话...); @Override public void work() System.out.println(手机工作中...); class Camera_ implements Usb @Override public void work() System.out.println(相机工作中...); 多态传递现象（接口之间的继承）： public class InterfacePolyPass public static void main(String[] args) //接口类型的变量可以指向实现了该接口的类的对象实例 IG ig = new Teacher(); //如果 IG 继承了 IH 接口，而 Teacher 类实现了 IG 接口 //那么，实际上就相当于 Teacher 类也实现了 IH 接口. //这就是所谓的 接口多态传递现象. IH ih = new Teacher(); interface IH void hi(); interface IG extends IH class Teacher implements IG @Override public void hi() 一道题： public class InterfaceExercise02 public static void main(String[] args) interface A // 1min 看看 int x = 0; //想到 等价 public static final int x = 0; class B int x = 1; //普通属性 class C extends B implements A public void pX() //System.out.println(x); //错误，原因不明确 x //可以明确的指定 x //访问接口的 x 就使用 A.x //访问父类的 x 就使用 super.x System.out.println(A.x + + super.x); public static void main(String[] args) new C().pX(); class C extends B implements A这句是对的，没有语法错误。 如何区分X: //访问接口的 x 就使用 A.x //访问父类的 x 就使用 super.x 内部类定义如果定义类在局部位置(方法中代码块) :(1) 局部内部类 (2) 匿名内部类 。 定义在成员位置 (1) 成员内部类 (2) 静态内部类。 基本介绍： 分类： 使用局部内部类可以参考局部变量 public class c// public static void main(String[] args) //演示一遍 Outer02 outer02 = new Outer02(); outer02.m1(); System.out.println(outer02 的 hashcode= + outer02); class Outer02 //外部类 private int n1 = 100; private void m2() System.out.println(Outer02 m2()); //私有方法 public void m1() //方法 //1.局部内部类是定义在外部类的局部位置,通常在方法 //3.不能添加访问修饰符,但是可以使用 final 修饰 //4.作用域 : 仅仅在定义它的方法或代码块中 final class Inner02 //局部内部类(本质仍然是一个类) //2.可以直接访问外部类的所有成员，包含私有的 private int n1 = 800; public void f1() //5. 局部内部类可以直接访问外部类的成员，比如下面 外部类 n1 和 m2() //7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员， // 使用 外部类名.this.成员）去访问 // 老韩解读 Outer02.this 本质就是外部类的对象, 即哪个对象调用了 m1, Outer02.this 就是哪个对象 System.out.println(n1= + n1 + 外部类的 n1= + Outer02.this.n1); System.out.println(Outer02.this hashcode= + Outer02.this); m2(); //6. 外部类在方法中，可以创建 Inner02 对象，然后调用方法即可 Inner02 inner02 = new Inner02(); inner02.f1(); System.out.println(outer02 的 hashcode= + outer02);这个输出的是 全类名+@+哈希码的十六进制（调用了toString），System.out.println(Outer02.this hashcode= + Outer02.this);这个也是。 匿名内部类（重要） 记住最后有一个分号。 new后面加接口的相当于是实现接口，接类的相当于是继承。 接口： IA tiger new IA(){}；类：Animal animal new Animal()，可以调用构造器。 public class AnonymousInnerClass public static void main(String[] args) Outer04 outer04 = new Outer04(); outer04.method(); class Outer04 //外部类 private int n1 = 10;//属性 public void method() //方法 //基于接口的匿名内部类 //老韩解读 //1.需求： 想使用 IA 接口,并创建对象 //2.传统方式，是写一个类，实现该接口，并创建对象 //3.老韩需求是 Tiger/Dog 类只是使用一次，后面再不使用 //4. 可以使用匿名内部类来简化开发 //5. tiger 的编译类型 ? IA //6. tiger 的运行类型 ? 就是匿名内部类 Outer04$1 /* 我们看底层 会分配 类名 Outer04$1 class Outer04$1 implements IA @Override public void cry() System.out.println(老虎叫唤...); */ //7. jdk 底层在创建匿名内部类 Outer04$1,立即马上就创建了 Outer04$1 实例，并且把地址 // 返回给 tiger //8. 匿名内部类使用一次，就不能再使用 IA tiger = new IA() @Override public void cry() System.out.println(老虎叫唤...); ; System.out.println(tiger 的运行类型= + tiger.getClass()); tiger.cry(); tiger.cry(); tiger.cry(); //演示基于类的匿名内部类 //分析 //1. father 编译类型 Father //2. father 运行类型 Outer04$2 //3. 底层会创建匿名内部类 /* class Outer04$2 extends Father @Override public void test() System.out.println(匿名内部类重写了 test 方法); */ //4. 同时也直接返回了 匿名内部类 Outer04$2 的对象 //5. 注意(jack) 参数列表会传递给 构造器 Father father = new Father(jack) @Override public void test() System.out.println(匿名内部类重写了 test 方法); ; System.out.println(father 对象的运行类型= + father.getClass());//Outer04$2 father.test(); //基于抽象类的匿名内部类 Animal animal = new Animal() @Override void eat() System.out.println(小狗吃骨头...); ; animal.eat(); interface IA //接口 public void cry(); class Father //类 public Father(String name) //构造器 System.out.println(接收到 name= + name); public void test() //方法 abstract class Animal //抽象类 abstract void eat(); getClass() 返回的是此时的运行类型，哪一个类的。 这里所说的匿名内部类只能使用一次，注意是说匿名内部类，而不是说对象，指向匿名内部类的对象可以使用多次。 tiger可以使用多次，但是匿名内部类——下面部分——只能使用一次。 new IA() @Override public void cry() System.out.println(老虎叫唤...); ; 由于普通的类有类名，如：public class Amimal{…}，使用时Animal al new Animal()；可根据这个Animal类名多次new使用，创建实例，Animal类的代码在new时是固定的。而匿名内部类没有类名，每次使用时，都要new 类名（）{…};这里的代码不是固定的，每次都可以变化，故只能用一次。 类似于创造对象的语法：Father father new Father(“jack”){}，不过后面要加上内容。 体现对象特征：可以当作实参。 第三点和前面的局部内部类一样。 public class InnerClassExercise01 public static void main(String[] args) //当做实参直接传递，简洁高效 f1(new IL() @Override public void show() System.out.println(这是一副名画~~...); ); //传统方法 f1(new Picture()); //静态方法,形参是接口类型 public static void f1(IL il) il.show(); //接口 interface IL void show(); //类-实现 IL = 编程领域 (硬编码) class Picture implements IL @Override public void show() System.out.println(这是一副名画 XX...); public interface Printable void print(String message); public static void method(Printable p) String message = 匿名内部类; p.print(message); public static void main(String[]args) method(new Printable() public void print(String message) System.out.println(message); ); 成员内部类 public class MemberInnerClass01 public static void main(String[] args) Outer08 outer08 = new Outer08(); outer08.t1(); //外部其他类，使用成员内部类的三种方式 //老韩解读 // 第一种方式 // outer08.new Inner08(); 相当于把 new Inner08()当做是 outer08 成员 // 这就是一个语法，不要特别的纠结. Outer08.Inner08 inner08 = outer08.new Inner08(); inner08.say(); // 第二方式 在外部类中，编写一个方法，可以返回 Inner08 对象 Outer08.Inner08 inner08Instance = outer08.getInner08Instance(); inner08Instance.say(); class Outer08 //外部类 private int n1 = 10; public String name = 张三; private void hi() System.out.println(hi()方法...); //1.注意: 成员内部类，是定义在外部内的成员位置上 //2.可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员 public class Inner08 //成员内部类 private double sal = 99.8; private int n1 = 66; public void say() //可以直接访问外部类的所有成员，包含私有的 //如果成员内部类的成员和外部类的成员重名，会遵守就近原则. //，可以通过 外部类名.this.属性 来访问外部类的成员 System.out.println(n1 = + n1 + name = + name + 外部类的 n1= + Outer08.this.n1); hi(); //方法，返回一个 Inner08 实例 public Inner08 getInner08Instance() return new Inner08(); //写方法 public void t1() //使用成员内部类 //创建成员内部类的对象，然后使用相关的方法 Inner08 inner08 = new Inner08(); inner08.say(); System.out.println(inner08.sal); System.out.println(inner08.sal); 仍可以直接输出sal，虽然它是成员内部类，但是仍处于同一个类中，所以即使是private，也可以直接用。 外部其它类使用成员内部类的三种方式： 1、 outer08.new Inner08() 相当于把 new Inner08()当做是 outer08 成员 outer08.new Inner08().say(); 2、创建一个成员内部类的对象，通过对象去访问他里面的方法： Outer08.Inner08 inner08 = outer08.new Inner08(); inner08.say(); 3、在外部类中，编写一个方法，可以返回成员内部类对象： Outer08 outer08 = new Outer08(); Outer08.Inner08 inner08Instance = outer08.getInner08Instance(); inner08Instance.say(); 或者将这个方法定义为静态方法会更加简单。 静态内部类 这个不用加this。 外部其它类使用静态内部类的方式和上面一个的完全一样。 一道题： public class Test //外部类 public Test() //构造器 Inner s1 = new Inner(); s1.a = 10; Inner s2 = new Inner(); System.out.println(s2.a); class Inner //内部类，成员内部类 public int a = 5; public static void main(String[] args) Test t = new Test(); Inner r = t.new Inner();//5 System.out.println(r.a);//5 Inner r = t.new Inner();这句话前面不用再引入Test类的原因是这句代码原本就是再Test类里面进行的。 枚举和注解枚举基础枚举类[枚: 一个一个，举： 例举 。 即把具体的对象一个一个例举出来的类就称为枚举类] 何时使用：（1）需要创建的类只有有限几个对象（2）只读，不需要修改。 1）枚举对应英文(enumeration, 简写 enum。 2）枚举是一组常量的集合。 3） 可以这里理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象。 枚举的两种实现方式：1）自定义类实现枚举； 2) 使用 enum 关键字实现枚举。 自定义类实现枚举 public class Enumeration02 public static void main(String[] args) System.out.println(Season.AUTUMN); System.out.println(Season.SPRING); //演示字定义枚举实现 class Season //类 private String name; private String desc;//描述 //定义了四个对象, 固定. public static final Season SPRING = new Season(春天, 温暖); public static final Season WINTER = new Season(冬天, 寒冷); public static final Season AUTUMN = new Season(秋天, 凉爽); public static final Season SUMMER = new Season(夏天, 炎热); //1. 将构造器私有化,目的防止 直接 new //2. 去掉 setXxx 方法, 防止属性被修改 //3. 在 Season 内部，直接创建固定的对象 //4. 优化，可以加入 final 修饰符 private Season(String name, String desc) this.name = name; this.desc = desc; public String getName() return name; public String getDesc() return desc; @Override public String toString() return Season + name= + name + \\ + , desc= + desc + \\ + ; 小结：自定义类实现枚举特点： 构造器私有化 本类内部创建一组对象[四个 春夏秋冬] 对外暴露对象（通过为对象添加 public final static 修饰符） 可以提供 get 方法，但是不要提供 set enum关键字实现枚举public class Enumeration03 public static void main(String[] args) System.out.println(Season2.AUTUMN); System.out.println(Season2.SUMMER); //演示使用 enum 关键字来实现枚举类 enum Season2 //类 //如果使用了 enum 来实现枚举类 //1. 使用关键字 enum 替代 class //2. public static final Season SPRING = new Season(春天, 温暖) 直接使用 SPRING(春天, 温暖) 解读 常量名(实参列表) //3. 如果有多个常量(对象)， 使用 ,号间隔即可 //4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面 //5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 () SPRING(春天, 温暖), WINTER(冬天, 寒冷), AUTUMN(秋天, 凉爽), SUMMER(夏天, 炎热)/*, What()*/; private String name; private String desc;//描述 private Season2() //无参构造器 private Season2(String name, String desc) this.name = name; this.desc = desc; public String getName() return name; public String getDesc() return desc; @Override public String toString() return Season + name= + name + \\ + , desc= + desc + \\ + ; 不去重新定义toString的话，它输出的是枚举类里面每个对象的对象名。 注意事项： 当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类 传统的 public static final Season2 SPRING new Season2(“春天”, “温暖”); 简化成 SPRING(“春天”, “温暖”)， 这里必须知道，它调用的是哪个构造器. 如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略 当有多个枚举对象时，使用’,’间隔，最后有一个分号结尾 枚举对象必须放在枚举类的行首. enum常用方法+增强for说明：使用关键字 enum 时，会隐式继承 Enum 类, 这样我们就可以使用 Enum 类相关的方法。 使用 Season2 枚举类，来演示各种方法 //补充了一个增强 for // int[] nums = 1, 2, 9; // //普通的 for 循环 // System.out.println(=====普通的 for=====); // for (int i = 0; i nums.length; i++) // System.out.println(nums[i]); // // System.out.println(=====增强的 for=====); // //执行流程是 依次从 nums 数组中取出数据，赋给 i, 如果取出完毕，则退出 for // for(int i : nums) // System.out.println(i= + i); // public class EnumMethod public static void main(String[] args) //使用 Season2 枚举类，来演示各种方法 Season2 autumn = Season2.AUTUMN; //输出枚举对象的名字 System.out.println(autumn.name()); //ordinal() 输出的是该枚举对象的次序/编号，从 0 开始编号 //AUTUMN 枚举对象是第三个，因此输出 2 System.out.println(autumn.ordinal()); //从反编译可以看出 values 方法，返回 Season2[] //含有定义的所有枚举对象 Season2[] values = Season2.values(); System.out.println(===遍历取出枚举对象(增强 for)====); for (Season2 season: values) //增强 for 循环 System.out.println(season); //valueOf：将字符串转换成枚举对象，要求字符串必须 为已有的常量名，否则报异常 //执行流程 //1. 根据你输入的 AUTUMN 到 Season2 的枚举对象去查找 //2. 如果找到了，就返回，如果没有找到，就报错 Season2 autumn1 = Season2.valueOf(AUTUMN); System.out.println(autumn1= + autumn1); System.out.println(autumn == autumn1); //compareTo：比较两个枚举常量，比较的就是编号 //老韩解读 //1. 就是把 Season2.AUTUMN 枚举对象的编号 和 Season2.SUMMER 枚举对象的编号比较 //2. 看看结果 /* public final int compareTo(E o) return self.ordinal - other.ordinal; Season2.AUTUMN 的编号[2] - Season2.SUMMER 的编号[3] */ System.out.println(Season2.AUTUMN.compareTo(Season2.SUMMER)); enum实现接口 使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制。 枚举类和普通类一样，可以实现接口，如下形式。enum 类名 implements 接口 1，接口 2{} interface IPlaying public void playing(); enum Music implements IPlaying CLASSICMUSIC; @Override public void playing() System.out.println(播放好听的音乐...); 调用：Music.CLASSICMUSIC.playing(); 注解基础1) 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。 2) 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。 3) 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角 色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。 三个基本的 Annotation: 1) @Override: 限定某个方法，是重写父类方法, 该注解只能用于方法 2) @Deprecated: 用于表示某个程序元素(类, 方法等)已过时 3) @SuppressWarnings: 抑制编译器警告 @Override 如果你写了@Override 注解，编译器就会去检查该方法是否真的重写了父类的方法，如果的确重写了，则编译通过，如果没有构成重写，则编译错误。 @Deprecated@Deprecated class A @Deprecated public int n1 = 10; @Deprecated public void hi() @SuppressWarnings 当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息 在{“”} 中，可以写入你希望抑制(不显示)警告信息 关于 SuppressWarnings 作用范围是和你放置的位置相关 比如 @SuppressWarnings 放置在 main 方法，那么抑制警告的范围就是 main 通常我们可以放置具体的语句, 方法, 类. @SuppressWarnings(rawtypes) 异常-Exception引入例子： public class Exception01 public static void main(String[] args) int num1 = 10; int num2 = 0;//Scanner(); //老韩解读 //1. num1 / num2 = 10 / 0 //2. 当执行到 num1 / num2 因为 num2 = 0, 程序就会出现(抛出)异常 ArithmeticException //3. 当抛出异常后，程序就退出，崩溃了 , 下面的代码就不在执行 //4. 大家想想这样的程序好吗? 不好，不应该出现了一个不算致命的问题，就导致整个系统崩溃 //5. java 设计者，提供了一个叫 异常处理机制来解决该问题 // int res = num1 / num2; //如果程序员，认为一段代码可能出现异常/问题，可以使用 try-catch 异常处理机制来解决 //从而保证程序的健壮性 //将该代码块-选中-快捷键 ctrl + alt + t - 选中 try-catch //6. 如果进行异常处理，那么即使出现了异常，程序可以继续执行 try int res = num1 / num2; catch (Exception e) //e.printStackTrace(); System.out.println(出现异常的原因= + e.getMessage());//输出异常信息 System.out.println(程序继续运行....); 将该代码块-选中-快捷键 ctrl + alt + t - 选中 try-catch，不能使用系统给你的，需要做些修改，不然只会将问题再输出一遍，程序仍然会中断。 将catch后面的方法体变为System.out.println(出现异常的原因= + e.getMessage());，程序就不会中断了。 输出异常信息： e.printStackTrace(); 或者 System.out.println(出现异常的原因= + e.getMessage()); 下面是程序给的：如果将throw new RuntimeException(e);注释掉，程序也会继续往下运行。 try int res = num1 / num2; catch (Exception e) throw new RuntimeException(e); 基础 运行时异常 NullPointerException 空指针异常 ArithmeticException 数学运算异常 ArrayIndexOutOfBoundsException 数组下标越界异常 ClassCastException 类型转换异常 NumberFormatException 数字格式不正确异常[] 4、当试图将对象强制转换为不是实例的子类时，抛出该异常。 public class ClassCastException_ public static void main(String[] args) A b = new B(); //向上转型 B b2 = (B)b;//向下转型，这里是 OK C c2 = (C)b;//这里抛出 ClassCastException class A class B extends A class C extends A 5、当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常 public class NumberFormatException_ public static void main(String[] args) String name = 韩顺平教育; //将 String 转成 int int num = Integer.parseInt(name);//抛出 NumberFormatException System.out.println(num);//1234 编译异常 例子没看懂 异常处理 try-catch 异常处理 上面的引入例子 public class TryCatchDetail public static void main(String[] args) //ctrl + atl + t //老韩解读 //1. 如果异常发生了，则异常发生后面的代码不会执行，直接进入到 catch 块 //2. 如果异常没有发生，则顺序执行 try 的代码块，不会进入到 catch //3. 如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用如下代码- finally try String str = 韩顺平; int a = Integer.parseInt(str); System.out.println(数字： + a); catch (NumberFormatException e) System.out.println(异常信息= + e.getMessage()); finally System.out.println(finally 代码块被执行...); System.out.println(程序继续...); 如果异常发生了，则异常发生后面的代码不会执行，直接进入到 catch 块：这里讲的异常后面的代码的范围是在try里面的，try里面的某处代码发生问题后，这处后面的代码不执行，直接跳到catch。 public class c public static void main(String[] args) //老韩解读 //1.如果 try 代码块有可能有多个异常 //2.可以使用多个 catch 分别捕获不同的异常，相应处理 //3.要求子类异常写在前面，父类异常写在后面 try Person person = new Person(); //person = null; System.out.println(person.getName());//NullPointerException int n1 = 10; int n2 = 0; int res = n1 / n2;//ArithmeticException catch (NullPointerException e) System.out.println(空指针异常= + e.getMessage()); catch (ArithmeticException e) System.out.println(算术异常= + e.getMessage()); catch (Exception e) System.out.println(e.getMessage()); finally class Person private String name = jack; public String getName() return name; 上面代码不存在空指针问题。 有异常才会崩掉。 利用try-catch解决问题如果用户输入的不是一个整数，就提示他反复输入，直到输入一个整数为止 import java.util.Scanner; public class TryCatchExercise04 public static void main(String[] args) //如果用户输入的不是一个整数，就提示他反复输入，直到输入一个整数为止 //思路 //1. 创建 Scanner 对象 //2. 使用无限循环，去接收一个输入 //3. 然后将该输入的值，转成一个 int //4. 如果在转换时，抛出异常，说明输入的内容不是一个可以转成 int 的内容 //5. 如果没有抛出异常，则 break 该循环 Scanner scanner = new Scanner(System.in); int num = 0; String inputStr = ; while (true) System.out.println(请输入一个整数:); // inputStr = scanner.next(); try num = Integer.parseInt(inputStr); //这里是可能抛出异常 break; catch (NumberFormatException e) System.out.println(你输入的不是一个整数:); System.out.println(你输入的值是= + num); throws 异常处理 没有用try-catch去处理异常，啥都没写就是默认throws处理，不用去写，就是默认它处理的。 import java.io.FileInputStream; import java.io.FileNotFoundException; /** * @author 韩顺平 * @version 1.0 */ public class ThrowsDetail public static void main(String[] args) f2(); public static void f2() /*throws ArithmeticException*/ //1.对于编译异常，程序中必须处理，比如 try-catch 或者 throws //2.对于运行时异常，程序中如果没有处理，默认就是 throws 的方式处理 int n1 = 10; int n2 = 0; double res = n1 / n2; public static void f1() throws FileNotFoundException //这里大家思考问题 调用 f3() 报错 //老韩解读 //1. 因为 f3() 方法抛出的是一个编译异常 //2. 即这时，就要 f1() 必须处理这个编译异常 //3. 在 f1() 中，要么 try-catch-finally ,或者继续 throws 这个编译异常 f3(); // 抛出异常 public static void f3() throws FileNotFoundException FileInputStream fis = new FileInputStream(d://aa.txt); public static void f4() //老韩解读: //1. 在 f4()中调用方法 f5() 是 OK //2. 原因是 f5() 抛出的是运行异常 //3. 而 java 中，并不要求程序员显示处理,因为有默认处理机制 f5(); public static void f5() throws ArithmeticException class Father //父类 public void method() throws RuntimeException class Son extends Father //子类 //3. 子类重写父类的方法时，对抛出异常的规定:子类重写的方法， // 所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常类型的子类型 //4. 在 throws 过程中，如果有方法 try-catch , 就相当于处理异常，就可以不必 throws @Override public void method() throws ArithmeticException 有点没看懂上面那个。 编写方法抛出异常： 声明一个方法抛出异常要在括号后面加throws 异常。 编写程序，定义一个 static 方法 methodA()，令其声明抛出一个 IOException 异常，再定义 另一个 static 方法 methodB()，在该方法中调用 methodA()方法。在 main()方法中调用 methodB() 方法。试编译该类，看编译器会报告什么？对于这种情况应如何处理？ import java.io.IOException; public class c public static void methodA() throws IOException System.out.println(In method A); public static void methodB() methodA(); // 编译错误，没有处理 methodA()方法抛出的非运行时异常 System.out.println(In method B); public static void main(String args[]) methodB(); 编译器报告： java: 未报告的异常错误java.io.IOException; 必须对其进行捕获或声明以便抛出 处理： （1）声明 methodB()方法抛出 IOException 异常。 （2）在 methodB()方法中使用 try-catch 结构对 methodA()方法调用进行异常处理。 try methodA(); catch(IOException e) 自定义异常 步骤： public class CustomException public static void main(String[] args) /*throws AgeException*/ int age = 180; //要求范围在 18 – 120 之间，否则抛出一个自定义异常 if(!(age = 18 age = 120)) //这里我们可以通过构造器，设置信息 throw new AgeException(年龄需要在 18~120 之间); System.out.println(你的年龄范围正确.); //自定义一个异常 //老韩解读 //1. 一般情况下，我们自定义异常是继承 RuntimeException //2. 即把自定义异常做成 运行时异常，好处时，我们可以使用默认的处理机制 //3. 即比较方便 class AgeException extends RuntimeException public AgeException(String message) //构造器 super(message); 记住这个例子，以后的按这个例子来写。 写一个方法，令其打印出保存下来的 String 对象： public void output1() System.out.println(getMessage()); 要调用这个方法的话，一定要记得把catch里面异常的类型改为这个方法所在的自定义异常类，然后才能调用这个方法。如果是原来的Exception的话，由于自定义的是它的子类，而它作为父类是不能调用子类的方法的，除非向下转型。 public class c public static void main(String[] args) try throw new MyException(My Exception.); catch(MyException e) e.output1(); System.out.println(e.getMessage()); class MyException extends Exception public MyException() public MyException(String message) super(message); public void output1() System.out.println(getMessage()); finally里面的内容是try运行完后无论如何都会运行的。 为什么“制造异常”在后面：因为在A中的throw生成了一个RuntimeException异常，所以main方法中的try就发生了异常，然后catch捕捉RuntimeException异常，之后在它的方法体中输出RuntimeException异常的内容“制造异常”，所以“制造异常”在后面。 常用类包装类介绍针对八种基本数据类型相应的引用类型—包装类。 有了类的特点，就可以调用类中的方法。 包装类和基本数据类型的转换装箱：基本数据类型-包装类型；拆箱相反。 //jdk5 前是手动装箱和拆箱 //手动装箱 int-Integer int n1 = 100; Integer integer = new Integer(n1);//现在会报错 Integer integer1 = Integer.valueOf(n1); //手动拆箱 //Integer - int int i = integer.intValue(); //jdk5（包括jdk5）后，就可以自动装箱和自动拆箱 int n2 = 200; //自动装箱 int-Integer Integer integer2 = n2; //底层使用的是 Integer.valueOf(n2) //自动拆箱 Integer-int int n3 = integer2; //底层仍然使用的是 intValue()方法 第一个输出1.0的原因： 在 Java 中，三元运算符的两种可能结果会被提升为一个共同的类型。在这个例子中，new Integer(1) 和 new Double(2.0) 将会被提升为 Double 类型，因为 Double 是 Integer 和 Double 的共同父类。然后 obj1 会被赋值为 Double 类型的 1.0。 //示例六 Integer i11=127; int i12=127; //只要有基本数据类型，判断的是值是否相同，会自动拆箱 System.out.println(i11==i12); //T //示例七 Integer i13=128; int i14=128; System.out.println(i13==i14);//T 包装类型和 String 类型的相互转换//包装类(Integer)-String Integer i = 100;//自动装箱 //方式 1 String str1 = i + ; //方式 2 String str2 = i.toString(); //方式 3 String str3 = String.valueOf(i); //String - 包装类(Integer) String str4 = 12345; Integer i2 = Integer.parseInt(str4);//使用到自动装箱 Integer i3 = new Integer(str4);//构造器 Integer i2 = Integer.parseInt(str4);先转化为int类型，再用到自动装箱变为包装类。 Integer 类和 Character 类的常用方法System.out.println(Integer.MIN_VALUE); //返回最小值 System.out.println(Integer.MAX_VALUE);//返回最大值 System.out.println(Character.isDigit(a));//判断是不是数字 System.out.println(Character.isLetter(a));//判断是不是字母 System.out.println(Character.isUpperCase(a));//判断是不是大写 System.out.println(Character.isLowerCase(a));//判断是不是小写 System.out.println(Character.isWhitespace(a));//判断是不是空格 System.out.println(Character.toUpperCase(a));//转成大写 System.out.println(Character.toLowerCase(A));//转成小写 其它的与Integer类相似。 String类基础 1）字符串的字符使用 Unicode 字符编码，一个字符(不区分字母还是汉字)占两个字节； 2）String 是 final 类，不能被其他的类继承。 创建String对象的两种方式： 两种方式的区别： 字符串的特性 变量名储存的只是地址。 两个变量相加和两个字符串（两个常量）直接相加创造的对象个数不同。 String类的常用方法+进制转化常用方法 // 2.equalsIgnoreCase 忽略大小写的判断内容是否相等 String username = johN; if (john.equalsIgnoreCase(username)) System.out.println(Success!); else System.out.println(Failure!); // 3.length 获取字符的个数，字符串的长度 System.out.println(韩顺平.length()); // 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1 String s1 = wer@terwe@g; int index = s1.indexOf(@); System.out.println(index);// 3 System.out.println(weIndex= + s1.indexOf(we));//0 // 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1 s1 = wer@terwe@g@; index = s1.lastIndexOf(@); System.out.println(index);//11 System.out.println(ter 的位置= + s1.lastIndexOf(ter));//4 // 6.substring 截取指定范围的子串 String name = hello,张三; //下面 name.substring(6) 从索引 6 开始截取后面所有的内容 System.out.println(name.substring(6));//截取后面的字符 //name.substring(0,5)表示从索引 0 开始截取，截取到索引 5-1=4 位置 System.out.println(name.substring(2,5));//llo String[] elem = sentence.split([, .]);//这句代表sentence内以, .三个为分界点。 index = result.indexOf(hello, index + censored.length()); result，censored都是字符串，这个方法还可以指定从哪个位置开始查找。前面是查找的内容，后面是索引。 // 1.toUpperCase 转换成大写 String s = heLLo; System.out.println(s.toUpperCase());//HELLO // 2.toLowerCase concat可以连续使用，只要在括号后面继续加上就好了。 replace() 是全替换，方法执行后，返回的结果才是替换过的，对原字符串无影响。 String s11 = s1.replace(林黛玉, jack);林黛玉全部被替换，这是没有指定范围的情况，如果指定了范围就只会替代那个范围的字符，如下(forbidden是违禁词，字符串)，还有一个例子在StringBuffer那边： // 替换当前违禁词为censored result.replace(index, index + forbidden.length(), censored); String poem = 锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦; String[] split = poem.split(,); poem = E:\\\\aaa\\\\bbb; split = poem.split(\\\\\\\\); for (int i = 0; i split.length; i++) System.out.println(split[i]); System.out.println(s.toLowerCase());//hello // 3.concat 拼接字符串 String s1 = 宝玉; s1 = s1.concat(林黛玉).concat(薛宝钗).concat(together); System.out.println(s1);//宝玉林黛玉薛宝钗 together // 4.replace 替换字符串中的字符 s1 = 宝玉 and 林黛玉 林黛玉 林黛玉; //在 s1 中，将 所有的 林黛玉 替换成薛宝钗 // 老韩解读: s1.replace() 方法执行后，返回的结果才是替换过的. // 注意对 s1 没有任何影响 String s11 = s1.replace(宝玉, jack); System.out.println(s1);//宝玉 and 林黛玉 林黛玉 林黛玉 System.out.println(s11);//jack and 林黛玉 林黛玉 林黛玉 // 5.split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \\\\等 String poem = 锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦; //老韩解读： // 1. 以 , 为标准对 poem 进行分割 , 返回一个数组 // 2. 在对字符串进行分割时，如果有特殊字符，需要加入 转义符 \\ String[] split = poem.split(,); poem = E:\\\\aaa\\\\bbb; split = poem.split(\\\\\\\\); System.out.println(==分割后内容===); for (int i = 0; i split.length; i++) System.out.println(split[i]); 原本的split数组存储的是诗句，但是下面再使用它来存储新的分割字符串时，不是以覆盖的形式覆盖原先内容，应该是原本存储内容全部清空然后存储新的内容，或者不是清空而是split存储的地址变了。 // 6.toCharArray 转换成字符数组 s = happy; char[] chs = s.toCharArray(); for (int i = 0; i chs.length; i++) System.out.println(chs[i]); // 7.compareTo 比较两个字符串的大小，如果前者大， // 则返回正数，后者大，则返回负数，如果相等，返回 0 // 老韩解读 // (1) 如果长度相同，并且每个字符也相同，就返回 0 // (2) 如果长度相同或者不相同，但是在进行比较时，可以区分大小 // 就返回 if (c1 != c2) // return c1 - c2; // // (3) 如果前面的部分都相同，就返回 str1.len - str2.len String a = jcck;// len = 3 String b = jack;// len = 4 System.out.println(a.compareTo(b)); // 返回值是 c - a = 2 的值 // 8.format 格式字符串 /* 占位符有: * %s 字符串 %c 字符 %d 整型 %.2f 浮点型 * */ String name = john; int age = 10; double score = 56.857; char gender = 男; //将所有的信息都拼接在一个字符串. String info =我的姓名是 + name + 年龄是 + age + ,成绩是 + score + 性别是 + gender + 。希望大家喜欢我！; System.out.println(info); //老韩解读 //1. %s , %d , %.2f %c 称为占位符 //2. 这些占位符由后面变量来替换 //3. %s 表示后面由 字符串来替换 //4. %d 是整数来替换 //5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理 //6. %c 使用 char 类型来替换 String formatStr = 我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！; String info2 = String.format(formatStr, name, age, score, gender); System.out.println(info2= + info2); 进制转化 方法三：递归 StringBuffer 类介绍 //1. StringBuffer 的直接父类 是 AbstractStringBuilder //2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化 //3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final // 该 value 数组存放 字符串内容，引出存放在堆中的 //4. StringBuffer 是一个 final 类，不能被继承 //5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除) // 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String StringBuffer stringBuffer = new StringBuffer(hello); String和StringBuffer的相互转换//看 String——StringBuffer String str = hello tom; //方式 1 使用构造器 //注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响 StringBuffer stringBuffer = new StringBuffer(str); //方式 2 使用的是 append 方法 StringBuffer stringBuffer1 = new StringBuffer(); stringBuffer1 = stringBuffer1.append(str); //看看 StringBuffer -String StringBuffer stringBuffer3 = new StringBuffer(韩顺平教育); //方式 1 使用 StringBuffer 提供的 toString 方法 String s = stringBuffer3.toString(); //方式 2: 使用构造器来搞定 String s1 = new String(stringBuffer3); 常用方法上承String类方法。 StringBuffer s = new StringBuffer(hello); //增 s.append(,);// hello, s.append(张三丰);//hello,张三丰 s.append(赵敏).append(100).append(true).append(10.5);//hello,张三丰赵敏100true10.5 System.out.println(s);//hello,张三丰赵敏 100true10.5 //删 /* * 删除索引为=start end 处的字符 * 解读: 删除 11~14 的字符 [11, 14) */ s.delete(11, 14); System.out.println(s);//hello,张三丰赵敏true10.5 //改 //老韩解读，使用 周芷若 替换 索引 9-11 的字符 [9,11) s.replace(9, 11, 周芷若); System.out.println(s);//hello,张三丰周芷若 true10.5 //查找指定的子串在字符串第一次出现的索引，如果找不到返回-1 int indexOf = s.indexOf(张三丰); System.out.println(indexOf);//6 //插 //老韩解读，在索引为 9 的位置插入 赵敏,原来索引为 9 的内容自动后移 s.insert(9, 赵敏); System.out.println(s);//hello,张三丰赵敏周芷若 true10.5 //长度 System.out.println(s.length());//22 System.out.println(s); 对StringBuffer类对象进行修改，字数不需要对等，它会自动调整空间。 方法括号里的数字代表的都是索引数字。 insert，在索引为 9 的位置插入 “赵敏”,原来索引为 9 的内容自动后移。 **reverse()**，StringBuffer也可以用。 StringBuilder 的 reverse() 方法会直接修改 str 本身，而不是创建一个新的字符串。 测试题String str = null;// ok StringBuffer sb = new StringBuffer(); //ok sb.append(str);//需要看源码 , 底层调用的是 AbstractStringBuilder 的 appendNull System.out.println(sb.length());//4 System.out.println(sb);//null //下面的构造器，会抛出 NullpointerException StringBuffer sb1 = new StringBuffer(str);//看底层源码 super(str.length() + 16); System.out.println(sb1); str为空，所以将str转换为StringBuffer时会产生空指针异常；但是str的字符串长度为4，因为存储了null。 StringBuilder 类介绍和比较 StringBuffer stringBuffer = new StringBuffer(hello); String类要先转化为StringBuffer才能转化为StringBuider。 1. StringBuffer 的直接父类 是 AbstractStringBuilder2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final 该 value 数组存放 字符串内容，引出存放在堆中的4. StringBuffer 是一个 final 类，不能被继承5. 因为 StringBuffer 字符内容是存在 char[] value, 所以再变化(增加删除)不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String StringBuilder 常用方法和StringBuffer的方法一样。 Math类-常用方法（均为静态方法） //1.abs 绝对值 int abs = Math.abs(-9); System.out.println(abs);//9 //2.pow 求幂 double pow = Math.pow(2, 4);//2 的 4 次方 System.out.println(pow);//16 //3.ceil 向上取整,返回=该参数的最小整数(转成 double); double ceil = Math.ceil(3.9); System.out.println(ceil);//4.0 //4.floor 向下取整，返回=该参数的最大整数(转成 double) double floor = Math.floor(4.001); System.out.println(floor);//4.0 //5.round 四舍五入 Math.floor(该参数+0.5) long round = Math.round(5.51); System.out.println(round);//6 //6.sqrt 求开方 double sqrt = Math.sqrt(9.0); System.out.println(sqrt);//3.0 //7.random 求随机数 // random 返回的是 0 = x 1 之间的一个随机小数 // 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7 // 即返回一个数 x 2 = x = 7 // 老韩解读 Math.random() * (b-a) 返回的就是 0 = 数 b-a // (1) (int)(a) = x = (int)(a + Math.random() * (b-a +1) ) // (2) 使用具体的数给小伙伴介绍 a = 2 b = 7 // (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6) // Math.random()*6 返回的是 0 = x 6 小数 // 2 + Math.random()*6 返回的就是 2= x 8 小数 // (int)(2 + Math.random()*6) = 2 = x = 7 // (3) 公式就是 (int)(a + Math.random() * (b-a +1) ) for(int i = 0; i 100; i++) System.out.println((int)(2 + Math.random() * (7 - 2 + 1))); //max , min 返回最大值和最小值 int min = Math.min(1, 9); int max = Math.max(45, 90); System.out.println(min= + min); System.out.println(max= + max); Math.round()返回的是long类型的数。 Arrays 类常用方法（静态）需要引入Arrays类 toString就是返回数组内容；sort可以对字符数组进行排序。 fill方法是把原数组里的所有元素全部替换成填充的数字。 fill(arr,fromIndex,toIndex,value)，在范围内的替换为value。 基本数据类型和包装类都可以调用Arrays的方法。 import java.util.Arrays; public class c public static void main(String[] args) int[] arr = 1, 2, 90, 123, 567; // binarySearch 通过二分搜索法进行查找，要求必须排好 // 老韩解读 //1. 使用 binarySearch 二叉查找 //2. 要求该数组是有序的. 如果该数组是无序的，不能使用 binarySearch //3. 如果数组中不存在该元素，就返回 return -(low + 1); //low为该元素应该插入的位置，以维持数组的排序顺序。 int index = Arrays.binarySearch(arr, 567); System.out.println(index= + index); //copyOf 数组元素的复制 // 老韩解读 //1. 从 arr 数组中，拷贝 arr.length 个元素到 newArr 数组中 //2. 如果拷贝的长度 arr.length 就在新数组的后面 增加 null //3. 如果拷贝长度 0 就抛出异常 NegativeArraySizeException //4. 该方法的底层使用的是 System.arraycopy() int[] newArr = Arrays.copyOf(arr, arr.length); System.out.println(==拷贝执行完毕后==); System.out.println(Arrays.toString(newArr)); //fill 数组元素的填充 int[] num = new int[]9,3,2; //老韩解读 //1. 使用 99 去填充 num 数组，可以理解成是替换原理的元素 Arrays.fill(num, 99); System.out.println(==num 数组填充后==); System.out.println(Arrays.toString(num)); //equals 比较两个数组元素内容是否完全一致 int[] arr2 = 1, 2, 90, 123; //老韩解读 //1. 如果 arr 和 arr2 数组的元素一样，则方法 true; //2. 如果不是完全一样，就返回 false boolean equals = Arrays.equals(arr, arr2); System.out.println(equals= + equals); sort排序的定制排序sort是可以重载的，也可以通过传入一个接口 Comparator 实现定制排序，调用 定制排序 时，传入两个参数 (1) 排序的数组 arr (2) 实现了 Comparator 接口的匿名内部类 , 要求实现 compare 方法。 下面的是自己编写的冒泡排序方法加上实现定制排序的Comparator匿名类，用sort实现这种定制排序的原理和这种形式是一样的。 Arrays.sort(arr, new Comparator()) import java.util.Arrays; import java.util.Comparator; public class c public static void main(String[] args) int[] arr = 1, -1, 8, 0, 20; //bubble01(arr); bubble02(arr, new Comparator() @Override public int compare(Object o1, Object o2) int i1 = (Integer) o1; int i2 = (Integer) o2; return i2 - i1;// return i2 - i1; ); System.out.println(==定制排序后的情况==); System.out.println(Arrays.toString(arr)); //使用冒泡完成排序 public static void bubble01(int[] arr) int temp = 0; for (int i = 0; i arr.length - 1; i++) for (int j = 0; j arr.length - 1 - i; j++) //从小到大 if (arr[j] arr[j + 1]) temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; //结合冒泡 + 定制 public static void bubble02(int[] arr, Comparator c) int temp = 0; for (int i = 0; i arr.length - 1; i++) for (int j = 0; j arr.length - 1 - i; j++) //数组排序由 c.compare(arr[j], arr[j + 1])返回的值决定 if (c.compare(arr[j], arr[j + 1]) 0) temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; import java.util.Arrays; import java.util.Comparator; //(1)price 从大到小 Arrays.sort(books, new Comparator() //这里是对 Book 数组排序，因此 o1 和 o2 就是 Book 对象 @Override public int compare(Object o1, Object o2) Book book1 = (Book) o1; Book book2 = (Book) o2; double priceVal = book2.getPrice() - book1.getPrice(); //这里老师进行了一个转换 //如果发现返回结果和我们输出的不一致，就修改一下返回的 1 和 -1 if(priceVal 0) return 1; else if(priceVal 0) return -1; else return 0; ); //(2)price 从小到大 Arrays.sort(books, new Comparator() //这里是对 Book 数组排序，因此 o1 和 o2 就是 Book 对象 @Override public int compare(Object o1, Object o2) Book book1 = (Book) o1; Book book2 = (Book) o2; double priceVal = book2.getPrice() - book1.getPrice(); if(priceVal 0) return -1; else if(priceVal 0) return 1; else return 0; ); //(3)按照书名长度从大到小 Arrays.sort(books, new Comparator() //这里是对 Book 数组排序，因此 o1 和 o2 就是 Book 对象 @Override public int compare(Object o1, Object o2) Book book1 = (Book) o1; Book book2 = (Book) o2; //要求按照书名的长度来进行排序 return book2.getName().length() - book1.getName().length(); ); System 类-常用方法 //exit 退出当前程序 System.out.println(ok1); //老韩解读 //1. exit(0) 表示程序退出 //2. 0 表示一个状态 , 正常的状态 System.exit(0);// System.out.println(ok2); //currentTimeMillens:返回当前时间距离 1970-1-1 的毫秒数 // 老韩解读: System.out.println(System.currentTimeMillis()); //实现方法，调用 job 方法 //得到开始的时间 long start = System.currentTimeMillis(); job(); //得的结束的时间 long end = System.currentTimeMillis(); System.out.println(任务执行时间 + (end - start)); arraycopy的翻前面的去看。 BigInteger 和 BigDecimal 类 使用方法都需要引入相关类。 import java.math.BigInteger; //当我们编程中，需要处理很大的整数，long 不够用 //可以使用 BigInteger 的类来搞定 BigInteger bigInteger = new BigInteger(23788888899999999999999999999); BigInteger bigInteger2 = new BigInteger(10099999999999999999999999999999999999999999999999999999999999999999999999999999999); System.out.println(bigInteger); //老韩解读 //1. 在对 BigInteger 进行加减乘除的时候，需要使用对应的方法，不能直接进行 + - * / //2. 可以创建一个 要操作的 BigInteger 然后进行相应操作 BigInteger add = bigInteger.add(bigInteger2); System.out.println(add);// BigInteger subtract = bigInteger.subtract(bigInteger2); System.out.println(subtract);//减 BigInteger multiply = bigInteger.multiply(bigInteger2); System.out.println(multiply);//乘 BigInteger divide = bigInteger.divide(bigInteger2); System.out.println(divide);//除 BigInteger add = bigInteger.add(bigInteger2);代表的是bigInteger和bigInteger2相加，其它的类似。 BigDecimal类的方法调用和赋值与BigInteger类似。 import java.math.BigDecimal; 需要注意的是除法。 //System.out.println(bigDecimal.divide(bigDecimal2));//可能抛出异常 ArithmeticException //在调用 divide 方法时，指定精度即可. BigDecimal.ROUND_CEILING //如果有无限循环小数，就会保留 分子 的精度 System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING)); 日期类第一代日期类 import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class c public static void main(String[] args) throws ParseException // 添加 throws ParseException //1. 获取当前系统时间 //2. 这里的 Date 类是在 java.util 包 //3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换 Date d1 = new Date(); // 获取当前系统时间 d1.getTime(); //返回的是一个 long 类型的值，表示自1970年1月1日00:00:00 UTC以来的毫秒数。 System.out.println(当前日期= + d1); Date d2 = new Date(9234567); // 通过指定毫秒数得到时间 System.out.println(d2= + d2); // 获取某个时间对应的毫秒数 // 老韩解读 //1. 创建 SimpleDateFormat 对象，可以指定相应的格式 //2. 这里的格式使用的字母是规定好，不能乱写 SimpleDateFormat sdf = new SimpleDateFormat(yyyy 年 MM 月 dd 日 HH:mm:ss E); String format = sdf.format(d1); // format:将日期转换成指定格式的字符串 System.out.println(当前日期= + format); // 老韩解读 //1. 可以把一个格式化的 String 转成对应的 Date //2. 得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换 //3. 在把 String - Date ， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常 String s = 2024 年 08 月 04 日 04:32:53 周日; Date parse = sdf.parse(s); System.out.println(parse= + sdf.format(parse)); 如果想要将String转成对应的Date的话，需要引入import java.text.ParseException;，并且在主方法还需要抛出ParseException， public static void main(String[] args) throws ParseException，因为即使格式正确，但是Date parse = sdf.parse(s);这句在编译时仍会产生该异常，在主方法添加完后，如果格式不正确就会在运行时产生该异常，导致不能运行下去。 date.getTime(): date.getTime() 返回的是一个 long 类型的值，表示自1970年1月1日00:00:00 UTC以来的毫秒数。 //1. 创建 SimpleDateFormat 对象，可以指定相应的格式 //2. 这里的格式使用的字母是规定好，不能乱写 SimpleDateFormat sdf = new SimpleDateFormat(yyyy 年 MM 月 dd 日 HH:mm:ss E); 格式不是固定的，字母是固定的，格式是自己编写的。 h代表12小时制，H代表24小时制，但输入时都需按照24小时制输入。 第二代日期类 import java.util.Calendar; public class c public static void main(String[] args) //1. Calendar 是一个抽象类， 并且构造器是 private //2. 可以通过 getInstance() 来获取实例 //3. 提供大量的方法和字段提供给程序员 //4. Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活) //5. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成= Calendar.HOUR_OF_DAY Calendar c = Calendar.getInstance(); //创建日历类对象//比较简单，自由 System.out.println(c= + c); //2.获取日历对象的某个日历字段 System.out.println(年： + c.get(Calendar.YEAR)); // 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号 System.out.println(月： + (c.get(Calendar.MONTH) + 1)); System.out.println(日： + c.get(Calendar.DAY_OF_MONTH)); System.out.println(小时： + c.get(Calendar.HOUR)); System.out.println(分钟： + c.get(Calendar.MINUTE)); System.out.println(秒： + c.get(Calendar.SECOND)); //Calender 没有专门的格式化方法，所以需要程序员自己来组合显示 System.out.println(c.get(Calendar.YEAR) + - + (c.get(Calendar.MONTH) + 1) + - + c.get(Calendar.DAY_OF_MONTH) + + c.get(Calendar.HOUR_OF_DAY) + : + c.get(Calendar.MINUTE) + : + c.get(Calendar.SECOND) ); 第三代日期类（感觉比较好用） import java.time.LocalDate; import java.time.LocalDateTime; import java.time.LocalTime; import java.time.format.DateTimeFormatter; public class c public static void main(String[] args) //1. 使用 now() 返回表示当前日期时间的 对象 LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now() System.out.println(ldt); //2. 使用 DateTimeFormatter 对象来进行格式化 // 创建 DateTimeFormatter 对象 DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(yyyy-MM-dd HH:mm:ss); String format = dateTimeFormatter.format(ldt); System.out.println(格式化的日期= + format); System.out.println(年= + ldt.getYear()); System.out.println(月= + ldt.getMonth()); System.out.println(月= + ldt.getMonthValue()); System.out.println(日= + ldt.getDayOfMonth()); System.out.println(时= + ldt.getHour()); System.out.println(分= + ldt.getMinute()); System.out.println(秒= + ldt.getSecond()); LocalDate now = LocalDate.now(); //可以获取年月日 LocalTime now2 = LocalTime.now();//获取到时分秒 //提供 plus 和 minus 方法可以对当前时间进行加或者减 //看看 890 天后，是什么时候 把 年月日-时分秒 LocalDateTime localDateTime = ldt.plusDays(890); System.out.println(890 天后= + dateTimeFormatter.format(localDateTime)); //看看在 3456 分钟前是什么时候，把 年月日-时分秒输出 LocalDateTime localDateTime2 = ldt.minusMinutes(3456); System.out.println(3456 分钟前 日期= + dateTimeFormatter.format(localDateTime2)); plusDays，minusMinutes应该就是plus和minus后面加时间表示后面括号里的数字代表什么。 DateTimeFormatter 格式日期类 SimpleDateFormate用于第一代日期类。 Instant 时间戳 表示的是格林威治时间。 集合 集合的框架体系 迭代器（Iterable）：是所有集合的基础，定义了遍历集合元素的方法。 集合（Collection）：是Java集合框架的根接口，提供了基本的集合操作，如添加、删除和检查元素。 列表（List）：是Collection的子接口，支持元素的随机访问，并允许在列表中插入和删除元素。 向量（Vector）：是List的一个实现，提供了线程安全的操作，但性能上可能不如ArrayList。 数组列表（ArrayList）：是List的另一个实现，使用动态数组来存储元素，提供了快速访问和修改的功能。 链表（LinkedList）：也是List的一个实现，使用链表结构存储元素，适用于频繁的插入和删除操作。 树集（TreeSet）：是基于红黑树实现的Set接口，它确保集合元素处于排序状态，不允许重复元素。 哈希集（HashSet）：是Set接口的另一个实现，不保证集合的迭代顺序，且允许null元素的存在。 Map：是Java中最基础的数据结构之一，提供了键值对的存储方式。 HashMap：是Map接口的一个常用实现，通过哈希表来存储键值对，提供了较快的访问速度。 TreeMap：是Map接口的另一种实现，它使用红黑树来存储键值对，可以确保元素按照键的顺序进行排序。 Hashtable：是Java早期版本中提供的一个线程安全的哈希表实现，但因其性能较低，在现代Java开发中较少使用。 LinkedHashMap：保留了插入顺序的HashMap实现，它维护了一个双向链表来记录元素的插入顺序。 Properties：是Java标准库中的一个类，用于处理键值对，通常用于配置文件或作为字典使用。 1. 集合主要是两组(单列集合 , 双列集合) 2. Collection 接口有两个重要的子接口 List，Set , 他们的实现子类都是单列集合 3. Map 接口的实现子类 是双列集合，存放的 K-V import java.util.ArrayList; import java.util.HashMap; public class c public static void main(String[] args) ArrayList arrayList = new ArrayList(); arrayList.add(jack); arrayList.add(tom); HashMap hashMap = new HashMap(); hashMap.put(NO1, 北京); hashMap.put(NO2, 上海); Collection 接口和常用方法Collection 接口实现类的特点 Collection 接口常用方法,以实现子类 ArrayList 来演示 import java.util.ArrayList; import java.util.List; public class c @SuppressWarnings(unchecked, rawtypes) public static void main(String[] args) List list = new ArrayList(); // add:添加单个元素 list.add(jack); list.add(10);//list.add(new Integer(10)) list.add(true); System.out.println(list= + list); // remove:删除指定元素，并返回该元素 //list.remove(0);//删除第一个元素 list.remove(true);//指定删除某个元素 System.out.println(list= + list); // contains:查找元素是否存在 System.out.println(list.contains(jack));//T // size:获取元素个数 System.out.println(list.size());//2 // isEmpty:判断是否为空 System.out.println(list.isEmpty());//F // clear:清空 list.clear(); System.out.println(list= + list); // addAll:添加多个元素 ArrayList list2 = new ArrayList(); list2.add(红楼梦); list2.add(三国演义); list.addAll(list2);//list.addAll(红楼梦,三国演义)，这样是错的 System.out.println(list= + list); // containsAll:查找多个元素是否都存在 System.out.println(list.containsAll(list2));//T // removeAll：删除多个元素 list.add(聊斋); list.removeAll(list2); System.out.println(list= + list);//[聊斋] // 说明：以 ArrayList 实现类来演示. remove:删除指定元素后数组列表里的元素会自动填补空缺。 remove括号里面加的是索引的话（索引内容，如果存储1的话，那么remove(1)删除的是序列为1的元素而不是1），会返回一个Object型的该索引对应的数据，但如果后面加的是对象的话就不会返回。 原文里面用@SuppressWarnings(all)抑制全部警告，我感觉这样不好，所以就一个个抑制没什么大问题的警报，@SuppressWarnings(unchecked, rawtypes)，这两个是由List以及相关方法引起的（也适用于下面的内容，Set、Map），与语法对错无关。 Collection 接口遍历元素方式使用 Iterator(迭代器) Collection的子接口例如List等也都可以使用迭代器。 coll是Collection的一个对象。 import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class c @SuppressWarnings(rawtypes, unchecked) public static void main(String[] args) Collection col = new ArrayList(); col.add(new Book(三国演义, 罗贯中, 10.1)); col.add(new Book(小李飞刀, 古龙, 5.1)); col.add(new Book(红楼梦, 曹雪芹, 34.6)); //System.out.println(col= + col); //现在老师希望能够遍历 col 集合 //1. 先得到 col 对应的 迭代器 Iterator iterator = col.iterator(); //2. 使用 while 循环遍历 // while (iterator.hasNext()) //判断是否还有数据 // //返回下一个元素，类型是 Object // Object obj = iterator.next(); // System.out.println(obj= + obj); // //老师教大家一个快捷键，快速生成 while = itit //显示所有的快捷键的的快捷键 ctrl + j while (iterator.hasNext()) Object obj = iterator.next(); System.out.println(obj= + obj); //3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素 // iterator.next();//NoSuchElementException //4. 如果希望再次遍历，需要重置我们的迭代器 iterator = col.iterator(); System.out.println(===第二次遍历===); while (iterator.hasNext()) Object obj = iterator.next(); System.out.println(obj= + obj); class Book private String name; private String author; private double price; public Book(String name, String author, double price) this.name = name; this.author = author; this.price = price; @Override public String toString() return Book + name= + name + \\ + , author= + author + \\ + , price= + price + ; System.out.println(col= + col);仍然可以一次性输出col的内容。 for 循环增强 List list = new ArrayList(); list.add(new Dog(小黑, 3)); list.add(new Dog(大黄, 100)); list.add(new Dog(大壮, 8)); //先使用 for 增强 for (Object dog : list) System.out.println(dog= + dog); //使用迭代器 System.out.println(===使用迭代器来遍历===); Iterator iterator = list.iterator(); for (Object dog : list)这个for语句里的对象类型必须是Object。因为元素在存入list中的时候会转化为Object类型。 List 接口和常用方法介绍和常用方法 索引是从 0 开始的。 import java.util.ArrayList; import java.util.List; public class c @SuppressWarnings(rawtypes, unchecked) public static void main(String[] args) List list = new ArrayList(); list.add(张三丰); list.add(贾宝玉); // void add(int index, Object ele):在 index 位置插入 ele 元素 //在 index = 1 的位置插入一个对象 list.add(1, 韩顺平); System.out.println(list= + list); // boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来 List list2 = new ArrayList(); list2.add(jack); list2.add(tom); list.addAll(1, list2); System.out.println(list= + list); // Object get(int index):获取指定 index 位置的元素 //说过 // int indexOf(Object obj):返回 obj 在集合中首次出现的位置 System.out.println(list.indexOf(tom));//2 // int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置 list.add(韩顺平); System.out.println(list= + list); System.out.println(list.lastIndexOf(韩顺平)); // Object remove(int index):移除指定 index 位置的元素，并返回此元素 list.remove(0); System.out.println(list= + list); // Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换. list.set(1, 玛丽); System.out.println(list= + list); // List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合 // 注意返回的子集合 fromIndex = subList toIndex List returnlist = list.subList(0, 2); System.out.println(returnlist= + returnlist); void add(int index, Object ele):在 index 位置插入 ele 元素原索引位置的元素依次后移。 list.getLast()：取最后一个元素。 List 的三种遍历方式 使用普通 for for (int i = 0; i list.size(); i++) System.out.println(对象= + list.get(i)); ArrayList 底层结构和源码分析 指定大小：List list new ArrayList(5); 想看源码去pdf里面看。 Vector 底层结构和源码剖析 想看源码自己去pdf里面看。 Vector 和 ArrayList 的比较 LinkedList 底层结构 Set 接口和常用方法 和 List 接口一样, Set 接口也是 Collection 的子接口，因此，常用方法和 Collection 接口一样。 Set 接口实现类HashSet基础 可以连续存放相同的值，程序不会报错，但最后只会存储第一个值，就是只存储一个。 底层机制+存储自定义类时的注意事项想看源码去pdf。 哈希值一样后根据equals方法判断内容是否相同，因此要注意存储的对象类型是否有覆盖equals方法，若没有则按Object类的equals方法来，即比较两个对象的引用（内存地址）是否相同。 import java.util.HashSet; public class c @SuppressWarnings(rawtypes, unchecked) public static void main(String[] args) HashSet set = new HashSet(); //说明 //1. 在执行 add 方法后，会返回一个 boolean 值 //2. 如果添加成功，返回 true, 否则返回 false //3. 可以通过 remove 指定删除哪个对象 System.out.println(set.add(john));//T System.out.println(set.add(lucy));//T System.out.println(set.add(john));//F System.out.println(set.add(jack));//T System.out.println(set.add(Rose));//T set.remove(john); System.out.println(set= + set);//3 个 // set = new HashSet(); System.out.println(set= + set);//0 //4 Hashset 不能添加相同的元素/数据? set.add(lucy);//添加成功 set.add(lucy);//加入不了 set.add(new Dog(tom));//OK set.add(new Dog(tom));//Ok System.out.println(set= + set); //在加深一下. 非常经典的面试题. //看源码，做分析， 先给小伙伴留一个坑，以后讲完源码，你就了然 //去看他的源码，即 add 到底发生了什么?= 底层机制. set.add(new String(hsp));//ok set.add(new String(hsp));//加入不了. System.out.println(set= + set); class Dog //定义了 Dog 类 private String name; public Dog(String name) this.name = name; @Override public String toString() return Dog + name= + name + \\ + ; 在Java中，HashSet是基于哈希表实现的集合，它确保集合中的元素是唯一的，即不能添加相同的元素（根据元素的equals()和hashCode()方法判断）。 然而，在示例中，Dog类没有覆盖equals()和hashCode()方法。因此，默认情况下，HashSet会使用Object类中的equals()和hashCode()方法来比较对象的引用是否相等。HashSet使用默认的Object类的实现，这将比较对象的引用（内存地址）。在Java中，对象的引用不同即使其内容相同，也会被视为不同的对象。 具体到代码，当添加两个相同名称的Dog对象时，例如new Dog(tom)，由于每次使用new关键字创建一个新的对象实例，这两个对象的引用是不同的。即使它们的内容相同，它们在内存中的地址也不同。 因此，HashSet会将这两个对象视为不同的元素，并将它们都添加到集合中。 在Java中，String类覆盖了equals()和hashCode()方法，String类的hashCode方法是根据字符串的内容来计算哈希值的。这意味着两个内容相同的String对象会被认为是相等的，并且它们的哈希码也相同。因此，当你尝试将两个内容相同的String对象添加到HashSet中时，第二个String对象不会被添加，因为HashSet检测到集合中已经存在一个相同的元素。 如果希望HashSet根据对象的内容（比如Dog对象的名称）来判断是否相等，则需要在Dog类中覆盖equals()和hashCode()方法。例如，可以根据name属性来实现这两个方法，这样相同名称的Dog对象就会被视为相等，不能重复添加到HashSet中。 class Dog private String name; public Dog(String name) this.name = name; @Override public boolean equals(Object o) if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Dog dog = (Dog) o; return Objects.equals(name, dog.name); @Override public int hashCode() return Objects.hash(name); @Override public String toString() return Dog + name= + name + \\ + ; 为什么没有重写hashCode方法还是会存储两个相同的Dog对象。 在这种情况下，即使两个Dog对象的name属性相同，它们的哈希码仍然是基于Object类的hashCode()方法，该方法返回对象的内存地址。因此，两个相同name的Dog对象会有不同的哈希码，被存储在不同的哈希桶中。而HashSet的存储机制是当俩个哈希码相同的时候才会调用equals方法进行判断，若两个对象的哈希码都不同则存储在两个不同的地方，不会调用equals。 Objects.equals(Object a, Object b)方法会执行以下操作： 如果a和b都是null，返回true。 如果只有一个是null，返回false。 否则，返回a.equals(b)的结果。 使用equals还避免了name字段为null时的空指针异常。 若自定义类有两个属性，两个属性都相同则为同一对象，如下覆盖，其余类似 @Override public boolean equals(Object o) if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee employee = (Employee) o; return age == employee.age Objects.equals(name, employee.name); @Override public int hashCode() return Objects.hash(name, age); LinkedHashSet+double类的compare Double类中的compare方法用于比较两个double值。它返回一个整数，指示第一个double值是等于、少于还是大于第二个double值。这种方法可以避免浮点数直接比较时可能出现的误差问题。 Double.compare(double d1, double d2) 返回值： 如果d1等于d2，返回0。 如果d1小于d2，返回一个负数。 如果d1大于d2，返回一个正数。 Map 接口和常用方法基础 当有相同的 k , 就等价于替换。 import java.util.HashMap; import java.util.Map; public class c @SuppressWarnings(rawtypes, unchecked) public static void main(String[] args) Map map = new HashMap(); map.put(no1, 韩顺平);//k-v map.put(no2, 张无忌);//k-v map.put(no1, 张三丰);//当有相同的 k , 就等价于替换. map.put(no3, 张三丰);//k-v map.put(null, null); //k-v map.put(null, abc); //等价替换 map.put(no4, null); //k-v map.put(no5, null); //k-v map.put(1, 赵敏);//k-v map.put(new Object(), 金毛狮王);//k-v // 通过 get 方法，传入 key ,会返回对应的 value System.out.println(map.get(no2));//张无忌 System.out.println(map= + map); Map 接口常用方法import java.util.HashMap; import java.util.Map; public class c @SuppressWarnings(rawtypes, unchecked) public static void main(String[] args) Map map = new HashMap(); map.put(邓超, new Book(, 100));//OK map.put(邓超, 孙俪);//替换- 一会分析源码 map.put(王宝强, 马蓉);//OK map.put(宋喆, 马蓉);//OK map.put(刘令博, null);//OK map.put(null, 刘亦菲);//OK map.put(鹿晗, 关晓彤);//OK map.put(hsp, hsp 的老婆); System.out.println(map= + map); // remove:根据键删除映射关系 map.remove(null); System.out.println(map= + map); // get：根据键获取值 Object val = map.get(鹿晗); System.out.println(val= + val); // size:获取元素个数 System.out.println(k-v= + map.size()); // isEmpty:判断个数是否为 0 System.out.println(map.isEmpty());//F // clear:清除 k-v //map.clear(); System.out.println(map= + map); // containsKey:查找键是否存在 System.out.println(结果= + map.containsKey(hsp));//T class Book private String name; private int num; public Book(String name, int num) this.name = name; this.num = num; 遍历方法： import java.util.*; public class c @SuppressWarnings(rawtypes, unchecked) public static void main(String[] args) Map map = new HashMap(); map.put(邓超, 孙俪); map.put(王宝强, 马蓉); map.put(宋喆, 马蓉); map.put(刘令博, null); map.put(null, 刘亦菲); map.put(鹿晗, 关晓彤); //第一组: 先取出 所有的 Key , 通过 Key 取出对应的 Value Set keyset = map.keySet(); //(1) 增强 for System.out.println(-----第一种方式-------); for (Object key : keyset) System.out.println(key + - + map.get(key)); //(2) 迭代器 System.out.println(----第二种方式--------); Iterator iterator = keyset.iterator(); while (iterator.hasNext()) Object key = iterator.next(); System.out.println(key + - + map.get(key)); //第二组: 把所有的 values 取出 Collection values = map.values(); //这里可以使用所有的 Collections 使用的遍历方法 //(1) 增强 for System.out.println(---取出所有的 value 增强 for----); for (Object value : values) System.out.println(value); //(2) 迭代器 System.out.println(---取出所有的 value 迭代器----); Iterator iterator2 = values.iterator(); while (iterator2.hasNext()) Object value = iterator2.next(); System.out.println(value); //第三组: 通过 entrySet 来获取 k-v Set entrySet = map.entrySet();// entrySetMap.EntryK,V //(1) 增强 for System.out.println(----使用 EntrySet 的 for 增强(第 3 种)----); for (Object entry : entrySet) //将 entry 转成 Map.Entry Map.Entry m = (Map.Entry) entry; System.out.println(m.getKey() + - + m.getValue()); //(2) 迭代器 System.out.println(----使用 EntrySet 的 迭代器(第 4 种)----); Iterator iterator3 = entrySet.iterator(); while (iterator3.hasNext()) Object entry = iterator3.next(); //System.out.println(next.getClass());//HashMap$Node -实现- Map.Entry (getKey,getValue) //向下转型 Map.Entry Map.Entry m = (Map.Entry) entry; System.out.println(m.getKey() + - + m.getValue()); Map 接口实现类HashMap 源码看pdf Hashtable Properties key和value也不能为null。 没教第3、4点。 开发中如何选择集合实现类 TreeSet import java.util.Comparator; import java.util.TreeSet; public class c @SuppressWarnings(rawtypes, unchecked) public static void main(String[] args) //1. 当我们使用无参构造器，创建 TreeSet 时，仍然是无序的 //2. 老师希望添加的元素，按照字符串大小来排序 //3. 使用 TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类) // 并指定排序规则 //4. 简单看看源码 //老韩解读 /* 1. 构造器把传入的比较器对象，赋给了 TreeSet 的底层的 TreeMap 的属性 this.comparator public TreeMap(Comparator? super K comparator) this.comparator = comparator; 2. 在 调用 treeSet.add(tom), 在底层会执行到 if (cpr != null) //cpr 就是我们的匿名内部类(对象) do parent = t; //动态绑定到我们的匿名内部类(对象)compare cmp = cpr.compare(key, t.key); if (cmp 0) t = t.left; else if (cmp 0) t = t.right; else //如果相等，即返回 0,这个 Key 就没有加入 return t.setValue(value); while (t != null); */ // TreeSet treeSet = new TreeSet(); TreeSet treeSet = new TreeSet(new Comparator() @Override public int compare(Object o1, Object o2) //下面 调用 String 的 compareTo 方法进行字符串大小比较 //如果老韩要求加入的元素，按照长度大小排序 //return ((String) o2).compareTo((String) o1); return ((String) o1).length() - ((String) o2).length(); ); //添加数据. treeSet.add(jack); treeSet.add(tom);//3 treeSet.add(sp); treeSet.add(a); treeSet.add(abc);//3 System.out.println(treeSet= + treeSet); 根据源码，当想加入的两个对象有compare判断返回0时就只会添加第一个。例子里的”tom”和”abc”就只添加了”tom”。 如果只是TreeSet treeSet = new TreeSet();就是没有添加Comparator的时候，是按自然顺序排列的。 TreeMap 道理和TreeSet一样。 Collections 工具类 排序操作(Collections里的static方法) import java.util.*; public class c @SuppressWarnings(rawtypes, unchecked) public static void main(String[] args) //创建 ArrayList 集合，用于测试. List list = new ArrayList(); list.add(tom); list.add(smith); list.add(king); list.add(milan); list.add(tom); // reverse(List)：反转 List 中元素的顺序 Collections.reverse(list); System.out.println(list= + list); // shuffle(List)：对 List 集合元素进行随机排序 // for (int i = 0; i 5; i++) // Collections.shuffle(list); // System.out.println(list= + list); // // sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 Collections.sort(list); System.out.println(自然排序后); System.out.println(list= + list); // sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 //我们希望按照 字符串的长度大小排序 Collections.sort(list, new Comparator() @Override public int compare(Object o1, Object o2) //可以加入校验代码. return ((String) o2).length() - ((String) o1).length();//注意是o2-o1 ); System.out.println(字符串长度大小排序= + list);//从长到短排 // swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换 //比如 Collections.swap(list, 0, 1); System.out.println(交换后的情况); System.out.println(list= + list); //Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 System.out.println(自然顺序最大元素= + Collections.max(list)); //Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 //比如，我们要返回长度最大的元素 Object maxObject = Collections.max(list, new Comparator() @Override public int compare(Object o1, Object o2) return ((String)o1).length() - ((String)o2).length(); //看源码得知应该是如果compare(o1,o2)0,则等于o1 ); System.out.println(长度最大的元素= + maxObject); //Object min(Collection) //Object min(Collection，Comparator) //上面的两个方法，参考 max 即可 //int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 System.out.println(tom 出现的次数= + Collections.frequency(list, tom)); //void copy(List dest,List src)：将 src 中的内容复制到 dest 中 ArrayList dest = new ArrayList(); //为了完成一个完整拷贝，我们需要先给 dest 赋值，大小和 list.size()一样 for(int i = 0; i list.size(); i++) dest.add(); //拷贝 Collections.copy(dest, list); System.out.println(dest= + dest); //boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值 //如果 list 中，有 tom 就替换成 汤姆 Collections.replaceAll(list, tom, 汤姆); System.out.println(list 替换后= + list); 自然排序是一种默认的对象排序方式，它是根据对象的内在特征或属性来排序的，通常是按升序。例如，对于整数，自然排序是按照数字的大小进行排序；对于字符串，自然排序是按照字母的字典顺序进行排序。自然排序通常是最直观和常见的排序方式，它使得对象在集合中以一种有序的方式存储和检索。 在 Java 中，自然排序是通过 Comparable 接口来实现的。这个接口定义了一个 compareTo 方法，允许对象自己来决定如何与其他对象进行比较。对于自定义类型，需要确保该类实现了Comparable接口，并重写compareTo方法来定义自然顺序（例子在下面）。 import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Scanner; //从大到小排序 public class Main public static void main(String[] args) Scanner scanner = new Scanner(System.in); Customer customer1 = new Customer(小明,scanner.nextInt()); Customer customer2 = new Customer(小军,scanner.nextInt()); Customer customer3 = new Customer(小红,scanner.nextInt()); ListCustomer customers = new ArrayList(); customers.add(customer1); customers.add(customer2); customers.add(customer3); Collections.sort(customers); System.out.println(customers); class Customer implements ComparableCustomer private String name; private int consumption; public Customer(String name, int consumption) this.name = name; this.consumption = consumption; @Override public String toString() return Customer + name= + name + \\ + , consumption= + consumption + ; public int compareTo(Customer customer) return customer.consumption - this.consumption; frequency: import java.util.*; public class c @SuppressWarnings(rawtypes, unchecked) public static void main(String[] args) String sentence = Asenal.North London Forever!We are champion.We want more.; String[] split = sentence.split([ .!]); List list = Arrays.asList(split); Map map = new HashMap(); for(Object object : list) map.put(object,Collections.frequency(list,object)); System.out.println(map); 泛型引入/* 请编写程序，在 ArrayList 中，添加 3 个 Dog 对象 Dog 对象含有 name 和 age, 并输出 name 和 age (要求使用 getXxx()) */ //使用传统的方法来解决 ArrayList arrayList = new ArrayList(); arrayList.add(new Dog(旺财, 10)); arrayList.add(new Dog(发财, 1)); arrayList.add(new Dog(小黄, 5)); //假如我们的程序员，不小心，添加了一只猫 arrayList.add(new Cat(招财猫, 8)); //遍历 for (Object o : arrayList) //向下转型 Object -Dog Dog dog = (Dog) o; System.out.println(dog.getName() + - + dog.getAge()); 可以发现无论是猫还是狗都可以存入arrayList中，并且程序在编译阶段不会出错，但是在运行阶段会出错。 分析使用传统方法解决问题： 使用泛型来解决：ArrayListDog arrayList = new ArrayListDog(); //1. 当我们 ArrayListDog 表示存放到 ArrayList 集合中的元素是 Dog 类型 (细节后面说...) //2. 如果编译器发现添加的类型，不满足要求，就会报错 //3. 在遍历的时候，可以直接取出 Dog 类型而不是 Object //4. public class ArrayListE E 称为泛型,那么 Dog-E ArrayListDog arrayList = new ArrayListDog(); arrayList.add(new Dog(旺财, 10)); arrayList.add(new Dog(发财, 1)); arrayList.add(new Dog(小黄, 5)); //假如我们的程序员，不小心，添加了一只猫 // arrayList.add(new Cat(招财猫, 8)); System.out.println(===使用泛型====); for (Dog dog : arrayList) System.out.println(dog.getName() + - + dog.getAge()); 使用泛型来解决问题时，当添加猫的时候系统就会发出警报了。 介绍 与第4点相关的代码： public class c public static void main(String[] args) //注意，特别强调： E 具体的数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型 PersonString person = new PersonString(韩顺平教育); person.show(); //String /* 你可以这样理解，上面的 Person 类 class Person String s ;//E 表示 s 的数据类型, 该数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型 public Person(String s) //E 也可以是参数类型 this.s = s; public String f() //返回类型使用 E return s; */ PersonInteger person2 = new PersonInteger(100); person2.show();//Integer /* class Person Integer s ;//E 表示 s 的数据类型, 该数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型 public Person(Integer s) //E 也可以是参数类型 this.s = s; public Integer f() //返回类型使用 E return s; */ //泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型， // 或者是某个方法的返回值的类型，或者是参数类型 class PersonE E s;//E 表示 s 的数据类型, 该数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型 public Person(E s) //E 也可以是参数类型 this.s = s; public E f() //返回类型使用 E return s; public void show() System.out.println(s.getClass());//显示 s 的运行类型 泛型的语法声明： 实例化： import java.util.*; public class c @SuppressWarnings(rawtypes, unchecked) public static void main(String[] args) //使用泛型方式给 HashSet 放入 3 个学生对象 HashSetStudent students = new HashSetStudent(); students.add(new Student(jack, 18)); students.add(new Student(tom, 28)); students.add(new Student(mary, 19)); //遍历 for (Student student : students) System.out.println(student); //使用泛型方式给 HashMap 放入 3 个学生对象 //K - String,V-Student HashMapString, Student hm = new HashMapString, Student(); /* public class HashMapK,V */ hm.put(milan, new Student(milan, 38)); hm.put(smith, new Student(smith, 48)); hm.put(hsp, new Student(hsp, 28)); //迭代器 EntrySet /* public SetMap.EntryK,V entrySet() SetMap.EntryK,V es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es; */ SetMap.EntryString, Student entries = hm.entrySet(); /* public final IteratorMap.EntryK,V iterator() return new EntryIterator(); */ IteratorMap.EntryString, Student iterator = entries.iterator(); System.out.println(==============================); while (iterator.hasNext()) Map.EntryString, Student next = iterator.next(); System.out.println(next.getKey() + - + next.getValue()); class Student private String name; private int age; public Student(String name, int age) this.name = name; this.age = age; public String getName() return name; public void setName(String name) this.name = name; public int getAge() return age; public void setAge(int age) this.age = age; @Override public String toString() return Student + name= + name + \\ + , age= + age + ; IteratorMap.EntryString, Student iterator = entries.iterator(); 注意事项和细节 import java.util.*; public class c @SuppressWarnings(rawtypes, unchecked) public static void main(String[] args) //2. 说明 //因为 E 指定了 A 类型, 构造器传入了 new A() //在给泛型指定具体类型后，可以传入该类型或者其子类类型 PigA aPig = new PigA(new A()); aPig.f(); PigA aPig2 = new PigA(new B()); aPig2.f(); //3. 泛型的使用形式 ArrayListInteger list1 = new ArrayListInteger(); ListInteger list2 = new ArrayListInteger(); //在实际开发中，我们往往简写 //编译器会进行类型推断, 老师推荐使用下面写法 ArrayListInteger list3 = new ArrayList(); ListInteger list4 = new ArrayList(); ArrayListPig pigs = new ArrayList(); //4. 如果是这样写 泛型默认是 Object ArrayList arrayList = new ArrayList();//等价 ArrayListObject arrayList = new ArrayListObject(); /* public boolean add(Object e) ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; */ Tiger tiger = new Tiger(); /* class Tiger //类 Object e; public Tiger() public Tiger(Object e) this.e = e; */ class TigerE //类 E e; public Tiger() public Tiger(E e) this.e = e; class A class B extends A class PigE // E e; public Pig(E e) this.e = e; public void f() System.out.println(e.getClass()); //运行类型 自定义泛型自定义泛型类 上面有出现过。 package com.Hnu.experiment; import java.util.*; public class test @SuppressWarnings(rawtypes) public static void main(String[] args) //T=Double, R=String, M=Integer TigerDouble,String,Integer g = new Tiger(john); g.setT(10.9); //OK //g.setT(yy); //错误，类型不对 System.out.println(g); Tiger g2 = new Tiger(john~~);//OK T=Object R=Object M=Object g2.setT(yy); //OK ,因为 T=Object yy=String 是 Object 子类 System.out.println(g2= + g2); //老韩解读 //1. Tiger 后面泛型，所以我们把 Tiger 就称为自定义泛型类 //2, T, R, M 泛型的标识符, 一般是单个大写字母 //3. 泛型标识符可以有多个. //4. 普通成员可以使用泛型 (属性、方法) //5. 使用泛型的数组，不能初始化 //6. 静态方法中不能使用类的泛型 class TigerT, R, M String name; R r; //属性使用到泛型 M m; T t; //因为数组在 new 不能确定 T 的类型，就无法在内存开空间 T[] ts; public Tiger(String name) this.name = name; public Tiger(R r, M m, T t) //构造器使用泛型 this.r = r; this.m = m; this.t = t; public Tiger(String name, R r, M m, T t) //构造器使用泛型 this.name = name; this.r = r; this.m = m; this.t = t; //因为静态是和类相关的，在类加载时，对象还没有创建 //所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化,所以不能使用类的泛型 // static R r2; // public static void m1(M m) // // //方法使用泛型 public String getName() return name; public void setName(String name) this.name = name; public R getR() return r; public void setR(R r) //方法使用到泛型 this.r = r; public M getM() //返回类型可以使用泛型. return m; public void setM(M m) this.m = m; public T getT() return t; public void setT(T t) this.t = t; @Override public String toString() return Tiger + name= + name + \\ + , r= + r + , m= + m + , t= + t + , ts= + Arrays.toString(ts) + ; 自定义泛型接口 接口中定义的属性都是静态属性，所以不能使用泛型来定义。 继承接口的时候也要确定泛型。 //实现接口时，直接指定泛型接口的类型 //给 U 指定 Integer 给 R 指定了 Float //所以，当我们实现 IUsb 方法时，会使用 Integer 替换 U, 使用 Float 替换 R class BB implements IUsbInteger, Float @Override public Float get(Integer integer) return null; @Override public void hi(Float aFloat) @Override public void run(Float r1, Float r2, Integer u1, Integer u2) //没有指定类型，默认为 Object //建议直接写成 IUsbObject,Object class CC implements IUsb //等价 class CC implements IUsbObject,Object @Override public Object get(Object o) return null; @Override public void hi(Object o) @Override public void run(Object r1, Object r2, Object u1, Object u2) interface IUsbU, R int n = 10; //U name; 不能这样使用 //普通方法中，可以使用接口泛型 R get(U u); void hi(R r); void run(R r1, R r2, U u1, U u2); //在 jdk8 中，可以在接口中，使用默认方法, 也是可以使用泛型 default R method(U u) return null; 自定义泛型方法 为什么在方法前要声明一个泛型呢，不声明会怎么样。 这个方法不声明且定义这个类的时候也没有声明的话那编译会出错，前面为什么可以只是使用了泛型而不在方法那边声明，因为这个方法使用的泛型在定义那个类的时候就已经声明过了。 public K void hello(R r, K k)只声明一个的原因是R在定义这个类的时候就已经声明过了。 package com.Hnu.experiment; import java.util.*; public class test @SuppressWarnings(rawtypes) public static void main(String[] args) Car car = new Car(); car.fly(宝马, 100);//当调用方法时，传入参数，编译器，就会确定类型 System.out.println(=======); car.fly(300, 100.1);//当调用方法时，传入参数，编译器，就会确定类型 //测试 //T-String, R- ArrayList FishString, ArrayList fish = new Fish(); fish.hello(new ArrayList(), 11.3f); //泛型方法，可以定义在普通类中, 也可以定义在泛型类中 class Car //普通类 public void run() //普通方法 //说明 泛型方法 //1. T,R 就是泛型 //2. 是提供给 fly 使用的 public T, R void fly(T t, R r) //泛型方法 System.out.println(t.getClass());//String System.out.println(r.getClass());//Integer class FishT, R //泛型类 public void run() //普通方法 public U, M void eat(U u, M m) //泛型方法 //说明 //1. 下面 hi 方法不是泛型方法 //2. 是 hi 方法使用了类声明的 泛型 public void hi(T t) //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型 public K void hello(R r, K k) System.out.println(r.getClass());//ArrayList System.out.println(k.getClass());//Float 泛型的继承和通配符 在给泛型指定具体类型后，可以传入该类型或者其子类类型，意思是传入的变量可以是子类，但后面写的泛型不能是子类。 import java.util.*; public class c @SuppressWarnings(rawtypes, unchecked) public static void main(String[] args) Object o = new String(xx); //泛型没有继承性 //ListObject list = new ArrayListString(); //举例说明下面三个方法的使用 ListObject list1 = new ArrayList(); ListString list2 = new ArrayList(); ListAA list3 = new ArrayList(); ListBB list4 = new ArrayList(); ListCC list5 = new ArrayList(); //如果是 List? c ，可以接受任意的泛型类型 printCollection1(list1); printCollection1(list2); printCollection1(list3); printCollection1(list4); printCollection1(list5); //List? extends AA c： 表示 上限，可以接受 AA 或者 AA 子类 // printCollection2(list1);//× // printCollection2(list2);//× printCollection2(list3);//√ printCollection2(list4);//√ printCollection2(list5);//√ //List? super AA c: 支持 AA 类以及 AA 类的父类，不限于直接父类 printCollection3(list1);//√ //printCollection3(list2);//× printCollection3(list3);//√ //printCollection3(list4);//× //printCollection3(list5);//× //冒泡排序 //插入排序 //.... // ? extends AA 表示 上限，可以接受 AA 或者 AA 子类 public static void printCollection2(List? extends AA c) for (Object object : c) System.out.println(object); //说明: List? 表示 任意的泛型类型都可以接受 public static void printCollection1(List? c) for (Object object : c) // 通配符，取出时，就是 Object System.out.println(object); // ? super 子类类名 AA:支持 AA 类以及 AA 类的父类，不限于直接父类， //规定了泛型的下限 public static void printCollection3(List? super AA c) for (Object object : c) System.out.println(object); class AA class BB extends AA class CC extends BB JUnitimport org.junit.jupiter.api.Test; public class c public static void main(String[] args) //传统方式 //new JUnit_().m1(); //new JUnit_().m2(); @Test public void m1() System.out.println(m1 方法被调用); @Test public void m2() System.out.println(m2 方法被调用); @Test public void m3() System.out.println(m3 方法被调用); 方便，方法可以进行单独测试。 IO 流文件流 常用的文件操作创建文件对象相关构造器和方法 import org.junit.jupiter.api.Test; import java.io.*; //方式 1 new File(String pathname) @Test public void create01() String filePath = e:\\ ews1.txt; File file = new File(filePath); try file.createNewFile(); System.out.println(文件创建成功); catch (IOException e) e.printStackTrace(); Java中的printStackTrace()方法是Throwable类的一个公共方法，它用于打印异常（Exception）或错误（Error）的栈追踪信息到标准错误流（System.err）。当程序抛出异常或错误，并被捕获后，可以使用printStackTrace()方法输出详细的调用栈信息，这在调试程序时非常有用，因为它可以帮助开发者确定异常发生的位置和原因。 e或者E都可以。 //方式 2 new File(File parent,String child) //根据父目录文件+子路径构建 //e: ews2.txt @Test public void create02() File parentFile = new File(e:\\\\); String fileName = news2.txt; //这里的 file 对象，在 java 程序中，只是一个对象 //只有执行了 createNewFile 方法，才会真正的，在磁盘创建该文件 File file = new File(parentFile, fileName); try file.createNewFile(); System.out.println(创建成功~); catch (IOException e) e.printStackTrace(); //方式 2 new File(File parent,String child) //根据父目录文件+子路径构建 //e:\\work\\work1.txt @Test public void create02() File parentFile = new File(e:\\\\work\\\\);//转义字符\\ String fileName = work1.txt; //这里的 file 对象，在 java 程序中，只是一个对象 //只有执行了 createNewFile 方法，才会真正的，在磁盘创建该文件 File file = new File(parentFile, fileName); try file.createNewFile(); System.out.println(创建成功~); catch (IOException e) e.printStackTrace(); 得先在E盘里有个work文件夹才可以。上面还可以写作： File parentFile = new File(e:\\\\); String fileName = work\\\\work1.txt; //方式 3 new File(String parent,String child) //根据父目录+子路径构建 @Test public void create03() //String parentPath = e:\\\\; String parentPath = e:\\\\; String fileName = news4.txt; File file = new File(parentPath, fileName); try file.createNewFile(); System.out.println(创建成功~); catch (IOException e) e.printStackTrace(); file.creatNewFile()必须用try-catch包围不然会编译异常。 获取文件的相关信息 package com.Hnu.experiment; import org.junit.jupiter.api.Test; import java.io.*; public class test public static void main(String[] args) //方式 1 new File(String pathname) @Test public void create01() String filePath = e:\\ ews1.txt; File file = new File(filePath); try file.createNewFile(); System.out.println(文件创建成功); catch (IOException e) e.printStackTrace(); //调用相应的方法，得到对应信息 System.out.println(文件名字= + file.getName()); //getName、getAbsolutePath、getParent、length、exists、isFile、isDirectory System.out.println(文件绝对路径= + file.getAbsolutePath()); System.out.println(文件父级目录= + file.getParent()); System.out.println(文件大小(字节)= + file.length()); System.out.println(文件是否存在= + file.exists());//T System.out.println(是不是一个文件= + file.isFile());//T System.out.println(是不是一个目录= + file.isDirectory());//F isFile()和isDirectory()括号里面都不能加对象。 目录的操作和文件删除 没例子 IO 流原理及流的分类原理： 分类： FileInputStream(文件– 程序)演示 FileInputStream 的使用(字节输入流 文件– 程序)： 读取的内容是文件里的内容。 import org.junit.jupiter.api.Test; import java.io.*; public class c public static void main(String[] args) /** * 演示读取文件... * 单个字节的读取，效率比较低 * - 使用 read(byte[] b) */ @Test public void readFile01() String filePath = e:\\\\hello.txt; int readData = 0; FileInputStream fileInputStream = null; try //创建 FileInputStream 对象，用于读取 文件 fileInputStream = new FileInputStream(filePath); //从该输入流读取一个字节的数据。 如果没有输入可用，此方法将阻止。 //如果返回-1 , 表示读取完毕 while ((readData = fileInputStream.read()) != -1) System.out.print((char)readData);//转成 char 显示 catch (IOException e) e.printStackTrace(); finally //关闭文件流，释放资源. try fileInputStream.close(); catch (IOException e) e.printStackTrace(); /** * 使用 read(byte[] b) 读取文件，提高效率 */ @Test public void readFile02() String filePath = e:\\\\hello.txt; //字节数组 byte[] buf = new byte[8]; //一次读取 8 个字节. int readLen = 0; FileInputStream fileInputStream = null; try //创建 FileInputStream 对象，用于读取 文件 fileInputStream = new FileInputStream(filePath); //从该输入流读取最多 buf.length 字节的数据到字节数组。 此方法将阻塞，直到某些输入可用。 //如果返回-1 , 表示读取完毕 //如果读取正常, 返回实际读取的字节数 while ((readLen = fileInputStream.read(buf)) != -1) System.out.print(new String(buf, 0, readLen));//显示 catch (IOException e) e.printStackTrace(); finally //关闭文件流，释放资源. try fileInputStream.close(); catch (IOException e) e.printStackTrace(); fileInputStream.read()括号是空的就默认是一个一个字节读取。 new String(buf, 0, readLen)，该方法在下面的FileReader有介绍，为什么不直接是(buf)，因为文件里的内容可能不是8的倍数，而读取内容是在buf里面以覆盖的形式存储的，所以直接是buf的话会输出额外内容。 为什么System.out.print((char)readData)需要强制转化为char? FileInputStream.read() 方法每次读取一个字节的数据，并返回该字节的数据作为 int 类型。具体来说，返回的 int 范围是 0 到 255（因为一个字节是 8 位，最大值是 255）。如果读取到文件的末尾，read() 方法返回 -1，表示已经没有数据可以读取了。 由于返回类型是 int，而不是直接返回 byte 或 char，这是因为它需要处理可能的 EOF（End of File）情况，即 -1。 FileOutputStream(程序-文本)直接写入文件，不是像BufferedOutputStream要等流关闭后才可以写入。 import org.junit.jupiter.api.Test; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; public class c public static void main(String[] args) /** * 演示使用 FileOutputStream 将数据写到文件中, * 如果该文件不存在，则创建该文件 */ @Test public void writeFile() //创建 FileOutputStream 对象 String filePath = e:\\\\a.txt; FileOutputStream fileOutputStream = null; try //得到 FileOutputStream 对象 对象 //老师说明 //1. new FileOutputStream(filePath) 创建方式，当写入内容，会覆盖原来的内容 //2. new FileOutputStream(filePath, true) 创建方式，当写入内容，是追加到文件后面 fileOutputStream = new FileOutputStream(filePath, true); //写入一个字节 //fileOutputStream.write(H);// //写入字符串 String str = hsp,world!; //str.getBytes() 可以把 字符串- 字节数组 //fileOutputStream.write(str.getBytes()); /* write(byte[] b, int off, int len) 将 len 字节从位于偏移量 off 的指定字节数组写入此文件输出流 */ fileOutputStream.write(str.getBytes(), 0, 3);//写入htp catch (IOException e) e.printStackTrace(); finally try fileOutputStream.close(); catch (IOException e) e.printStackTrace(); 要求: 编程完成图片音乐的拷贝： import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.FileInputStream; public class c public static void main(String[] args) //完成 文件拷贝，将 e:\\\\Koala.jpg 拷贝 c:\\\\ //思路分析 //1. 创建文件的输入流 , 将文件读入到程序 //2. 创建文件的输出流， 将读取到的文件数据，写入到指定的文件. String srcFilePath = e:\\\\Koala.jpg; String destFilePath = e:\\\\Koala3.jpg; FileInputStream fileInputStream = null; FileOutputStream fileOutputStream = null; try fileInputStream = new FileInputStream(srcFilePath); fileOutputStream = new FileOutputStream(destFilePath); //定义一个字节数组,提高读取效果 byte[] buf = new byte[1024]; int readLen = 0; while ((readLen = fileInputStream.read(buf)) != -1) //读取到后，就写入到文件 通过 fileOutputStream //即，是一边读，一边写 fileOutputStream.write(buf, 0, readLen);//一定要使用这个方法 System.out.println(拷贝 ok~); catch (IOException e) e.printStackTrace(); finally try //关闭输入流和输出流，释放资源 if (fileInputStream != null) fileInputStream.close(); if (fileOutputStream != null) fileOutputStream.close(); catch (IOException e) e.printStackTrace(); 该程序中的fileOutputStream.write(buf, 0, readLen)buf是字节数组，存储的不是字母，那么写入文本的时候写入的是数字还是字母？ buf 是一个字节数组，里面存储的是从源文件（即 Koala.jpg）中读取的原始二进制数据。写入的内容是图片的二进制数据，而不是数字或者字母。换句话说，写入的是文件的原始字节数据。二进制文件，比如图片、音频、视频等，都是以字节流的形式存储的，每个字节都可能代表一个像素的颜色值、一段声音的波形等。 对于图片文件：fileOutputStream.write(buf, 0, readLen) 写入的字节数据会被重新组装成图片文件，能够正确显示出原始图片内容。 对于文本文件：如果你在处理文本文件，这些字节数据可能代表字符的编码值（如 ASCII、UTF-8 编码），写入后重新读取时会显示原来的文本。 FileReader 和 FileWriter(处理字符流)这俩只能处理字符，但是上面两个stream可以处理二进制数据，也就是字节流。 FileReader: 用于读取文本文件中的字符数据。它将字节数据自动转换为字符数据，使用系统默认的字符编码或指定的字符编码。 FileWriter: 用于将字符数据写入文本文件。它会将字符数据转换为字节数据，并写入文件中。 reader想要从文本中读到内容首先要有这个文本文件才可以不然就会报错，writer就不需要先创建文本了，它会自动创建如果没有的话。 FileReader 相关方法： new String（在上面的String类有讲到）括号里的也可以是byte数组new String(byte[] bytes, int offset, int length)。字符串在底层实际上也是以字节的形式存储的。字符串（String）在 Java 中是以字符（char）的形式表示的，而 char 在 Java 中是 16 位的 Unicode 字符。另一方面，byte 是 8 位的。因此，字节数组中的每个 byte 实际上可以表示一个 ASCII 字符（对于简单的英文字符）或者是一个 UTF-8 编码的字节（对于复杂的多字节字符，如汉字）。当调用时，Java 会将字节数组 bytes 中的数据按照指定的字符编码解码成字符串。默认情况下，Java 使用平台默认的字符集（通常是 UTF-8）来解释这些字节，并将它们转换为对应的字符。 FileWriter 常用方法： import org.junit.jupiter.api.Test; import java.io.*; public class c public static void main(String[] args) /** * 单个字符读取文件 */ @Test public void readFile01() String filePath = e:\\\\story.txt; FileReader fileReader = null; int data = 0; //1. 创建 FileReader 对象 try fileReader = new FileReader(filePath); //循环读取 使用 read, 单个字符读取 while ((data = fileReader.read()) != -1) System.out.print((char) data); catch (IOException e) e.printStackTrace(); finally try if (fileReader != null) fileReader.close(); catch (IOException e) e.printStackTrace(); /** * 字符数组读取文件 */ @Test public void readFile02() System.out.println(~~~readFile02 ~~~); String filePath = e:\\\\story.txt; FileReader fileReader = null; int readLen = 0; char[] buf = new char[8]; //1. 创建 FileReader 对象 try fileReader = new FileReader(filePath); //循环读取 使用 read(buf), 返回的是实际读取到的字符数 //如果返回-1, 说明到文件结束 while ((readLen = fileReader.read(buf)) != -1) System.out.print(new String(buf, 0, readLen)); catch (IOException e) e.printStackTrace(); finally try if (fileReader != null) fileReader.close(); catch (IOException e) e.printStackTrace(); 使用 FileWriter 将 “风雨之后，定见彩虹” 写入到 note.txt 文件中： import java.io.FileWriter; import java.io.IOException; public class c public static void main(String[] args) String filePath = e:\\ ote.txt; //创建 FileWriter 对象 FileWriter fileWriter = null; char[] chars = a, b, c; try fileWriter = new FileWriter(filePath);//默认是覆盖写入 // 3) write(int):写入单个字符 fileWriter.write(H); // 4) write(char[]):写入指定数组 fileWriter.write(chars); // 5) write(char[],off,len):写入指定数组的指定部分 fileWriter.write(韩顺平教育.toCharArray(), 0, 3); // 6) write（string）：写入整个字符串 fileWriter.write( 你好北京~); fileWriter.write(风雨之后，定见彩虹); // 7) write(string,off,len):写入字符串的指定部分 fileWriter.write(上海天津, 0, 2); //在数据量大的情况下，可以使用循环操作. catch (IOException e) e.printStackTrace(); finally //对应 FileWriter , 一定要关闭流，或者 flush 才能真正的把数据写入到文件 try //fileWriter.flush(); //关闭文件流，等价 flush() + 关闭 fileWriter.close(); catch (IOException e) e.printStackTrace(); System.out.println(程序结束...); fileWriter = new FileWriter(filePath);//默认是覆盖写入 覆盖写入没有错，那为什么按照上面的程序，最后note文本里的内容会是存进去的所有内容呢？因为它们全部都是在同一个try-catch里面存进去的，而对应 FileWriter , 要关闭流，或者 flush 才能真正的把数据写入到文件，关闭流是在finally里面，所以上面那些内容都是一起、一次被写入note的，只写了这一次，所以内容是全部。如果后面继续写入其它内容就会覆盖之前写的内容了。 怎么继续写入呢，如果直接在后面fileWriter.write的话会因为流关闭而出现异常，所以要重新要这样，再开一个： fileWriter = new FileWriter(filePath); fileWriter.write(H); fileWriter.close(); fileWriter = new FileWriter(filePath,true);//这个会追加到后面 节点流和处理流介绍 处理流功能： BufferedReader 和 BufferedWriter(字符操作) 1、使用BufferedReader读取文本文件并显示在控制台 import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; public class c public static void main(String[] args) throws IOException String filePath = e:\\\\a.java; //创建 bufferedReader BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath)); //读取 String line; //按行读取, 效率高 //说明 //1. bufferedReader.readLine() 是按行读取文件 //2. 当返回 null 时，表示文件读取完毕 while ((line = bufferedReader.readLine()) != null) System.out.println(line); //关闭流, 这里注意，只需要关闭 BufferedReader ，因为底层会自动的去关闭 节点流 bufferedReader.close(); 为什么这边没有try-catch呢，因为这次在主方法就抛出了异常。 为什么FileNotFoundException和java.io.IOException可以用同一个catch(IOException e)捕获？ 在Java中，FileNotFoundException是IOException的一个子类。这意味着FileNotFoundException是IOException的一个更具体的类型。当你使用catch(IOException e)块时，它可以捕获类型为IOException的异常，以及它的任何子类（包括FileNotFoundException）。 2、使用BufferedWriter输入 import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; public class c public static void main(String[] args) throws IOException String filePath = e:\\\\ok.txt; //创建 BufferedWriter //说明: //1. new FileWriter(filePath, true) 表示以追加的方式写入 //2. new FileWriter(filePath) , 表示以覆盖的方式写入 BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(filePath)); bufferedWriter.write(hello, 韩顺平教育!); bufferedWriter.newLine();//插入一个和系统相关的换行 bufferedWriter.write(hello2, 韩顺平教育!); bufferedWriter.newLine(); bufferedWriter.write(hello3, 韩顺平教育!); bufferedWriter.newLine(); //说明：关闭外层流即可 ， 传入的 new FileWriter(filePath) ,会在底层关闭 bufferedWriter.close(); 验证是覆盖写入，后面加上 bufferedWriter = new BufferedWriter(new FileWriter(filePath)); bufferedWriter.write(hello3, 韩顺平教育!); bufferedWriter.close(); 3、综合使用BufferedReader和BufferedWriter完成文件拷贝 import java.io.*; public class c public static void main(String[] args) //1. BufferedReader 和 BufferedWriter 是安装字符操作 //2. 不要去操作 二进制文件[声音，视频，doc, pdf ], 可能造成文件损坏 String srcFilePath = e:\\\\a.java; String destFilePath = e:\\\\a2.java; // String srcFilePath = e:\\\\0245_韩顺平零基础学 Java_引出 this.avi; // String destFilePath = e:\\\\a2 韩顺平.avi; BufferedReader br = null; BufferedWriter bw = null; String line; try br = new BufferedReader(new FileReader(srcFilePath)); bw = new BufferedWriter(new FileWriter(destFilePath)); //说明: readLine 读取一行内容，但是没有换行 while ((line = br.readLine()) != null) //每读取一行，就写入 bw.write(line); //插入一个换行 bw.newLine(); System.out.println(拷贝完毕...); catch (IOException e) e.printStackTrace(); finally //关闭流 try if(br != null) br.close(); if(bw != null) bw.close(); catch (IOException e) e.printStackTrace(); 为什么拷贝的时候要换行？ 在你的代码中，BufferedReader.readLine() 方法被用来读取文件中的一行内容。readLine() 方法会读取一行文本，但它不会包含行尾的换行符（即不会包含 或 \\r ）。 因此，如果你只是用 bw.write(line); 来写入文件，那么原文件中的换行符将不会被复制到目标文件中，结果就是所有的行都会被写入同一行中。为了保持原文件的格式不变，在每次写入一行内容后，需要手动添加一个换行符。bw.newLine(); 方法就是用于这个目的的，它会根据操作系统的换行符标准（Windows 是 \\r ，UnixLinux 是 ）插入适当的换行符，从而确保目标文件的内容和原文件一致。 关闭流的条件为什么是不为空？ 在使用文件流时，关闭流是非常重要的步骤。关闭流能够释放系统资源，避免内存泄漏以及锁定文件等问题。如果不关闭流，可能会导致文件无法被其他进程或操作所访问。 关闭流之前要检查流对象是否为 null，是因为如果某个流在创建过程中发生异常，那么该流对象可能依然是 null。如果你在 null 的情况下直接调用 close() 方法，就会引发 NullPointerException。 BufferedInputStream 和 BufferedOutputStream(字节流) 使用Buffered……流完成文件的复制 使用 BufferedOutputStream 和 BufferedInputStream，使用他们，可以完成二进制文件拷贝. 思考：字节流可以操作二进制文件，可以操作文本文件吗？当然可以 import java.io.*; public class c public static void main(String[] args) // String srcFilePath = e:\\\\Koala.jpg; // String destFilePath = e:\\\\hsp.jpg; // String srcFilePath = e:\\\\0245_韩顺平零基础学 Java_引出 this.avi; // String destFilePath = e:\\\\hsp.avi; String srcFilePath = e:\\\\a.java; String destFilePath = e:\\\\a3.java; //创建 BufferedOutputStream 对象 BufferedInputStream 对象 BufferedInputStream bis = null; BufferedOutputStream bos = null; try //因为 FileInputStream 是 InputStream 子类 bis = new BufferedInputStream(new FileInputStream(srcFilePath)); bos = new BufferedOutputStream(new FileOutputStream(destFilePath)); //循环的读取文件，并写入到 destFilePath byte[] buff = new byte[1024]; int readLen = 0; //当返回 -1 时，就表示文件读取完毕 while ((readLen = bis.read(buff)) != -1) bos.write(buff, 0, readLen); System.out.println(文件拷贝完毕~~~); catch (IOException e) e.printStackTrace(); finally //关闭流 , 关闭外层的处理流即可，底层会去关闭节点流 try if (bis != null) bis.close(); if (bos != null) bos.close(); catch (IOException e) e.printStackTrace(); FileOutputStream和BufferedOutputStream的区别FileOutputStream直接写入文件：FileOutputStream 是用于将数据写入文件（如二进制文件）的输出流。它是字节流的一种，直接连接到文件。无缓冲：FileOutputStream 默认情况下不提供缓冲功能。这意味着每次调用 write 方法时，数据都会直接写入到文件中，这可能会导致频繁的磁盘IO操作，从而影响性能。用途：适用于需要直接控制文件写入过程，或者对性能要求不是非常高的场景。BufferedOutputStream缓冲写入：BufferedOutputStream 为另一个输出流（如 FileOutputStream）添加缓冲功能。它内部维护了一个缓冲区，数据首先写入到这个缓冲区中，当缓冲区满或者显式调用 flush() 方法时，缓冲区中的数据才会被写入到目标输出流（如文件）中。性能提升：由于减少了磁盘IO操作的次数（因为数据是批量写入的），BufferedOutputStream 相比 FileOutputStream 提供了更好的性能。用途：适用于需要高效写入大量数据的场景，如文件复制、大文件写入等。总结如果你需要直接写入文件，且对性能要求不高，或者写入的数据量不大，可以直接使用 FileOutputStream。如果你需要高效写入大量数据到文件，推荐使用 BufferedOutputStream，因为它通过缓冲机制减少了磁盘IO操作的次数，从而提高了性能。 FileInputStream和BufferedInputStream的区别FileInputStream直接读取文件：FileInputStream 是用于从文件中读取数据的输入流。它是字节流的一种，直接连接到文件，并以字节为单位读取数据。无缓冲：FileInputStream 在读取文件时，默认情况下不提供缓冲功能。这意味着每次调用 read() 方法时，都会直接从文件中读取数据，这可能会导致频繁的磁盘IO操作，从而影响性能。用途：适用于需要直接读取文件内容，且对性能要求不是非常高的场景。BufferedInputStream缓冲读取：BufferedInputStream 为另一个输入流（如 FileInputStream）添加缓冲功能。它内部维护了一个缓冲区，数据首先被读取到这个缓冲区中，当需要读取数据时，直接从缓冲区中获取，减少了磁盘IO操作的次数。性能提升：由于使用了缓冲机制，BufferedInputStream 相比 FileInputStream 提供了更好的读取性能。特别是在处理大文件或需要频繁读取文件的场景下，性能优势更加明显。内部实现：BufferedInputStream 的底层仍旧调用了 FileInputStream 的 read0() 方法来从文件中读取数据，但它会在读取之前将数据预先读取到缓冲区中。当缓冲区中的数据被读取完毕后，它会再次从文件中读取数据填充缓冲区。用途：适用于需要高效读取大量数据的场景，如文件解析、数据处理等。 对象流-ObjectInputStream 和 ObjectOutputStream 对象流介绍： 功能：提供了对基本类型或对象类型的序列化和反序列化的方法ObjectOutputStream 提供 序列化功能ObjectInputStream 提供 反序列化功能 import java.io.FileOutputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class c public static void main(String[] args)throws Exception //序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存 String filePath = e:\\\\data.dat; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath)); //序列化数据到 e:\\data.dat oos.writeInt(100);// int - Integer (实现了 Serializable) oos.writeBoolean(true);// boolean - Boolean (实现了 Serializable) oos.writeChar(a);// char - Character (实现了 Serializable) oos.writeDouble(9.5);// double - Double (实现了 Serializable) oos.writeUTF(韩顺平教育);//String //保存一个 dog 对象 oos.writeObject(new Dog(旺财, 10, 日本, 白色)); oos.close(); System.out.println(数据保存完毕(序列化形式)); class Dog implements Serializable private String name; private int year; private String country; private String color; public Dog() public Dog(String name, int year, String country, String color) this.color=color; this.name=name; this.year=year; this.country=country; 自定义类要实现接口才能被保存，所以class Dog implements Serializable。 import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.Serializable; public class c public static void main(String[] args)throws Exception // 1.创建流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(e:\\\\data.dat)); // 2.读取， 注意顺序 System.out.println(ois.readInt()); System.out.println(ois.readBoolean()); System.out.println(ois.readChar()); System.out.println(ois.readDouble()); System.out.println(ois.readUTF()); System.out.println(ois.readObject()); // 3.关闭 ois.close(); System.out.println(以反序列化的方式读取(恢复)ok~); class Dog implements Serializable private String name; private int year; private String country; private String color; public Dog() public Dog(String name, int year, String country, String color) this.color=color; this.name=name; this.year=year; this.country=country; 读取的数据里面有自定义类那该自定义类得在程序里面定义了才可以被读取。 标准输入输出流 转换流-InputStreamReader 和 OutputStreamWriter使用 BufferedReader 对象读取txt文件，默认情况下，读取文件是按照 utf-8 编码，读取中文文件的时候可能会出现乱码问题，因为中文是多字节的，而utf-8是处理单字节的。 import java.io.*; public class c public static void main(String[] args) throws IOException String filePath = e:\\\\a.txt; //解读 //1. 把 FileInputStream 转成 InputStreamReader //2. 指定编码 gbk //InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath), gbk); //3. 把 InputStreamReader 传入 BufferedReader //BufferedReader br = new BufferedReader(isr); //将 2 和 3 合在一起 BufferedReader br = new BufferedReader(new InputStreamReader( new FileInputStream(filePath), gbk)); //4. 读取 String s = br.readLine(); System.out.println(读取内容= + s); //5. 关闭外层流 br.close(); 但是为什么在txt文件里输入中文，使用BufferedReader读取的时候却可以正常输出呢？因为这个时候输入用的就是utf-8编码的，而BufferedReader默认是用utf-8编码的，所以可以正常输出，而转化流按gbk形式读取，所以会出现乱码情况。想用上面程序正常读取中文，那中文得是以gbk形式存储的才行。 import java.io.*; public class c public static void main(String[] args) throws IOException OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(e:\\\\a.txt), gbk); // 2.写入 osw.write(hello,韩顺平教育~); // 3.关闭 osw.close(); System.out.println(保存成功~); 打印流-PrintStream 和 PrintWriter只用输出流没有输入流。 PrintWriter：需要close才可以存入 import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; public class c public static void main(String[] args) throws IOException //PrintWriter printWriter = new PrintWriter(System.out); PrintWriter printWriter = new PrintWriter(new FileWriter(e:\\\\f2.txt)); printWriter.print(hi, 北京你好~~~~); printWriter.close();//flush + 关闭流, 才会将数据写入到文件.. 像下面的一样，这边也可以用write。 PrintStream：不用close就可以存入 import java.io.IOException; import java.io.PrintStream; public class c public static void main(String[] args) throws IOException PrintStream out = System.out; //在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器 /* public void print(String s) if (s == null) s = null; write(s); */ out.print(john, hello);//也可以使用println自带换行。 //因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印/输出 out.write(韩顺平,你好.getBytes()); out.close(); //我们可以去修改打印流输出的位置/设备 //1. 输出修改成到 e:\\\\f1.txt //2. hello, 韩顺平教育~ 就会输出到 e:\\f1.txt //3. public static void setOut(PrintStream out) // checkIO(); // setOut0(out); // native 方法，修改了 out // System.setOut(new PrintStream(e:\\\\f1.txt)); System.out.println(hello, 韩顺平教育~); 这个输入时覆盖写入，也不能使用追加写入，只能是覆盖。 Properties 类 传统方法： import java.io.BufferedReader; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; public class Properties01 public static void main(String[] args) throws IOException //读取 mysql.properties 文件，并得到 ip, user 和 pwd BufferedReader br = new BufferedReader(new FileReader(src\\\\mysql.properties)); String line = ; while ((line = br.readLine()) != null) //循环读取 String[] split = line.split(=); //如果我们要求指定的 ip 值 if (ip.equals(split[0])) System.out.println(split[0] + 值是: + split[1]); br.close(); Properties介绍： 使用Properties类进行读取、创建： //读取 import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; import java.util.Properties; public class Properties02 public static void main(String[] args) throws IOException //使用 Properties 类来读取 mysql.properties 文件 //1. 创建 Properties 对象 Properties properties = new Properties(); //2. 加载指定配置文件 properties.load(new FileReader(src\\\\mysql.properties)); //3. 把 k-v 显示控制台 properties.list(System.out); //4. 根据 key 获取对应的值 String user = properties.getProperty(user); String pwd = properties.getProperty(pwd); System.out.println(用户名= + user); System.out.println(密码是= + pwd); //创建 //Properties 父类是 Hashtable ， 底层就是 Hashtable 核心方法 import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.util.Properties; public class Properties03 public static void main(String[] args) throws IOException //使用 Properties 类来创建 配置文件, 修改配置文件内容 Properties properties = new Properties(); //创建 //1.如果该文件没有 key 就是创建 //2.如果该文件有 key ,就是修改 properties.setProperty(charset, utf8); properties.setProperty(user, 汤姆);//注意保存时，是中文的 unicode 码值 properties.setProperty(pwd, 888888); //将 k-v 存储文件中即可 properties.store(new FileOutputStream(src\\\\mysql2.properties), null); System.out.println(保存配置文件成功~);","tags":["语言"]},{"title":"python2","path":"/2024/10/05/python2/","content":"输出同时输出字符和数字：将数字转化为字符处理。 x,y,z = 1,2,3 print(三个数的和为： + str(x + y + z)) x,y,z = 1,2,3 print(三个数的和为：,x + y + z) 数据类型基本文本类型： str 数字类型： int, float, complex(复数) 序列类型： list, tuple, range 映射类型： dict 套装类型： set, frozenset 布尔类型： bool 二进制类型： bytes, bytearray, memoryview 可使用以下type()函数获取任何对象的数据类型。 浮点数类型float：可以使用e(E)来表示科学计数法，x、y仍属于浮点数类型 x = 1e2 y = 2E3 print(x)#100.0 print(y)#2000.0 complex： 复数写有“j”作为虚部。 x = 3 + 5j y = 5j print(x)#(3+5j) print(y)#5j 强制转化： x = 1 y = complex(x) print(x)#1 print(y)#(1+0j) 随机数Python 有一个内置模块 random可以用来生成随机数，需要引入。 import random random.randrange(3,30,3)不是生成3到30之间的任何整数，因为width 3 ，所以生成的应该是3 + 3 * i 。 该方法生成的都是整数，包括负整数。 step步长的应用——生成n的随机整数范围(倍数) 让我们生成 5 到 100 之间的随机整数，即 5 的倍数，例如 5, 10, 25, 90, 95等。 import random number = random.randrange(5, 101, 5) print(Random number range (multiple) of 5 is , number) python字符串基础可以使用三个引号将多行字符串分配给变量。 x = gsgad asgsa ags ilnk print(x) 字符串是数组，Python 没有字符数据类型，单个字符只是一个长度为 1 的字符串。方括号可用于访问字符串的元素。这里用到了切片，你可以不懂。获取位置 1 处的字符（记住第一个字符的位置为 0）： a = Hello, World! print(a[1]) len()函数返回字符串的长度，注意标点符号和空格也算一个长度：len(a) 要检查字符串中是否存在某个短语或字符，我们可以使用关键字 in，返回值为布尔类型。 txt =The best things in life are free! print(free in txt) 如果是要检查不存在某个短语或字符的话，除了使用 in 外，还可以使用 not in ： txt =The best things in life are free! print(free not in txt) 不存在就会输出true。 切片字符串1）切片 获取从位置 2 到位置 5 的字符（不包括在内）： txt = The best things in life are free! print(txt[2:5]) 仍然是左闭右开的规律，且第一个字符索引为0。 2）从头开始切片 txt = The best things in life are free! print(txt[:5]) 3)切到最后 通过省略结束索引，范围将到最后。 txt = The best things in life are free! print(txt[2:]) 4）负索引 使用负索引从字符串末尾开始切片，就是从右往左看，不再是从左往右看。 txt = The best things in life are free! print(txt[-5:-2]) 这个时候字符串的最后一个元素索引为 -1，往前递减。 f r e e 这个时候要切片仍要按字符串顺序写入，不能写[-1:-5]，而使用负索引时由于是从后往前的，所以变成了左闭右开。 -4 -3 -2 -1 修改字符串1）upper()方法以大写形式返回字符串（不改变原字符串）：txt.upper()，txt内容直接全部转化为大写；也可以选择字符转大写，txt[2].upper()。 2）lower()方法以小写形式返回字符串。 3）strip()方法删除开头和结尾的任何空格（不改变原字符串）： txt = The best things in life are free! print(txt.strip()) print(txt) 4）replace()方法用另一个字符串替换一个字符串(不改变原字符串)： txt = The best things in life are free! print(txt.replace(e,E,4)) print(txt) replace(“要修改的”,”要修改成的”,要修改的数量)，没有规定数量则默认全部修改。 5）拆分字符串 split()方法返回一个列表，其中指定分隔符之间的文本成为列表项。split()如果找到分隔符的实例，该方法会将字符串拆分为子字符串。 txt = The best things in life are free! print(txt.split( )) 若要以多个字符作为分割符，那不像 java 中一样，python要用and txt = The best things in life are free! print(txt.split( and e)) my_list = txt.split( ) my_list的类型为list。 字符串连接要连接或组合两个字符串，可以使用 + 运算符。 格式化字符串对变量的格式化format1）format单个传参 通过使用format() 方法来组合字符串和数字！format()方法接受传递的参数，格式化它们，并将它们放在占位符所在的字符串中{}。 age = 20 txt = Tom今年 print(txt.format(age)) age的值会出现在“{}”里。 2）format多个传参 不规定顺序，默认按输入顺序取值： quantity = 20 itemno = 3000 price = 49.95 myorder = 川川今年 岁 买了个华为手机 每个月花费 元. print(myorder.format(quantity, itemno, price)) 规定顺序：按序列号取值 quantity = 20 itemno = 3000 price = 49.95 myorder = 川川今年 2岁 买了个华为手机 0 每个月花费 1 元. print(myorder.format(quantity, itemno, price)) %3）% 这个程序是将数字变为字符串后填入语句中的。 快速写法：f不限数据类型同时也不做精度控制，原来是什么样的就输出什么样的。 对表达式的格式化 其它方法 布尔值bool()函数允许您评估任何值，并给您 True或False 作为返回。如果它具有某种内容，几乎任何值都会被评估。任何字符串都是True，空字符串除外。任何数字都是True，除了 0。任何列表、元组、集合和字典都是True，空的除外。 例如()、 []、{}、 “”、 数字 0和 False、None值，计算值为False。 Python 也有许多返回布尔值的内置函数，如 isinstance() 函数，可用于确定对象是否属于某种数据类型。 x = 20 print(isinstance(x,int)) 列表基础+元组定义列表是使用方括号创建的，可以直接输出，和java中的一样。 mylist = [ 川川一号, 川川二号, 川川三号, 川川四号] print(mylist) 创建新列表时也可以使用 list() 构造函数。 mylist = list(( 川川一号, 川川二号, 川川三号, 川川四号)) print(mylist) 为什么list需要有两个括号？因为传递给list()函数的参数是一个元组，而不是普通的单个字符串或其他类型的单个对象。 外层括号：list()函数的外层括号用于调用该函数。 内层括号：( ... )内层括号用于定义一个元组。Python中的元组使用括号()定义。如果在调用list()时传递了一个元组（用括号括起来的多个元素），你就需要使用内层括号来创建这个元组。 这个代码实际上是将一个元组传递给list()函数，并将这个元组转换成列表。 元组（Tuple）是Python中的一种数据类型，用于存储多个值。它与列表（List）非常相似，但有几个关键区别： 1）不可变性（Immutable）: 元组一旦创建，其元素不能修改（即不能增删改）。这与列表不同，列表是可变的（Mutable）。 2）使用小括号定义: 元组使用小括号 () 定义，而列表使用方括号 []。 3）可以包含不同类型的数据: 元组可以包含不同类型的元素，例如整数、字符串、浮点数等：mixed_tuple = (1, hello, 3.14) 4）访问方式与列表相同: 元组的元素通过索引访问，索引从0开始。 现在重新回到列表： 由于列表已编入索引，因此列表可以包含具有相同值的项目。 列表项可以是任何数据类型，同一列表中也可以包含不同类型的项。 总结： List列表是一个有序且可变的集合。允许重复成员。 turple元组是一个有序且不可更改的集合。允许重复成员。 Set集合是一个无序且无索引的集合。没有重复的成员。 dict字典是一个有序（从 Python 3.7 版开始）且可变的集合。没有重复的成员。 操作访问列表 1）正常索引 2）负索引 3）索引范围 print(mylist[1:3]) print(mylist[-3:-1]) 4）检查是否存在，和字符串一样 更改列表 更改一个范围内的元素： mylist = [ 川川一号, 川川二号, 川川三号, 川川四号, 川川五号] mylist[1:3] = [哈皮川川,憨批川川] print(mylist) 插入列表 insert()方法在指定的索引处插入一个项目。 mylist = [ 川川一号, 川川二号, 川川三号, 川川四号, 川川五号] mylist.insert(2,帅哥呀) print(mylist) 添加列表 1）末尾添加：要将值添加到列表的末尾，请使用append() 方法。 2）指定位置添加：insert()函数。 3）合并列表：要将另一个列表中的元素附加到当前列表，请使用extend()方法。 mylist = [ 川川一号, 川川二号, 川川三号, 川川四号, 川川五号] mylist1 = [ 川川一号, 川川二号, 川川三号, 川川四号] mylist.extend(mylist1) print(mylist) extend()方法不一定要 列表，您也可以添加任何可迭代对象（元组、集合、字典等）。 mylist = [ 川川一号, 川川二号, 川川三号, 川川四号, 川川五号] mylist1 = (川川,菜鸟) mylist.extend(mylist1) print(mylist) 使用 + 运算符 mylist = [ 川川一号, 川川二号, 川川三号, 川川四号, 川川五号] mylist1 = [川川,菜鸟] my = mylist1 + mylist print(my) 删除列表 remove()方法删除指定的项目。 mylist.remove(川川二号) pop()方法删除指定的索引，如果不指定索引，该pop()方法将删除最后一项。 mylist.pop(2) del删除指定的索引,也可以完全删除列表。 del mylist[0] del mylist clear()方法清空列表。该列表仍然存在，但没有内容。 mylist.clear() 循环列表for方法一： 循环遍历列表您可以使用循环遍历列表项for 。 mylist = [ 川川一号, 川川二号, 川川三号, 川川四号] for i in mylist: print(i) 方法二：遍历索引号 mylist = [ 川川一号, 川川二号, 川川三号, 川川四号] for i in range(len(mylist)): print(mylist[i]) 相当于以前的： for(int i = 0;i mylist.length;i ++) print(mylist.charAt(i) 变量作用域 whilemylist = [ 川川一号, 川川二号, 川川三号, 川川四号] i = 0 while i len(mylist): print(mylist[i]) i += 1 那如果我while循环下面还要写不属于循环体的内容要怎么办呢？下面写的内容与while对齐就行，就代表不是循环的内容了。 mylist = [ 川川一号, 川川二号, 川川三号, 川川四号] i = 0 while i len(mylist): print(mylist[i]) i += 1 i = 1 print(i) continue和break和以前的一样 列表推导式 一个表达式，后面为一个 for 子句，然后，跟着 for 子句，if 语句 OldList = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] TestList = [j for i in OldList for j in i if j % 2 == 0] print(TestList) # [2, 4, 6, 8] 排序sort()方法区分大小写，导致所有大写字母都排在小写字母之前，按自然顺序排序。thislist.sort() 不区分大小写的排序函数，则应使用str.lower作为键函数：thislist.sort(key = str. lower) reverse()方法反转元素的当前排序顺序。 复制列表copy()方法制作列表的副本： fruits = [ apple, banana, cherry, kiwi, mango] f = fruits.copy() print(f) list()方法制作列表的副本： fruits = [ apple, banana, cherry, kiwi, mango] f = list(fruits) print(f) 操作合集 数据输入 input默认接受的类型是字符串，所以你输入的数据是按照字符串去处理的，获取到的数据永远是字符串类型的。 判断语句if语句 注意：条件后面加冒号，结构体前面要留有空白（四个空格），就是要缩进；没有缩进代表和 if 是同级的，不受 if 控制。 if else语句 if elif else语句 判断条件里可以是输入语句： 该代码在节省代码量的同时还做到了不用一次性输入三个变量，而是等前面一个不满足条件后在输入下一个变量值。 函数和c语言大差不差的。 调用函数时，鼠标停在函数上，会出现说明文档。 数据容器列表 列表中可以存储不同的数据类型。 tuple(元组)元组一旦定义完成就不能被修改。但是如果元组中有元素list，可以修改list里的数据，list不变，变得是list里面的内容。 str(字符串)和元组一样，字符串时无法修改的，对它进行修改操作得到的是一个新的字符串，原字符串仍不变。 数据容器(序列)的切片操作 切片操作不会影响到序列本身，而是会产生一个新的序列。 步长默认为1，所以可以不写。 起始和结束都不写的话，表示从头到尾。 set(集合)不重复，无序，不支持下标索引。 合并后的结果仍然不会包括重复元素，且是两个集合元素的随机排序。 dict(字典，映射)类似于java中的map 不允许key重复，若定义时有多个相同的key，则后面的key会覆盖前面的key所对应的value。 pop删除元素后，会返回key对应的value。 数据容器对比总结 利用max和min筛选字典中的最大最小元素，只看key不看value。 字符串转列表(元组，集合)会将字符串的每一个元素都提取出来单独变成列表(元组，集合)的元素，字典转列表(元组，集合)会将key提取出来变成元素，抛弃value。 可以发现，排序的结果都变成了列表对象，且是升序排序，若想降序的话，那就加上reverse True。 函数进阶函数多返回值 函数的多种传参方式位置参数就是最普通的函数的参数名字。 关键字参数 缺省参数 当没有给gender传递值的时候，gender的值就是”男”。 缺省参数必须写在最后，但不限制数量。 不定长参数 元组 字典 匿名参数函数作为参数传入普通的传入数据的形式，计算逻辑时确定的，但是计算的数据不是确定的；传入函数的形式，计算的数据是确定的，但计算逻辑不确定。 lambda匿名函数 lambda函数直接将函数体的结果return，不用写return语句。","tags":["语言"]},{"path":"/2024/10/05/职业/","content":"数据分析师对代码能力要求不高，侧重的是对业务的理解，逻辑思维和对业务方向的精准判断。由于岗位要求不高，可以做的人多，可能是裁员的优先考虑对象，提升空间不高 越往高级，数据分析师其实就会逐渐轻技能而重分析。很多职位要求都需要具备良好的沟通表达能力。需要有较高的逻辑分析能力。最好需要有行业背景，像金融啥的。 数据分析相对来说还是一个比较看重经验的行业，从业时间越长，经验越是丰富，相对薪资水平也会越高，很多数据分析师的薪资也是逐年递增的。 要求： 所以数据分析师工资高，真不一定意味着数据分析师紧缺，也可能是需要这个岗位的都是大公司，所以开出的工资高。 而且套用一个说职业前景的万能句式：数据分析师行业不缺人，缺的是精尖。你要想去一个公司做专业的数据分析师，就得证明自己比那些懂数据分析的运营、销售、市场强，也得证明自己比那些懂业务的程序员强，不然人家现有的员工组合拼凑就够用了，干嘛要你。 当然，专业的数据分析师也确实存在缺口，这个职业在国内火起来还不算久，国内缺乏真正的数据分析专业人才，很多人都是学了点软件应用就敢说自己是数据分析师，结果给个需求，既不知道怎么确定指标体系，又不知道如何找数据，好不容易可视化完，也分析不出个123，反正业务部门自己看去吧。 所以套用一句说职业的万能句式：数据分析师不缺普通人，缺的是牛人。你要是左手能数据挖掘ai建模，右手写分析报告建议策略，就可以被抢着要了。 当然一般人（比如我）做到这个级别还是有难度的（反正我在编程上一塌糊涂），所以我建议是技术和业务选一侧走到精通，另一侧做辅助。然后，如果编程和我一样废，或者是转行年纪稍大的，就选业务吧。 不过既然轻技能，那就势必会重思维和经验，在业务侧，你的数据分析思维很重要，比如老板要你分析一个产品应不应该上线，一个活动值不值得策划实施，这时候你要自行判断应该从什么角度进行分析，什么数据是关键指标，并通过分析数据给出业务上的意见，甚至出一个业务方案。 这需要你懂得统计学和概率论，以及基于这些数据基础而来的各种分析方法，什么AB测试，多维度拆分，AARRR分析法5w分析法，千变万化，不离其宗；还需要你对一个行业的业务发展上下游都有了解，能判断一个数据的变动是对应哪个环节。 这些东西，即使你是数据分析科班出身，都未必能在工作里直接用好，因为教材是套路的，但业务是多变而且超越教材的，所以比起啃书，我更建议你听听从业者的经验，看人家是如何把理论应用于实践，最好还能练一练，这样省去了自己在实际业务上摸爬滚打的试错成本，最好还能在求职前有一些个人项目经历，求职的时候就等于有了拿得出手的实习经历。 可能对于一些科班出身的人来说，数据科学方向就是一直以来所预期的发展方向，但在实际的职场上，数据分析更多的是重在分析，毕竟不是所有的公司需要程序员，但只要是商业公司，总会有对业务进行分析的需求。 就像前面说的，我更建议大家做业务侧，业务侧吃经验，重思维，真的要更适合普通人。尤其是大龄转行0基础想靠敲代码创出一片天的，真的要好好考虑一下，这把年纪想学通编程得付出多少时间和辛苦，你的家庭能等得起吗，你又真的能学得会吗？ 越往高级，数据分析师其实就会逐渐轻技能而重分析，真正数据获取阶段的工作做的很少，可能都会交给团队里的初级伙伴来完成。高级分析师则注重在分析阶段，需要的是在对业务的全局把控，对行业和经济的深刻理解。即使是技能，也要求模型优化等更高级别的能力。 而如果你成为创业者或者市场方面的高管，建模这样的工作也会被分派到下面，而你则要根据这些报告做出正确的决策。 ETL工程师数据工程师入门简单？ 是从事系统编程、数据库编程与设计，要掌握各种常用的编程语言的专业技术人员。也叫数据库工程师。 为什么之前叫ETL工程师，现在更多的是称数据工程师？ 我觉得从我个人而言，首先要从更宏观的角度来理解ETL工程师。一般传统公司称ETL工程师，因为以前经常是将业务系统的数据取出来，进行数据清洗，再按照星型或雪花型建模再放到数仓中为下游BI服务。 而现在为什么叫数据工程师？是因为大家意识到，随着数据量的增多，数据产生的价值和变现的维度也随之增多了，数据工程师需要掌握的技能发生了许多变化。 其中最重要的是要肩负起这两点责任：运营数据（养数据）和达到公司的数据目的。这是ETL工程师或者说是数据工程师最终要达到的目标， 利用ETL工具完成数据抽取、清洗、转换、装载，mysql，SQL，hadoophiveSpark，Linux，数据仓库原理，熟悉至少一门编程语言，例如Python、Java、Scala等 一味的解释数据仓库概念可能没意思，我们从不同角色出发吧！ 老板：我是一家手机公司的老板，今天要向去董事局汇报，我要准备一份介绍过去三年的用户增长、用户留存、用户活跃度、手机里面每个APP使用率等情况的报表，假如下面没有BI，那我肯定就蒙了…… BI：我是一名非技术BI，我天天看竞品的分析报告，看双十一销量，看各种评论，知道自己的产品有哪些短板有哪些长处，我分析南北地域差异，国内外客户喜好，总之我在手机领域有着很强的行业解读能力和数据解读能力，我可以画出非常漂亮的图表和PPT。今天老板让我出一份报表，我还要去刷脸找ETL工程师帮我跑出这次报告的数据，基于这份数据我要给出一定的解读，为啥这个月手机卖得不如上个月，为啥用户流失越来越严重等等都是我要去做的。 ETL工程师 : 我是食物链最底层的苦逼ETL工程师，我会写shell、我会搭hadoophivehbase、会写超复杂逻辑的SQL，今天那个不会自己计算数据的BI又让我跑几个数据，我本想让她提需求流程的，但她说这是老板要的(运营惯用的杀手锏！！！)，要加急处理，我只能放下手头的活儿给她跑数据了，花了半个小时把数据跑好给她，希望能就这么交差吧。 大数据工程师，就是我们所知的大数据开发工程师，主要从事大数据平台的搭建，对个人技术要求偏高，需要从业者具备java基础，还得具备以下技术能力，hadoop、hive、hase、flume、storm、kafka、spark等，是一个非常庞大的技术集群。 如果你以为我每天就做这点事那你就错了，我平时的工作可不仅仅就是完成上面交给我的任务哦，我还负责数据ETL过程、数据建模、定时任务的分配、甚至有时Hadoop集群的维护等等都得我去做，每件事单独拿出来都可以拿出来写本书。 就拿ETL过程来说吧，你要把原始数据从各种数据库、各种服务器的不同业务日志归一化到同一类格式，要约定好分隔符，然后导入到分布式文件系统HDFS，甚至你还要和业务系统定义数据格式出规范，数据收集完，你还得出中间表，数据过滤，格式统一，ID统一，维度统一，通过不同的数据现象进行数据，完了，你就得出一些日报周报之类的数据了，这时候你要按照需求把数据组织成一定的格式然后导Mysql、或者HBASE等等。 总之你就是需要把数据各种收集、各种处理、然后各种导入导出，是不是很有意思？ 不过这些数据仓库都非常初级，其中ETL工程师可发挥的空间太多了！ 正常情况下，老板→BI→ETL出一份报告，这中间能否BI直接去计算数据？SQL太复杂，那么可不可以一切数据标签化，BI甚至老板要什么就选什么？ ETL工程师可以把数据收集自动化、可以规范业务日志格式、可以将一切都配置化，但是这些都是基于N+1的，也就是说今天的发生了什么一定要到明天才能看到，那么有没有一个系统能把数据分析做到实时或者准实时？参考双十一大屏，马总要是到12号才能知道成交了多少笔不劈了那帮做数据的才怪。 目前绝大部分分析系统都基于离线计算（HADOOPODPS），那这里有个问题了，运营或BI想看个数据还得你离线慢腾腾跑完才能看到，那么有没有一个系统可以支持你再大的数据量，再复杂的逻辑，毫秒出数据？ 我没有提到的还有算法工程师、大数据运维工程师等等。 大数据开发做大数据开发需要有强大的逻辑思维和代码编写能力，数学能力，以及对算法的敏感度。如果说数据分析更多的是和人打交道的话，那么大数据开发更像是机器打交道(阿宅们的福音）。大数据开发就不需要考虑和心理学相关问题，只是别人给你需求，按照他的需求编写好逻辑，提供给他他要的就行了。有一个绝对听话的编译软件陪着你，不需要过多的考虑他人的想法， 大数据开发主要是大数据组件的二次开发，或者大数据平台的搭建等方向，我目前干的就是大数据组件的二次开发。总而言之就是，参与大数据分布式应用系统服务器端或客户端软件开发工作（需求开发、故障解决和性能优化等）。主要偏向于Java方向，Java要求较高。 熟练掌握Java，有相关并发的编程经验，精通JavaPythonC++scalago语言中一种或多种，熟悉数据结构和算法，熟悉linux; 对HadoopFlinkPrestoDruidRedisKafka等开源技术有一定的了解， 读过源码的优先； 数据科学家难 对数据的敏感程度直接决定了你将会如何使用手头的工具和知识，最终影响到conclusion的质量 data scientist的另外一个区别于其他类似职业的特性就是深入。且不管scientist这种叫法是否合适，但是被称作scientist的人必须永远是走在cutting-edge的人才，同时也必须是对问题、数据、方法、结论都有着深入理解的人，而不仅仅是停留在数据、现象、问题的表面，否则就变成了机械、简单、重复的统计分析。因此，data scientist作为交叉学科人才，并不仅仅要求你拥有七十二般武艺，更需要你在关键的领域拥有对知识全面而深入的理解，看问题的角度需要独到犀利。除此之外，你还要像一名真正的scientist一样，拥有强烈的探索欲、好奇心、行动力。"},{"path":"/2024/10/05/学习/","content":"牛客网刷题 《深入浅出 MySQL》 前面的部分的“基础篇”可以快速略过，重点的就是后面的“开发篇和优化篇”。 尤其是后面的“优化篇”对我帮助很大，学习了一些常见的 MySQL 优化方式。 毕竟数据库性能优化是对我们来说很重要的一趴。 《MySQL 技术内幕：InnoDB存储引擎》 MySQL 中用的做多的就是 InnoDB 引擎，所以更进一步学习 InnoDB 存储引擎很有必要。 这本书反正就是 MySQL 中的经典书，解析了 InnoDB 的体系结构、实现原理、工作机制，里面呆了大量的实践内容。 《高性能 MySQL》 MySQL 不老的经典大部头，这个大家就放在最后看好了。 这本书好的方面是，每一章都是相对独立的主题，大家可以根据目录选择性的阅读。 我记得当时我主要就是看了创建高性能的索引、查询性能优化这几个章节，不得不说：Nice！ 作为数据分析师，日常使用 SQL，主要就是把自己想要的数据或者指标需求转化成 SQL 的语言逻辑去数据库等地方查询数据。 很多初学者会被网上的一些信息误导，以为 SQL 的学习要掌握到极精深的地步，恨不得深入内核嚼碎了来学。 怎么说呢，没必要，数据分析师使用 SQL 的重点就是在【查询】两个字上。 所以单纯对数据分析师来说，SQL 的掌握主要在基础语言的学习和性能优化上的学习上就好了。 没必要深入内核去学习。 其实大概分的话，由浅入深分成 3 个阶段吧： （1）入门阶段 入门阶段的话就是熟练的掌握增删改查语句、运算符以及函数。 增删改查语句主要就是 select、insert、update、delete。 运算符主要就是算术运算符（+、-、*、、%）、赋值运算符（）、比较运算符（＞、≥、＜、≤）和逻辑运算符（AND、ANY、BETWEEN、IN）。 函数主要就是算法函数和时间函数等。 （2）进阶阶段 这一个阶段是重中之重 进阶阶段主要是熟练掌握多表查询、分组查询、子查询、组合查询等。其中最重要的就是多表查询。 工作里往往数据不是放在一个表里，而是不同的数据放在不同的表里，这就需要会从不同的表中根据业务需求来获取数据，这就需要 SQL 进行多表查询。 （3）高级阶段 高级阶段要是为了提高 SQL 的效率。都是写 SQL，怎么可以让 SQL 执行效率更快。 在这各阶段，主要要求你去学习约束、事务、锁、触发器、视图等内容。 虽然我希望大家都能掌握到第 3 阶段，但是我也知道，这对刚入行的数据分析师是有点难度的，因为这些是需要你在大量工作中积累经验。 所以对于我希望你最好掌握到第二阶段【进阶】。"},{"path":"/2024/10/05/数据结构_复杂度/","content":"算法的时间复杂度和空间复杂度 时间复杂度定义：算法的时间复杂度是一个函数（数学里面带有未知数的函数表达式），它定义了该算法的运行时间。一个算法所花费的时间于其中的语句的执行次数成正比例，算法中的基本操作的执行次数为算法的时间复杂度。 计算：计算时间复杂度的时，不一定要计算精确的执行次数，而只要大概之小红次数，那么这里我们使用大O的渐近表示法。 例子： 大O的渐近表示法：用于描述函数渐近行为的数学符号。 推导大O阶的方法： 1、用常数1取代运行时间中的所有加法常数。 2、在修改后的运行次数函数中，只保留最高阶项。 3、如果最高阶项存在且不是1，则去除于这个项目相乘的常数，得到的结果就是大O阶。 该实例的时间复杂度是O(N)；平均情况一般等于（最好+最坏）2；一般不看平均。 排序的表本身就是有序的，比较次数，可以判断出是n-1次的比较，没有数据交换，此时时间复杂度为O(n)。当最坏的情况，即待排序是逆序的情况。当初始序列从大到小逆序时，需要进行n-1趟排序，进行n(n-1)2次比较和交换。 不要被题目的程序误导，实在想不出来就去看冒泡排序怎么写。 算时间复杂度不能只去看是几层循环，而要去看他的思想。 设查找了X次 反推：最后剩下一个，那上一次的数量就是1的两倍，再上一次就又是两倍。 正推：总数一半一半减少，最后剩下一个。 递归算法：递归次数*每次递归调用的次数 虽然N3,但是右边那块空的相对于其他的来说很小，所以是O(2^N). 那也不对啊，这个程序应该到N3的时候就直接输出1了，而不是会递归到0和1. 下面这题是”真正的”O(2^N)。 空间复杂度定义：要注意计算的是额外的空间 计算： 每一次循环结束后使用的空间都会被释放掉，所以从头到尾，i 所使用的应该都是同一个空间。 可直接看malloc 递归的空间复杂度要看它递归的深度（次数），这题一共有N次，每次都额外建立了都是常数个额外空间。 函数开辟的空间一次只能给一个用，不能同时开两个分别进行。 当你要算F(N)的时候要先算N-1，要算N-1要先算N-2，依次类推不断往下一直到1，那一共要建立n+1个空间，算完2的时候算3时可以重复利用之前使用的空间（此时已经被释放掉了），所以数量不变，以此类推，一直向上，数量始终不变，所以是O(N)。 顺序表和链表线性表 线性表在逻辑上是线性的关系，不是线性的关系的话比如，树形结构。 顺序表顺序表其实就是数组。 要从头连续存储。 1、静态顺序表 特点：如果满了的话就不让插入； 缺点：不知道大小要定义多少，小了不够用，大了浪费。 2、动态顺序表 空间容量指的不是字节数而是个数"},{"path":"/2024/10/05/Kaggle/","content":"Kaggle是什么Kaggle成立于2010年，是一个进行数据发掘和预测竞赛的在线平台。从公司的角度来讲，可以提供一些数据，进而提出一个实际需要解决的问题；从参赛者的角度来讲，他们将组队参与项目，针对其中一个问题提出解决方案，最终由公司选出的最佳方案可以获得5K-10K美金的奖金。 除此之外，Kaggle官方每年还会举办一次大规模的竞赛，奖金高达一百万美金，吸引了广大的数据科学爱好者参与其中。从某种角度来讲，大家可以把它理解为一个众包平台，类似国内的猪八戒。但是不同于传统的低层次劳动力需求，Kaggle一直致力于解决业界难题，因此也创造了一种全新的劳动力市场——不再以学历和工作经验作为唯一的人才评判标准，而是着眼于个人技能，为顶尖人才和公司之间搭建了一座桥梁。 这里有一篇对Kaggle首席科学家Jeremy Howard的采访，介绍了Kaggle的创建初衷及运营模式，即任用最聪明的人解决世界上最棘手的问题；同时，任何公司和组织都可以受益于机器学习的发展进步， Kaggle参赛者的背景大多是什么样的？从比赛目标出发，参赛者主要分为两种，一种是以奖金和排名为目的，包括靠奖金为生的职业Kaggler；另外一种就是以提升相关skills和背景为目的业余爱好者甚至在校学生了。 从背景来看，前者的来源主要有丰富data science、data mining、machine learning工作经验的业内人士，或者是实力强劲的民间“技术宅”；而后者则往往是一些有一定技术能力，但经验欠缺，从中进行学习和锻炼的“长江后浪”。 0基础的人如何上手Kaggle？理论上来讲，Kaggle欢迎任何数据科学的爱好者，不过实际上，要想真的参与其中，还是有一定门槛的。一般来讲，参赛者最好具有统计、计算机或数学相关背景，有一定的coding技能，对机器学习和深度学习有基本的了解。Kaggle任务虽然不限制编程语言，但绝大多数队伍会选用Python和R，所以你应该至少熟悉其中一种。 此外，对于那些对成绩有追求的人，Feature Engineering也是必不可少的。 当然，如果你从未独立做过一个项目，还是要从练习赛开始熟悉。因为竞赛模式中的任务是公司悬赏发布的实际案例，并没有标准的答案；而练习赛不仅项目难度低，而且是有官方给出的参考方案的，大家可以用来对比改善自己的测试结果，从中进行提高。 所以呢，建议感兴趣的同学先去独立做一下101和playground的训练赛，至于做多少个案例才能上道，就要看个人素质啦。这里为大家推荐几篇非常好的文章，里面手把手的教了大家入门级的三个经典练习项目，供大家学习。 Titanic（泰坦尼克之灾） 中文教程： 逻辑回归应用之Kaggle泰坦尼克之灾英文教程：An Interactive Data Science Tutorial House Prices: Advanced Regression Techniques（房价预测） 中文教程：Kaggle竞赛 — 2017年房价预测英文教程：How to get to TOP 25% with Simple Model using sklearn Digital Recognition（数字识别） 中文教程：大数据竞赛平台—Kaggle 入门英文教程：Interactive Intro to Dimensionality Reduction Kaggle竞赛的认可度高么？Kaggle作为Data Science业内享有盛名的平台，在业界拥有极高的认可度。所以如果你是想寻找相关行业的工作，那一个漂亮的Kaggle profile将为你的简历增色不少。 对于刚刚进入这个行业的菜鸟而言，参加Kaggle的项目是非常“长见识”的，可能初期的尝试会非常吃力，毕竟都是非常前沿的问题，但是如果能坚持完整的把一个项目做下来，且不说coding能力会有一个很大的提高，在实际案例中解决问题的能力也会得到极大的锻炼，为自己的职业生涯打下一个良好的基础。如果能在Kaggle这种高手云集的比赛中获得一个还不错的成绩，写在简历上足以打动你今后的Boss，跳槽就翻倍的高薪工作指日可待！值得一提的是，虽然是汇集精英的社区，Kaggle的论坛氛围很好，对新人非常友好，大家一定要多看Script多请教！ 首先，选择数据量小的项目，这样不管使用什么算法都不会耗时太久，对机器性能要求也不高，出结果也比较快；其次，选择难度低奖金少的项目，一方面竞争小，另一方面也适合新手；最后，选择参与人数多的项目，毕竟有那么多“僵尸号”撑着。这样下来，基本上认认真真做下来排名都不会太难看。 选择恰当的工具： 我们都知道循序渐进的道理，因此对于刚刚涉猎Kaggle，只是希望从中学习，而不追求高排名的同学，可以先从学习Machine Learning中常用的模型开始，比如Logistic Regression和Random Forest，这两个模型对于大部分问题就够了；基础好的还可以学习一下Gradient Boosting，虽然难度高一点，但是可视化效果会好很多。"},{"title":"Hello World","path":"/2024/10/04/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"}]