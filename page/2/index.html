<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>coygOdegaard</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="coygOdegaard">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="coygOdegaard">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Odegaard">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="coygOdegaard" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/三笠.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">Odegaard</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 10px;">大数据</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">语言</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a gunner.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/三笠.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-数据结构1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/" class="article-date">
  	<time datetime="2024-10-05T09:53:50.000Z" itemprop="datePublished">2024-10-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/">
        数据结构1
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240127164721571.png" alt="image-20240127164721571"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240127164543672.png" alt="image-20240127164543672"></p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240127164928463.png" alt="image-20240127164928463"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240127165239561.png" alt="image-20240127165239561"></p>
<p>在存储当前元素的时候顺便存储了下个元素的地址</p>
<p>接下来两个了解就可以</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240127165445674.png" alt="image-20240127165445674"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240127165514183.png" alt="image-20240127165514183"></p>
<h2 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h2><p>数据类型是一组性质相同的值的集合以及定义于这个值集合上的一组操作的总称。数据类型&#x3D;值的集合+<strong>值集合上的一组操作</strong>。</p>
<p>在定义一个变量的数据类型的时候也规定了它值的范围以及能进行的操作。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240127170323095.png" alt="image-20240127170323095"></p>
<p>抽象数据类型就是一个概念</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240127170445860.png" alt="image-20240127170445860"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240127171025284.png" alt="image-20240127171025284"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240127171059544.png" alt="image-20240127171059544"></p>
<p><strong>例子：</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240127171335993.png" alt="image-20240127171335993"></p>
<p>因为要返回C本身，所以前面加上&amp;</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240127171658402.png" alt="image-20240127171658402"></p>
<p>assigh是构建虚数</p>
<p><strong>小结：</strong><img src="/../source/imgs/$%7Bfiilname%7D/image-20240127180218139.png" alt="image-20240127180218139"></p>
<h2 id="抽象数据类型的表示与实现"><a href="#抽象数据类型的表示与实现" class="headerlink" title="抽象数据类型的表示与实现"></a>抽象数据类型的表示与实现</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240128101926420.png" alt="image-20240128101926420"></p>
<p>抽象数据类型利用处理器里已存在的数据类型来说明新的结构，用已经实现的操作来组合形成新的操作。</p>
<p>例如：<img src="/../source/imgs/$%7Bfiilname%7D/image-20240128102515684.png" alt="image-20240128102515684"></p>
<h2 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240128103051438.png" alt="image-20240128103051438"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240128103215990.png" alt="image-20240128103215990"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240128103459228.png" alt="image-20240128103459228"></p>
<p><strong>时间复杂度</strong>，求得时候只考虑算法中的基本操作执行的次数</p>
<p>若T(n)函数可以分解为T1(n)和T2(n)两个函数，则可以利用加法和乘法法则</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240128113828306.png" alt="image-20240128113828306"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240128114150366.png" alt="image-20240128114150366"></p>
<p><strong>空间复杂度</strong></p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="定义和特点"><a href="#定义和特点" class="headerlink" title="定义和特点"></a>定义和特点</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240128223218645.png" alt="image-20240128223218645"></p>
<p>这里面的数据a[i]只是一个抽象的符号，其具体含义在不同情况下可以不同。</p>
<p>同一线性表中的元素必定是具有相同特性，数据元素间的关系是线性关系，1-1的</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240128223601677.png" alt="image-20240128223601677"></p>
<p>线性表属于顺序存储结构，而顺序存储结构存在问题：存储空间分配不灵活，运算的空间复杂度高。</p>
<p>线性表有两种基本的存储结构：<strong>顺序</strong>存储结构和<strong>链式</strong>存储结构。</p>
<h2 id="类型（抽象数据类型）定义"><a href="#类型（抽象数据类型）定义" class="headerlink" title="类型（抽象数据类型）定义"></a>类型（抽象数据类型）定义</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240128225013212.png" alt="image-20240128225013212"></p>
<h2 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h2><p>顺序表示就是顺序存储结构</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240129103850300.png" alt="image-20240129103850300"></p>
<p>存储的时候不能改变它们的顺序，存储的空间也要是连续的，中间没有空出的存储单元。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240129104941349.png" alt="image-20240129104941349"></p>
<p>存储线性表的一个模板（上面那个）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240129110700726.png" alt="image-20240129110700726"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240129111035519.png" alt="image-20240129111035519"></p>
<p>例子：存储多项式</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240129105807288.png" alt="image-20240129105807288"></p>
<p>c++中传地址的方式——引用类型作参数</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240129111750089.png" alt="image-20240129111750089"></p>
<p>从另一个角度说，i 和j 的地址是一样的，所以i 改变j 也会改变。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240129111931228.png" alt="image-20240129111931228"></p>
<p>m是对a的引用，n是对b的引用，所以对m和n的操作就是对a和b的操作。这种方式比传指针要简单。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240129112319812.png" alt="image-20240129112319812"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240129120204427.png" alt="image-20240129120204427"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240129160801123.png" alt="image-20240129160801123"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240129162211640.png" alt="image-20240129162211640"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240129162310655.png" alt="image-20240129162310655"></p>
<p>上面的那些红色字迹不用管，这题的期望值就是4。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240129161925291.png" alt="image-20240129161925291"></p>
<h2 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130105455805.png" alt="image-20240130105455805"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130105846253.png" alt="image-20240130105846253"></p>
<p>部分术语</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130110209994.png" alt="image-20240130110209994"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130110342838.png" alt="image-20240130110342838"></p>
<p>双链表一个存储前驱的指针，一个存储后继的指针</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130110531125.png" alt="image-20240130110531125"></p>
<p>头结点是额外附加的一个节点，有时会出现，所以链表的存储结构有两种形式：一种是有头结点的一种是没有的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130111022583.png" alt="image-20240130111022583"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130111202565.png" alt="image-20240130111202565"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130111321613.png" alt="image-20240130111321613"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130111442191.png" alt="image-20240130111442191"></p>
<p><strong>顺序表是随机存储，链表是顺序存取。</strong></p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130174916038.png" alt="image-20240130174916038"></p>
<p>Lnode和*LinkList都是类型名，Lnode *a相当于LinkList a。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130175335921.png" alt="image-20240130175335921"></p>
<p>常用的是前两个	</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130175623007.png" alt="image-20240130175623007"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130210457939.png" alt="image-20240130210457939"></p>
<p>因为要直接改变L的值，所以用&amp;L。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130211216292.png" alt="image-20240130211216292"></p>
<p>销毁，c用free那前面就要用mallloc，c++用delete那前面就要用new</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130211646412.png" alt="image-20240130211646412"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130220655401.png" alt="image-20240130220655401"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130221827475.png" alt="image-20240130221827475"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240130223956212.png" alt="image-20240130223956212"></p>
<p>第2的那个算法，和上面计算个数的算法不一样，用这个算法计算表长（即没有j&lt;i-1这个条件）会多出一个。然后当j&#x3D;1时，它所记得这个1代表的是首元结点，此时指针指向第一个结点，所以从另一个角度看，可以认为这个算法就是寻找第j 个结点 。这个算法中p&#x3D;L而不是p&#x3D;L-&gt;next，是因为这样，当我们找到第j 个结点的时候，p 此时就指向这个结点，而不是这个下一个结点。并且这个算法同时也可以解决插入在最后面的情况，例如：表长为5，要插入在第六个结点，此时，j 值最多为6，所以，p 可以等于第5个结点，此时j 也等于5，p 也不为空，若p 为空，则说明要插入位置大于表长+1，是错的。     <strong>妙</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131112132556.png" alt="image-20240131112132556"></p>
<p>也叫前插法，都接在头结点后面。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131115331514.png" alt="image-20240131115331514"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131115725772.png" alt="image-20240131115725772"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131115951390.png" alt="image-20240131115951390"></p>
<p>因为尾插法是在最后一项后面插入的，所以要多设一个变量来存储最后一项的信息；二头插法是从头开始插入的，已经有一个L存储了，所以不需要额外的一个变量。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131122217346.png" alt="image-20240131122217346"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131133820939.png" alt="image-20240131133820939"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131134010461.png" alt="image-20240131134010461"></p>
<p>用尾指针表示循环链表更好。</p>
<p>两个链表合并：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131134726965.png" alt="image-20240131134726965"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131134855492.png" alt="image-20240131134855492"></p>
<p>注意最后return的是Tb</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131135410991.png" alt="image-20240131135410991"></p>
<p>双向单链表的头结点的prior为空</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131135554700.png" alt="image-20240131135554700"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131135801318.png" alt="image-20240131135801318"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131140307801.png" alt="image-20240131140307801"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131153311150.png" alt="image-20240131153311150"></p>
<h3 id="三种表的时间效率比较"><a href="#三种表的时间效率比较" class="headerlink" title="三种表的时间效率比较"></a>三种表的时间效率比较</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131153843328.png" alt="image-20240131153843328"></p>
<p>双向循环链表牺牲空间换取时间</p>
<h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131154238465.png" alt="image-20240131154238465"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131154331470.png" alt="image-20240131154331470"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240131154538272.png" alt="image-20240131154538272"></p>
<h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203104017610.png" alt="image-20240203104017610"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203104029654.png" alt="image-20240203104029654"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203104351785.png" alt="image-20240203104351785"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203105015613.png" alt="image-20240203105015613"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203105037562.png" alt="image-20240203105037562"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203105711670.png" alt="image-20240203105711670"></p>
<p>出循环的条件是pa或者pb为空，最后一项都输完了。</p>
<p>本方法不需要额外的空间，只需修改指针就可以了，所以空间复杂度为O(1)。</p>
<p>稀疏多项式相加</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203115103134.png" alt="image-20240203115103134"></p>
<p>最后因为所有项都到Pa里了，Pb没有用 了，所以要释放Pb的头结点。</p>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p>栈和队列是限定插入和删除只能在表的“<strong>端点</strong>”进行的线性表。</p>
<p>栈，简称LIFO结构，插入新元素只能插入在表尾，删除元素也是从表尾开始。——后进先出</p>
<p>队列，插入新元素在表尾，删除元素从表头开始。——先进先出</p>
<p> <strong>栈是解决封闭对应问题的有效方法</strong>。 </p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203153935765.png" alt="image-20240203153935765"></p>
<h2 id="定义和特点-1"><a href="#定义和特点-1" class="headerlink" title="定义和特点"></a>定义和特点</h2><p><strong>栈：</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203155226995.png" alt="image-20240203155226995"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203155527112.png" alt="image-20240203155527112"></p>
<p>可以一边入栈一边出栈，只要入栈顺序没变就行。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203155840371.png" alt="image-20240203155840371"></p>
<p><strong>队列：</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203160124068.png" alt="image-20240203160124068"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203160227814.png" alt="image-20240203160227814"></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>一、进制转化（栈）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203160822121.png" alt="image-20240203160822121"></p>
<p>二、括号匹配的检验（栈）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203161016775.png" alt="image-20240203161016775"></p>
<p>在外面的括号要晚匹配，在里面的括号要先匹配，相当于栈的后进先出。</p>
<p>三、表达式求值（栈）</p>
<p>后面会详细讲</p>
<p>接下来介绍的算法是有运算符优先级确定运算顺序的对表达式求值算法——算符优先算法</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203161537156.png" alt="image-20240203161537156"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203162128387.png" alt="image-20240203162128387"></p>
<p>四、舞伴问题（队列）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203163300835.png" alt="image-20240203163300835"></p>
<h2 id="栈的表示和实现"><a href="#栈的表示和实现" class="headerlink" title="栈的表示和实现"></a>栈的表示和实现</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203165113076.png" alt="image-20240203165113076"></p>
<p>n&#x3D;0的时候叫做空栈</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203165258956.png" alt="image-20240203165258956"></p>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203165619730.png" alt="image-20240203165619730"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203170552897.png" alt="image-20240203170552897"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240203170707763.png" alt="image-20240203170707763"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205205035844.png" alt="image-20240205205035844"></p>
<p>栈中的元素个数仍可以用top-base来算，其实top和base也可以是整型变量。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205205629896.png" alt="image-20240205205629896"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205210014859.png" alt="image-20240205210014859"></p>
<p>只要将top指针指向base指针，不管中间有哪些值，就是为空。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205210623930.png" alt="image-20240205210623930"></p>
<p>第一步delete是把数组回归内存了（base相当于是数组名），红色的几句是把结构体里的元素设置为空了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205211111207.png" alt="image-20240205211111207"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205212506217.png" alt="image-20240205212506217"></p>
<p>top指针下移后，top所指的元素是否有值就无所谓了，不需要将其清除或者其他操作。</p>
<p>为什么要先减，因为top指针比存储的位置大1。</p>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205214127633.png" alt="image-20240205214127633"></p>
<p>an里面存储的是前驱元素，不是后继元素，它的方向是从n-&gt;1的，和单链表的相反。（感觉方向没啥区别）</p>
<p>如果多一个头结点的话，那操作更加麻烦。</p>
<p>指针方向由上往下的话，那插入元素就相当于是头插法，因为S指向的是首元结点。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205214722773.png" alt="image-20240205214722773"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205214733752.png" alt="image-20240205214733752"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205215152393.png" alt="image-20240205215152393"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205215317853.png" alt="image-20240205215317853"></p>
<h2 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205223805062.png" alt="image-20240205223805062"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205223909252.png" alt="image-20240205223909252"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205224120366.png" alt="image-20240205224120366"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205224419543.png" alt="image-20240205224419543"></p>
<p>后调用的先返回，符合栈的特点，所以多个函数的嵌套就可以用栈来实现。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205224721441.png" alt="image-20240205224721441"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205224829776.png" alt="image-20240205224829776"></p>
<p>fact是一个用来计算阶层的函数。</p>
<p>在递归的过程中，由高级语言的系统自动生成一个栈存储相关数据。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205225050279.png" alt="image-20240205225050279"></p>
<p>递归的时间效率不高</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240205225241787.png" alt="image-20240205225241787"></p>
<p>一般情况下还是用递归</p>
<h2 id="队列的表示和操作的实现"><a href="#队列的表示和操作的实现" class="headerlink" title="队列的表示和操作的实现"></a>队列的表示和操作的实现</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206102641822.png" alt="image-20240206102641822"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206102726594.png" alt="image-20240206102726594"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206102858096.png" alt="image-20240206102858096"></p>
<h3 id="循环顺序队"><a href="#循环顺序队" class="headerlink" title="循环顺序队"></a>循环顺序队</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206110146633.png" alt="image-20240206110146633"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206103557156.png" alt="image-20240206103557156"></p>
<p>不可以继续入队，会越界</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206103815929.png" alt="image-20240206103815929"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206105454690.png" alt="image-20240206105454690"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206105839090.png" alt="image-20240206105839090"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206105950312.png" alt="image-20240206105950312"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206110614016.png" alt="image-20240206110614016"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206111006830.png" alt="image-20240206111006830"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206111357035.png" alt="image-20240206111357035"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206111629679.png" alt="image-20240206111629679"></p>
<h3 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206114241566.png" alt="image-20240206114241566"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206114450054.png" alt="image-20240206114450054"></p>
<p>入队只能从队尾输入</p>
<p> <img src="/../source/imgs/$%7Bfiilname%7D/image-20240206115845986.png" alt="image-20240206115845986"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206120219204.png" alt="image-20240206120219204"></p>
<p>但Q.front为空的时候才会跳出循环。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206120649559.png" alt="image-20240206120649559"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206120756111.png" alt="image-20240206120756111"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206120904197.png" alt="image-20240206120904197"></p>
<h1 id="串，数组和广义表"><a href="#串，数组和广义表" class="headerlink" title="串，数组和广义表"></a>串，数组和广义表</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208160951735.png" alt="image-20240208160951735"></p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>感觉就是字符串</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208161109202.png" alt="image-20240208161109202"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208161209490.png" alt="image-20240208161209490"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208161509249.png" alt="image-20240208161509249"></p>
<p>应该是b 在d 中的位置是：5。</p>
<p>串相等：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。</p>
<p><strong>所有的空串都是相等的。</strong></p>
<h3 id="类型定义和存储结构"><a href="#类型定义和存储结构" class="headerlink" title="类型定义和存储结构"></a>类型定义和存储结构</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208165504432.png" alt="image-20240208165504432"></p>
<p>串中元素的逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构。</p>
<p>顺序存储结构——顺序串；链式存储结构——链串。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208173831481.png" alt="image-20240208173831481"></p>
<p>一般不用ch[0]，这样可以为后面的算法带来简便。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208174253068.png" alt="image-20240208174253068"></p>
<p>存储数值的那个部分叫做<strong>块</strong>，如图。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208174356815.png" alt="image-20240208174356815"></p>
<h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208174832458.png" alt="image-20240208174832458"></p>
<h4 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h4><p>BF，暴力破解法</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208175200905.png" alt="image-20240208175200905"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208204406810.png" alt="image-20240208204406810"></p>
<p>返回第一个字符的序号</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208204920246.png" alt="image-20240208204920246"></p>
<p>为什么i&#x3D;1，因为它存储时从1开始存的，0的位置没有存储。<strong>j应该是&gt;而不是&gt;&#x3D;</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208205321687.png" alt="image-20240208205321687"></p>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208210046857.png" alt="image-20240208210046857"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208210416309.png" alt="image-20240208210416309"></p>
<p>j 前面的字符，不包括j 本身。</p>
<p>其他情况就是j 前面的字符和从头开始的字符没有匹配的情况。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208212213731.png" alt="image-20240208212213731"></p>
<p>为什么j 会等于1呢，因为模式串存储也是从1 开始，0 并不存储。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216114641082.png" alt="image-20240216114641082"></p>
<p>为什么if 条件里面会有j&#x3D;&#x3D;0，因为当不匹配且当时j&#x3D;1的时候（也就是模式串第一位就不匹配），j 才会等于0，接下来主串和模式串都要往后移一位再继续比较，所以i++,j++。</p>
<p>下面是求next的</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240208212009223.png" alt="image-20240208212009223"></p>
<p>next值的改进-&gt;nextvalue</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216114505276.png" alt="image-20240216114505276"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216113034151.png" alt="image-20240216113034151"></p>
<p>next是一个一个慢慢比对过去，naxtvalue是一步到位。</p>
<p>例如：比对到第5位，原本第五位的next为2，那就将第五位的字符与第二位的字符比对，相同，则暂时为第二位字符的next值，然后第二位继续和第一位比，若相同就按照前面一部继续，不相同那 nextvalue 就等于第二位的next了。就是说因为第五位和第二位是相同的，所以第二位肯定不匹配，那就相当于j&#x3D;next[2]了，接着假如next[2]这个位置的字符和第五位的又一样，那肯定也不能匹配，那就继续从这位的next继续比对，知道和第五位不同的位置停下来，那接下来就是要从这个位置开始比较最划算，那nextvalue就等于这个位置。或者就是第五位字符和第二位比对，相同就为第二位的nextvalue，不相同则nextvalue 等于next。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216164550867.png" alt="image-20240216164550867"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216164728384.png" alt="image-20240216164728384"></p>
<p>L是一个存储元素的字节数，不乘L那求得就是这个元素前面有多少个元素，乘了那就是前面所占的空间。（不加a的话，a应该是首元素地址）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216165216388.png" alt="image-20240216165216388"></p>
<h3 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216170650127.png" alt="image-20240216170650127"></p>
<p>节省空间</p>
<h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>对应存储到一维数组当中</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216201750728.png" alt="image-20240216201750728"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216202233791.png" alt="image-20240216202233791"></p>
<p>an1的存储位置：(1+2+3+…+n-1)+(1-1)&#x3D;n(n-1)&#x2F;2</p>
<h4 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216203447109.png" alt="image-20240216203447109"></p>
<p>存储方法和确认位置的方法和上面那个差不多，下三角矩阵i&gt;&#x3D;j是因为一行的除了常数c外的个数等于i 值，而要找三角里的元素，那j 肯定是&lt;&#x3D;i 的。上三角矩阵+1是因为对角线上的元素不是常数c。</p>
<h4 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216203941849.png" alt="image-20240216203941849"></p>
<p>图中有三条对角线，所以是三对角矩阵。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216204216591.png" alt="image-20240216204216591"></p>
<h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216204445441.png" alt="image-20240216204445441"></p>
<p>顺序存储结构</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216204641955.png" alt="image-20240216204641955"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216204804776.png" alt="image-20240216204804776"></p>
<p>链式存储结构</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216204950947.png" alt="image-20240216204950947"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216211428461.png" alt="image-20240216211428461"></p>
<p>上面和旁边的那个head存的是头指针。</p>
<h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>就是扩展的线性表，线性表里的每个元素都是同一种类型的，但是广义表里的不一定是。</p>
<p>线性表是特殊的广义表。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240218111940757.png" alt="image-20240218111940757"></p>
<p>原子就是单一元素</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240218112148999.png" alt="image-20240218112148999"></p>
<p>表尾可以是空表。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240218112328837.png" alt="image-20240218112328837"></p>
<p>第六种叫做递归的广义表；第五种直接用广义表的名字C和D，拥有共同的定义，叫做共享广义表</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240218112850130.png" alt="image-20240218112850130"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240218113606538.png" alt="image-20240218113606538"></p>
<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240218165713461.png" alt="image-20240218165713461"></p>
<p>树是由根和子树组成的。</p>
<p>树是n个结点的有限集，树的定义是一个递归的定义。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240218170157197.png" alt="image-20240218170157197"></p>
<p>凹入越深代表层次越低</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240218175805131.png" alt="image-20240218175805131"></p>
<p><strong>结点的度</strong>既是它子树的个数又是它后继结点的个数又是它分支的个数。</p>
<p>这个树的度是3。</p>
<p>B,C,D为A的孩子，A就是B,C,D的双亲；双亲和孩子就是线性表里的前驱和后继。</p>
<p>拥有共同双亲的结点叫做兄弟。</p>
<p><strong>树的深度（高度）</strong>：树中结点的最大层次。</p>
<p>这棵树的深度是4。</p>
<p><strong>有序树</strong>：树中结点的各子树从左往右有次序（最左边的为第一个孩子）。（就是T1,T2,T3是一棵树，T1,T3,T2是另一棵树）</p>
<p><strong>无序树</strong>：树中结点的各子树无次序。（T1,T2,T3和T2,T1,T3是同一棵树）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240218180429652.png" alt="image-20240218180429652"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240218180530668.png" alt="image-20240218180530668"></p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>普通树若不转化为二叉树，则运算很难实现。</p>
<p><strong>所有的树都可以和二叉树相互转化。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240218180947488.png" alt="image-20240218180947488"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240218181104052.png" alt="image-20240218181104052"></p>
<p>二叉树不是有序树，两个概念</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240218181255104.png" alt="image-20240218181255104"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240222164704431.png" alt="image-20240222164704431"></p>
<h2 id="二叉树的性质和存储结构"><a href="#二叉树的性质和存储结构" class="headerlink" title="二叉树的性质和存储结构"></a>二叉树的性质和存储结构</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><strong>1、</strong>在二叉树的第i 层上至多有2^(i-1)个结点(i&gt;&#x3D;1)，至少有1个结点。</p>
<p><strong>2、</strong>深度为k的二叉树至多有2^k-1个结点(k&gt;&#x3D;1)，至少有k个结点。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240226123750695.png" alt="image-20240226123750695"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240226124842786.png" alt="image-20240226124842786"></p>
<p>n为结点数，边就是圈起来的那个，度为1的结点数是n1。</p>
<p>下面的两个式子相等即可以求出该结论。</p>
<p>重要的是分析过程，总边数那一行，左边的式子是从下往上分析，右边那个是从上往下分析，分析的都是边和结点之间的关系。</p>
<p>最后由最后两个式子可以推出性质3的结论。</p>
<h4 id="两种特殊形式的二叉树"><a href="#两种特殊形式的二叉树" class="headerlink" title="两种特殊形式的二叉树"></a>两种特殊形式的二叉树</h4><p><strong>满二叉树</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240310154828093.png" alt="image-20240310154828093"></p>
<p>满二叉树在同样深度的二叉树中结点个数和叶子结点个数最多。</p>
<p><strong>完全二叉树</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240310155201506.png" alt="image-20240310155201506"></p>
<p>为什么第三个图形是非完全二叉树，因为第三个图形中的第6个结点没有对应满二叉树中的第六个结点，并且非完全里的第六个结点占据的是满二叉树里的第7个结点的位置。</p>
<p>在满二叉树中，从最后一个结点开始，<strong>连续</strong>地去掉<strong>任意</strong>个结点，即是一棵完全二叉树。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240310155932043.png" alt="image-20240310155932043"></p>
<p>层次最大的两层就是最后一层和倒数第二层。</p>
<h5 id="性质（4，5，关于完全二叉树的）"><a href="#性质（4，5，关于完全二叉树的）" class="headerlink" title="性质（4，5，关于完全二叉树的）"></a>性质（4，5，关于完全二叉树的）</h5><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240310160550396.png" alt="image-20240310160550396"></p>
<p>那个特殊符号代表的是取整</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240310160825738.png" alt="image-20240310160825738"></p>
<h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240310161327482.png" alt="image-20240310161327482"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240310161410464.png" alt="image-20240310161410464"></p>
<p>TElemType 代表的是数组里面要存储的元素（最好去看一下typedef后加数组的情况的解释）。</p>
<p>此时定义完的bt 代表一个数组，可以存储MAXSTIZE 个元素。</p>
<p>存储不是满二叉树的情况</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240310162013542.png" alt="image-20240310162013542"></p>
<p>缺点和前面的都差不多。</p>
<p>适用与满二叉树和完全二叉树。</p>
<h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p><strong>二叉链表</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240310163152019.png" alt="image-20240310163152019"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240310163347189.png" alt="image-20240310163347189"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240310163645533.png" alt="image-20240310163645533"></p>
<p><strong>三叉链表</strong>（便于寻找双亲）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240310163817979.png" alt="image-20240310163817979"></p>
<h2 id="遍历二叉树和线索二叉树"><a href="#遍历二叉树和线索二叉树" class="headerlink" title="遍历二叉树和线索二叉树"></a>遍历二叉树和线索二叉树</h2><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><h4 id="三种遍历方法"><a href="#三种遍历方法" class="headerlink" title="三种遍历方法"></a>三种遍历方法</h4><p>依次遍历二叉树的三个组成部分就是遍历了整个二叉树。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240317170154318.png" alt="image-20240317170154318"></p>
<p>D:根结点；L:左子树；R:右子树。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240317170428756.png" alt="image-20240317170428756"></p>
<p>采用递归的方法遍历。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240317170855246.png" alt="image-20240317170855246"></p>
<p>中序和后序遍历道理一样。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240317171308163.png" alt="image-20240317171308163"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240317171503262.png" alt="image-20240317171503262"></p>
<p>若题目要求将中缀表达式转化为后缀表达式，可以先将中缀表达式化作树的形式，然后再转化为后缀表达式。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240317171856530.png" alt="image-20240317171856530"></p>
<p>若只知道先序和后序则不可以确认一棵二叉树。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240317172248472.png" alt="image-20240317172248472"></p>
<p>判断完左右子树后，继续分析判断根和左右子树，直到左右子树中的一个   元素为空或为1，即可以判断元素位置。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240317172839511.png" alt="image-20240317172839511"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240317173135946.png" alt="image-20240317173135946"></p>
<p>后序遍历先左右后根，所以根位于最后，可以从后往前看。</p>
<p><strong>上面两种题型都要先确定根</strong></p>
<h4 id="二叉树的遍历算法"><a href="#二叉树的遍历算法" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h4><h5 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h5><p><strong>先序遍历</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240317174338628.png" alt="image-20240317174338628"></p>
<p>用二叉链表实现</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240317174735489.png" alt="image-20240317174735489"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324091243004.png" alt="image-20240324091243004"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240317175534497.png" alt="image-20240317175534497"></p>
<p>T是指针。</p>
<p>visit(T)可直接替换为对根节点进行的操作。</p>
<p><strong>中序遍历</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324091508322.png" alt="image-20240324091508322"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324091548013.png" alt="image-20240324091548013"></p>
<p><strong>后序遍历</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324091750803.png" alt="image-20240324091750803"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324091805832.png" alt="image-20240324091805832"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324091921852.png" alt="image-20240324091921852"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324092111487.png" alt="image-20240324092111487"></p>
<p>紫色线路为算法的访问路径</p>
<h5 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h5><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324092626487.png" alt="image-20240324092626487"></p>
<p>因为是中序遍历，所以在遍历过程中，碰到根结点要先存储起来，等到第二次遍历到的时候在输出，符合栈的思想，所以要建立一个栈来存储根结点。</p>
<p>重点是理清先后关系。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324093800755.png" alt="image-20240324093800755"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324094148253.png" alt="image-20240324094148253"></p>
<p>TRUE为1 ，FALSE 为0 。</p>
<p>指针变量q用来存储栈里面弹出的根结点的值。</p>
<h4 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324100832408.png" alt="image-20240324100832408"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324101045866.png" alt="image-20240324101045866"></p>
<p>入队						出队</p>
<p>a							  a</p>
<p>b f							b</p>
<p>f c d						 f</p>
<p>c d g						c</p>
<p>d g						   d</p>
<p>g e							g</p>
<p>e h							e</p>
<p>h							   h</p>
<p>从队列中出一个结点然后将它的左右子树结点入队。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324101558813.png" alt="image-20240324101558813"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324101704020.png" alt="image-20240324101704020"></p>
<p>和二叉树的非递归算法有点类似</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><strong>二叉树的建立</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324102735507.png" alt="image-20240324102735507"></p>
<p>若输入的二叉树的结点中没有包含空结点，那根据这些结点所建立的二叉树不唯一，若将空结点一起输入，那建立的二叉树就是唯一的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240324103640807.png" alt="image-20240324103640807"></p>
<p><strong>复制二叉树</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331084057520.png" alt="image-20240331084057520"></p>
<p><strong>计算二叉树的深度</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331085109571.png" alt="image-20240331085109571"></p>
<p>计算某一子树的深度时，若m&#x3D;n则任意一个加一都会等于该子树的深度。</p>
<p><strong>计算二叉树的结点数量</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331110645552.png" alt="image-20240331110645552"></p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331112334427.png" alt="image-20240331112334427"></p>
<p>结点的前驱和后继结点不是看树里的结点来判断的，而是看它的遍历顺序来判断。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331112903617.png" alt="image-20240331112903617"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331112959121.png" alt="image-20240331112959121"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331113051434.png" alt="image-20240331113051434"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331113226206.png" alt="image-20240331113226206"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331113850192.png" alt="image-20240331113850192"></p>
<p>这是中序遍历的线索二叉树</p>
<h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331145729866.png" alt="image-20240331145729866"></p>
<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p><strong>双亲表示法</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331150242564.png" alt="image-20240331150242564"></p>
<p>r 代表根结点的位置，n 代表数量。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331150442735.png" alt="image-20240331150442735"></p>
<p><strong>孩子链表</strong></p>
<p>特点：找孩子容易，找双亲难。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331151329318.png" alt="image-20240331151329318"></p>
<p>链表里的数据部分存储的是孩子结点的下标。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331151625871.png" alt="image-20240331151625871"></p>
<p>如何克服缺点，将双亲表示法和孩子链表相结合，在双亲结点中再添加一个空间用来存储该结点的双亲所在位置的下标。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331152159409.png" alt="image-20240331152159409"></p>
<p><strong>孩子兄弟表示法（常用）</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331152452933.png" alt="image-20240331152452933"></p>
<p>找双亲困难，但可以根据需要再添加一个指针域用来指向它的双亲结点。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331152835893.png" alt="image-20240331152835893"></p>
<h3 id="树和二叉树的转化"><a href="#树和二叉树的转化" class="headerlink" title="树和二叉树的转化"></a>树和二叉树的转化</h3><p>由于树和二叉树都可以用二叉链表作存储结构，则以二叉链表为媒介可以导出数和二叉树之间的对应关系。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405211228912.png" alt="image-20240405211228912"></p>
<p>一棵树的二叉链表是唯一的，而它对应的二叉树也是唯一的。</p>
<p>同一个二叉链表，左右指针域解释为孩子、兄弟则是树的存储方式，解释为左右子树，则是二叉树的存储形式。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405211647384.png" alt="image-20240405211647384"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405211821926.png" alt="image-20240405211821926"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405211928387.png" alt="image-20240405211928387"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405212044394.png" alt="image-20240405212044394"></p>
<h3 id="森林与二叉树的转化"><a href="#森林与二叉树的转化" class="headerlink" title="森林与二叉树的转化"></a>森林与二叉树的转化</h3><p>与树和二叉树的转化类似</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405212319844.png" alt="image-20240405212319844"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405212417458.png" alt="image-20240405212417458"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405212621831.png" alt="image-20240405212621831"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405212748167.png" alt="image-20240405212748167"></p>
<h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405213103578.png" alt="image-20240405213103578"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405213232528.png" alt="image-20240405213232528"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405213343843.png" alt="image-20240405213343843"></p>
<p>第一棵树遍历完之后，剩下的第三部分继续看成森林，然后再分成三部分，继续遍历。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405213413590.png" alt="image-20240405213413590"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405213802768.png" alt="image-20240405213802768"></p>
<h2 id="哈夫曼树及其应用"><a href="#哈夫曼树及其应用" class="headerlink" title="哈夫曼树及其应用"></a>哈夫曼树及其应用</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405215710407.png" alt="image-20240405215710407"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405215942369.png" alt="image-20240405215942369"></p>
<p>哈夫曼树的效率最高</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405220317088.png" alt="image-20240405220317088"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405220713754.png" alt="image-20240405220713754"></p>
<p>结点数目相同的二叉树中，路径最短的不一定是完全二叉树。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405221321967.png" alt="image-20240405221321967"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405221751933.png" alt="image-20240405221751933"></p>
<p>树的度是树中各结点的度中的最大值。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240405222054595.png" alt="image-20240405222054595"></p>
<p>权值较小的离根远，较大的离根近。</p>
<p>具有相同带权结点的哈夫曼树<strong>不唯一</strong>。</p>
<h3 id="构造算法"><a href="#构造算法" class="headerlink" title="构造算法"></a>构造算法</h3><p>贪心算法：先挑权值小的叶子结点构造哈夫曼树。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414095135336.png" alt="image-20240414095135336"></p>
<p>Ti是只有一个带权为wi的根结点。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414095508545.png" alt="image-20240414095508545"></p>
<p>根据刚开始的举例，哈夫曼树中的结点为空的应该是判断条件。</p>
<p>哈夫曼树的结点的度为0或2，没有为1的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414095958424.png" alt="image-20240414095958424"></p>
<p>n-1各新结点都是度为2的结点。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414100331303.png" alt="image-20240414100331303"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414100718091.png" alt="image-20240414100718091"></p>
<p>使用数组进存储时因为在后面给结点赋双亲结点和左右子树时比较容易。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414101210199.png" alt="image-20240414101210199"></p>
<p>初始状态，构造n个子树。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414101331941.png" alt="image-20240414101331941"></p>
<p>完成第一次循环，删除两个结点就是给两个结点的双亲结点赋值。</p>
<p>所以判断剩余结点的条件就是双亲结点是否为0.</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414101631640.png" alt="image-20240414101631640"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414101943214.png" alt="image-20240414101943214"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414101958619.png" alt="image-20240414101958619"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414102120779.png" alt="image-20240414102120779"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414102604656.png" alt="image-20240414102604656"></p>
<h3 id="哈夫曼树的应用——哈夫曼编码"><a href="#哈夫曼树的应用——哈夫曼编码" class="headerlink" title="哈夫曼树的应用——哈夫曼编码"></a>哈夫曼树的应用——哈夫曼编码</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414102929965.png" alt="image-20240414102929965"></p>
<p>每个字母都用固定长度的空间来存储，比较浪费。</p>
<p>因此让出现次数较多的字母用较少的空间来存储，可以减少浪费。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414103254254.png" alt="image-20240414103254254"></p>
<p>任意一个字符的编码都不是另一个字符的前缀，而哈夫曼树只有叶子结点有值，所以利用哈夫曼树进行编码可以避免出现重码。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414103512970.png" alt="image-20240414103512970"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414104305770.png" alt="image-20240414104305770"></p>
<p>解码采用暴力破解法（我觉得），但其实不是。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414104746689.png" alt="image-20240414104746689"></p>
<p>每个叶子结点的编码不用经过其它需要翻译的字符的结点，所以不会出现一个字符的编码是另一个字符的前缀的情况。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414105526907.png" alt="image-20240414105526907"></p>
<p>cd数组是用来暂时存储寻找字符的编码过程中的编码，从倒数第二个也就是第5位开始存储。</p>
<p>HC数组是用来存储字符编码的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414110048899.png" alt="image-20240414110048899"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414110440879.png" alt="image-20240414110440879"></p>
<p><strong>文件的编码和解码</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414111042964.png" alt="image-20240414111042964"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414111125810.png" alt="image-20240414111125810"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414111427864.png" alt="image-20240414111427864"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-C语言-0" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/05/C%E8%AF%AD%E8%A8%80-0/" class="article-date">
  	<time datetime="2024-10-05T09:52:53.000Z" itemprop="datePublished">2024-10-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/05/C%E8%AF%AD%E8%A8%80-0/">
        C语言
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="size和strlen"><a href="#size和strlen" class="headerlink" title="size和strlen"></a>size和strlen</h1><img src="../source/imgs/${fiilname}/image-20231120202724760.png" alt="image-20231120202724760" style="zoom:50%;" />

<p>若先定义了一个字符数组却没有直接赋值，那么后面再直接赋值即B是不行的；采用A一个个输入可以；只能用C进行赋值。</p>
<p>在字符数组中，sizeof会将’\0’计算在数组大小里面；strlen 则不会。</p>
<h1 id="指针类"><a href="#指针类" class="headerlink" title="指针类"></a>指针类</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><img src="../source/imgs/${fiilname}/image-20231121170743913.png" alt="image-20231121170743913" style="zoom:50%;" />

<img src="../source/imgs/${fiilname}/image-20231121170813279.png" alt="image-20231121170813279" style="zoom:50%;" />

<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>是数组，存储的是指针。</p>
<p>例：int arr[10]&#x3D;{0};   &#x2F;&#x2F;整型数组，数组用来存放整型(int)</p>
<pre><code>    int* parr[4];       //指针数组，数组用来存放整型指针(int *)
</code></pre>
<p><strong>[]的优先级大于</strong>*</p>
<p>用法一：存储一些变量的地址</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240103205959123.png" alt="image-20240103205959123"></p>
<p>用法二：用来存储数组的头地址</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240103211527763.png" alt="image-20240103211527763"></p>
<h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><p>是指针，存储的是数组的地址。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240104192506645.png" alt="image-20240104192506645"></p>
<p>int arr[10]</p>
<p>arr和&amp;arr的输出结果相同。但是&amp;arr表示的是一整个数组首元素的地址，而不是数组单个首元素的地址，所以&amp;arr+1，逃过的是整个数组的大小；arr表示的是数组首元素的地址，所以arr+1代表的是跳过一个元素。</p>
<p><strong>用法一</strong>：用来表示一维数组</p>
<p>（1）第一种输出方式</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240104193736429.png" alt="image-20240104193736429"></p>
<p>解引用：指针被解除引用就是它所指向的变量了，解引用的操作符是’*’。</p>
<p>例如某指针变量p，解引用就是*p，也就是p所指向的变量了。</p>
<p>（2）第二种输出方式</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240104195039871.png" alt="image-20240104195039871"></p>
<p><strong>用法二</strong>：处理二维数组，较经常使用，用于此比较简单</p>
<p>看课本去</p>
<h1 id="c预处理器"><a href="#c预处理器" class="headerlink" title="c预处理器"></a>c预处理器</h1><p><strong>预处理器后面不需要“；”</strong></p>
<img src="../source/imgs/${fiilname}/image-20231124214349048.png" alt="image-20231124214349048" style="zoom:60%;" />

<p>某种程度上”#define”后面的名称相当于函数名称，再后面的东西相当于函数体</p>
<img src="../source/imgs/${fiilname}/image-20231124214430334.png" alt="image-20231124214430334" style="zoom:60%;" />

<img src="../source/imgs/${fiilname}/image-20231124214842663.png" alt="image-20231124214842663" style="zoom:60%;" />

<p>这些宏不能被修改，DATE和TIME得用%s。每个两侧是两个下划线。</p>
<h2 id=""><a href="#" class="headerlink" title="\"></a>\</h2><p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符“\”，然后就可以换行继续写了。可以参考下面的程序</p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><img src="../source/imgs/${fiilname}/image-20231124215609356.png" alt="image-20231124215609356" style="zoom:50%;" />

<p>使用“#”即可输出a,b且不需要定义a和b。message_for有点像函数，但从某种程度上比函数方便。</p>
<p><strong>“#”不能在程序中使用</strong></p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><img src="../source/imgs/${fiilname}/image-20231124222009122.png" alt="image-20231124222009122" style="zoom:50%;" />

<h2 id="defined"><a href="#defined" class="headerlink" title="defined()"></a>defined()</h2><p>预处理器 <strong>defined</strong> 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符<strong>已定义，则值为真（非零）</strong>。如果指定的标识符<strong>未定义，则值为假（零）</strong>。</p>
<img src="../source/imgs/${fiilname}/image-20231124222927472.png" alt="image-20231124222927472" style="zoom:50%;" />

<h2 id="参数化的宏"><a href="#参数化的宏" class="headerlink" title="参数化的宏"></a>参数化的宏</h2><p>可以用来写函数</p>
<img src="../source/imgs/${fiilname}/image-20231124223145890.png" alt="image-20231124223145890" style="zoom:60%;" />

<p>在使用带有参数的宏之前，必须使用 <strong>#define</strong> 指令定义。<strong>参数列表是括在圆括号内</strong>，且必须紧跟在宏名称的后边。<strong>宏名称和左圆括号之间不允许有空格</strong>。</p>
<img src="../source/imgs/${fiilname}/image-20231124223306726.png" alt="image-20231124223306726" style="zoom:60%;" />

<img src="../source/imgs/${fiilname}/image-20231204222701538.png" alt="image-20231204222701538" style="zoom:67%;" />

<p>使用#define含参时，<strong>参数括号很重要</strong></p>
<img src="../source/imgs/${fiilname}/image-20231124223539702.png" alt="image-20231124223539702" style="zoom:60%;" />

<h1 id="算数转化"><a href="#算数转化" class="headerlink" title="算数转化"></a>算数转化</h1><img src="../source/imgs/${fiilname}/image-20231128102311992.png" alt="image-20231128102311992" style="zoom:50%;" />

<p><strong>常用的算术转换不适用于赋值运算符、逻辑运算符 &amp;&amp; 和 ||。</strong></p>
<p>对于赋值运算符，如 “&#x3D;”，它并不执行算术转换。如果一个变量是 int 类型，而另一个变量是 double 类型，那么它们之间进行赋值运算时，double 类型的值不会被转换成 int 类型，而是直接将 double 类型的值赋给 int 类型的变量。</p>
<p>对于逻辑运算符 “&amp;&amp;” 和 “||”，C 语言中也没有进行算术转换。这两个运算符只对真和假进行逻辑判断，而不是进行算术运算。因此，无论表达式两边的值是什么类型，都不会进行算术转换。</p>
<p>例：</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()

&#123;

int a = 5;
double b = 3.14;

// 赋值运算不执行算术转换
a = b; // a 的值现在是 3.14，而不是 3

// 逻辑运算符也不执行算术转换
if (a &gt; b) &#123; // 这里不会试图比较两个数的数值大小，而是直接比较它们的类型和值
    printf(&quot;a is greater than b&quot;);
&#125;

&#125;</code></pre>

<img src="../source/imgs/${fiilname}/image-20231128104301300.png" alt="image-20231128104301300" style="zoom:80%;" />

<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h2 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h2><p>用来打开文件，基本语法格式：FILE *fopen( const char *filename, const char *mode );</p>
<p>在这里，<strong>filename</strong> 是字符串，用来命名文件，访问模式 <strong>mode</strong> 的值可以是下列值中的一个：</p>
<img src="../source/imgs/${fiilname}/image-20231128215809538.png" alt="image-20231128215809538" style="zoom:67%;" />

<pre><code class="hljs plaintext">`#include &lt;stdio.h&gt;`
`int main() &#123;`
    `FILE *fp;`
    `char c;`
    `fp = fopen(&quot;test.txt&quot;, &quot;r&quot;); // 打开名为test.txt的文件，以只读方式打开`
    `if (fp == NULL) &#123; // 如果打开文件失败`
        `printf(&quot;Failed to open file.\n&quot;);`
        `return 1;`
    `&#125;`
    `while ((c = fgetc(fp)) != EOF) &#123; // 从文件中读取一个字符，直到文件末尾`
        `printf(&quot;%c&quot;, c); // 输出读取到的字符`
    `&#125;`
    `fclose(fp); // 关闭文件`
    `return 0;`
`&#125;`</code></pre>



<h2 id="fclose函数"><a href="#fclose函数" class="headerlink" title="fclose函数"></a>fclose函数</h2><p>关闭文件，基本语法格式：int fputc( int c, FILE *fp );</p>
<p>如果成功关闭文件，<strong>fclose( )</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。</p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>将<strong>字符</strong>写入文件中：**int fputc( int c, FILE *fp )**;函数 <strong>fputc()</strong> 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <strong>EOF</strong>。</p>
<p>将<strong>字符串</strong>写入文件中：**int fputs( const char *s, FILE *fp )**;函数 <strong>fputs()</strong> 把字符串 <strong>s</strong> 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <strong>EOF</strong>。</p>
<p>也可以使用 <strong>int fprintf(FILE *fp,const char *format, …)</strong> 函数把一个字符串写入到文件中。</p>
<pre><code class="hljs plaintext">`#include &lt;stdio.h&gt;`

`int main()`
`&#123;`
   `FILE *fp = NULL;`

   `fp = fopen(&quot;/tmp/test.txt&quot;, &quot;w+&quot;);`
   `fprintf(fp, &quot;This is testing for fprintf...\n&quot;);`
   `fputs(&quot;This is testing for fputs...\n&quot;, fp);`
   `fclose(fp);`
`&#125;`</code></pre>

<p>当上面的代码被编译和执行时，它会在 &#x2F;tmp 目录中创建一个新的文件 <strong>test.txt</strong>，并使用两个不同的函数写入两行。接下来让我们来读取这个文件。</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>读取单个字符：int fgetc( FILE * fp );</p>
<p>读取字符串：char *fgets( char *buf, int n, FILE *fp );函数 <strong>fgets()</strong> 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 <strong>buf</strong>（比如字符数组），并在最后追加一个 <strong>null</strong> 字符来终止字符串。如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。</p>
<p>您也可以使用 <strong>int fscanf(FILE *fp, const char *format, …)</strong> 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。</p>
<img src="../source/imgs/${fiilname}/image-20231128233441169.png" alt="image-20231128233441169" style="zoom:80%;" />

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>先找递归出口；相当于while循环，没有符合出口条件就继续递归。</p>
<img src="../source/imgs/${fiilname}/image-20231129145750566.png" alt="image-20231129145750566" style="zoom:50%;" />

<p>与直接的语句(如while循环)相比，递归函数会耗费更多的运行时间，并且要占用大量的栈空间。</p>
<p>采用递归方法来解决问题，必须符合以下三个条件：</p>
<p>1、可以把要解决的问题转化为一个新问题，而这个新的问题的解决方法仍与原来的解决方法相同，只是所处理的对象有规律地递增或递减。</p>
<p>说明：解决问题的方法相同，调用函数的参数每次不同（有规律的递增或递减），如果没有规律也就不能适用递归调用。</p>
<p>2、可以应用这个转化过程使问题得到解决。</p>
<p>说明：使用其他的办法比较麻烦或很难解决，而使用递归的方法可以很好地解决问题。</p>
<p>3、必定要有一个明确的结束递归的条件。</p>
<p>说明：一定要能够在适当的地方结束递归调用。不然可能导致系统崩溃。</p>
<p><strong>深度优先遍历</strong></p>
<p><strong>题目：</strong>将一个正整数N分解成几个正整数相加，可以有多种分解方法，例如7&#x3D;6+1，7&#x3D;5+2，7&#x3D;5+1+1，…。编程求出正整数N的所有整数分解式子。</p>
<p>输入格式：</p>
<p>每个输入包含一个测试用例，即正整数N (0&lt;N≤30)。</p>
<p>输出格式：</p>
<p>按递增顺序输出N的所有整数分解式子。递增顺序是指：对于两个分解序列<em>N</em>1&#x3D;{<em>n</em>1,<em>n</em>2,⋯}和<em>N</em>2&#x3D;{<em>m</em>1,<em>m</em>2,⋯}，若存在<em>i</em>使得<em>n</em>1&#x3D;<em>m</em>1,⋯,<em>n**i</em>&#x3D;<em>m**i</em>，但是<em>n**i</em>+1&lt;<em>m**i</em>+1,则<em>N</em>1序列必定在<em>N</em>2序列之前输出。每个式子由小到大相加，式子间用分号隔开，且每输出4个式子后换行。</p>
<p>输入样例：</p>
<pre><code class="hljs in">7</code></pre>

<p>输出样例：</p>
<pre><code class="hljs out">7=1+1+1+1+1+1+1;7=1+1+1+1+1+2;7=1+1+1+1+3;7=1+1+1+2+2
7=1+1+1+4;7=1+1+2+3;7=1+1+5;7=1+2+2+2
7=1+2+4;7=1+3+3;7=1+6;7=2+2+3
7=2+5;7=3+4;7=7</code></pre>

<p>a[0]&#x3D;1-&gt;a[1]&#x3D;1-&gt;a[2]&#x3D;1-&gt;index&#x3D;3</p>
<p>​			-&gt;a[1]&#x3D;2-&gt;index&#x3D;2</p>
<p>a[0]&#x3D;2-&gt;无法继续，递归没有出口就不用理会</p>
<p>a[0]&#x3D;3-&gt;index&#x3D;1</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
int part[30]=&#123;0&#125;;
int n,cout=0;
void divide(int sub,int min,int m)
&#123;
	if(sub==0)
	&#123;
		printf(&quot;%d=%d&quot;,n,part[0]);
		for(int i=1;i&lt;m;i++)
			printf(&quot;+%d&quot;,part[i]);
		if(part[0]==n);//为了让最后一个输出没有分号
		else if(cout&lt;3)
		&#123;
			cout++;
			printf(&quot;;&quot;);
		&#125;
		else&#123;
			cout=0;
			printf(&quot;\n&quot;);
		&#125;
	&#125;
	else&#123;
		for(int i=min;i&lt;=sub;i++)
		&#123;
			part[m]=i;
			min=i;
			divide(sub-min,min,m+1);
		&#125;	
	&#125;
&#125;
int main() &#123;
	int num;
	scanf(&quot;%d&quot;,&amp;num);
	n=num;
	divide(num,1,0);
    return 0;
&#125;</code></pre>



<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>定义一个函数，函数可以接受可变数量的参数.</p>
<img src="../source/imgs/${fiilname}/image-20231129155416219.png" alt="image-20231129155416219" style="zoom:75%;" />

<p>常用的宏有：</p>
<ul>
<li><code>**va_start(ap, last_arg)**</code>：初始化可变参数列表。<code>ap</code> 是一个 <code>va_list</code> 类型的变量，<code>last_arg</code> 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 <code>ap</code> 指向可变参数列表中的第一个参数。</li>
<li><code>**va_arg(ap, type)**</code>：获取可变参数列表中的下一个参数。<code>ap</code> 是一个 <code>va_list</code> 类型的变量，<code>type</code> 是下一个参数的类型。该宏返回类型为 <code>type</code> 的值，并将 <code>ap</code> 指向下一个参数。</li>
<li><code>**va_end(ap)**</code>：结束可变参数列表的访问。<code>ap</code> 是一个 <code>va_list</code> 类型的变量。该宏将 <code>ap</code> 置为 <code>NULL</code>。</li>
</ul>
<pre><code class="hljs plaintext">`#include &lt;stdio.h&gt;`
`#include &lt;stdarg.h&gt;`

`double average(int num,...)`
`&#123;`

    va_list valist;
    double sum = 0.0;
    int i;
     
    /* 为 num 个参数初始化 valist */
    va_start(valist, num);
     
    /* 访问所有赋给 valist 的参数 */
    for (i = 0; i &lt; num; i++)
    &#123;
       sum += va_arg(valist, int);
    &#125;
    /* 清理为 valist 保留的内存 */
    va_end(valist);
     
    return sum/num;

`&#125;`

`int main()`
`&#123;`
   `printf(&quot;Average of 2, 3, 4, 5 = %f\n&quot;, average(4, 2,3,4,5));`
   `printf(&quot;Average of 5, 10, 15 = %f\n&quot;, average(3, 5,10,15));`
`&#125;`</code></pre>

<p>输出结果为：Average of 2, 3, 4, 5 &#x3D; 3.500000<br>                       Average of 5, 10, 15 &#x3D; 10.000000</p>
<img src="../source/imgs/${fiilname}/image-20231129155741175.png" alt="image-20231129155741175" style="zoom:60%;" />

<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><img src="../source/imgs/${fiilname}/image-20231205155942730.png" alt="image-20231205155942730" style="zoom:80%;" />

<p><strong>malloc的内存空间不会初始化，值是未知的，calloc的内存空间会被初始化为0</strong></p>
<p><strong>realloc里面如果那个数组原本的空间为0的话，那realloc的功能相当于malloc</strong></p>
<p>但是，如果您预先不知道需要存储的文本长度，例如您想存储有关一个主题的详细描述。在这里，我们<strong>需要定义一个指针</strong>，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示：</p>
<img src="../source/imgs/${fiilname}/image-20231205162854728.png" alt="image-20231205162854728" style="zoom:80%;" />

<p>上面的程序也可以使用 <strong>calloc()</strong> 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：</p>
<pre><code class="hljs plaintext">calloc(200, sizeof(char));</code></pre>

<h2 id="重新调整内存的大小"><a href="#重新调整内存的大小" class="headerlink" title="重新调整内存的大小"></a>重新调整内存的大小</h2><img src="../source/imgs/${fiilname}/image-20231205163707012.png" alt="image-20231205163707012" style="zoom:80%;" />

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code class="hljs plaintext">Name = Zara Ali
Description: Zara ali a DPS student.She is in class 10th</code></pre>

<p>您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20231205164222817.png" alt="image-20231205164222817"></p>
<h2 id="申请二维数组的空间"><a href="#申请二维数组的空间" class="headerlink" title="申请二维数组的空间"></a>申请二维数组的空间</h2><p><strong>方法一</strong>：二级指针</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240122210202548.png" alt="image-20240122210202548"></p>
<p>地址是连续的</p>
<p><strong>方法二</strong>：数组指针</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240122211732940.png" alt="image-20240122211732940"></p>
<p><strong>方法三</strong>：一维数组模拟二维数组</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240122212028150.png" alt="image-20240122212028150"></p>
<p>一般使用第一种和第二种方法，如果以指针为参数传递到一个函数一个二维数组要用方法一，方法二会报错。但是方法二简洁，然后用完要释放。</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>冒泡排序里，j&#x3D;0;</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;
	int a[5]=&#123;3,1,7,5,4&#125;;
	int i,j,t;
	for(i=1;i&lt;5;i++)&#123;
		for(j=0;j&lt;5;j++)&#123;
			if(a[j]&gt;a[j+1])&#123;
				t=a[j];
				a[j]=a[j+1];
				a[j+1]=t;
			&#125;
		&#125;
	&#125;
	for(i=0;i&lt;5;i++)
		printf(&quot;%d&quot;,a[i]);
	return 0;
&#125;</code></pre>

<p>选择排序：</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;
	int a[5]=&#123;3,1,7,5,4&#125;;
	int i,j,t;
	for(i=0;i&lt;4;i++)&#123;
		for(j=i;j&lt;5;j++)&#123;
			if(a[j]&lt;a[i])&#123;
				t=a[i];
				a[i]=a[j];
				a[j]=t;
			&#125;
		&#125;
	&#125;
	for(i=0;i&lt;5;i++)
		printf(&quot;%d &quot;,a[i]);
	return 0;
&#125;</code></pre>

<img src="../source/imgs/${fiilname}/image-20231211212515250.png" alt="image-20231211212515250" style="zoom:80%;" />

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><img src="../source/imgs/${fiilname}/image-20231211205858599.png" alt="image-20231211205858599" style="zoom:60%;" />

<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
void insertion_sort(int a[], int len)&#123;
    int i,t,temp;
    for(t=1;t&lt;len;t++)&#123;
    	temp=a[t];
    	for(i=t;i&gt;=0;i--)&#123;
    		if(a[i-1]&gt;temp)
				a[i]=a[i-1];
    		else &#123;
    			a[i]=temp;
    			break;
			&#125;
		&#125;
	&#125;
&#125;
int main() &#123;
    int arr[] = &#123; 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 &#125;;
    int len = (int) sizeof(arr) / sizeof(*arr);
    insertion_sort(arr, len);
    int i;
    for (i = 0; i &lt; len; i++)
		printf(&quot;%d &quot;,arr[i]);
    return 0;
&#125;</code></pre>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>稳定，速度快，适合大数据量的排序</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
void printA(int* arr,int len)&#123;
	for(int i=0;i&lt;len;i++)&#123;
		printf(&quot;%d &quot;,arr[i]);
	&#125;
	printf(&quot;\n&quot;);
&#125;
void merge(int* arr,int left,int mid,int right)&#123;
	int i=left;
	int j=mid;
	int* temp=(int*)malloc((right-left)*4);
	int index=0;
	while(i&lt;mid&amp;&amp;j&lt;right)&#123;
		if(arr[i]&lt;arr[j])&#123;
			temp[index]=arr[i];
			i++;
		&#125;else&#123;
			temp[index]=arr[j];
			j++;
		&#125;
		index++;
	&#125;
	while(i&lt;mid)&#123;
		temp[index]=arr[i];
		index++;
		i++;
	&#125;
	while(j&lt;right)&#123;
		temp[index]=arr[j];
		index++;
		j++;
	&#125;for(int i=0;i&lt;index;i++)&#123;
		arr[left+i]=temp[i];
	&#125;
	free(temp);
&#125;
void mergeSort(int* arr,int left,int right)&#123;
	if(right-left&lt;=1)&#123;
		return;
	&#125;
	int mid=(left+right)/2;
	mergeSort(arr,left,mid);
	mergeSort(arr,mid,right);
	merge(arr,left,mid,right);
&#125;
int main()&#123;
	int* arr1=(int*)malloc(4*4);
	arr1[0]=10;
	arr1[1]=9;
	arr1[2]=8;
	arr1[3]=7;
	mergeSort(arr1,0,4);
	printA(arr1,4);
	return 0;
&#125;</code></pre>



<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>还没写</p>
<h1 id="亦或"><a href="#亦或" class="headerlink" title="亦或"></a>亦或</h1><p>异或运算符”∧”也称XOR运算符。它的规则是若参加运算的两个二进位同号，则结果为0（假）；异号则为1（真）。即 0∧0＝0，0∧1＝1， 1^0&#x3D;1，1∧1＝0。</p>
<p><strong>相同为0，不相同为1</strong></p>
<p>运算 说明<br>0 ^ 0&#x3D;0,0 ^ 1&#x3D;1，0亦或任何数，其结果&#x3D;任何数<br>1 ^ 0&#x3D;1,1 ^ 1&#x3D;0，1亦或任何数，其结果&#x3D;任何数取反<br>x ^ x&#x3D;0 任何数异或自己，等于把自己置0</p>
<img src="../source/imgs/${fiilname}/image-20240125161412126.png" alt="image-20240125161412126" style="zoom:80%;" />

<p>常见用途:</p>
<p>（1）使特定位翻转</p>
<p>比如：01111010，想使其低4位翻转，即1变为0，0变为1。可以将它与00001111进行∧运算，即</p>
<p>​         0111 1010</p>
<p>​         0000 1111</p>
<p>结果：    0111 0101</p>
<p>结果值的低4位正好是原数低4位的翻转。要使哪几位翻转就将与其∧运算的该几位置为1即可。这是因为原数中值为1的位与1进行∧运算得0，原数中的位值0与1进行∧运算的结果得1。</p>
<p>(2)实现两个值的交换</p>
<p>通过按位异或运算，可以实现两个值的交换，而不必使用临时变量。例如交换两个整数a&#x3D;3，b&#x3D;4的值，可通过下列语句实现：</p>
<p>a＝a∧b;<br>b＝b∧a;<br>a&#x3D;a∧b;</p>
<p>0011 —a &#x3D;3</p>
<p>0100 —b &#x3D;4</p>
<p>-———-</p>
<p>0111—-a &#x3D;7</p>
<p>0100—-b &#x3D;4</p>
<p>-———-</p>
<p>0011—–b &#x3D;3</p>
<p>0111——a &#x3D;&#x3D;7</p>
<p>0100—-a &#x3D;&#x3D;3</p>
<p>（3）还可以找到一组数内只出现一次的数，只需要把所有数一起做异或运算如：1 2 3 4 5 1 2 3 4</p>
<p>因为1^1&#x3D;0，2^2&#x3D;0，3^3&#x3D;0，4^4&#x3D;0，5^0&#x3D;5</p>
<p>又异或满足交换律和结合律</p>
<p>1^2^3^4^5^1^2^3^4&#x3D;5</p>
<p>所以5只出现了一次</p>
<h1 id="strtok函数"><a href="#strtok函数" class="headerlink" title="strtok函数"></a>strtok函数</h1><p><code>strtok</code> 函数是 C 语言中用于分割字符串的函数。它在字符串中查找特定的分隔符，并将字符串分割成多个子字符串。以下是一些简单的 <code>strtok</code> 函数的例子：</p>
<p>一、基本使用</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() &#123;
    char str[] = &quot;apple,orange,banana&quot;;
    char *token = strtok(str, &quot;,&quot;);
    

while (token != NULL) &#123;
    printf(&quot;%s\n&quot;, token);
    token = strtok(NULL, &quot;,&quot;);
&#125;

return 0;

&#125;</code></pre>

<p>二、使用不同分隔符</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() &#123;
    char str[] = &quot;apple orange:banana&quot;;
    char *token = strtok(str, &quot; :&quot;);
    

while (token != NULL) &#123;
    printf(&quot;%s\n&quot;, token);
    token = strtok(NULL, &quot; :&quot;);
&#125;

return 0;

&#125;</code></pre>

<p>三、处理多个连续分隔符</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() &#123;
    char str[] = &quot;apple,,orange,,banana&quot;;
    char *token = strtok(str, &quot;,&quot;);
    

while (token != NULL) &#123;
    printf(&quot;%s\n&quot;, token);
    token = strtok(NULL, &quot;,&quot;);
&#125;

return 0;

&#125;</code></pre>

<p>输出：</p>
<pre><code class="hljs plaintext">apple
orange
banana</code></pre>

<p>请注意，<code>strtok</code> 函数在每次调用时会修改原始字符串，用 <code>NULL</code> 作为第一个参数来继续处理相同的字符串。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;

int main()
&#123;
    int i, n, t1 = 0, t2 = 1, nextTerm;

    printf(&quot;输出几项: &quot;);
    scanf(&quot;%d&quot;, &amp;n);
     
    printf(&quot;斐波那契数列: &quot;);
     
    for (i = 1; i &lt;= n; ++i)
    &#123;
        printf(&quot;%d, &quot;, t1);
        nextTerm = t1 + t2;
        t1 = t2;
        t2 = nextTerm;
    &#125;
    return 0;

&#125;</code></pre>

<h2 id="金字塔型图案"><a href="#金字塔型图案" class="headerlink" title="金字塔型图案"></a>金字塔型图案</h2><p>使用字母</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
int main()
&#123;
    int i, j;
    char input, alphabet = &#x27;A&#x27;;

    printf(&quot;输入大写字母: &quot;);
    scanf(&quot;%c&quot;,&amp;input);
     
    for(i=1; i &lt;= (input-&#x27;A&#x27;+1); ++i)
    &#123;
        for(j=1;j&lt;=i;++j)
        &#123;
            printf(&quot;%c&quot;, alphabet);
        &#125;
        ++alphabet;
     
        printf(&quot;\n&quot;);
    &#125;
    return 0;

&#125;</code></pre>

<p>金字塔</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
int main()
&#123;
    int i, space, rows, k=0;

    printf(&quot;Enter number of rows: &quot;);
    scanf(&quot;%d&quot;,&amp;rows);
     
    for(i=1; i&lt;=rows; ++i, k=0)
    &#123;
        for(space=1; space&lt;=rows-i; ++space)
        &#123;
            printf(&quot;  &quot;);
        &#125;
     
        while(k != 2*i-1)
        &#123;
            printf(&quot;* &quot;);
            ++k;
        &#125;
     
        printf(&quot;\n&quot;);
    &#125;
    
    return 0;

&#125;</code></pre>

<p>space&#x3D;1比较巧妙，直接代表中间的那个“*”；但是k难一点</p>
<h2 id="菱形"><a href="#菱形" class="headerlink" title="菱形"></a>菱形</h2><p>可扩展</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
int main()
&#123;
    int i,j,k;
    for(i=0;i&lt;=3;i++) &#123;
        for(j=0;j&lt;=2-i;j++) &#123;
            printf(&quot; &quot;);
        &#125;
        for(k=0;k&lt;=2*i;k++) &#123;
            printf(&quot;*&quot;);
        &#125;
        printf(&quot;\n&quot;);
    &#125;
    for(i=0;i&lt;=2;i++) &#123;
        for(j=0;j&lt;=i;j++) &#123;
            printf(&quot; &quot;);
        &#125;
        for(k=0;k&lt;=4-2*i;k++) &#123;
            printf(&quot;*&quot;);
        &#125;
        printf(&quot;\n&quot;);
    &#125;

&#125;</code></pre>

<img src="../source/imgs/${fiilname}/image-20240121164754559.png" alt="image-20240121164754559" style="zoom:50%;" />

<h2 id="二进制转化为十进制"><a href="#二进制转化为十进制" class="headerlink" title="二进制转化为十进制"></a>二进制转化为十进制</h2><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int convertBinaryToDecimal(long long n);

int main()
&#123;
    long long n;
    printf(&quot;输入一个二进制数: &quot;);
    scanf(&quot;%lld&quot;, &amp;n);
    printf(&quot;二进制数 %lld 转换为十进制为 %d&quot;, n, convertBinaryToDecimal(n));
    return 0;
&#125;

int convertBinaryToDecimal(long long n)
&#123;
    int decimalNumber = 0, i = 0, remainder;
    while (n!=0)
    &#123;
        remainder = n%10;
        n /= 10;
        decimalNumber += remainder*pow(2,i);
        ++i;
    &#125;
    return decimalNumber;
&#125;</code></pre>

<p>重点是<strong>pow</strong>的运用</p>
<h2 id="字符串的翻转"><a href="#字符串的翻转" class="headerlink" title="@字符串的翻转"></a>@字符串的翻转</h2><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
void reverseSentence();

int main()
&#123;
    printf(&quot;输入一个字符串: &quot;);
    reverseSentence();

    return 0;

&#125;

void reverseSentence()
&#123;
    char c;
    scanf(&quot;%c&quot;, &amp;c);

    if( c != &#x27;\n&#x27;)
    &#123;
        reverseSentence();
        printf(&quot;%c&quot;,c);
    &#125;

&#125;</code></pre>

<p>很巧妙，也可以用来翻转一串数字</p>
<h2 id="矩阵转化"><a href="#矩阵转化" class="headerlink" title="矩阵转化"></a>矩阵转化</h2><pre><code class="hljs plaintext">for(i=0; i&lt;r; ++i)

        for(j=0; j&lt;c; ++j) 

       &#123; 

           transpose[j][i]= a[i][j];

        &#125;</code></pre>

<h2 id="删除字符串中的特殊字符"><a href="#删除字符串中的特殊字符" class="headerlink" title="删除字符串中的特殊字符"></a>删除字符串中的特殊字符</h2><p>可以推广</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;

int main()
&#123;
    char line[150];
    int i, j;
    printf(&quot;输入一个字符串: &quot;);
    fgets(line, (sizeof line / sizeof line[0]), stdin);//输入字符串
	//gets(line);
    for(i = 0; line[i] != &#x27;\0&#x27;; ++i)
    &#123;
        while (!( (line[i] &gt;= &#x27;a&#x27; &amp;&amp; line[i] &lt;= &#x27;z&#x27;) || (line[i] &gt;= &#x27;A&#x27; &amp;&amp; line[i] &lt;= &#x27;Z&#x27;) || line[i] == &#x27;\0&#x27;) )
        &#123;
            for(j = i; line[j] != &#x27;\0&#x27;; ++j)
            &#123;
                line[j] = line[j+1];
            &#125;
            line[j] = &#x27;\0&#x27;;
        &#125;
    &#125;
    printf(&quot;输出: &quot;);
    puts(line);
    return 0;
&#125;</code></pre>

<p>注意while循环里的条件</p>
<p>里面输入字符串是用fgets函数（看之后的笔记，估计得用stdin才能输入字符串到数组中），也可以用gets函数</p>
<h3 id="fgets函数"><a href="#fgets函数" class="headerlink" title="fgets函数"></a>fgets函数</h3><p>C 库函数 <strong>char *fgets(char *str, int n, FILE *stream)</strong> 从指定的流 stream 读取一行，并把它存储在 <strong>str</strong> 所指向的字符串内。当读取 <strong>(n-1)</strong> 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p>
<p>下面是 fgets() 函数的声明。</p>
<pre><code class="hljs plaintext">char *fgets(char *str, int n, FILE *stream)</code></pre>

<p>参数</p>
<ul>
<li><strong>str</strong> – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。</li>
<li><strong>n</strong> – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。</li>
</ul>
<h2 id="查找字符在字符串中出现的次数"><a href="#查找字符在字符串中出现的次数" class="headerlink" title="查找字符在字符串中出现的次数"></a>查找字符在字符串中出现的次数</h2><p>#include &lt;stdio.h&gt;</p>
<p>int main()<br>{<br>   char str[1000], ch;<br>   int i, frequency &#x3D; 0;</p>
<p>   printf(“输入字符串: “);<br>   fgets(str, (sizeof str &#x2F; sizeof str[0]), stdin);</p>
<p>   printf(“输入要查找的字符: “);<br>   scanf(“%c”,&amp;ch);</p>
<p>   for(i &#x3D; 0; <strong>str[i] !&#x3D; ‘\0’</strong>; ++i)<br>   {<br>       <strong>if(ch &#x3D;&#x3D; str[i])</strong><br>           ++frequency;<br>   }</p>
<p>   printf(“字符 %c 在字符串中出现的次数为 %d”, ch, frequency);</p>
<p>   return 0;<br>}</p>
<p>用这个if条件可以不需要输入要输多少或者判断字符串长度</p>
<h2 id="约瑟夫生者死者小游戏（continue-逻辑）"><a href="#约瑟夫生者死者小游戏（continue-逻辑）" class="headerlink" title="约瑟夫生者死者小游戏（continue,逻辑）"></a>约瑟夫生者死者小游戏（continue,逻辑）</h2><p>30 个人在一条船上，超载，需要 15 人下船。</p>
<p>于是人们排成一队，排队的位置即为他们的编号。</p>
<p>报数，从 1 开始，数到 9 的人下船。</p>
<p>如此循环，直到船上仅剩 15 人为止，问都有哪些编号的人下船了呢？</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;

int c = 0;
int i = 1;
int j = 0;
int a[30] = &#123; 0 &#125;;
int b[30] = &#123; 0 &#125;;

int main() &#123;
    while (i&lt;=31) &#123;
        if (i == 31) &#123;
            i = 1;
        &#125; else if (c == 15) &#123;
            break;
        &#125; else &#123;
            if (b[i] != 0) &#123;
                i++;
                continue;
            &#125; else &#123;
                j++;
                if (j != 9) &#123;
                    i++;
                    continue;
                &#125; else &#123;
                    b[i] = 1;
                    a[i] = j;//可有可无
                    j = 0;
                    printf(&quot;第%d号下船了\n&quot;, i);
                    i++;
                    c++;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>continue的用法,但是这题用continue反而加大了难度。直接一个if就可以了。</p>
<h1 id="经典"><a href="#经典" class="headerlink" title="经典"></a>经典</h1><p>1、将一个正整数分解质因数</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;
    int n,i;
    printf(&quot;请输入整数：&quot;);
    scanf(&quot;%d&quot;,&amp;n);
    printf(&quot;%d=&quot;,n);
    for(i=2;i&lt;=n;i++)
    &#123;
        while(n%i==0)
        &#123;
            printf(&quot;%d&quot;,i);
            n/=i;
            if(n!=1) printf(&quot;*&quot;);
        &#125;
    &#125;
    

    printf(&quot;\n&quot;);
    return 0;

&#125;</code></pre>

<h2 id="2、辗转相除法"><a href="#2、辗转相除法" class="headerlink" title="2、辗转相除法"></a>2、辗转相除法</h2><p>求两数的最大公约数和最小公倍数</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;
    int a,b,t,r,n;
    printf(&quot;请输入两个数字：\n&quot;);
    scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
    if(a&lt;b)
    &#123;t=b;b=a;a=t;&#125;
    r=a%b;
    n=a*b;
    while(r!=0)
    &#123;
        a=b;
        b=r;
        r=a%b;
    &#125;
    printf(&quot;这两个数的最大公约数是%d，最小公倍数是%d\n&quot;,b,n/b);
    

return 0;

&#125;</code></pre>

<p>3、</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>一、</strong></p>
<p>你的程序要读入一行文本，其中以空格分隔为若干个单词，以<code>.</code>结束。你要输出每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如<code>it&#39;s</code>算一个单词，长度为4。注意，行中可能出现连续的空格；最后的<code>.</code>不计算在内。</p>
<p>输入格式：</p>
<p>输入在一行中给出一行文本，以<code>.</code>结束</p>
<p>输出格式：</p>
<p>在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。</p>
<p>输入样例：</p>
<pre><code class="hljs in">It&#x27;s great to see you here.</code></pre>

<p>输出样例：</p>
<pre><code class="hljs out">4 5 2 3 3 4</code></pre>

<p>方法一.我自己的，比较规矩，不奇特</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
&#123;
	char sentence[1000];
	int i,j=0,num[100]=&#123;0&#125;,len,m=0;
	gets(sentence);
	len=strlen(sentence);
	for(i=0;i&lt;len;i++)
	&#123;
		if(sentence[i]!=&#x27; &#x27;)&#123;
			if(sentence[i]!=&#x27;.&#x27;)&#123;
			num[j]++;
			m=1;
			&#125;else break;
		&#125;
		if(sentence[i]==&#x27; &#x27;&amp;&amp;m==1)&#123;
			j++;
			m=0;
		&#125;
	&#125;
	for(i=0;i&lt;=j;i++)&#123;
		if(num[i]==0) break;
		printf(&quot;%d&quot;,num[i]);
		if(i!=j&amp;&amp;m!=0) 
			printf(&quot; &quot;);
		&#125;
	return 0;
&#125;</code></pre>

<p>方法二：新奇，简单</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
&#123;
	int i=0,t = 0;
	int k = 0;
	int s[20] = &#123; 0 &#125;;
	char arr[20];
	while (1)
	&#123;
		scanf(&quot;%s&quot;, arr);
		t = strlen(arr);
		if (arr[t - 1] == &#x27;.&#x27;)
		&#123;
			t = t-1;
			s[i]=t;
			break;
		&#125;
		s[i]=t;
		i++;	
	&#125;
	for(i=0;i&lt;20;i++)
	&#123;
		if (s[i] == 0)
			break;
		printf(&quot;%d&quot;, s[i]);
	&#125;
	return 0;
&#125;</code></pre>

<h2 id="2、"><a href="#2、" class="headerlink" title="@2、"></a>@2、</h2><p>输入一个整数（位数不超过9位）代表一个人民币值（单位为元），请转换成财务要求的大写中文格式。如23108元，转换后变成“贰万叁仟壹百零捌”元。为了简化输出，用小写英文字母a-j顺序代表大写数字0-9，用S、B、Q、W、Y分别代表拾、百、仟、万、亿。于是23108元应被转换输出为“<code>cWdQbBai</code>”元。</p>
<p>输入格式：</p>
<p>输入在一行中给出一个不超过9位的非负整数。</p>
<p>输出格式：</p>
<p>在一行中输出转换后的结果。注意“零”的用法必须符合中文习惯。</p>
<p>输入样例1：</p>
<p>813227345</p>
<p>输出样例1：</p>
<p><code>iYbQdBcScWhQdBeSf</code></p>
<p>输入样例2：</p>
<p>6900</p>
<p>输出样例2：</p>
<p><code>gQjB</code></p>
<p><strong>方法一</strong></p>
<p>123456<br>a[0]&#x3D;6<br>a[1]&#x3D;5<br>a[2]&#x3D;4<br>a[3]&#x3D;3<br>a[4]&#x3D;2<br>a[5]&#x3D;1</p>
<p>数不超过9位，则最大位亿。用数组将每一位数分解储存，然后遍历。因为十、百、千在千位、百位、十位、千万位、百万位、十万位都要输出一次。所以要余4，</p>
<p>如果余数为0，则是个位、万位或者亿位不需要输出。</p>
<p>如果余数为1，则是十位或者十万位，需要输出S。</p>
<p>如果余数为2，则是百位或者百万位，需要输出B。</p>
<p>如果余数为3，则是千位或者千万位，需要输出Q。</p>
<p>如果遍历的数为0，根据实际情况不管多少0只输出一个。</p>
<p>如果遍历的数不为0，则进行上述余4，判断余数。</p>
<p>如果数最大为亿，则输出Y</p>
<p>如果是千万、百万、十万位、则要输出W</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;
	int n,count=0;
	int num[10]=&#123;0&#125;;   //用于存放数字的每一位，要初始化为0，不然会错 
	scanf(&quot;%d&quot;,&amp;n);
	while(n)
	&#123;   //分解数字的各个位数 
		num[count++]=n%10;
		n/=10;
	&#125;
	for(int i=count-1;i&gt;=0;i--)
	&#123;
		if(num[i]!=0)
		&#123;   //不为 0 
			switch(i%4) //十、百、千 是四个一循环
			&#123;   //如果余数为 0 根据实际则不用没有后面的 
				case 0: printf(&quot;%c&quot;,num[i]+&#x27;a&#x27;); break;
				case 1: printf(&quot;%cS&quot;,num[i]+&#x27;a&#x27;); break;
				case 2: printf(&quot;%cB&quot;,num[i]+&#x27;a&#x27;); break;
				case 3: printf(&quot;%cQ&quot;,num[i]+&#x27;a&#x27;); break;
			&#125;
		&#125;
		//用于输出数字中间有多个 0 的情况，这种情况只输出一个 0 
		else if(num[i]==0&amp;&amp;num[i-1]!=0&amp;&amp;i&gt;0)
			printf(&quot;%c&quot;,num[i]+&#x27;a&#x27;);
		if(i==8)  //上亿的数输出 Y 
			printf(&quot;Y&quot;);
		//如果上十万、百万、千万、亿的则输出 W 
		else if(i==4&amp;&amp;(num[4]+num[5]+num[6]+num[7])&gt;0)
			printf(&quot;W&quot;);
	&#125;
	if(count==0)  //如果数为 0 则输出 a 
		printf(&quot;a&quot;);
	return 0;
&#125;</code></pre>

<p><strong>方法二</strong></p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
void f(int k);
void g(int k);
int main()
&#123;
	int num;
	int i;
	scanf(&quot;%d&quot;,&amp;num);
	if(num==0)
		printf(&quot;a&quot;);
	int buf[10]=&#123;0&#125;;
	int cnt=0;
	do&#123;
		buf[cnt++]=num%10;//个位数存入数组
		num/=10;//sum值改变
	&#125;while(num!=0);
	for(int i=cnt-1;i&gt;=0;i--)&#123;
		if(buf[i]!=0)&#123;
			f(buf[i]);
			g(i);
		&#125;
		if(buf[i]==0&amp;&amp;(i==8||i==4))
			g(i);
		if(buf[i]==0&amp;&amp;(i==2||i==6)&amp;&amp;buf[i-2]!=0)
			f(0);
		if(buf[i]==0&amp;&amp;(i==1||i==5)&amp;&amp;buf[i-1]!=0)
			f(0);
	&#125;
	return 0;
&#125;
void f(int k)&#123;
    switch (k)&#123;
        case 0:printf(&quot;a&quot;);
            break;
        case 1:printf(&quot;b&quot;);
            break;
        case 2:printf(&quot;c&quot;);
            break; 
        case 3:printf(&quot;d&quot;);
            break;
        case 4:printf(&quot;e&quot;);
            break;
        case 5:printf(&quot;f&quot;);
            break;
        case 6:printf(&quot;g&quot;);
            break;
        case 7:printf(&quot;h&quot;);
            break;
        case 8:printf(&quot;i&quot;);
            break;
        case 9:printf(&quot;j&quot;);
            break;
    &#125;
&#125;
void g(int k)&#123;
    switch (k)&#123;
    	case 1:printf(&quot;S&quot;);
        	break;
    	case 2:printf(&quot;B&quot;);
        	break; 
    	case 3:printf(&quot;Q&quot;);
        	break;
    	case 4:printf(&quot;W&quot;);
        	break;
    	case 5:printf(&quot;S&quot;);
        	break;
    	case 6:printf(&quot;B&quot;);	
        	break;
    	case 7:printf(&quot;Q&quot;);
        	break;
    	case 8:printf(&quot;Y&quot;);
        	break;
    	case 9:printf(&quot;S&quot;);
        	break;
	&#125;
&#125;</code></pre>

<h2 id="3、用亦或寻找单身狗数"><a href="#3、用亦或寻找单身狗数" class="headerlink" title="3、用亦或寻找单身狗数"></a>3、用亦或寻找单身狗数</h2><p>一、只有一个单身狗数</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240125161931649.png" alt="image-20240125161931649"></p>
<h2 id="4、本题要求实现一个打印非负整数阶乘的函数。"><a href="#4、本题要求实现一个打印非负整数阶乘的函数。" class="headerlink" title="4、本题要求实现一个打印非负整数阶乘的函数。"></a>4、本题要求实现一个打印非负整数阶乘的函数。</h2><p>函数接口定义：</p>
<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print_Factorial</span> <span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">int</span> N )</span></span>;</code></pre>

<p>其中<code>N</code>是用户传入的参数，其值不超过1000。如果<code>N</code>是非负整数，则该函数必须在一行中打印出<code>N</code>!的值，否则打印“Invalid input”。</p>
<p>裁判测试程序样例：</p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print_Factorial</span> <span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">int</span> N )</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> N;
    
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);
    <span class="hljs-built_in">Print_Factorial</span>(N);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* 你的代码将被嵌在这里 */</span></code></pre>

<p>输入样例：</p>
<pre><code class="hljs in">15</code></pre>

<p>输出样例：</p>
<pre><code class="hljs out">1307674368000</code></pre>

<pre><code class="hljs plaintext">void Print_Factorial(int N)
&#123;
    int a[3000];
    int temp,num,digit;           //temp：每一位的结果  num:进位   digit：结果的位数
    int i,j;
    a[0]=1;
    digit=1;                      //从第1位开始 
    if(N&gt;=0) &#123;
        for(i=2;i&lt;=N;i++)&#123;
            for(j=0;j&lt;digit;j++)&#123;
              temp=a[j]*i+num;    
              a[j]=temp%10;       //把当前位的数字存入数字 
              num=temp/10;        //向前面一位进位 
            &#125; 
            while(num)&#123;           //当现有位数算完，仍有进位，则数组需扩大 
                a[digit]=num%10;
                num/=10;
                digit++;
            &#125;
        &#125;
        for(i=digit-1;i&gt;=0;i--)&#123;
            printf(&quot;%d&quot;,a[i]);
        &#125;
    &#125;
    else printf(&quot;Invalid input&quot;);
&#125;</code></pre>

<p><strong>5、</strong>这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数<code>x</code>，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字<code>s</code>，表示<code>x</code>乘以<code>s</code>是一个光棍，第二个数字<code>n</code>是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。</p>
<p>提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除<code>x</code>为止。但难点在于，<code>s</code>可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。</p>
<p>输入格式：</p>
<p>输入在一行中给出一个不以5结尾的正奇数<code>x</code>（&lt;1000）。</p>
<p>输出格式：</p>
<p>在一行中输出相应的最小的<code>s</code>和<code>n</code>，其间以1个空格分隔。</p>
<p>输入样例：</p>
<pre><code class="hljs in">31</code></pre>

<p>输出样例：</p>
<pre><code class="hljs out">3584229390681 15</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240206211018948.png" alt="image-20240206211018948"></p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int main()
&#123;
    int N;
    scanf(&quot;%d&quot;,&amp;N);
    int i,x,n;
    i=1,n=N,x=1;
    while(n/10)
    &#123;
        n/=10;
        x+=pow(10,i);
        i++;
    &#125;
    if(N==x)
    &#123;
        printf(&quot;1 %d\n&quot;,i);
        return 0;
    &#125;
    x+=pow(10,i);   //比N多一位的光棍数 
    while(x%N)
    &#123;
        printf(&quot;%d&quot;,x/N);
        x=(x%N)*10+1;
        i++;
    &#125; 
    printf(&quot;%d %d\n&quot;,x/N,i+1);
    return 0;
&#125;</code></pre>

<p>6、</p>
<p>本题要求你实现一个稍微更值钱一点的 AI 英文问答程序，规则是：</p>
<ul>
<li>无论用户说什么，首先把对方说的话在一行中原样打印出来；</li>
<li>消除原文中多余空格：把相邻单词间的多个空格换成 1 个空格，把行首尾的空格全部删掉，把标点符号前面的空格删掉；</li>
<li>把原文中所有大写英文字母变成小写，除了 <code>I</code>；</li>
<li>把原文中所有独立的 <code>can you</code>、<code>could you</code> 对应地换成 <code>I can</code>、<code>I could</code>—— 这里“独立”是指被空格或标点符号分隔开的单词；</li>
<li>把原文中所有独立的 <code>I</code> 和 <code>me</code> 换成 <code>you</code>；</li>
<li>把原文中所有的问号 <code>?</code> 换成惊叹号 <code>!</code>；</li>
<li>在一行中输出替换后的句子作为 AI 的回答。</li>
</ul>
<p>输入格式：</p>
<p>输入首先在第一行给出不超过 10 的正整数 N，随后 N 行，每行给出一句不超过 1000 个字符的、以回车结尾的用户的对话，对话为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。</p>
<p>输出格式：</p>
<p>按题面要求输出，每个 AI 的回答前要加上 <code>AI:</code> 和一个空格。</p>
<p>输入样例：</p>
<pre><code class="hljs in">6
Hello ?
 Good to chat   with you
can   you speak Chinese?
Really?
Could you show me 5
What Is this prime? I,don &#x27;t know</code></pre>

<p>输出样例：</p>
<pre><code class="hljs out">Hello ?
AI: hello!
 Good to chat   with you
AI: good to chat with you
can   you speak Chinese?
AI: I can speak chinese!
Really?
AI: really!
Could you show me 5
AI: I could show you 5
What Is this prime? I,don &#x27;t know
AI: what Is this prime! you,don&#x27;t know</code></pre>

<p><strong>答案：</strong></p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;ctype.h&gt;
#define len 10000

void substitute(char a[][len],char* q,char* t1,char* r1,int i);
void dele(char a[][len],int i)
&#123;
    int j=0;
    int k=0;
    int count=0;
    char temp[]=&quot;  &quot;;
  /*把行首的空格全部删掉*/
     count=strlen(a[i]);
	for(;;)
	&#123;
		if(a[i][j]==&#x27; &#x27;) j++;
		else break;
	&#125;
	for(k=0;j&lt;=count;j++)
		a[i][k++]=a[i][j];
     /*把相邻单词间的多个空格换成 1 个空格*/
     for(;;)
     &#123;
         if(strstr(a[i],temp)!=NULL)
         &#123;
            for(j=(strstr(a[i],temp)-a[i]);j&lt;count;++j)
                a[i][j]=a[i][j+1];
         &#125;
         else
           break;
     &#125;
	     /*把标点符号前面的空格删掉*/
     j=0;
     for(;j&lt;count;++j)
        if(ispunct(a[i][j+1])!=0&amp;&amp;a[i][j]==32)
        &#123;
             for(k=j;k&lt;count;++k)
                a[i][k]=a[i][k+1];
             --j;
        &#125;
    /*把行尾的空格全部删掉*/
    for(;;)
    &#123;
        count=strlen(a[i]);
        if(a[i][count-1]==32)
            a[i][count-1]=0;
        else
            break;
    &#125;
    return;
&#125;
/*把原文中所有独立的can you could you 对应地换成 I can、I could—— 这里“独立”是指被空格或标点符号分隔开的单词,把原文中所有独立的 I 和 me 换成 you*/
void replace(char a[][len],int i)
&#123;
    char t1[]=&quot;can you&quot;;
    char t2[]=&quot;could you&quot;;
    char r1[]=&quot;i can&quot;;
    char r2[]=&quot;i could&quot;;
	int j=0;
	char t3[]=&quot;I&quot;;
    char t4[]=&quot;me&quot;;
    char r3[]=&quot;you&quot;;
	char *q=a[i];
	/*can you*/    
	substitute(a,a[i],t1,r1,i);

/*could you*/
substitute(a,a[i],t2,r2,i);

/*I*/
substitute(a,a[i],t3,r3,i);

/*me*/
substitute(a,a[i],t4,r3,i);

/* i变成I*/
while(strstr(a[i],r1)!=NULL)
&#123;
	q=strstr(a[i],r1);
	*q=&#x27;I&#x27;;
&#125;
/* i变成I*/
while(strstr(a[i],r2)!=NULL)
&#123;
	q=strstr(a[i],r2);
	*q=&#x27;I&#x27;;
&#125;
     /*感叹号替换*/
for(j=0;a[i][j]!=0;++j)
  if(a[i][j]==&#x27;?&#x27;)
    a[i][j]=&#x27;!&#x27;;

return;

&#125;

/*把原文中所有大写英文字母变成小写，除了 I；把原文中所有的问号 ? 换成惊叹号 !；*/
void lower(char a[][len],int i)
&#123;
    int j=0,cout;
    cout=strlen(a[i]);
    /*变小写*/
    for(j=0;j&lt;cout;++j)
      if(a[i][j]!=&#x27;I&#x27;)
         a[i][j]=tolower(a[i][j]);
    return;
&#125;

void substitute(char a[][len],char* q,char* t1,char* r1,int i)
&#123;
	char temp1[len]=&#123;0&#125;;
	int leap=0;
	int count=0;
	leap=strlen(t1);
	for(;;)
    &#123;
        if(strstr(q,t1)!=NULL)
        &#123;
            q=strstr(q,t1);
            if((isalnum(*(q-1))!=0&amp;&amp;q!=a[i])||isalnum(*(q+leap))!=0)
                q=q+leap;
            else
			&#123;
				count=q-a[i];
				strncpy(temp1,a[i],count);
				strcat(temp1,r1);
				strcat(temp1,q+leap);
				strcpy(a[i],temp1);
                memset(temp1,0,len);
			&#125;                                
		&#125;
		else
			break;
	&#125;
	return;
&#125;

int main(void)
&#123;
    char a[11][len]=&#123;0&#125;;
    int i=0;
    int n=0;

scanf(&quot;%d&quot;,&amp;n);
getchar();
for(i=0;i&lt;n;++i)
    gets(a[i]);
for(i=0;i&lt;n;++i)
&#123;
	printf(&quot;%s\n&quot;,a[i]);
	dele(a,i);
	lower(a,i);
	replace(a,i);
	printf(&quot;AI: %s\n&quot;,a[i]);
&#125;
return 0;

&#125;</code></pre>

<p>为什么要先变小写再替换呢？</p>
<p>因为英文句子中的首字母要大写，所以can I会变成Can I，按理来说此时应该回答you can的，但是C为大写，不能识别，所以要先转化为小写。</p>
<p>q&#x3D;strstr(q,t1);为什么括号里面是q呢？</p>
<p>如果是a[i]的话，那每次q赋值都会从首地址开始找，若符合了if条件，那就会陷入无限循环中，且时间消耗也会更多，所以为q 更加合理。</p>
<h1 id="题目经验"><a href="#题目经验" class="headerlink" title="题目经验"></a>题目经验</h1><p><strong>1.遇到超过范围的数可以当作字符处理</strong></p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;   
    int count[10]=&#123;0&#125;;
    char a;
    while((a=getchar())!=&#x27;\n&#x27;)
    &#123;
        count[a-&#x27;0&#x27;]++;
    &#125;
    for(int i=0;i&lt;10;i++)
    &#123;
        if(count[i]!=0)
        &#123;
            printf(&quot;%d:%d\n&quot;,i,count[i]);
        &#125;
    &#125;
    return 0;
&#125;</code></pre>

<p>可以处理1000位及以下的数；<strong>getchar</strong>的用法很巧妙</p>
<hr>
<p><strong>2、</strong></p>
<p>每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。</p>
<p><strong>输入格式：</strong></p>
<p>输入第一行给出一个正整数 <em>N</em>（≤1000），随后 <em>N</em> 行，每行给出一个考生的信息：<code>准考证号 试机座位号 考试座位号</code>。其中<code>准考证号</code>由 16 位数字组成，座位从 1 到 <em>N</em> 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。</p>
<p>考生信息之后，给出一个正整数 <em>M</em>（≤<em>N</em>），随后一行中给出 <em>M</em> 个待查询的试机座位号码，以空格分隔。</p>
<p><strong>输出格式：</strong></p>
<p>对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。</p>
<p><strong>输入样例：</strong></p>
<pre><code class="hljs in">4
3310120150912233 2 4
3310120150912119 4 1
3310120150912126 1 3
3310120150912002 3 2
2
3 4</code></pre>

<p><strong>输出样例：</strong></p>
<pre><code class="hljs out">3310120150912002 2
3310120150912119 1</code></pre>

<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
struct stu&#123;
	char zhun[17];
	int sj,ks;
&#125;;
int main()
&#123;
	struct stu a[1001];
	int i,N,M;
	scanf(&quot;%d&quot;,&amp;N);
	for(i=0;i&lt;N;i++)
	&#123;
		scanf(&quot;%s %d %d&quot;,&amp;a[0].zhun,&amp;a[0].sj ,&amp;a[0].ks );
		a[a[0].sj]=a[0];
	&#125;
	scanf(&quot;%d&quot;,&amp;N);
	for(i=0;i&lt;N;i++)
	&#123;
		scanf(&quot;%d&quot;,&amp;M);
		printf(&quot;%s %d\n&quot;,a[M].zhun ,a[M].ks );
	&#125;
	return 0;
&#125;</code></pre>

<p>struct结构可以直接赋值，但是数组不行</p>
<p>for循环里直接输入数字，就可以不用在创建一个数组，更加直接，效率更高</p>
<p>程序里面给struct结构的值赋值的仔细看</p>
<hr>
<p>**3. **int&#x2F;char a<code>[2][10]</code>&#x3D;[ [‘h’,’e’,’l’,’l’,’o’], [‘w’,’o’,’r’,’l’,’d’] ];</p>
<p>像a[1][8】这种没有存储字母的，里面存的是’0’,可以输出，%c,%d都可以，所以可以用”if a【i】【j】&#x3D;&#x3D;0”来判断当前这行的有效字符是否已经输完。</p>
<hr>
<p><strong>4、</strong></p>
<pre><code class="hljs plaintext">printf(&quot;%d=%d&quot;,i,a[0]);
           for(n=1;n&lt;=k;n++)
               printf(&quot;+%d&quot;,a[n]);
           printf(&quot;\n&quot;);</code></pre>

<p><strong>5、</strong>两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。</p>
<pre><code class="hljs plaintext">#include &lt;stdio.h&gt;
int main()
&#123;
    char i,j,k;
    for(i=&#x27;x&#x27;;i&lt;=&#x27;z&#x27;;i++) &#123;
        for(j=&#x27;x&#x27;;j&lt;=&#x27;z&#x27;;j++) &#123;
            if(i!=j) &#123;
                for(k=&#x27;x&#x27;;k&lt;=&#x27;z&#x27;;k++) &#123;
                    if(i!=k&amp;&amp;j!=k) &#123;
                        if(i!=&#x27;x&#x27;&amp;&amp;k!=&#x27;x&#x27;&amp;&amp;k!=&#x27;z&#x27;) &#123;
                            printf(&quot;顺序为：a--%c\tb--%c\tc--%c\n&quot;,i,j,k);
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;</code></pre>

<p><strong>6、</strong>两个字符数组若字符串没有完全占满数组，则后面空出来的两个数组剩余部分都相同。</p>
<p>因此要注意该程序里的<strong>m&lt;t</strong>.</p>
<p><strong>题目</strong>：输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。</p>
<p>输入格式：</p>
<p>输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。</p>
<p>输出格式：</p>
<p>在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。</p>
<p>输入样例：</p>
<pre><code class="hljs in">Tomcat is a male ccatat
cat</code></pre>

<p>输出样例：</p>
<pre><code class="hljs out">Tom is a male</code></pre>

<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
&#123;
	char a[81],b[81],i=0,t,m=0,len,c,n=1;
	gets(a);
	gets(b);
	t=strlen(b);
	len=strlen(a);
	while(n)
	&#123;
		n=0;
		for(i=0;i&lt;=len;i++)
		&#123;	
			m=0;
			if(a[i]==b[m])
			&#123;
				c=i;
				while(a[c]==b[m]&amp;&amp;m&lt;t)
				&#123;
					c++;m++;
				&#125;
			&#125;
			if(m==t)
			&#123;
				n=1;
				for(i;i&lt;=len;i++)
					a[i]=a[i+t];
				break;
			&#125;
		&#125;
	&#125;
	printf(&quot;%s&quot;,a);
	return 0;
&#125;</code></pre>

<h2 id="7、思想，旋转数组，逆置的思想"><a href="#7、思想，旋转数组，逆置的思想" class="headerlink" title="7、思想，旋转数组，逆置的思想"></a><strong>7、</strong>思想，旋转数组，逆置的思想</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240125221755975.png" alt="image-20240125221755975"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240125221716337.png" alt="image-20240125221716337"></p>
<p>第一种：写函数，相对简单一点</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240125221950701.png" alt="image-20240125221950701"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240125222037168.png" alt="image-20240125222037168"></p>
<p>第二种：不写函数，稍微麻烦一点，但不难</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240125222135444.png" alt="image-20240125222135444"></p>
<p>8、存储字符串里的单词，字符串以回车结束</p>
<pre><code class="hljs plaintext">#include&lt;stdio.h&gt;
int main()
&#123;
	char list[5][5],c;
	int i=0;
	do&#123;
		scanf(&quot;%s&quot;,list[i++]);
		c=getchar();//用c来存单词间的空格
	&#125;while(c!=&#x27;\n&#x27;);//此循环用于存储句子
	i--;
	for(i=0;i&lt;5;i++)
		printf(&quot;%s &quot;,list[i]);
    return 0;
&#125;</code></pre>

<p><strong>8、</strong>	gets 函数在读取字符串的时候<strong>会将“回车”读取为’\0’并存入数组中</strong>，所以在设置数组长度的时候最好<strong>为它预留空间</strong>，不然可能会出错。</p>
<p><strong>9、</strong>在读取数字之后，scanf 会读取到换行符，然后将其留在输入缓冲区中。然后下一个 scanf 会读取这个换行符，因为 “%c” 格式可以读取空白字符（包括空格、制表符和换行符）。这导致了不希望的结果。</p>
<p>解决方法是<strong>在 “%c” 前添加一个空格</strong>，这样可以跳过空白字符。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213204949165.png" alt="image-20240213204949165"></p>
<p><strong>10、</strong>把行尾的空格全部删掉</p>
<pre><code class="hljs plaintext">for(;;)
 &#123;
     count=strlen(a[i]);
     if(a[i][count-1]==32)
         a[i][count-1]=0;
     else
         break;
 &#125;</code></pre>



<h1 id="新的函数"><a href="#新的函数" class="headerlink" title="新的函数"></a>新的函数</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231214406.png" alt="image-20240213231214406"></p>
<h2 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a>strstr</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231317116.png" alt="image-20240213231317116"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231332778.png" alt="image-20240213231332778"></p>
<h2 id="ispunct"><a href="#ispunct" class="headerlink" title="ispunct"></a>ispunct</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231435350.png" alt="image-20240213231435350"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231503510.png" alt="image-20240213231503510"></p>
<h2 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231542438.png" alt="image-20240213231542438"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231625192.png" alt="image-20240213231625192"></p>
<h2 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231753060.png" alt="image-20240213231753060"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231809288.png" alt="image-20240213231809288"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231832523.png" alt="image-20240213231832523"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240213231921627.png" alt="image-20240213231921627"></p>
<p><strong><code>memset</code>函数可以给整型数组统一赋值0或1，其他的很有可能会出错。</strong></p>
<h2 id="tolower"><a href="#tolower" class="headerlink" title="tolower"></a>tolower</h2><p>toupper小写转大写，用法和tolower一样</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240215152206911.png" alt="image-20240215152206911"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240215152218344.png" alt="image-20240215152218344"></p>
<pre><code class="hljs plaintext">a[i][j]=tolower(a[i][j]);</code></pre>

<h2 id="strncat"><a href="#strncat" class="headerlink" title="strncat"></a>strncat</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217203955099.png" alt="image-20240217203955099"></p>
<h2 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217213347657.png" alt="image-20240217213347657"></p>
<p><strong>返回值</strong>(这个返回值应该是对的，其他的看不大懂)</p>
<p>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</p>
<pre><code class="hljs plaintext">#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main () &#123;
   char str[80] = &quot;This is - www.runoob.com - website&quot;;
   const char s[2] = &quot;-&quot;;
   char *token;

   /* 获取第一个子字符串 */
   token = strtok(str, s);

   /* 继续获取其他的子字符串 */
   while( token != NULL ) &#123;
      printf( &quot;%s\n&quot;, token );
    

      token = strtok(NULL, s);

   &#125;

   return(0);
&#125;</code></pre>

<p>结果：</p>
<pre><code class="hljs plaintext">This is 
 www.runoob.com 
 website</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217213607992.png" alt="image-20240217213607992"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217213623742.png" alt="image-20240217213623742"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217220348613.png" alt="image-20240217220348613"></p>
<h2 id="islower"><a href="#islower" class="headerlink" title="islower"></a>islower</h2><p>头文件：stype.h</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217213941826.png" alt="image-20240217213941826"></p>
<h1 id="一些网上的笔记"><a href="#一些网上的笔记" class="headerlink" title="一些网上的笔记"></a>一些网上的笔记</h1><p>1、</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216221429404.png" alt="image-20240216221429404"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216221444962.png" alt="image-20240216221444962"></p>
<p>2、</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216223851646.png" alt="image-20240216223851646"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240216223902150.png" alt="image-20240216223902150"></p>
<p>3、</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217104124564.png" alt="image-20240217104124564"></p>
<h2 id="4、移位操作符"><a href="#4、移位操作符" class="headerlink" title="4、移位操作符"></a>4、移位操作符</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217110715052.png" alt="image-20240217110715052"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217110742049.png" alt="image-20240217110742049"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217151215674.png" alt="image-20240217151215674"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217151257573.png" alt="image-20240217151257573"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217151318182.png" alt="image-20240217151318182"></p>
<p>5、</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240217152230808.png" alt="image-20240217152230808"></p>
<p>6、</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%AD%E8%A8%80/" rel="tag">语言</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Java-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/05/Java-1/" class="article-date">
  	<time datetime="2024-10-05T09:51:15.000Z" itemprop="datePublished">2024-10-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/05/Java-1/">
        Java
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>一个源文件中最多只能有一个 public 类，其它类的个数不限。</p>
<p>创建类就是class 后加 “类名字 {} ; ” 就可以了。</p>
<pre><code class="hljs plaintext">public class Hello &#123;
	//编写一个 main 方法
	public static void main(String[] args) &#123; 
		System.out.println(&quot;韩顺平教育 hello&quot;); 
	&#125; 
&#125;</code></pre>

<p>两个println之间会自动跳行，如果输出用的是print则和c语言中的printf一样。</p>
<p>&#x2F;&#x2F;对代码的相关说明<br>&#x2F;&#x2F;1. public class Hello 表示 Hello 是一个类,是一个 public 公有的类<br>&#x2F;&#x2F;2. Hello{ } 表示一个类的开始和结束<br>&#x2F;&#x2F;3. public static void main(String[] args) 表示一个主方法,即我们程序的入口<br>&#x2F;&#x2F;4. main() {} 表示方法的开始和结束<br>&#x2F;&#x2F;5. System.out.println(“hello,world<del>“); 表示输出”hello,world</del>“到屏幕</p>
<p>&#x2F;&#x2F;6. ;表示语句结束</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331162808560.png" alt="image-20240331162808560"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331162911540.png" alt="image-20240331162911540"></p>
<p>public static void main(String[] args)相当于int main()。</p>
<pre><code class="hljs plaintext">public class Dog &#123;
    //一个源文件中最多只能有一个 public 类。其它类的个数不限，也可以将 main 方法写在非 public 类中，
//然后指定运行非 public 类，这样入口方法就是非 public 的 main 方法
    public static void main(String[] args) &#123;
        System.out.println(&quot;hello, 小狗狗~&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">public class ChangeChar &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
        int n=2;
        int m=5;
        int sum = n + m;
        System.out.println(sum);
    &#125;
&#125;</code></pre>

<p>输出变量不用双引号，然后就跟c语言里一样，不能一次性输出两个变量。</p>
<p>里面定义sum，它的第一轮运算（不包括赋值）必须在定义后面接着，像上面那样，但之后的运算就和以前一样了。</p>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><pre><code class="hljs plaintext">在控制台，输入 tab 键，可以实现命令补全
\t ：一个制表位，实现对齐的功能
\n ：换行符
\\ ：一个\
\&quot; :一个&quot;
\&#x27; ：一个&#x27; 
\r :一个回车 (r前面的好像输不出来)</code></pre>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><pre><code class="hljs plaintext">public class Var02 &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//记录人的信息
        int age = 30;
        double score = 88.9;
        char gender = &#x27;男&#x27;;
        String name = &quot;king&quot;;
//输出信息, 快捷键
        System.out.println(&quot;人的信息如下:&quot;);
        System.out.println(name);
        System.out.println(age);
        System.out.println(score);
        System.out.println(gender);
    &#125;
&#125;</code></pre>

<p>输出变量不用加双引号，且两句println中自带换行；另外，可以直接命名字符串为一个变量了，string 变量名&#x3D;”字符串”。</p>
<p>String类型的变量可以直接这样赋值：s1&#x3D;new String(“abc”)，数组的赋值用法。</p>
<p>char后面可以加汉字了。</p>
<p>变量在同一个作用域中不能重名，但不同的可以。</p>
<h2 id="“-”的使用"><a href="#“-”的使用" class="headerlink" title="“+”的使用"></a>“+”的使用</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331170957715.png" alt="image-20240331170957715"></p>
<p>注意是左右两项，然后<strong>从左到右</strong>，但是加括号可以改变运算顺序。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331171207534.png" alt="image-20240331171207534"></p>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331171313736.png" alt="image-20240331171313736"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331171422444.png" alt="image-20240331171422444"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331172107978.png" alt="image-20240331172107978"></p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331172159351.png" alt="image-20240331172159351"></p>
<p><strong>细节:如果是直接查询得的的小数或者直接赋值，是可以判断相等</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331172343300.png" alt="image-20240331172343300"></p>
<pre><code class="hljs plaintext">public class FloatDetail &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//Java 的浮点型常量(具体值)默认为 double 型，声明 float 型常量，须后加‘f’或‘F&#x27; //float num1 = 1.1; //对不对?错误
        float num2 = 1.1F; //对的
        double num3 = 1.1; //对
        double num4 = 1.1f; //对
//十进制数形式：如：5.12 512.0f .512 (必须有小数点）
        double num5 = .123; //等价 0.123
        System.out.println(num5);
        //科学计数法形式:如：5.12e2 [5.12 * 10 的 2 次方 ] 5.12E-2 []
        System.out.println(5.12e2);//512.0
        System.out.println(5.12E-2);//0.0512
//通常情况下，应该使用 double 型，因为它比 float 型更精确。
//[举例说明]double num9 = 2.1234567851;float num10 = 2.1234567851F;
        double num9 = 2.1234567851;
        float num10 = 2.1234567851F;
        System.out.println(num9);
        System.out.println(num10);
//浮点数使用陷阱: 2.7 和 8.1 / 3 比较
//看看一段代码
        double num11 = 2.7;
        double num12 = 2.7; //8.1 / 3; //2.7
        System.out.println(num11);//2.7
        System.out.println(num12);//接近 2.7 的一个小数，而不是 2.7
//得到一个重要的使用点: 当我们对运算结果是小数的进行相等判断是，要小心
//应该是以两个数的差值的绝对值，在某个精度范围类判断
        if( num11 == num12) &#123;
            System.out.println(&quot;num11 == num12 相等&quot;);
        &#125;
//正确的写法 , ctrl + / 注释快捷键, 再次输入就取消注释
        if(Math.abs(num11 - num12) &lt; 0.000001 ) &#123;
            System.out.println(&quot;差值非常小，到我的规定精度，认为相等...&quot;);
        &#125;
//细节:如果是直接查询得的的小数或者直接赋值，是可以判断相等
    &#125;
&#125;</code></pre>

<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符我们用字符串 String。</p>
<p>Java里的字符对应的是 Unicode 码。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331174353745.png" alt="image-20240331174353745"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331173809136.png" alt="image-20240331173809136"></p>
<pre><code class="hljs plaintext">public class CharDetail &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//在 java 中，char 的本质是一个整数，在默认输出时，是 unicode 码对应的字符
//要输出对应的数字，可以(int)字符
        char c1 = 97;
        System.out.println(c1); // a
        char c2 = &#x27;a&#x27;; //输出&#x27;a&#x27; 对应的 数字
        System.out.println((int)c2);
        char c3 = &#x27;韩&#x27;;
        System.out.println((int)c3);//38889
        char c4 = 38889;
        System.out.println(c4);//韩
//char 类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码.
		System.out.println(&#x27;a&#x27; + 10);//107
//课堂小测试
        char c5 = &#x27;b&#x27; + 1;//98+1==&gt; 99
        System.out.println((int)c5); //99
        System.out.println(c5); //99-&gt;对应的字符-&gt;编码表 ASCII(规定好的)=&gt;c
    &#125;
&#125;</code></pre>

<h3 id="布尔类型-boolean"><a href="#布尔类型-boolean" class="headerlink" title="布尔类型 boolean"></a>布尔类型 boolean</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406104725188.png" alt="image-20240406104725188"></p>
<h2 id="查看类的使用方法"><a href="#查看类的使用方法" class="headerlink" title="查看类的使用方法"></a>查看类的使用方法</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240331173512452.png" alt="image-20240331173512452"></p>
<h2 id="基本数据类型转化"><a href="#基本数据类型转化" class="headerlink" title="基本数据类型转化"></a>基本数据类型转化</h2><h3 id="自动类型转化"><a href="#自动类型转化" class="headerlink" title="自动类型转化"></a>自动类型转化</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406105123566.png" alt="image-20240406105123566"></p>
<pre><code class="hljs plaintext">public class AutoConvertDetail &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//细节 1： 有多种类型的数据混合运算时，
//系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算
        int n1 = 10; //ok
//float d1 = n1 + 1.1;//错误 n1 + 1.1 =&gt; 结果类型是 double
//double d1 = n1 + 1.1;//对 n1 + 1.1 =&gt; 结果类型是 double
        float d1 = n1 + 1.1F;//对 n1 + 1.1 =&gt; 结果类型是 float
//细节 2: 当我们把精度(容量)大 的数据类型赋值给精度(容量)小 的数据类型时，
//就会报错，反之就会进行自动类型转换。
//
//int n2 = 1.1;//错误 double -&gt; int
//细节 3: (byte, short) 和 char 之间不会相互自动转换
//当把具体数赋给 byte 时，(1)先判断该数是否在 byte 范围内，如果是就可以
        byte b1 = 10; //对 , -128-127
// int n2 = 1; //n2 是 int
// byte b2 = n2; //错误，原因： 如果是变量赋值，判断类型
//
// char c1 = b1; //错误， 原因 byte 不能自动转成 char
//
//
//细节 4: byte，short，char 他们三者可以计算，在计算时首先转换为 int 类型
        byte b2 = 1;
        byte b3 = 2;
        short s1 = 1;
//short s2 = b2 + s1;//错, b2 + s1 =&gt; int
        int s2 = b2 + s1;//对, b2 + s1 =&gt; int
//byte b4 = b2 + b3; //错误: b2 + b3 =&gt; int
//
//boolean 不参与转换
        boolean pass = true;
//int num100 = pass;// boolean 不参与类型的自动转换
//自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型
//看一道题
        byte b4 = 1;
        short s3 = 100;
        int num200 = 1;
        float num300 = 1.1F;
        double num500 = b4 + s3 + num200 + num300; //float -&gt; double
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">int n1 = 10; //ok
//float d1 = n1 + 1.1;//错误 n1 + 1.1 =&gt; 结果类型是 double</code></pre>

<p>因为数字1.1没有定义数据类型，所以默认为double型。</p>
<h3 id="强制类型转化"><a href="#强制类型转化" class="headerlink" title="强制类型转化"></a>强制类型转化</h3><p>在将容量大的数据类型转化为容量小的数据类型时需要用到，可能会造成精度降低或溢出，和c语言中一样。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406110811133.png" alt="image-20240406110811133"></p>
<p>第4点在上面自动类型转化有提到。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406111009378.png" alt="image-20240406111009378"></p>
<h2 id="基本数据类型和String类型的转化"><a href="#基本数据类型和String类型的转化" class="headerlink" title="基本数据类型和String类型的转化"></a>基本数据类型和String类型的转化</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406111320032.png" alt="image-20240406111320032"></p>
<pre><code class="hljs plaintext">public class StringToBasic &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//基本数据类型-&gt;String
        int n1 = 100;
        float f1 = 1.1F;
        double d1 = 4.5;
        boolean b1 = true;
        String s1 = n1 + &quot;&quot;;
        String s2 = f1 + &quot;&quot;;
        String s3 = d1 + &quot;&quot;;
        String s4 = b1 + &quot;&quot;;
        System.out.println(s1 + &quot; &quot; + s2 + &quot; &quot; + s3 + &quot; &quot; + s4);
        //System.out.println(s1  + s2  + s3  + s4);这样输出字符串之间没有空格
//String-&gt;对应的基本数据类型
        String s5 = &quot;123&quot;;
//会在 OOP 讲对象和方法的时候回详细
//解读 使用 基本数据类型对应的包装类，的相应方法，得到基本数据类型
        int num1 = Integer.parseInt(s5);
        double num2 = Double.parseDouble(s5);
        float num3 = Float.parseFloat(s5);
        long num4 = Long.parseLong(s5);
        byte num5 = Byte.parseByte(s5);
        boolean b = Boolean.parseBoolean(&quot;true&quot;);
        short num6 = Short.parseShort(s5);
        System.out.println(&quot;===================&quot;);
        System.out.println(num1);//123
        System.out.println(num2);//123.0
        System.out.println(num3);//123.0
        System.out.println(num4);//123
        System.out.println(num5);//123
        System.out.println(num6);//123
        System.out.println(b);//true
//怎么把字符串转成字符 char -&gt; 含义是指 把字符串的第一个字符得到
//解读 s5.charAt(0) 得到 s5 字符串的第一个字符 &#x27;1&#x27; System.out.println(s5.charAt(0));
    &#125;
&#125;</code></pre>

<p>数据类型转化完后直接输出也可以。</p>
<pre><code class="hljs plaintext">System.out.println(s1);</code></pre>

<p>在将 String 类型转成基本数据类型时，<strong>要确保String类型可以转化为有效的数据</strong>，比如 我们可以把 “123” , 转成一 个整数，但是不能把 “hello” 转成一个整数。</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406145737348.png" alt="image-20240406145737348"></p>
<p>“&#x2F;”也有点不同，相除的数中要有小数结果才会是小数，其他与c语言一样。</p>
<pre><code class="hljs plaintext">class ArithmeticOperator &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
// /使用
        System.out.println(10 / 4); //从数学来看是 2.5, java 中 2
        System.out.println(10.0 / 4); //java 是 2.5
// 注释快捷键 ctrl + /, 再次输入 ctrl + / 取消注释
        double d = 10 / 4;//java 中 10 / 4 = 2, 2=&gt;2.0
        System.out.println(d);// 是 2.0
// % 取模 ,取余
// 在 % 的本质 看一个公式!!!! a % b = a - a / b * b
// -10 % 3 =&gt; -10 - (-10) / 3 * 3 = -10 + 9 = -1
// 10 % -3 = 10 - 10 / (-3) * (-3) = 10 - 9 = 1
// -10 % -3 = (-10) - (-10) / (-3) * (-3) = -10 + 9 = -1
        System.out.println(10 % 3); //1
        System.out.println(-10 % 3); // -1
        System.out.println(10 % -3); //1
        System.out.println(-10 % -3);//-1
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">double d = 10 / 4;//java 中 10 / 4 = 2, 2=&gt;2.0</code></pre>

<p><strong>% 的本质看一个公式!!!! a % b &#x3D; a - a &#x2F; b * b</strong></p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406153915032.png" alt="image-20240406153915032"></p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406154707308.png" alt="image-20240406154707308"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406154757093.png" alt="image-20240406154757093"></p>
<p>（1）对于**&amp;&amp;短路与**而言，如果第一个条件为 false ,<strong>后面的条件不再判断</strong> ，效率高。</p>
<p>​		对于**&amp;逻辑与**而言，如果第一个条件为 false ,<strong>后面的条件仍然会判断</strong>，效率低。</p>
<p>（2）||短路或：如果第一个条件为 true， &#x2F;&#x2F;则第二个条件不会判断，最终结果为 true，效率高。</p>
<p>​		| 逻辑或：不管第一个条件是否为 true，<strong>第二个条件都要判断</strong>，效率低。</p>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>条件表达式 <strong>?</strong> 表达式 1**:** 表达式 2**;**<br>运算规则：</p>
<pre><code>       1. 如果条件表达式为 true，运算后的结果是表达式 1；
       2. 如果条件表达式为 false，运算后的结果是表达式 2；
</code></pre>
<pre><code class="hljs plaintext">//三元运算符细节
public class TernaryOperatorDetail &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//表达式 1 和表达式 2 要为可以赋给接收变量的类型
//(或可以自动转换/或者强制转换)
        int a = 3;
        int b = 8;
        int c = a &gt; b ? (int)1.1 : (int)3.4;//可以的
        double d = a &gt; b ? a : b + 3;//可以的，满足 int -&gt; double
    &#125;
&#125;</code></pre>

<p><strong>double d &#x3D; a &gt; b ? a : b + 3;&#x2F;&#x2F;可以的，满足 int -&gt; double</strong></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240406160744093.png" alt="image-20240406160744093"></p>
<pre><code class="hljs plaintext">标识符命名规范
1) 包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm
2) 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰]
比如： TankShotGame
3) 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小
驼峰， 简称 驼峰法]
比如： tankShotGame
4) 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ
比如 ：定义一个所得税率 TAX_RATE</code></pre>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><h2 id="if-普通输入变量"><a href="#if-普通输入变量" class="headerlink" title="if+普通输入变量"></a>if+普通输入变量</h2><pre><code class="hljs plaintext">import java.util.Scanner;//导入
//if 的快速入门
public class If01 &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//编写一个程序,可以输入人的年龄,如果该同志的年龄大于 18 岁, //则输出 &quot;你年龄大于 18,要对自己的行为负责,送入监狱&quot;
//
//思路分析
//1. 接收输入的年龄, 应该定义一个 Scanner 对象
//2. 把年龄保存到一个变量 int age
//3. 使用 if 判断，输出对应信息
//应该定义一个 Scanner 对象
        Scanner myScanner = new Scanner(System.in);
        System.out.println(&quot;请输入年龄&quot;);
//把年龄保存到一个变量 int age
        int age = myScanner.nextInt();
//使用 if 判断，输出对应信息
        if(age &gt; 18) &#123;
            System.out.println(&quot;你年龄大于 18,要对自己的行为负责,送入监狱&quot;);
        &#125;
        System.out.println(&quot;程序继续...&quot;);
    &#125;
&#125;</code></pre>

<p><strong>导入语句需要放在开头。</strong></p>
<pre><code class="hljs plaintext">Scanner myScanner = new Scanner(System.in);</code></pre>

<p>myScanner可以替换成别的对象名字，然后下面的也要一起替换。</p>
<p>例：</p>
<pre><code class="hljs plaintext">import java.util.Scanner;
public class test &#123;
    public static void main(String[] args)&#123;
        Scanner two = new Scanner(System.in);
        int age =two.nextInt();
        System.out.println(age);
    &#125;
&#125;</code></pre>

<h2 id="switch-输入字符"><a href="#switch-输入字符" class="headerlink" title="switch+输入字符"></a>switch+输入字符</h2><p>第一种：switch用法和c 语言一样。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414162104595.png" alt="image-20240414162104595"></p>
<p><strong>返回值不包括小数，但包括字符串。</strong></p>
<p>第二种：</p>
<pre><code class="hljs plaintext">switch(num)&#123;
    case 1 -&gt; System.out.println(&quot;春暖花开&quot;);
    case 2 -&gt; System.out.println(&quot;夏日凉风&quot;);
    case 3 -&gt; System.out.println(&quot;秋月盈盈&quot;);
    case 4 -&gt; System.out.println(&quot;冬雪皑皑&quot;);
    default -&gt; System.out.println(&quot;季节输入非法.&quot;);
    &#125;</code></pre>

<p>第三种：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727215532534.png" alt="image-20240727215532534"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727215556763.png" alt="image-20240727215556763"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414160742794.png" alt="image-20240414160742794"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414160800080.png" alt="image-20240414160800080"></p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>和c 一样</p>
<h2 id="while和do-while"><a href="#while和do-while" class="headerlink" title="while和do while"></a>while和do while</h2><p>一样</p>
<h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><pre><code class="hljs plaintext">public class ForExercise &#123;
   public static void main(String[] args)&#123;
       Scanner myScanner = new Scanner(System.in);
       String name;
       String passwd;
       int chance = 3; //登录一次 ，就减少一次
       for( int i = 1; i &lt;= 3; i++) &#123;//3 次登录机会
           System.out.println(&quot;请输入名字&quot;);
           name = myScanner.next();
           System.out.println(&quot;请输入密码&quot;);
           passwd = myScanner.next();
//比较输入的名字和密码是否正确
//补充说明字符串 的内容 比较 使用的 方法 equals
           if(&quot;丁真&quot;.equals(name) &amp;&amp; &quot;666&quot;.equals(passwd)) &#123;
               System.out.println(&quot;恭喜你，登录成功~&quot;);
               break;
           &#125;
//登录的机会就减少一次
           chance--;
           System.out.println(&quot;你还有&quot; + chance + &quot;次登录机会&quot;);
       &#125;
   &#125;
&#125;</code></pre>

<h3 id="equal方法"><a href="#equal方法" class="headerlink" title="equal方法"></a>equal方法</h3><p>目前只知道用来比较字符串。</p>
<p><strong>格式：a字符串.equals(b字符串)</strong></p>
<p>equals()不能用于判断基本数据类型的变量。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414172133782.png" alt="image-20240414172133782"></p>
<p>x变量为基本数据类型，不能使用equals，比较的是引用类型的对象。</p>
<p>引用类型是 Java 语言中用户自定义的类型，包括类、接口、数组等。引用类型的对象是可变的，可以被修改。</p>
<p>equals针对的比较对象是引用类型， 在Java中Object对象是所有对象的父类，所以每个类都会有个equals的方法。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414173149611.png" alt="image-20240414173149611"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414173354781.png" alt="image-20240414173354781"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414174808879.png" alt="image-20240414174808879"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414174130949.png" alt="image-20240414174130949"></p>
<h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><pre><code class="hljs plaintext">(1) continue 语句用于结束本次循环，继续执行下一次循环。
(2) continue 语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 , 这个和前面的标签的
使用的规则一样.</code></pre>

<p>标签的使用</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414223450716.png" alt="image-20240414223450716"></p>
<p>break label1   跳出label1。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414223508413.png" alt="image-20240414223508413"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240414223520994.png" alt="image-20240414223520994"></p>
<p>若continue后面不加标签则和c 语言中的用法一样。</p>
<h1 id="数组，排序，查找"><a href="#数组，排序，查找" class="headerlink" title="数组，排序，查找"></a>数组，排序，查找</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><pre><code class="hljs plaintext">class ForExercise &#123;
   public static void main(String[] args)&#123;
       double[] hens = &#123;3, 5, 1, 3.4, 2, 50, 7.8, 88.8,1.1,5.6,100&#125;;
       System.out.println(&quot;===使用数组解决===&quot;);
       double totalWeight = 0;
       for( int i = 0; i &lt; hens.length; i++) &#123;
//System.out.println(&quot;第&quot; + (i+1) + &quot;个元素的值=&quot; + hens[i]);
           totalWeight += hens[i];
       &#125;
       System.out.println(&quot;总体重=&quot; + totalWeight
               + &quot;平均体重=&quot; + (totalWeight / hens.length) );
   &#125;
&#125;</code></pre>

<p><strong>一、</strong></p>
<p>直接给一个数组赋值</p>
<pre><code class="hljs plaintext">double[] hens = &#123;3, 5, 1, 3.4, 2, 50, 7.8, 88.8,1.1,5.6,100&#125;;</code></pre>

<pre><code class="hljs plaintext">double hens[] = &#123;3, 5, 1, 3.4, 2, 50, 7.8, 88.8,1.1,5.6,100&#125;;</code></pre>

<p>第二个也可以但会发出警报，不规范，最好用第一个。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416215806747.png" alt="image-20240416215806747"></p>
<p><strong>二、</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416220623063.png" alt="image-20240416220623063"></p>
<p>第四种不一定要给数组赋初值，只要规定它的大小就可以了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416225740440.png" alt="image-20240416225740440"></p>
<p>使用方法和c语言一样。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416221229472.png" alt="image-20240416221229472"></p>
<p>最好用int[] a</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416221318669.png" alt="image-20240416221318669"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416221835840.png" alt="image-20240416221835840"></p>
<p>int数组里面不能赋值字符串，所以第一行不行。</p>
<pre><code class="hljs plaintext">public class ArrayExercise01 &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
/*
创建一个 char 类型的 26 个元素的数组，分别 放置&#x27;A&#x27;-&#x27;Z&#x27;。
使用 for 循环访问所有元素并打印出来。
提示：char 类型数据运算 &#x27;A&#x27;+1 -&gt; &#x27;B&#x27; 思路分析
1. 定义一个 数组 char[] chars = new char[26]
2. 因为 &#x27;A&#x27; + 1 = &#x27;B&#x27; 类推，所以老师使用 for 来赋值
3. 使用 for 循环访问所有元素
*/
        char[] chars = new char[26];
        for( int i = 0; i &lt; chars.length; i++) &#123;//循环 26 次
//chars 是 char[]
//chars[i] 是 char
            chars[i] = (char)(&#x27;A&#x27; + i); //&#x27;A&#x27; + i 是 int , 需要强制转换
        &#125;
//循环输出
        System.out.println(&quot;===chars 数组===&quot;);
        for( int i = 0; i &lt; chars.length; i++) &#123;//循环 26 次
            System.out.print(chars[i] + &quot; &quot;);
        &#125;
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">chars[i] = (char)(&#x27;A&#x27; + i); //&#x27;A&#x27; + i 是 int , 需要强制转换</code></pre>

<p>这步和c语言中的不一样，需要强制转化，不然会出问题。char可以自动转化为int，但是int 不能自动转化char。但是如果是chars[i]&#x3D;97+i；就不需要强制转化，输出也是字符。</p>
<p>里面定义了数组chars，而chars.length就表示这个数组的长度，不用赋值。</p>
<hr>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416230046791.png" alt="image-20240416230046791"></p>
<pre><code class="hljs plaintext">class ForExercise &#123;
   public static void main(String[] args)&#123;
       int[] scores = &#123;88,99,100,92&#125;;
       int i;
       int[] number;
       number = scores;
       for(i=0;i&lt;4;i++)&#123;
           System.out.println(number[i]);
       &#125;
   &#125;
&#125;</code></pre>

<p>两个数组名可以直接相等，赋的值是地址，也就是number现在指向的就是scores数组，所以<strong>修改number数组里的值，scores数组里的值也会发生变化</strong>。<code>number = scores;</code>这句话的意思是让number指向scores的数据空间。</p>
<h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><h4 id="arraycopy"><a href="#arraycopy" class="headerlink" title="arraycopy ()"></a>arraycopy ()</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416231516983.png" alt="image-20240416231516983"></p>
<p>原数组的起始索引代表开始复制的地方，目标数组的起始索引代表开始替代的地方，<strong>起始索引是数组中的下标值</strong>。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416231543717.png" alt="image-20240416231543717"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240416231606165.png" alt="image-20240416231606165"></p>
<h4 id="copyOfRange"><a href="#copyOfRange" class="headerlink" title="copyOfRange"></a>copyOfRange</h4><p>需要引入，import java.util.Arrays;</p>
<p>Arrays.copyOfRange(int[] original, int from, int to)方法 ——-&gt;  拷贝从from(包括)到to(不包括)位置的数组</p>
<p>target &#x3D; Arrays.copyOfRange(source2,0,source2.length); target——目标数组，source2——要复制的数组。</p>
<h4 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h4><p>需要引入，import java.util.Arrays;</p>
<p>Arrays.copyOf(int[] original, int newLength)方法 ——-&gt;  截断或扩充数组（补0）</p>
<p>target &#x3D; Arrays.copyOf(source2, source2.length); target——目标数组，source2——要复制的数组。</p>
<h3 id="添加-扩容"><a href="#添加-扩容" class="headerlink" title="添加&#x2F;扩容"></a>添加&#x2F;扩容</h3><pre><code class="hljs plaintext">do &#123;
	int[] arrNew = new int[arr.length + 1];
	for(int i = 0; i &lt; arr.length; i++) &#123;
	arrNew[i] = arr[i];
    &#125;
    System.out.println(&quot;请输入你要添加的元素&quot;);
	int addNum = myScanner.nextInt();
	//把 addNum 赋给 arrNew 最后一个元素
	arrNew[arrNew.length - 1] = addNum;
	//让 arr 指向 arrNew
    arr = arrNew;
	//输出 arr 看看效果
	System.out.println(&quot;====arr 扩容后元素情况====&quot;);
	for(int i = 0; i &lt; arr.length; i++) &#123;
        System.out.print(arr[i] + &quot;\t&quot;);
	&#125;
	//问用户是否继续
    System.out.println(&quot;是否继续添加 y/n&quot;);
	char key = myScanner.next().charAt(0);
	if( key == &#x27;n&#x27;) &#123; //如果输入 n ,就结束
        break;
    &#125;
&#125;while(true);</code></pre>

<p><code>int[] arrNew = new int[arr.length + 1];</code>这句话虽然在循环当中数组名不变，但是会给它赋予新的空间，应该会导致这个数组变成一个新的数组，可参考数据结构里的赋值情况。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><pre><code class="hljs plaintext">String[] names = &#123;&quot;白眉鹰王&quot;, &quot;金毛狮王&quot;, &quot;紫衫龙王&quot;, &quot;青翼蝠王&quot;&#125;;
Scanner myScanner = new Scanner(System.in);
System.out.println(&quot;请输入名字&quot;);
String findName = myScanner.next();
//遍历数组，逐一比较，如果有，则提示信息，并退出
//这里老师给大家一个编程思想/技巧, 一个经典的方法
int index = -1;
for(int i = 0; i &lt; names.length; i++) &#123;
//比较 字符串比较 equals, 如果要找到名字就是当前元素
        if(findName.equals(names[i])) &#123;
        System.out.println(&quot;恭喜你找到 &quot; + findName);
System.out.println(&quot;下标为= &quot; + i);
//把 i 保存到 index
index = i;
break;//退出
        &#125;
	&#125;
        if(index == -1) &#123; //没有找到
        System.out.println(&quot;sorry ,没有找到 &quot; + findName);
&#125;</code></pre>

<p>这边比较字符串可直接使用equals。</p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><pre><code class="hljs plaintext">int[][] arr = &#123; 
        &#123;0, 0, 0, 0, 0, 0&#125;,
        &#123;0, 0, 1, 0, 0, 0&#125;, 
        &#123;0, 2, 0, 3, 0, 0&#125;, 
        &#123;0, 0, 0, 0, 0, 0&#125; 
&#125;;
System.out.println(&quot;二维数组的元素个数=&quot; + arr.length);
//(2) 二维数组的每个元素是一维数组, 所以如果需要得到每个一维数组的值
// 还需要再次遍历
//(3) 如果我们要访问第 (i+1)个一维数组的第 j+1 个值 arr[i][j];
// 举例 访问 3, =》 他是第 3 个一维数组的第 4 个值 arr[2][3]
System.out.println(&quot;第 3 个一维数组的第 4 个值=&quot; + arr[2][3]); //3
//输出二维图形
for(int i = 0; i &lt; arr.length; i++) &#123;//遍历二维数组的每个元素
//遍历二维数组的每个元素(数组)
//老韩解读
//1. arr[i] 表示 二维数组的第 i+1 个元素 比如 arr[0]：二维数组的第一个元素
//2. arr[i].length 得到 对应的 每个一维数组的长度
        for(int j = 0; j &lt; arr[i].length; j++) &#123;
        System.out.print(arr[i][j] + &quot; &quot;); //输出了一维数组
&#125;
        System.out.println();//换行
&#125;</code></pre>

<pre><code class="hljs plaintext">System.out.println();//换行</code></pre>

<pre><code class="hljs plaintext">System.out.println(&quot;二维数组的元素个数=&quot; + arr.length);
//(2) 二维数组的每个元素是一维数组, 所以如果需要得到每个一维数组的值
// 还需要再次遍历</code></pre>

<p><code>arr.length</code>代表的是二维数组中第一层的元素个数，也就是里面一维数组的个数。</p>
<p><code>arr[i].length</code>代表的是二维数组中的第 i+1 个一维数组中的元素个数。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421100232412.png" alt="image-20240421100232412"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421100247672.png" alt="image-20240421100247672"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421100300205.png" alt="image-20240421100300205"></p>
<p>第二种相当于是二维数组里的每个元素单独赋值，不过这边用的是“（）”而不是“{}”。</p>
<p><strong>动态初始化，当列数不确定时</strong></p>
<pre><code class="hljs plaintext">public class ForExercise &#123;
   public static void main(String[] args)&#123;
       int[][] arr = new int[3][];
       for(int i = 0; i &lt; arr.length; i++) &#123;//遍历 arr 每个一维数组
//给每个一维数组开空间 new
//如果没有给一维数组 new ,那么 arr[i]就是 null
           arr[i] = new int[i + 1];
//遍历一维数组，并给一维数组的每个元素赋值
           for(int j = 0; j &lt; arr[i].length; j++) &#123;
               arr[i][j] = i + 1;//赋值
           &#125;
       &#125;
       System.out.println(&quot;=====arr 元素=====&quot;);
//遍历 arr 输出
       for(int i = 0; i &lt; arr.length; i++) &#123;
//输出 arr 的每个一维数组
           for(int j = 0; j &lt; arr[i].length; j++) &#123;
               System.out.print(arr[i][j] + &quot; &quot;);
           &#125;
           System.out.println();//换行
       &#125;
   &#125;
&#125;</code></pre>

<p>二维数组的行数必须确认，列数可暂时不规定。</p>
<p><strong>二维数组中的每个一维数组的空间大小可以不相同。</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421101136977.png" alt="image-20240421101136977"></p>
<h1 id="面向对象编程（基础）"><a href="#面向对象编程（基础）" class="headerlink" title="面向对象编程（基础）"></a>面向对象编程（基础）</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><pre><code class="hljs plaintext">class ForExercise &#123;
   public static void main(String[] args)&#123;
       Cat cat1 = new Cat();
       cat1.name = &quot;小白&quot;;
       cat1.age = 3;
       cat1.color = &quot;白色&quot;;
       cat1.weight = 10;
//创建了第二只猫，并赋给 cat2
//cat2 也是一个对象(猫对象)
       Cat cat2 = new Cat();
       cat2.name = &quot;小花&quot;;
       cat2.age = 100;
       cat2.color = &quot;花色&quot;;
       cat2.weight = 20;
//怎么访问对象的属性呢
       System.out.println(&quot;第 1 只猫信息&quot; + cat1.name
               + &quot; &quot; + cat1.age + &quot; &quot; + cat1.color + &quot; &quot; + cat1.weight);
       System.out.println(&quot;第 2 只猫信息&quot; + cat2.name
               + &quot; &quot; + cat2.age + &quot; &quot; + cat2.color + &quot; &quot; + cat2.weight);
   &#125;
&#125;
class Cat &#123;
    //属性/成员变量
    String name; //名字
    int age; //年龄
    String color; //颜色
    double weight; //体重
//行为
&#125;</code></pre>

<pre><code class="hljs plaintext">//1. new Cat() 创建一只猫(猫对象)
//2. Cat cat1 = new Cat(); 把创建的猫赋给 cat1
//cat1就是一个对象</code></pre>

<p>对于Cat这个类的定义在程序的前面或者后面都可以，位置没有规定，只要有定义就可以。</p>
<p><strong>cat1只是对象名，new Cat()创建的对象空间（数据）才是真正的对象。</strong></p>
<h3 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421152812000.png" alt="image-20240421152812000"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421154101920.png" alt="image-20240421154101920"></p>
<h3 id="属性-成员变量-字段"><a href="#属性-成员变量-字段" class="headerlink" title="属性&#x2F;成员变量&#x2F;字段"></a>属性&#x2F;成员变量&#x2F;字段</h3><p>（1）从概念或叫法上看： 成员变量 &#x3D; 属性 &#x3D; field(字段) （即 成员变量是用来表示属性的，授课中，统一叫 属性)。</p>
<p>（2）属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)。</p>
<p>就是类的定义里的那些量。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421155237284.png" alt="image-20240421155237284"></p>
<p>有默认值，public啥的参考c++（我觉得）。</p>
<pre><code class="hljs plaintext">class Person &#123;
    //四个属性
    int age;
    String name;
    double sal;
    boolean isPass;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421155435513.png" alt="image-20240421155435513"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421160114725.png" alt="image-20240421160114725"></p>
<p>这个赋值跟数组那边的指向那个数组类似，这边<strong>修改p2里的值，p1里的值也会发生变化</strong>。</p>
<p>即<code>p2.age=12</code>这句话可以改变p2里的age但不能改变p1里的age。</p>
<h3 id="类和对象的内存分配"><a href="#类和对象的内存分配" class="headerlink" title="类和对象的内存分配"></a>类和对象的内存分配</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421161008041.png" alt="image-20240421161008041"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240421161024081.png" alt="image-20240421161024081"></p>
<p><strong>字符串属于常量</strong></p>
<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><p>即函数</p>
<pre><code class="hljs plaintext">class ForExercise &#123;
   public static void main(String[] args)&#123;
       //方法使用
//1. 方法写好后，如果不去调用(使用)，不会输出
//2. 先创建对象 ,然后调用方法即可
       Person p1 = new Person();
       p1.speak(); //调用方法
       p1.cal01(); //调用 cal01 方法
       p1.cal02(5); //调用 cal02 方法，同时给 n = 5
       p1.cal02(10); //调用 cal02 方法，同时给 n = 10
//调用 getSum 方法，同时 num1=10, num2=20
       //把 方法 getSum 返回的值，赋给 变量 returnRes
       int returnRes = p1.getSum(10, 20);
       System.out.println(&quot;getSum 方法返回的值=&quot; + returnRes);
   &#125;
&#125;
class Person &#123;
    String name;
    int age;
    //方法(成员方法)
//添加 speak 成员方法,输出 “我是一个好人”
//老韩解读
//1. public 表示方法是公开
//2. void ： 表示方法没有返回值
//3. speak() : speak 是方法名， () 形参列表
//4. &#123;&#125; 方法体，可以写我们要执行的代码
//5. System.out.println(&quot;我是一个好人&quot;); 表示我们的方法就是输出一句话
    public void speak() &#123;
        System.out.println(&quot;我是一个好人&quot;);
    &#125;
    //添加 cal01 成员方法,可以计算从 1+..+1000 的结果
    public void cal01() &#123;
//循环完成
        int res = 0;
        for(int i = 1; i &lt;= 1000; i++) &#123;
            res += i;
        &#125;
        System.out.println(&quot;cal01 方法 计算结果=&quot; + res);
    &#125;
    //添加 cal02 成员方法,该方法可以接收一个数 n，计算从 1+..+n 的结果
//老韩解读
//1. (int n) 形参列表， 表示当前有一个形参 n, 可以接收用户输入
    public void cal02(int n) &#123;
//循环完成
        int res = 0;
        for(int i = 1; i &lt;= n; i++) &#123;
            res += i;
        &#125;
        System.out.println(&quot;cal02 方法 计算结果=&quot; + res);
    &#125;
    //添加 getSum 成员方法,可以计算两个数的和
//老韩解读
//1. public 表示方法是公开的
//2. int :表示方法执行后，返回一个 int 值
//3. getSum 方法名
//4. (int num1, int num2) 形参列表，2 个形参，可以接收用户传入的两个数
//5. return res; 表示把 res 的值， 返回
    public int getSum(int num1, int num2) &#123;
        int res = num1 + num2;
        return res;
    &#125;
&#125;</code></pre>

<p>类里面的函数和c++里的一样要加上public啥的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240422104711717.png" alt="image-20240422104711717"></p>
<p>方法，接收一个二维数组</p>
<pre><code class="hljs plaintext">//方法，接收一个二维数组
public void printArr(int[][] map) &#123;
    System.out.println(&quot;=======&quot;);
//对传入的 map 数组进行遍历输出
    for(int i = 0; i &lt; map.length; i++) &#123;
        for(int j = 0; j &lt; map[i].length; j++) &#123;
            System.out.print(map[i][j] + &quot;_&quot;);
        &#125;
        System.out.println();
    &#125;
&#125;</code></pre>

<p>方法，返回一个数组</p>
<p>想要同时返回多个值，那就选择返回数组。返回的应该是数组地址。</p>
<pre><code class="hljs plaintext">int[] res = a.getSumAndSub(1, 4);
public int[] getSumAndSub(int n1, int n2) &#123;
    int[] resArr = new int[2]; //
    resArr[0] = n1 + n2;
    resArr[1] = n1 - n2;
    return resArr;
&#125;
//2. 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)</code></pre>

<pre><code class="hljs plaintext">//细节: 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型 的参数
byte b1 = 1;
byte b2 = 2;
a.getSumAndSub(b1, b2);//byte -&gt; int
//a.getSumAndSub(1.1, 1.8);//double -&gt;int(×)</code></pre>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>参数列表中的数，如果输入的数和定义的类型不同，但是可以自动转化也可以。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240422110254831.png" alt="image-20240422110254831"></p>
<pre><code class="hljs plaintext">//细节: 方法不能嵌套定义
public void f4() &#123;
//错误
// public void f5() &#123;
// &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240422110428982.png" alt="image-20240422110428982"></p>
<pre><code class="hljs plaintext">class A &#123;
    //同一个类中的方法调用：直接调用即可
//
    public void print(int n) &#123;
        System.out.println(&quot;print()方法被调用 n=&quot; + n);
    &#125;
    public void sayOk() &#123; //sayOk 调用 print(直接调用即可)
        print(10);
        System.out.println(&quot;继续执行 sayOK()~~~&quot;);
    &#125;
    //跨类中的方法 A 类调用 B 类方法：需要通过对象名调用
    public void m1() &#123;
//创建 B 对象, 然后在调用方法即可
        System.out.println(&quot;m1() 方法被调用&quot;);
        B b = new B();
        b.hi();
        System.out.println(&quot;m1() 继续执行:)&quot;);
    &#125;
&#125;
class B &#123;
    public void hi() &#123;
        System.out.println(&quot;B 类中的 hi()被执行&quot;);
    &#125;
&#125;</code></pre>

<p>跨类中的方法 A 类调用 B 类方法要先在A类中创建B对象，然后通过”对象名.方法名“调用。</p>
<h3 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h3><p>大部分和c语言中的形参，实参关系一样。</p>
<p>B 类中编写一个方法 test200，可以<strong>接收</strong>一个 Person(age,sal)<strong>对象</strong>，在方法中修改该对象属性，看看原来的对象是否变化？会变化.</p>
<pre><code class="hljs plaintext">class ForExercise &#123;
   public static void main(String[] args)&#123;
       B b=new B();
       Person p = new Person();
       p.name = &quot;jack&quot;;
       p.age = 10;
       b.test200(p);
//测试题, 如果 test200 执行的是 p = null ,下面的结果是 10
//测试题, 如果 test200 执行的是 p = new Person();..., 下面输出的是 10
       System.out.println(&quot;main 的 p.age=&quot; + p.age);//10000
   &#125;
&#125;
class Person &#123;
    String name;
    int age;
&#125;
class B &#123;
    public void test200(Person p) &#123;
		p.age = 10000; //修改对象属性
//思考
        //p = new Person();
        //p.name = &quot;tom&quot;;
        //p.age = 99;
//思考
//p = null;
    &#125;
&#125;</code></pre>

<p>在成员方法中直接修改传进来的对象属性，则外面的对象属性也会一起变化；</p>
<p>第二个是建立一个新的对象，相当于给p赋一个新的地址而不是通过p去修改属性，所以外面的p不会变化，就像c语言中想要修改传进函数中的地址时，需要双指针<code>int** a</code>这时候<code>*a</code>代表的时地址，通过修改*a才能改变外面的int *a；</p>
<p>第三个给p赋null原理和第二个一样。</p>
<pre><code class="hljs plaintext">public void test200(Person p) &#123;
   Person p2 = new Person();
   p2 = p;
   p2.age = 10000;
  &#125;</code></pre>

<p>这种方法（地址的传递）也会改变p中的值。</p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>java 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致！</p>
<p>形参列表不一致的意思是形参数量不一样或者是数量一样的情况下形参类型不一样。</p>
<p><strong>案例：</strong></p>
<p>类：MyCalculator 方法：calculate</p>
<ol>
<li>calculate(int n1, int n2) &#x2F;&#x2F;两个整数的和</li>
<li>calculate(int n1, double n2) &#x2F;&#x2F;一个整数，一个 double 的和</li>
<li>calculate(double n2, int n1)&#x2F;&#x2F;一个 double ,一个 Int 和</li>
<li>calculate(int n1, int n2,int n3)&#x2F;&#x2F;三个 int 的和</li>
</ol>
<p>若只是一个方法的访问修饰符不同，则第二个方法相当于是第一个方法的重复而不是重载。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240512102858424.png" alt="image-20240512102858424"></p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法，就可以通过可变参数实现。</p>
<p>语法：访问修饰符 返回类型 方法名(数据类型… 形参名) { }</p>
<p>例子：</p>
<p>类 HspMethod，方法 sum 【可以计算 2 个数的和，3 个数的和 ， 4. 5， 。。】</p>
<p>这题可以一个个利用方法重载写方法，或者利用可变参数。</p>
<p>方法名称相同，功能相同, 参数个数不同-&gt; 使用可变参数优化</p>
<pre><code class="hljs plaintext">class B &#123;
    //可以计算 2 个数的和，3 个数的和 ， 4. 5， 。。
    //1. int... 表示接受的是可变参数，类型是 int ,即可以接收多个 int(0-多)
//2. 使用可变参数时，可以当做数组来使用 即 nums 可以当做数组
//3. 遍历 nums 求和即可
    public int sum(int... nums) &#123;
//System.out.println(&quot;接收的参数个数=&quot; + nums.length);
        int res = 0;
        for(int i = 0; i &lt; nums.length; i++) &#123;
            res += nums[i];
        &#125;
        return res;
    &#125;
&#125;</code></pre>

<p> <code>nums.length</code>代表的是可变参数的个数；</p>
<pre><code class="hljs plaintext">HspMethod m = new HspMethod();
System.out.println(m.sum(1, 5, 100)); //106
System.out.println(m.sum(1,19)); //20</code></pre>

<p>调用还是像之前一样，方法里的nums并不需要出现在调用时的参数列表中。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240512105648039.png" alt="image-20240512105648039"></p>
<pre><code class="hljs plaintext">class VarParameterDetail &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
        //细节: 可变参数的实参可以为数组
        int[] arr = &#123;1, 2, 3&#125;;
        T t1 = new T();
        t1.f1(arr);
    &#125;
&#125;
class T &#123;
    public void f1(int... nums) &#123;
        System.out.println(&quot;长度=&quot; + nums.length);
    &#125;
    //细节: 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
    public void f2(String str, double... nums) &#123;
    &#125;
//细节: 一个形参列表中只能出现一个可变参数
//下面的写法是错的.
// public void f3(int... nums1, double... nums2) &#123;
// &#125;
&#125;</code></pre>

<p><strong>使用可变参数时，可以当做数组来使用——scores[i]</strong></p>
<pre><code class="hljs plaintext">class VarParameterExercise &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
        HspMethod hm = new HspMethod();
        System.out.println(hm.showScore(&quot;milan&quot; , 90.1, 80.0 ));
        System.out.println(hm.showScore(&quot;terry&quot; , 90.1, 80.0,10,30.5,70 ));
    &#125;
&#125;
class HspMethod &#123;
    /*
    有三个方法，分别实现返回姓名和两门课成绩(总分)，
    返回姓名和三门课成绩(总分)，返回姓名和五门课成绩（总分）。
    封装成一个可变参数的方法
    */
//分析 1. 方法名 showScore 2. 形参(String ,double... ) 3. 返回 String
//听课小伙伴，老师要求必须自己动手写
    public String showScore(String name ,double... scores ) &#123;
        double totalScore = 0;
        for(int i = 0; i &lt; scores.length; i++) &#123;
            totalScore += scores[i];
        &#125;
        return name + &quot; 有 &quot; +scores.length + &quot;门课的成绩总分为=&quot; + totalScore;
    &#125;
&#125;</code></pre>

<p><code>return name + &quot; 有 &quot; +scores.length + &quot;门课的成绩总分为=&quot; + totalScore;</code></p>
<p>返回一个字符串。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240512110945870.png" alt="image-20240512110945870"></p>
<p>这边的全局变量指的是在一个类中可以随便用的变量，而局部变量指的是在这个类中的方法中定义的变量，出了这个方法就不能使用。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240512111357129.png" alt="image-20240512111357129"></p>
<p>修饰符就是public啥的</p>
<h2 id="构造方法-构造器"><a href="#构造方法-构造器" class="headerlink" title="构造方法&#x2F;构造器"></a>构造方法&#x2F;构造器</h2><p>前面我们在创建人类的对象时，是先把一个对象创建好后，再给他的年龄和姓名属性赋值，如 果现在我要求，在创建人类的对象时，就直接指定这个对象的年龄和姓名，该怎么做? 这时就可以使用构造器。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240526095634527.png" alt="image-20240526095634527"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240526095701954.png" alt="image-20240526095701954"></p>
<pre><code class="hljs plaintext">class VarParameterExercise &#123;
    //编写一个 main 方法
    public static void main(String[] args) &#123;
//当我们 new 一个对象时，直接通过构造器指定名字和年龄
        Person p1 = new Person(&quot;smith&quot;, 80);
        System.out.println(&quot;p1 的信息如下&quot;);
        System.out.println(&quot;p1 对象 name=&quot; + p1.name);//smith
        System.out.println(&quot;p1 对象 age=&quot; + p1.age);//80
    &#125;
&#125;
//在创建人类的对象时，就直接指定这个对象的年龄和姓名
//
class Person &#123;
    String name;
    int age;

    //构造器
//老韩解读
//1. 构造器没有返回值, 也不能写 void
//2. 构造器的名称和类 Person 一样
//3. (String pName, int pAge) 是构造器形参列表，规则和成员方法一样
    public Person(String pName, int pAge) &#123;
        System.out.println(&quot;构造器被调用~~ 完成对象的属性初始化&quot;);
        name = pName;
        age = pAge;
    &#125;
&#125;</code></pre>

<p><strong>构造器没有返回值, 也不能写 void</strong></p>
<p><strong>Person p1 &#x3D; new Person(“smith”, 80);</strong></p>
<p><code>Person p1 = new Person();</code>这种形式现在就会报错了，除非显式表达一下，在下面。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240526104012922.png" alt="image-20240526104012922"></p>
<p>构造器也可以重载</p>
<pre><code class="hljs plaintext">class Dog &#123;
    //如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器(也叫默认构造器)
//使用 javap 指令 反编译看看
/*
默认构造器
Dog() &#123;
&#125;
*/
//一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，
//除非显式的定义一下,即: Dog()&#123;&#125; 写 (这点很重要)
//
    public Dog(String dName) &#123;
//... &#125;
        Dog() &#123; //显式的定义一下 无参构造器
        &#125;
    &#125;
&#125;</code></pre>

<p>无参构造器的结构体可以添加程序，如age&#x3D;3;</p>
<h2 id="对象创建的流程分析"><a href="#对象创建的流程分析" class="headerlink" title="对象创建的流程分析"></a>对象创建的流程分析</h2><p>看不懂，基础不牢，等老师讲吧</p>
<p>就是后台程序的运行顺序</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h3 id="初始理解-hashcode"><a href="#初始理解-hashcode" class="headerlink" title="初始理解+hashcode"></a>初始理解+hashcode</h3><pre><code class="hljs plaintext">class VarParameterExercise &#123;
    public static void main(String[] args) &#123;
        Dog dog1 = new Dog(&quot;大壮&quot;, 3);
        System.out.println(&quot;dog1 的 hashcode=&quot; + dog1.hashCode());
//dog1 调用了 info()方法
        dog1.info();
        System.out.println(&quot;============&quot;);
        Dog dog2 = new Dog(&quot;大黄&quot;, 2);
        System.out.println(&quot;dog2 的 hashcode=&quot; + dog2.hashCode());
        dog2.info();
    &#125;
&#125;
class Dog&#123; //类
    String name;
    int age;
// public Dog(String dName, int dAge)&#123;//构造器
// name = dName;
// age = dAge;
// &#125;
//如果我们构造器的形参，能够直接写成属性名，就更好了
//但是出现了一个问题，根据变量的作用域原则
//构造器的 name 是局部变量，而不是属性
//构造器的 age 是局部变量，而不是属性
//==&gt; 引出 this 关键字来解决
public Dog(String name, int age)&#123;//构造器
//this.name 就是当前对象的属性 name
    this.name = name;
//this.age 就是当前对象的属性 age
    this.age = age;
    System.out.println(&quot;this.hashCode=&quot; + this.hashCode());
&#125;
    public void info()&#123;//成员方法,输出属性 x 信息
        System.out.println(&quot;this.hashCode=&quot; + this.hashCode());
        System.out.println(name + &quot;\t&quot; + age + &quot;\t&quot;);
    &#125;
&#125;</code></pre>

<p>据我的理解，构造器里的name是局部变量，而this.name是属性的name。</p>
<p>this后面加的应该是属性，因为<code>this.dName</code>是错误的</p>
<p><code>dog1.info()</code> 方法和 <code>dog1.hashCode()</code> 中两者返回的哈希码是一样的，而哈希码表示的是这个东西的存储位置，因此这里的调用都针对同一个 <code>Dog</code> 对象 <code>dog1</code>。</p>
<p>this.name.hashCode输出的是属性中name的哈希码；不同对象里的name的哈希码是不同的；name是String类的，所以有哈希码。</p>
<ul>
<li>在构造器中，<code>name</code> 被赋值为 <code>dName</code>，即 <code>name = dName;</code>。</li>
<li>然后，<code>this.name</code> 和 <code>dName</code> 都引用同一个字符串对象，因为在 Java 中字符串是不可变的，并且字符串的 <code>hashCode()</code> 方法是基于字符串内容计算的。</li>
<li><code>String</code> 类的 <code>hashCode()</code> 方法返回的是<strong>基于字符串内容计算出的哈希码，而不是对象的内存地址</strong>。</li>
<li>因此，如果两个字符串对象的内容相同（如 <code>this.name</code> 和 <code>dName</code> 在这个上下文中），它们的 <code>hashCode()</code> 返回值也是相同的。</li>
<li><code>System.out.println(&quot;this.hashCode=&quot; + this.age.hashCode());</code> 这句话是错误的，因为 <code>this.age</code> 是一个基本数据类型 <code>int</code>，而基本数据类型 <code>int</code> 没有 <code>hashCode()</code> 方法。<code>hashCode()</code> 是 <code>Object</code> 类的方法，只有<strong>对象类型才有这个方法，而基本数据类型是没有的。</strong></li>
</ul>
<pre><code class="hljs plaintext">在这个 Dog 类的代码示例中，System.out.println(&quot;this.hashCode=&quot; + this.hashCode()); 被用来输出当前 Dog 对象的哈希码。哈希码是一个整数，用于唯一标识对象的引用，在某种程度上表示对象在内存中的位置。</code></pre>

<p>要理解 <code>System.out.println(&quot;this.hashCode=&quot; + this.hashCode());</code> 的作用以及输出什么，我们可以分几个部分来分析：</p>
<ol>
<li><strong><code>this.hashCode()</code> 的作用</strong>:<ul>
<li><code>this</code> 关键字指的是当前对象的引用。</li>
<li><code>hashCode()</code> 是 <code>Object</code> 类的一个方法，返回一个哈希码值，通常不同对象的哈希码值是不同的，除非 <code>hashCode()</code> 方法被重写。</li>
</ul>
</li>
<li><strong>在构造器中的 <code>System.out.println(&quot;this.hashCode=&quot; + this.hashCode());</code></strong>:<ul>
<li>当创建一个新的 <code>Dog</code> 对象时，这个构造器会被调用。</li>
<li><code>this.hashCode()</code> 会输出当前 <code>Dog</code> 对象的哈希码，帮助我们确认当前对象的内存地址（可以理解为对象的唯一标识）。</li>
</ul>
</li>
<li><strong>在 <code>info</code> 方法中的 <code>System.out.println(&quot;this.hashCode=&quot; + this.hashCode());</code></strong>:<ul>
<li>当调用 <code>info</code> 方法时，<code>this.hashCode()</code> 会再次输出当前对象的哈希码。</li>
<li>这样可以确认调用 <code>info</code> 方法的对象是哪个，验证 <code>Dog</code> 对象的哈希码。</li>
</ul>
</li>
</ol>
<h3 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h3><p>this小结：简单的说就是哪个对象被调用，this就代表哪个对象。</p>
<pre><code class="hljs plaintext">switch (key)&#123;
    case &quot;1&quot;:
        this.detail();
        break;
    case &quot;2&quot;:
        this.income();
        break;
    case &quot;3&quot;:
        this.pay();
        break;
    case &quot;4&quot;:
        this.exit();
        break;
    default:
        System.out.println(&quot;输入有误，请重新选择！&quot;);
    &#125;</code></pre>

<p>通过这样用this，可以调用这个类中的方法。</p>
<h3 id="注意和细节"><a href="#注意和细节" class="headerlink" title="注意和细节"></a>注意和细节</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240526231659923.png" alt="image-20240526231659923"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240526231714044.png" alt="image-20240526231714044"></p>
<pre><code class="hljs plaintext">class VarParameterExercise &#123;
    public static void main(String[] args) &#123;
        Person p1 = new Person(&quot;mary&quot;, 20);
        Person p2 = new Person(&quot;mary&quot;, 20);
        System.out.println(&quot;p1 和 p2 比较的结果=&quot; + p1.compareTo(p2));
    &#125;
&#125;
/*
定义 Person 类，里面有 name、age 属性，并提供 compareTo 比较方法，
用于判断是否和另一个人相等，提供测试类 TestPerson 用于测试, 名字和年龄完全一样，就返回 true, 否则返回 false
 */
class Person &#123;
    String name;
    int age;
    //构造器
    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    //compareTo 比较方法
    public boolean compareTo(Person p) &#123;
//名字和年龄完全一样
// if(this.name.equals(p.name) &amp;&amp; this.age == p.age) &#123;
// return true;
// &#125; else &#123;
// return false;
// &#125;
        return this.name.equals(p.name) &amp;&amp; this.age == p.age;
    &#125;
&#125;</code></pre>

<p><code>return this.name.equals(p.name) &amp;&amp; this.age == p.age;</code>里面的this指的是调用这个函数的对象。</p>
<p>上面第四点：例子：</p>
<p>为 Rectangle 类编写一个带参数的构造方法，通过用户给出的长、宽创建矩形对象，再 编写一个默认的构造方法，在该方法中调用有参数的构造方法</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240715200948826.png" alt="image-20240715200948826"></p>
<h1 id="面向对象编程（中级）"><a href="#面向对象编程（中级）" class="headerlink" title="面向对象编程（中级）"></a>面向对象编程（中级）</h1><h2 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h2><ol>
<li>删除当前行, 默认是 ctrl + Y 自己配置 ctrl + d</li>
<li>复制当前行, 自己配置 ctrl + alt + 向下光标</li>
<li>补全代码 alt + &#x2F;</li>
<li>添加注释和取消注释 ctrl + &#x2F; 【第一次是添加注释，第二次是取消注释】</li>
<li>导入该行需要的类 先配置 auto import , 然后使用 alt+enter 即可</li>
<li>快速格式化代码 ctrl + alt + L</li>
<li>快速运行程序 自己定义 alt + R</li>
<li>生成构造器等 alt + insert [提高开发效率]</li>
<li>查看一个类的层级关系 ctrl + H [学习继承后，非常有用]</li>
<li>将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用]</li>
<li>自动的分配变量名 , 通过 在后面加 .var [老师最喜欢的]</li>
<li>还有很多其它的快捷键…</li>
</ol>
<p>control + O 在子类中重写方法。</p>
<p>一个普通类实现接口,就必须将该接口的所有方法都实现,可以使用 alt+enter （得先将光标放于该类上）来解决。</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716104558577.png" alt="image-20240716104558577"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716105559989.png" alt="image-20240716105559989"></p>
<h3 id="引入包"><a href="#引入包" class="headerlink" title="引入包"></a>引入包</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716105745510.png" alt="image-20240716105745510"></p>
<pre><code class="hljs plaintext">package com.hspedu.pkg;
import java.util.Arrays;
//注意:
//老韩建议：我们需要使用到哪个类，就导入哪个类即可，不建议使用 *导入
//import java.util.Scanner; 表示只会引入 java.util 包下的 Scanner
//import java.util.*;//表示将 java.util 包下的所有类都引入(导入)
public class Import &#123;
    public static void main(String[] args) &#123;
//使用系统提供 Arrays 完成 数组排序
        int[] arr = &#123;-1, 20, 2, 13, 3&#125;;
//比如对其进行排序
//传统方法是，自己编写排序(冒泡)
//系统是提供了相关的类，可以方便完成 Arrays
        Arrays.sort(arr);
//输出排序结果
        for (int i = 0; i &lt; arr.length; i++) &#123;
            System.out.print(arr[i] + &quot;\t&quot;);
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="sort排序、collections、Integer"><a href="#sort排序、collections、Integer" class="headerlink" title="sort排序、collections、Integer"></a>sort排序、collections、Integer</h4><p>升序排序：首先要引入Arrays包，<code>import java.util.Arrays;</code></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716111438635.png" alt="image-20240716111438635"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716111525542.png" alt="image-20240716111525542"></p>
<p>输出应该是[5,2,9,1,3]</p>
<p>降序排序：在引入Arrays包的基础上，再引入Collections,<code>import java.util.Collections;</code></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716113303141.png" alt="image-20240716113303141"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716113759767.png" alt="image-20240716113759767"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716113811536.png" alt="image-20240716113811536"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716113833142.png" alt="image-20240716113833142"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716113915583.png" alt="image-20240716113915583"></p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716114938961.png" alt="image-20240716114938961"></p>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716152930438.png" alt="image-20240716152930438"></p>
<p>由继承得到的类叫作子类。</p>
<pre><code class="hljs plaintext">package com.hspedu.modifier;
public class A &#123;
    //四个属性,分别使用不同的访问修饰符来修饰
    public int n1 = 100;
    protected int n2 = 200;
    int n3 = 300;
    private int n4 = 400;
    public void m1() &#123;
//在同一类中，可以访问 public protected 默认 private 修饰属性和方法
        System.out.println(&quot;n1=&quot; + n1 + &quot; n2=&quot; + n2 + &quot; n3=&quot; + n3 + &quot; n4=&quot; + n4);
    &#125;
    protected void m2() &#123; &#125;
    void m3() &#123; &#125;
    private void m4() &#123; &#125;
    public void hi() &#123;
//在同一类中，可以访问 public protected 默认 private 修饰属性和方法
        m1();
        m2();
        m3();
        m4();
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.modifier;
public class B &#123;
    public void say() &#123;
        A a = new A();
//在同一个包下，可以访问 public , protected 和 默认修饰属性或方法,不能访问 private 属性或方法
        System.out.println(&quot;n1=&quot; + a.n1 + &quot; n2=&quot; + a.n2 + &quot; n3=&quot; + a.n3 );
        a.m1();
        a.m2();
        a.m3();
//a.m4(); 错误的
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.modifier;
public class Test &#123;
    public static void main(String[] args) &#123;
        A a = new A ();
        a.m1();
        B b = new B();
        b.say();
    &#125;
&#125;
//只有 默认和 public 可以修饰类
class Tiger&#123; &#125;</code></pre>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>面向对象编程有三大特征：封装、继承和多态。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716155111996.png" alt="image-20240716155111996"></p>
<pre><code class="hljs plaintext">package com.hspedu.encap;
public class a&#123;
    public static void main(String[] args)&#123;
        Person person = new Person();
        person.setName(&quot;韩顺平&quot;);
        person.setAge(30);
        person.setSalary(30000);
        System.out.println(person.info());
        System.out.println(person.getSalary());
//如果我们自己使用构造器指定属性
        Person smith = new Person(&quot;smith&quot;, 80, 50000);
        System.out.println(&quot;====smith 的信息======&quot;);
        
        System.out.println(smith.info());
    &#125;
&#125;
/*
那么在 java 中如何实现这种类似的控制呢?
请大家看一个小程序(com.hspedu.encap: Encapsulation01.java), 不能随便查看人的年龄,工资等隐私，并对设置的年龄进行合理的验证。年龄合理就设置，否则给默认
年龄, 必须在 1-120, 年龄， 工资不能直接查看 ， name 的长度在 2-6 字符 之间
*/
class Person &#123;
    public String name; //名字公开
    private int age; //age 私有化
    private double salary; //..
     public void say(int n,String name) &#123;
&#125;
//构造器 alt+insert
public Person() &#123;
&#125;
//有三个属性的构造器
public Person(String name, int age, double salary) &#123;
// this.name = name;
// this.age = age;
// this.salary = salary;
//我们可以将 set 方法写在构造器中，这样仍然可以验证
    setName(name);
    setAge(age);
    setSalary(salary);
&#125;
//自己写 setXxx 和 getXxx 太慢，我们使用快捷键
//然后根据要求来完善我们的代码.
 public String getName() &#123;
         return name;
&#125;
public void setName(String name) &#123;
//加入对数据的校验,相当于增加了业务逻辑
    if(name.length() &gt;= 2 &amp;&amp; name.length() &lt;=6 ) &#123;
        this.name = name;
    &#125;else &#123;
        System.out.println(&quot;名字的长度不对，需要(2-6)个字符，默认名字&quot;);
        this.name = &quot;无名人&quot;;
    &#125;
&#125;
public int getAge() &#123;
    return age;
&#125;
public void setAge(int age) &#123;
    //判断
    if(age &gt;= 1 &amp;&amp; age &lt;= 120) &#123;//如果是合理范围
        this.age = age;
    &#125; else &#123;
        System.out.println(&quot;你设置年龄不对，需要在 (1-120), 给默认年龄 18 &quot;);
        this.age = 18;//给一个默认年龄
    &#125;
&#125;
public double getSalary() &#123;
//可以这里增加对当前对象的权限判断
    return salary;
&#125;
public void setSalary(double salary) &#123;
    this.salary = salary;
&#125;
//写一个方法，返回属性信息
public String info() &#123;
    return &quot;信息为 name=&quot; + name + &quot; age=&quot; + age + &quot; 薪水=&quot; + salary;
&#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">smith.age = 70;//错误，因为是private,所以得用特定的方法去访问或者修改这个属性，即setName</code></pre>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716163920548.png" alt="image-20240716163920548"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716163953842.png" alt="image-20240716163953842"></p>
<p>​	继承可以跨包进行。</p>
<p>父类中private的属性子类不能直接使用。</p>
<pre><code class="hljs plaintext">package com.hspedu.extend_.improve_;
//父类,是 Pupil 和 Graduate 的父类
public class Student &#123;
    //共有属性
    public String name;
    public int age;
    private double score;//成绩
    //共有的方法
    public void setScore(double score) &#123;
        this.score = score;
    &#125;
    public void showInfo() &#123;
        System.out.println(&quot;学生名 &quot; + name + &quot; 年龄 &quot; + age + &quot; 成绩 &quot; + score);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.extend_.improve_;
//让 Pupil 继承 Student 类
public class Pupil extends Student &#123;
    public void testing() &#123;
        System.out.println(&quot;小学生 &quot; + name + &quot; 正在考小学数学..&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.extend_.improve_;

public class Graduate extends Student &#123;
    public void testing() &#123;//和 Pupil 不一样
        System.out.println(&quot;大学生 &quot; + name + &quot; 正在考大学数学..&quot;);
    &#125;
&#125;</code></pre>

<p>若和上面三个处于同一个包中，以下两句可以省略</p>
<pre><code class="hljs plaintext">import com.hspedu.extend_.improve_.Graduate;
import com.hspedu.extend_.improve_.Pupil;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.extend_.improve_;

import com.hspedu.extend_.improve_.Graduate;
import com.hspedu.extend_.improve_.Pupil;

public class Extends01 &#123;
    public static void main(String[] args) &#123;
        com.hspedu.extend_.improve_.Pupil pupil = new Pupil();
        pupil.name = &quot;银角大王~&quot;;
        pupil.age = 11;
        pupil.testing();
        pupil.setScore(50);
        pupil.showInfo();
        System.out.println(&quot;=======&quot;);
        com.hspedu.extend_.improve_.Graduate graduate = new Graduate();
        graduate.name = &quot;金角大王~&quot;;
        graduate.age = 23;
        graduate.testing();
        graduate.setScore(80);
        graduate.showInfo();
    &#125;
&#125;</code></pre>

<p>已经引进了Pupil包，<code>import com.hspedu.extend_.improve_.Pupil;</code>，那下面的<code>com.hspedu.extend_.improve_.Pupil pupil = new Pupil();</code>可以变成<code>Pupil pupil = new Pupil();</code>，Graduate那个也是一样的道理。</p>
<p>像之前的Scanner，原本的<code>Scanner input = new Scanner(System.in)</code>也可以写作<code>java.util.Scanner input = new Scanner(System.in)</code>。</p>
<p>由于上面的类定义都是public，所以也可以在别的包中使用：</p>
<pre><code class="hljs plaintext">这个所处的包

import com.hspedu.extend_.improve_.Graduate;
import com.hspedu.extend_.improve_.Pupil;

public class a &#123;
    public static void main(String[] args) &#123;
        com.hspedu.extend_.improve_.Pupil pupil = new Pupil();
        pupil.name = &quot;银角大王~&quot;;
        pupil.age = 11;
        pupil.testing();
        pupil.setScore(50);
        pupil.showInfo();
        System.out.println(&quot;=======&quot;);
        com.hspedu.extend_.improve_.Graduate graduate = new Graduate();
        graduate.name = &quot;金角大王~&quot;;
        graduate.age = 23;
        graduate.testing();
        graduate.setScore(80);
        graduate.showInfo();
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">import com.hspedu.extend_.improve_.Graduate;
import com.hspedu.extend_.improve_.Pupil;</code></pre>

<p>这两句不可以省略了，但下面的<code>com.hspedu.extend_.improve_.Pupil pupil = new Pupil();</code>在引入类后就可以变成<code>Pupil pupil = new Pupil();</code>了。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716204256473.png" alt="image-20240716204256473"></p>
<h3 id="深入讨论"><a href="#深入讨论" class="headerlink" title="深入讨论"></a>深入讨论</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716204345054.png" alt="image-20240716204345054"></p>
<p>父类没有提供无参构造器但也没提供有参构造器的时候，仍然是默认调用父类的无参构造器。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716204400577.png" alt="image-20240716204400577"></p>
<p>上面的看下面的例子都能懂，调用子类构造器，会从最顶级的父类一直往下调用，直到你调用的这个子类的构造器为止。不懂可运行下面程序。</p>
<pre><code class="hljs plaintext">package com.hspedu.extend_;

public class TopBase &#123; //父类是 Object
    public TopBase() &#123;
//super(); Object 的无参构造器
        System.out.println(&quot;构造器 TopBase() 被调用...&quot;);//1
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.extend_;

public class Base extends TopBase &#123; //父类
    //4 个属性
    public int n1 = 100;
    protected int n2 = 200;
    int n3 = 300;
    private int n4 = 400;
    public Base() &#123; //无参构造器
        System.out.println(&quot;父类 Base()构造器被调用....&quot;);
    &#125;
    public Base(String name, int age) &#123;//有参构造器
//默认 super()
        System.out.println(&quot;父类 Base(String name, int age)构造器被调用....&quot;);
    &#125;
    public Base(String name) &#123;//有参构造器
        System.out.println(&quot;父类 Base(String name)构造器被调用....&quot;);
    &#125;
    //父类提供一个 public 的方法,返回了 n4
    public int getN4() &#123;
        return n4;
    &#125;
    public void test100() &#123;
        System.out.println(&quot;test100&quot;);
    &#125;
    protected void test200() &#123;
        System.out.println(&quot;test200&quot;);
    &#125;
    void test300() &#123;
        System.out.println(&quot;test300&quot;);
    &#125;
    private void test400() &#123;
        System.out.println(&quot;test400&quot;);
    &#125;
    //call
    public void callTest400() &#123;
        test400();
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.extend_;

<span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-comment">//输入 ctrl + H 可以看到类的继承关系</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-comment">//子类</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sub</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;
<span class="hljs-comment">//1. 老师要调用父类的无参构造器, 如下或者 什么都不写,默认就是调用 super()</span>
<span class="hljs-comment">//super();//父类的无参构造器</span>
<span class="hljs-comment">//2. 老师要调用父类的 Base(String name) 构造器</span>
<span class="hljs-comment">//super(&quot;hsp&quot;);</span>
<span class="hljs-comment">//3. 老师要调用父类的 Base(String name, int age) 构造器</span>
        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;king&quot;</span>, <span class="hljs-number">20</span>);
<span class="hljs-comment">//细节： super 在使用时，必须放在构造器第一行</span>
<span class="hljs-comment">//细节: super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</span>
<span class="hljs-comment">//this() 不能再使用了</span>
        System.out.println(<span class="hljs-string">&quot;子类 Sub(String name, int age)构造器被调用....&quot;</span>);
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sub</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//无参构造器</span>
<span class="hljs-comment">//super(); //默认调用父类的无参构造器</span>
        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;smith&quot;</span>, <span class="hljs-number">10</span>);
        System.out.println(<span class="hljs-string">&quot;子类 Sub()构造器被调用....&quot;</span>);
    &#125;
    <span class="hljs-comment">//当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sub</span><span class="hljs-params">(String name)</span> &#123;
        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">30</span>);
<span class="hljs-comment">//do nothing... </span>
        System.out.println(<span class="hljs-string">&quot;子类 Sub(String name)构造器被调用....&quot;</span>);
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayOk</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//子类方法</span>
<span class="hljs-comment">//非私有的属性和方法可以在子类直接访问</span>
<span class="hljs-comment">//但是私有属性和方法不能在子类直接访问</span>
        System.out.println(n1 + <span class="hljs-string">&quot; &quot;</span> + n2 + <span class="hljs-string">&quot; &quot;</span> + n3);
        test100();
        test200();
        test300();
<span class="hljs-comment">//test400();错误</span>
<span class="hljs-comment">//要通过父类提供公共的方法去访问</span>
        System.out.println(<span class="hljs-string">&quot;n4=&quot;</span> + getN4());
        callTest400();<span class="hljs-comment">//</span>
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.extend_;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendsDetail</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
<span class="hljs-comment">// System.out.println(&quot;===第 1 个对象====&quot;);</span>
<span class="hljs-comment">// Sub sub = new Sub(); //创建了子类对象 sub</span>
<span class="hljs-comment">// System.out.println(&quot;===第 2 个对象====&quot;);</span>
<span class="hljs-comment">// Sub sub2 = new Sub(&quot;jack&quot;); //创建了子类对象 sub2</span>
        System.out.println(<span class="hljs-string">&quot;===第 3 对象====&quot;</span>);
        <span class="hljs-type">Sub</span> <span class="hljs-variable">sub3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>(<span class="hljs-string">&quot;king&quot;</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">//创建了子类对象 sub3</span>
        sub3.sayOk();
<span class="hljs-comment">//sub.sayOk();</span>
    &#125;
&#125;</code></pre>

<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716210400850.png" alt="image-20240716210400850"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240716210424127.png" alt="image-20240716210424127"></p>
<h3 id="本质分析"><a href="#本质分析" class="headerlink" title="本质分析"></a>本质分析</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717154518155.png" alt="image-20240717154518155"></p>
<pre><code class="hljs plaintext">/**
 * 讲解继承的本质
 */
public class a &#123;
    public static void main(String[] args) &#123;
        Son son = new Son();//内存的布局
//?-&gt; 这时请大家注意，要按照查找关系来返回信息
//(1) 首先看子类是否有该属性
//(2) 如果子类有这个属性，并且可以访问，则返回信息
//(3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)
//(4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object... 
        System.out.println(son.name);//返回就是大头儿子
//System.out.println(son.getAge());//返回的就是 39
        System.out.println(son.hobby);//返回的就是旅游
    &#125;
&#125;
class GrandPa &#123; //爷类
    String name = &quot;大头爷爷&quot;;
    String hobby = &quot;旅游&quot;;
&#125;
class Father extends GrandPa &#123;//父类
    String name = &quot;大头爸爸&quot;;
    private int age = 39;
    public int getAge() &#123;
        return age;
    &#125;
&#125;
class Son extends Father &#123; //子类
    String name = &quot;大头儿子&quot;;
&#125;</code></pre>

<p>看起来应该是从小到大，或者说遵循就近原则。</p>
<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>super 代表父类的引用，用于<strong>访问父类的属性、方法、构造器</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717161053557.png" alt="image-20240717161053557"></p>
<p>有的知识看前面的super。</p>
<pre><code class="hljs plaintext">super 的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用 super 去访问爷爷类的成员；
如果多个基类(上级类)中都有同名的成员，使用 super 访问遵循就近原则。A-&gt;B-&gt;C</code></pre>

<p>cal方法就是该子类或其父类中的一个方法。</p>
<pre><code class="hljs plaintext">找 cal 方法时(cal() 和 this.cal())，顺序是:
(1)先找本类，如果有，则调用
(2)如果没有，则找父类(如果有，并可以调用，则调用)
(3)如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类
提示：如果查找方法的过程中，找到了，但是不能访问， 则报错, cannot access；父类和爷类都有但是父类的不能访问，也会报错，因为遵循就近原则。
如果查找方法的过程中，没有找到，则提示方法不存在
        this.cal(); //等价 cal</code></pre>

<pre><code class="hljs plaintext">找 cal 方法(super.call()) 的顺序是直接查找父类，其他的规则一样</code></pre>

<p>n1是该子类或其父类的一个属性。</p>
<pre><code class="hljs plaintext">n1 和 this.n1 查找的规则是
(1) 先找本类，如果有，则调用
(2) 如果没有，则找父类(如果有，并可以调用，则调用)
(3) 如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类
 提示：如果查找属性的过程中，找到了，但是不能访问， 则报错, cannot access
 如果查找属性的过程中，没有找到，则提示属性不存在</code></pre>

<pre><code class="hljs plaintext">找 n1 (super.n1) 的顺序是直接查找父类属性，其他的规则一样</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717171108655.png" alt="image-20240717171108655"></p>
<p>super和this的区别</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717171138906.png" alt="image-20240717171138906"></p>
<h2 id="方法重写-覆盖"><a href="#方法重写-覆盖" class="headerlink" title="方法重写&#x2F;覆盖"></a>方法重写&#x2F;覆盖</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717171312869.png" alt="image-20240717171312869"></p>
<p>细节: 子类方法的返回类型和父类方法返回类型一样，  或者是父类返回类型的子类</p>
<p><strong>注意事项和细节</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717171717547.png" alt="image-20240717171717547"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717171807403.png" alt="image-20240717171807403"></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>介绍：方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。</p>
<p>具体表现：</p>
<p>（1）方法的多态：重写和重载</p>
<p>（2）对象的多态：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717200449840.png" alt="image-20240717200449840"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717200458838.png" alt="image-20240717200458838"></p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.poly_.objectpoly_;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;
        System.out.println(<span class="hljs-string">&quot;Animal cry() 动物在叫....&quot;</span>);
    &#125;
&#125;
<span class="hljs-keyword">package</span> com.hspedu.poly_.objectpoly_;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;
        System.out.println(<span class="hljs-string">&quot;Cat cry() 小猫喵喵叫...&quot;</span>);
    &#125;
&#125;
<span class="hljs-keyword">package</span> com.hspedu.poly_.objectpoly_;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;
        System.out.println(<span class="hljs-string">&quot;Dog cry() 小狗汪汪叫...&quot;</span>);
    &#125;
&#125;
<span class="hljs-keyword">package</span> com.hspedu.poly_.objectpoly_;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyObject</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
<span class="hljs-comment">//体验对象多态特点</span>
<span class="hljs-comment">//animal 编译类型就是 Animal , 运行类型 Dog</span>
        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();
<span class="hljs-comment">//因为运行时 , 执行到改行时，animal 运行类型是 Dog,所以 cry 就是 Dog 的 cry</span>
        animal.cry(); <span class="hljs-comment">//小狗汪汪叫</span>
<span class="hljs-comment">//animal 编译类型 Animal,运行类型就是 Cat</span>
        animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();
        animal.cry(); <span class="hljs-comment">//小猫喵喵叫</span>
    &#125;
&#125;</code></pre>

<p>多态的<strong>前提是</strong>：两个对象(类)存在继承关系。</p>
<h3 id="向上和向下转型"><a href="#向上和向下转型" class="headerlink" title="向上和向下转型"></a>向上和向下转型</h3><p>多态的向上转型</p>
<p>不能调用子类中的特有成员就是说明调用的是对父类中的方法进行重写的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717202046849.png" alt="image-20240717202046849"></p>
<p>向上转型也可以这么写：</p>
<pre><code class="hljs plaintext">Cat cat = new Cat();

Animal animal = cat;</code></pre>

<p>多态向下转型</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240717202102384.png" alt="image-20240717202102384"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240720155227537.png" alt="image-20240720155227537"></p>
<p>也可以  父类类型  引用名 &#x3D; （父类类型）父类引用，不过这样没啥用，使用方式还是和没转化前的一样，只能调用父类的东西。</p>
<pre><code class="hljs plaintext">package com.hspedu.poly_.detail_;
public class Animal &#123;
    String name = &quot;动物&quot;;
    int age = 10;
    public void sleep()&#123;
        System.out.println(&quot;睡&quot;);
    &#125;
    public void run()&#123;
        System.out.println(&quot;跑&quot;);
    &#125;
    public void eat()&#123;
        System.out.println(&quot;吃&quot;);
    &#125;
    public void show()&#123;
        System.out.println(&quot;hello,你好&quot;);
    &#125;
&#125;
package com.hspedu.poly_.detail_;
public class Cat extends Animal &#123;
    public void eat()&#123;//方法重写
        System.out.println(&quot;猫吃鱼&quot;);
    &#125;
    public void catchMouse()&#123;//Cat 特有方法
        System.out.println(&quot;猫抓老鼠&quot;);
    &#125;
&#125;
package com.hspedu.poly_.detail_;
public class Dog extends Animal &#123;//Dog 是 Animal 的子类
&#125;
package com.hspedu.poly_.detail_;
public class PolyDetail &#123;
    public static void main(String[] args) &#123;
//向上转型: 父类的引用指向了子类的对象
//语法：父类类型引用名 = new 子类类型();
    Animal animal = new Cat();
    Object obj = new Cat();//可以吗? 可以 Object 也是 Cat 的父类
//向上转型调用方法的规则如下:
//(1)可以调用父类中的所有成员(需遵守访问权限)
//(2)但是不能调用子类的特有的成员
//(#)因为在编译阶段，能调用哪些成员,是由编译类型来决定的
//animal.catchMouse();错误
//(4)最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法
//，然后调用，规则我前面我们讲的方法调用规则一致。
    animal.eat();//猫吃鱼.. animal.run();//跑
    animal.show();//hello,你好
    animal.sleep();//睡
//老师希望，可以调用 Cat 的 catchMouse 方法
//多态的向下转型
//(1)语法：子类类型 引用名 =（子类类型）父类引用;
//问一个问题? cat 的编译类型 Cat,运行类型是 Cat
    Cat cat = (Cat) animal;
    cat.catchMouse();//猫抓老鼠
//(2)要求父类的引用必须指向的是当前目标类型的对象
        Dog dog = (Dog) animal; //可以吗？不可以
        System.out.println(&quot;ok~~&quot;);
    &#125;
&#125;</code></pre>

<p><strong>属性没有重写之说,属性的值看编译类型</strong></p>
<pre><code class="hljs plaintext">package com.hspedu.poly_.detail_;
public class PolyDetail02 &#123;
    public static void main(String[] args) &#123;
//属性没有重写之说！属性的值看编译类型
        Base base = new Sub();//向上转型
        System.out.println(base.count);// ？ 看编译类型 10
        Sub sub = new Sub();
        System.out.println(sub.count);//? 20
    &#125;
&#125;
class Base &#123; //父类
    int count = 10;//属性
&#125;
class Sub extends Base &#123;//子类
    int count = 20;//属性
&#125;</code></pre>

<p><strong>instanceof 比较操作符</strong>，用于判断对象的<strong>运行类型</strong>是否为 XX 类型（后面的那个类型）或 XX 类型的子类型，</p>
<p>对象名  instanceof  类型名。</p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
        BB bb = new BB();
        System.out.println(bb instanceof BB);// true
        System.out.println(bb instanceof AA);// true
//aa 编译类型 AA, 运行类型是 BB
//BB 是 AA 子类
        AA aa = new BB();
        System.out.println(aa instanceof AA);//true
        System.out.println(aa instanceof BB);//true
        Object obj = new Object();
        System.out.println(obj instanceof AA);//false
        String str = &quot;hello&quot;;
//System.out.println(str instanceof AA);这句是错的,AA是一个类，str只是一个属性
        System.out.println(str instanceof Object);//true
    &#125;
&#125;
class AA &#123;&#125; //父类
class BB extends AA &#123;&#125;//子类</code></pre>

<h3 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240719165409567.png" alt="image-20240719165409567"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h4><p>多态数组 ： 数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。</p>
<p>应用实例:现有一个继承结构如下：要求创建 1 个 Person 对象、2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组 中，并调用每个对象 say 方法.</p>
<pre><code class="hljs plaintext">package com.hspedu.pkg;

public class Person &#123;//父类
    private String name;
    private int age;
    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    public String getName() &#123;return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public String say() &#123;//返回名字和年龄
        return name + &quot;\t&quot; + age;
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.pkg;

public class Student extends Person &#123;
    private double score;
    public Student(String name, int age, double score) &#123;
    	super(name, age);
        this.score = score;
    &#125;
    public double getScore() &#123;
        return score;
    &#125;
    public void setScore(double score) &#123;
        this.score = score;
    &#125;
    //重写父类 say
    @Override
    public String say() &#123;
        return &quot;学生 &quot; + super.say() + &quot; score=&quot; + score;
    &#125;
    //特有的方法
    public void study() &#123;
        System.out.println(&quot;学生 &quot; + getName() + &quot; 正在学 java...&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.pkg;

public class Teacher extends Person &#123;
    private double salary;
    public Teacher(String name, int age, double salary) &#123;
        super(name,age);
        this.salary = salary;
    &#125;
    public double getSalary() &#123;
        return salary;
    &#125;
    public void setSalary(double salary) &#123;
        this.salary = salary;
    &#125;
    //写重写父类的 say 方法
    @Override
    public String say() &#123;
        return &quot;老师 &quot; + super.say() + &quot; salary=&quot; + salary;
    &#125;
    //特有方法
    public void teach() &#123;
        System.out.println(&quot;老师 &quot; + getName() + &quot; 正在讲 java 课程...&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.pkg;

public class PloyArray &#123;
    public static void main(String[] args) &#123;
//应用实例:现有一个继承结构如下：要求创建 1 个 Person 对象、
// 2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组中，并调用每个对象 say 方法
        Person[] persons = new Person[5];
        persons[0] = new Person(&quot;jack&quot;, 20);
        persons[1] = new Student(&quot;mary&quot;, 18, 100);
        persons[2] = new Student(&quot;smith&quot;, 19, 30.1);
        persons[3] = new Teacher(&quot;scott&quot;, 30, 20000);
        persons[4] = new Teacher(&quot;king&quot;, 50, 25000);
//循环遍历多态数组，调用 say
        for (int i = 0; i &lt; persons.length; i++) &#123;
//老师提示: person[i] 编译类型是 Person ,运行类型是是根据实际情况由 JVM 来判断
            System.out.println(persons[i].say());//动态绑定机制
//这里大家聪明. 使用 类型判断 + 向下转型.
            if (persons[i] instanceof Student) &#123;//判断 person[i] 的运行类型是不是 Student
                Student student = (Student) persons[i];//向下转型
                student.study();
                //小伙伴也可以使用一条语句 ((Student)persons[i]).study();
            &#125; else if (persons[i] instanceof Teacher) &#123;
                Teacher teacher = (Teacher) persons[i];
                teacher.teach();
            &#125; else if (persons[i] instanceof Person) &#123;
                //System.out.println(&quot;你的类型有误, 请自己检查...&quot;);
            &#125; else &#123;
                System.out.println(&quot;你的类型有误, 请自己检查...&quot;);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>@Override：是一个伪代码，表示重写父类的方法，可以当作注释使用。</p>
<p>为什么要先判断Student：因为Student最小，<strong>先判断Teacher的话，运行类型是Student也可以通过</strong>。</p>
<pre><code class="hljs plaintext">Student student = (Student) persons[i];//向下转型
student.study();
                //小伙伴也可以使用一条语句 ((Student)persons[i]).study();</code></pre>

<h4 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240719192856826.png" alt="image-20240719192856826"></p>
<pre><code class="hljs plaintext">package com.hspedu.poly_.polyparameter_;
public class Employee &#123;
    private String name;
    private double salary;
    public Employee(String name, double salary) &#123;
        this.name = name;
        this.salary = salary;
    &#125;
    //得到年工资的方法
    public double getAnnual() &#123;
        return 12 * salary;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public double getSalary() &#123;
        return salary;
    &#125;
    public void setSalary(double salary) &#123;
        this.salary = salary;\
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.poly_.polyparameter_;
public class Manager extends Employee&#123;
    private double bonus;
    public Manager(String name, double salary, double bonus) &#123;
        super(name, salary);
        this.bonus = bonus;
    &#125;
    public double getBonus() &#123;
        return bonus;
    &#125;
    public void setBonus(double bonus) &#123;
        this.bonus = bonus;
    &#125;
    public void manage() &#123;
        System.out.println(&quot;经理 &quot; + getName() + &quot; is managing&quot;);
    &#125;
//重写获取年薪方法
    @Override
    public double getAnnual() &#123;
        return super.getAnnual() + bonus;
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.poly_.polyparameter_;
public class Worker extends Employee &#123;
    public Worker(String name, double salary) &#123;
        super(name, salary);
    &#125;
    public void work() &#123;
        System.out.println(&quot;普通员工 &quot; + getName() + &quot; is working&quot;);
    &#125;
    @Override
    public double getAnnual() &#123; //因为普通员工没有其它收入，则直接调用父类方法
        return super.getAnnual();
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">package com.hspedu.poly_.polyparameter_;
public class PloyParameter &#123;
    public static void main(String[] args) &#123;
        Worker tom = new Worker(&quot;tom&quot;, 2500);
        Manager milan = new Manager(&quot;milan&quot;, 5000, 200000);
        PloyParameter ployParameter = new PloyParameter();
        ployParameter.showEmpAnnual(tom);
        ployParameter.showEmpAnnual(milan);
        ployParameter.testWork(tom);
        ployParameter.testWork(milan);
    &#125;
    //showEmpAnnual(Employee e)
//实现获取任何员工对象的年工资,并在 main 方法中调用该方法 [e.getAnnual()]
    public void showEmpAnnual(Employee e) &#123;
        System.out.println(e.getAnnual());//动态绑定机制. &#125;
//添加一个方法，testWork,如果是普通员工，则调用 work 方法，如果是经理，则调用 manage 方法
        public void testWork(Employee e) &#123;
            if(e instanceof Worker) &#123;
                ((Worker) e).work();//有向下转型操作
            &#125; else if(e instanceof Manager) &#123;
                ((Manager) e).manage();//有向下转型操作
            &#125; else &#123;
                System.out.println(&quot;不做处理...&quot;);
            &#125;
        &#125;
    &#125;</code></pre>

<p>在主类中创建方法，然后要调用的话，需要先创建一个主类的对象，再通过这个对象进行调用。如果创建的是静态方法就不用先创建对象了，可以直接调用。</p>
<pre><code class="hljs plaintext">PloyParameter ployParameter = new PloyParameter();
        ployParameter.showEmpAnnual(tom);</code></pre>

<h2 id="Object类详解"><a href="#Object类详解" class="headerlink" title="Object类详解"></a>Object类详解</h2><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240720151522693.png" alt="image-20240720151522693"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240720151528940.png" alt="image-20240720151528940"></p>
<p>若是 对象1 equals 对象2，则是判断这两个对象的地址是否一样。</p>
<p>重写equals方法，就是直接在自己定义的类里面直接写就好了。</p>
<pre><code class="hljs plaintext">Person_ p1 = new Person_();
p1.name = &quot;hspedu&quot;;
Person_ p2 = new Person_();
p2.name = &quot;hspedu&quot;;
        System.out.println(p1==p2); //False
System.out.println(p1.name .equals( p2.name));//T
System.out.println(p1.equals(p2));//False</code></pre>

<h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode 方法"></a>hashCode 方法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240720162846185.png" alt="image-20240720162846185"></p>
<pre><code class="hljs plaintext">5 个小结:
        1) 提高具有哈希结构的容器的效率！
        2) 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！
        3) 两个引用，如果指向的是不同对象，则哈希值是不一样的
		4) 哈希值主要根据地址号来的！， 不能完全将哈希值等价于地址。
        5) 后面在集合，中 hashCode 如果需要的话，也会重写, 在讲解集合时，老韩在说如何重写 hashCode()</code></pre>

<p>对象名.hashCode()，输出该对象的哈希码。</p>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h3><p>感觉没啥大用。</p>
<pre><code class="hljs plaintext">1) 基本介绍
默认返回：全类名+@+哈希值的十六进制，【查看 Object 的 toString 方法】
子类往往重写 toString 方法，用于返回对象的属性信息
2) 重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式.
3) 当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用monster.toString()</code></pre>

<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
/*
Object 的 toString() 源码
(1)getClass().getName() 类的全类名(包名+类名 )
(2)Integer.toHexString(hashCode()) 将对象的 hashCode 值转成 16 进制字符串
public String toString() &#123;
return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
&#125;
*/
        Monster monster = new Monster(&quot;小妖怪&quot;, &quot;巡山的&quot;, 1000);
        System.out.println(monster.toString() + &quot; hashcode=&quot; + monster.hashCode());
        System.out.println(&quot;==当直接输出一个对象时，toString 方法会被默认的调用==&quot;);
        System.out.println(monster); //等价 monster.toString()
    &#125;
&#125;
class Monster &#123;
    private String name;
    private String job;
    private double sal;

    public Monster(String name, String job, double sal) &#123;
        this.name = name;
        this.job = job;
        this.sal = sal;
    &#125;

    //重写 toString 方法, 输出对象的属性
//使用快捷键即可 alt+insert -&gt; toString
    @Override
    public String toString() &#123; //重写后，一般是把对象的属性值输出，当然程序员也可以自己定制
        return &quot;Monster&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, job=&#x27;&quot; + job + &#x27;\&#x27;&#x27; +
                &quot;, sal=&quot; + sal +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用monster.toString()</code></pre>

<p><code>System.out.println(monster.toString() + &quot; hashcode=&quot; + monster.hashCode());</code>    </p>
<p>相当于   <code>System.out.println(monster + &quot; hashcode=&quot; + monster.hashCode());</code></p>
<h1 id="面向对象编程（高级）"><a href="#面向对象编程（高级）" class="headerlink" title="面向对象编程（高级）"></a>面向对象编程（高级）</h1><h2 id="类变量和类方法"><a href="#类变量和类方法" class="headerlink" title="类变量和类方法"></a>类变量和类方法</h2><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240722171151062.png" alt="image-20240722171151062"></p>
<p>就是静态变量&#x2F;全局变量，不过它是在类里面定义的。</p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
        Child child1 = new Child(&quot;白骨精&quot;);
        child1.join();
//count++;
        child1.count++;
        Child child2 = new Child(&quot;狐狸精&quot;);
        child2.join();
//count++;
        child2.count++;
        Child child3 = new Child(&quot;老鼠精&quot;);
        child3.join();
//count++;
        child3.count++;
//===========
//类变量，可以通过类名来访问
        System.out.println(&quot;共有&quot; + Child.count + &quot; 小孩加入了游戏...&quot;);
//下面的代码输出什么?
        System.out.println(&quot;child1.count=&quot; + child1.count);//3
        System.out.println(&quot;child2.count=&quot; + child2.count);//3
        System.out.println(&quot;child3.count=&quot; + child3.count);//3
    &#125;
&#125;
class Child &#123; //类
    private String name;
    //定义一个变量 count ,是一个类变量(静态变量) static 静态
//该变量最大的特点就是会被 Child 类的所有的对象实例共享
    public static int count = 0;
    public Child(String name) &#123;
        this.name = name;
    &#125;
    public void join() &#123;
        System.out.println(name + &quot; 加入了游戏..&quot;);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240722171101245.png" alt="image-20240722171101245"></p>
<p>说明：类变量是随着类的加载而创建，所以即使<strong>没有创建对象</strong>实例<strong>也可以访问</strong>。</p>
<pre><code class="hljs plaintext">public class VisitStatic &#123;
    public static void main(String[] args) &#123;
//类名.类变量名
//说明：类变量是随着类的加载而创建，所以即使没有创建对象实例也可以访问
        System.out.println(A.name);
        A a = new A();
//通过对象名.类变量名
        System.out.println(&quot;a.name=&quot; + a.name);
    &#125;
&#125;
class A &#123;
    //类变量
//类变量的访问，必须遵守 相关的访问权限. 
	public static String name = &quot;韩顺平教育&quot;;
//普通属性/普通成员变量/非静态属性/非静态成员变量/实例变量
    private int num = 10;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240722171203350.png" alt="image-20240722171203350"></p>
<p><strong>访问类变量</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240722171235698.png" alt="image-20240722171235698"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723110944904.png" alt="image-20240723110944904"></p>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723104249407.png" alt="image-20240723104249407"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723104256939.png" alt="image-20240723104256939"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723110339250.png" alt="image-20240723110339250"></p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
//创建 2 个学生对象，叫学费
        Stu tom = new Stu(&quot;tom&quot;);
//tom.payFee(100);
        Stu.payFee(100);//对不对?对
        Stu mary = new Stu(&quot;mary&quot;);
//mary.payFee(200);
        Stu.payFee(200);//对
//输出当前收到的总学费
        Stu.showFee();//300
//如果我们希望不创建实例，也可以调用某个方法(即当做工具来使用)
//这时，把方法做成静态方法时非常合适
        System.out.println(&quot;9 开平方的结果是=&quot; + Math.sqrt(9));
        System.out.println(MyTools.calSum(10, 30));
    &#125;
&#125;
//开发自己的工具类时，可以将方法做成静态的，方便调用
class MyTools &#123;
    //求出两个数的和
    public static double calSum(double n1, double n2) &#123;
        return n1 + n2;
    &#125;

    //可以写出很多这样的工具方法...
&#125;
class Stu &#123;
    private String name;//普通成员
    //定义一个静态变量，来累积学生的学费
    private static double fee = 0;

    public Stu(String name) &#123;
        this.name = name;
    &#125;

    //说明
//1. 当方法使用了 static 修饰后，该方法就是静态方法
//2. 静态方法就可以访问静态属性/变量
    public static void payFee(double fee) &#123;
        Stu.fee += fee;//累积到
    &#125;

    public static void showFee() &#123;
        System.out.println(&quot;总学费有:&quot; + Stu.fee);
    &#125;
&#125;</code></pre>

<p><code>System.out.println(&quot;9 开平方的结果是=&quot; + Math.sqrt(9));</code></p>
<pre><code class="hljs plaintext">Math.pow(double a,double b)；Math.sqrt(double a)</code></pre>

<p>上面都不需要引入类，可以直接使用。</p>
<p><strong>注意事项和细节</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723110401077.png" alt="image-20240723110401077"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723110406016.png" alt="image-20240723110406016"></p>
<p><strong>小结：记住两句话 (1) 静态方法，只能访问静态成员 (2) 非静态方法，可以访问所有的成员 (3) 在编写代码时，仍然要遵守访问权限规则。</strong></p>
<h2 id="理解main方法语法"><a href="#理解main方法语法" class="headerlink" title="理解main方法语法"></a>理解main方法语法</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723115424926.png" alt="image-20240723115424926"></p>
<ol>
<li>在 main()方法中，我们可以<strong>直接调用</strong> main 方法所在类的<strong>静态方法或静态属性</strong>； </li>
<li>但是，<strong>不能</strong>直接访问该类中的<strong>非静态成员</strong>，必须创建该类的一个实例对象后，才能<strong>通过这个对象</strong>去访问类中的非静态成员。</li>
</ol>
<pre><code class="hljs plaintext">public class Main01 &#123;
    //静态的变量/属性
    private static String name = &quot;韩顺平教育&quot;;
    //非静态的变量/属性
    private int n1 = 10000;
    //静态方法
    public static void hi() &#123;
        System.out.println(&quot;Main01 的 hi 方法&quot;);
    &#125;
    //非静态方法
    public void cry() &#123;
        System.out.println(&quot;Main01 的 cry 方法&quot;);
    &#125;
    public static void main(String[] args) &#123;
//可以直接使用 name
//1. 静态方法 main 可以访问本类的静态成员
        System.out.println(&quot;name=&quot; + name);
        hi();
//2. 静态方法 main 不可以访问本类的非静态成员
//System.out.println(&quot;n1=&quot; + n1);//错误
//cry();
//3. 静态方法 main 要访问本类的非静态成员，需要先创建对象 , 再调用即可
        Main01 main01 = new Main01();
        System.out.println(main01.n1);//ok
        main01.cry();
    &#125;
&#125;</code></pre>

<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723154528512.png" alt="image-20240723154528512"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723154851742.png" alt="image-20240723154851742"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723154929380.png" alt="image-20240723154929380"></p>
<p><strong>代码块调用的顺序优先于构造器</strong>，这样当我们不管调用哪个构造器，创建对象，都会先调用代码块的内容。</p>
<pre><code class="hljs plaintext">&#123;
    System.out.println(&quot;电影屏幕打开...&quot;);
    System.out.println(&quot;广告开始...&quot;);
    System.out.println(&quot;电影正是开始...&quot;);
&#125;;</code></pre>

<p>细节：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723155619628.png" alt="image-20240723155619628"></p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
//类被加载的情况举例
//1. 创建对象实例时(new)
// AA aa = new AA();
//2. 创建子类对象实例，父类也会被加载, 而且，父类先被加载，子类后被加载
// AA aa2 = new AA();
//3. 使用类的静态成员时(静态属性，静态方法)
// System.out.println(Cat.n1);
//static 代码块，是在类加载时，执行的，而且只会执行一次.
// DD dd = new DD();
// DD dd1 = new DD();
//普通的代码块，在创建对象实例时，会被隐式的调用。
// 被创建一次，就会调用一次。
// 如果只是使用类的静态成员时，普通代码块并不会执行
        System.out.println(DD.n1);//8888, 静态模块块一定会执行
    &#125;
&#125;
class DD &#123;
    public static int n1 = 8888;//静态属性
    //静态代码块
    static &#123;
        System.out.println(&quot;DD 的静态代码 1 被执行...&quot;);//
    &#125;
//普通代码块, 在 new 对象时，被调用，而且是每创建一个对象，就调用一次
//可以这样简单的，理解 普通代码块是构造器的补充
    &#123;
        System.out.println(&quot;DD 的普通代码块...&quot;);
    &#125;
&#125;
class Animal &#123;
    //静态代码块
    static &#123;
        System.out.println(&quot;Animal 的静态代码 1 被执行...&quot;);//
    &#125;
&#125;
class Cat extends Animal &#123;
    public static int n1 = 999;//静态属性
    //静态代码块
    static &#123;
        System.out.println(&quot;Cat 的静态代码 1 被执行...&quot;);//
    &#125;
&#125;
class BB &#123;
    //静态代码块
    static &#123;
        System.out.println(&quot;BB 的静态代码 1 被执行...&quot;);//1
    &#125;
&#125;
class AA extends BB &#123;
//静态代码块
    static &#123;
        System.out.println(&quot;AA 的静态代码 1 被执行...&quot;);//2
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">如果只是使用类的静态成员时，普通代码块并不会执行，但是静态模块会执行。

创建子类对象实例，父类也会被加载, 而且，父类先被加载，子类后被加载。</code></pre>

<p>为什么父类会先被加载，因为子类需要父类先创立子类才是完整的，是继承父类的，所以也是先调用父类的静态代码块、静态属性初始化，再调用子类的静态代码块、静态属性初始化。（下面有说明）</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723160923814.png" alt="image-20240723160923814"></p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
        A a = new A();// (1) A 静态代码块 01 (2) getN1 被调用...(3)A 普通代码块 01(4)getN2 被调用...(5)A() 构造器被调用
    &#125;
&#125;
class A &#123;
    &#123; //普通代码块
        System.out.println(&quot;A 普通代码块 01&quot;);
    &#125;
    private int n2 = getN2();//普通属性的初始化
    static &#123; //静态代码块
        System.out.println(&quot;A 静态代码块 01&quot;);
    &#125;
    //静态属性的初始化
    private static int n1 = getN1();
    public static int getN1() &#123;
        System.out.println(&quot;getN1 被调用...&quot;);
        return 100;
    &#125;
    public int getN2() &#123; //普通方法/非静态方法
        System.out.println(&quot;getN2 被调用...&quot;);
        return 200;
    &#125;
    //无参构造器
    public A() &#123;
        System.out.println(&quot;A() 构造器被调用&quot;);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723162241156.png" alt="image-20240723162241156"></p>
<p>静态相关的代码块，属性初始化，在类加载的时候就执行完毕了，是早于构造器和普通代码块的。</p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
        new BBB();//(1)AAA 的普通代码块(2)AAA() 构造器被调用(3)BBB 的普通代码块(4)BBB() 构造器被调用
    &#125;
&#125;
class AAA &#123; //父类 Object
    static&#123;
        System.out.println(&quot;AAA的静态代码块...&quot;);
    &#125;
    &#123;
        System.out.println(&quot;AAA 的普通代码块&quot;);
    &#125;
    public AAA() &#123;
//(1)super()
//(2)调用本类的普通代码块
        System.out.println(&quot;AAA() 构造器被调用....&quot;);
    &#125;
&#125;
class BBB extends AAA &#123;
    static&#123;
        System.out.println(&quot;BBB的静态代码块...&quot;);
    &#125;
    &#123;
        System.out.println(&quot;BBB 的普通代码块...&quot;);
    &#125;
    public BBB() &#123;
//(1)super()
//(2)调用本类的普通代码块
        System.out.println(&quot;BBB() 构造器被调用....&quot;);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723163738843.png" alt="image-20240723163738843"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723164003159.png" alt="image-20240723164003159"></p>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>什么是设计模式：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723173519242.png" alt="image-20240723173519242"></p>
<p>什么是单例模式：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723173836145.png" alt="image-20240723173836145"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723173846457.png" alt="image-20240723173846457"></p>
<p><strong>饿汉式</strong>单例模式：</p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
// GirlFriend xh = new GirlFriend(&quot;小红&quot;);
// GirlFriend xb = new GirlFriend(&quot;小白&quot;);
//通过方法可以获取对象
        GirlFriend instance = GirlFriend.getInstance();
        System.out.println(instance);
        GirlFriend instance2 = GirlFriend.getInstance();
        System.out.println(instance2);
        System.out.println(instance == instance2);//T
//System.out.println(GirlFriend.n1);
//...
    &#125;
&#125;
//有一个类， GirlFriend
//只能有一个女朋友
        class GirlFriend &#123;
            private String name;

            //public static int n1 = 100;
//为了能够在静态方法中，返回 gf 对象，需要将其修饰为 static
//對象，通常是重量級的對象, 餓漢式可能造成創建了對象，但是沒有使用.
            private static GirlFriend gf = new GirlFriend(&quot;小红红&quot;);
//如何保障我们只能创建一个 GirlFriend 对象
//步骤[单例模式-饿汉式]
//1. 将构造器私有化
//2. 在类的内部直接创建对象(该对象是 static)
//3. 提供一个公共的 static 方法，返回 gf 对象
            private GirlFriend(String name) &#123;
                System.out.println(&quot;構造器被調用.&quot;);
                this.name = name;
            &#125;

            public static GirlFriend getInstance() &#123;
                return gf;
            &#125;

            @Override
            public String toString() &#123;
                return &quot;GirlFriend&#123;&quot; +
                        &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                        &#x27;&#125;&#x27;;
            &#125;
        &#125;</code></pre>

<p>当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用monster.toString()。</p>
<p> <code>System.out.println(instance == instance2);//T</code>    这句说明第二次返回的gf和第一次返回的是同一个，说明了是单例。</p>
<p><strong>懒汉式</strong>单例模式：</p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args) &#123;
//new Cat(&quot;大黃&quot;);
//System.out.println(Cat.n1);
        Cat instance = Cat.getInstance();
        System.out.println(instance);
//再次調用 getInstance
        Cat instance2 = Cat.getInstance();
        System.out.println(instance2);
        System.out.println(instance == instance2);//T
    &#125;
&#125;
//希望在程序運行過程中，只能創建一個 Cat 對象
//使用單例模式
class Cat &#123;
    private String name;
    public static int n1 = 999;
    private static Cat cat ; //默認是 null
    //步驟
//1.仍然構造器私有化
//2.定義一個 static 靜態屬性對象
//3.提供一個 public 的 static 方法，可以返回一個 Cat 對象
//4.懶漢式，只有當用戶使用 getInstance 時，才返回 cat 對象, 後面再次調用時，會返回上次創建的 cat 對象
// 從而保證了單例
    private Cat(String name) &#123;
        System.out.println(&quot;構造器調用...&quot;);
        this.name = name;
    &#125;
    public static Cat getInstance() &#123;
        if(cat == null) &#123;//如果還沒有創建 cat 對象
            cat = new Cat(&quot;小可愛&quot;);
        &#125;
        return cat;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Cat&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p>饿汉式和懒汉式的区别：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240723194324191.png" alt="image-20240723194324191"></p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725094033403.png" alt="image-20240725094033403"></p>
<p>final class A { }</p>
<p>public final void hi() {}</p>
<p>public final double TAX_RATE &#x3D; 0.08;&#x2F;&#x2F;常量</p>
<p>public static final double TAX_RATE &#x3D; 99.9;</p>
<pre><code class="hljs plaintext">//当不希望某个局部变量被修改，可以使用 final 修饰
class F &#123;
    public void cry() &#123;
//这时，NUM 也称为 局部常量
        final double NUM = 0.01;
//NUM = 0.9;
        System.out.println(&quot;NUM=&quot; + NUM);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725095011997.png" alt="image-20240725095011997"></p>
<pre><code class="hljs plaintext">class AA &#123;
    /*
    1. 定义时：如 public final double TAX_RATE=0.08;
    2. 在构造器中
    3. 在代码块中
    */
    public final double TAX_RATE = 0.08;//1.定义时赋值
    public final double TAX_RATE2 ;
    public final double TAX_RATE3 ;
    public AA() &#123;//构造器中赋值
        TAX_RATE2 = 1.1;
    &#125;
    &#123;//在代码块赋值
        TAX_RATE3 = 8.8;
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725101855889.png" alt="image-20240725101855889"></p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725155654016.png" alt="image-20240725155654016"></p>
<pre><code class="hljs plaintext">abstract class Animal &#123;
    private String name;
    public Animal(String name) &#123;
        this.name = name;
    &#125;
//思考：这里 eat 这里你实现了，其实没有什么意义
//即： 父类方法不确定性的问题
//===&gt; 考虑将该方法设计为抽象(abstract)方法
//===&gt; 所谓抽象方法就是没有实现的方法
//===&gt; 所谓没有实现就是指，没有方法体
//===&gt; 当一个类中存在抽象方法时，需要将该类声明为 abstract 类
//===&gt; 一般来说，抽象类会被继承，有其子类来实现抽象方法. 
    public abstract void eat() ;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725160337428.png" alt="image-20240725160337428"></p>
<p><strong>注意事项和细节：</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725160623681.png" alt="image-20240725160623681"></p>
<pre><code class="hljs plaintext">public class AbstractDetail01 &#123;
    public static void main(String[] args) &#123;
//抽象类，不能被实例化
//new A();
    &#125;
&#125;
//抽象类不一定要包含 abstract 方法。也就是说,抽象类可以没有 abstract 方法
//，还可以有实现的方法。
abstract class A &#123;
    public void hi() &#123;
        System.out.println(&quot;hi&quot;);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725160911284.png" alt="image-20240725160911284"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725160917675.png" alt="image-20240725160917675"></p>
<pre><code class="hljs plaintext">//如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为 abstract 类
abstract class E &#123;
    public abstract void hi();
&#125;
abstract class F extends E &#123;
&#125;
class G extends E &#123;
    @Override
    public void hi() &#123; //这里相等于 G 子类实现了父类 E 的抽象方法，所谓实现方法，就是有方法体
    &#125;
&#125;</code></pre>

<p>实现就是有方法体就可以了，方法体为空也可以。</p>
<p>在子类中实现抽象方法的时候，方法的访问修饰符、类型等不变。</p>
<h2 id="抽象类最佳实践-模板设计模式"><a href="#抽象类最佳实践-模板设计模式" class="headerlink" title="抽象类最佳实践-模板设计模式"></a>抽象类最佳实践-模板设计模式</h2><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板。</p>
<p>能解决的问题：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725162340448.png" alt="image-20240725162340448"></p>
<pre><code class="hljs plaintext">abstract class Template &#123; //抽象类-模板设计模式
    public abstract void job();//抽象方法
    public void calculateTime() &#123;//实现方法，调用 job 方法
//得到开始的时间
        long start = System.currentTimeMillis();
        job(); //动态绑定机制
//得的结束的时间
        long end = System.currentTimeMillis();
        System.out.println(&quot;任务执行时间 &quot; + (end - start));
    &#125;
&#125;

class AA extends Template &#123;
    //计算任务
//1+....+ 800000
    @Override
    public void job() &#123; //实现 Template 的抽象方法 job
        long num = 0;
        for (long i = 1; i &lt;= 800000; i++) &#123;
            num += i;
        &#125;
    &#125;
&#125;

class BB extends Template&#123;
    public void job() &#123;//这里也去，重写了 Template 的 job 方法
        long num = 0;
        for (long i = 1; i &lt;= 80000; i++) &#123;
            num *= i;
        &#125;
    &#125;
&#125;

public class c&#123;
    public static void main(String[] args) &#123;
        AA aa = new AA();
        aa.calculateTime(); //这里还是需要有良好的 OOP 基础，对多态
        BB bb = new BB();
        bb.calculateTime();
    &#125;
&#125;</code></pre>

<p>为什么 aa.calculateTime()，计算的是AA里的job运行时间而不是父类里的job。</p>
<pre><code class="hljs plaintext">当 calculateTime()方法内部调用 job() 方法时，Java 虚拟机根据对象的实际类型也就是运行类型（AA 或 BB）来决定调用哪个 job() 方法。因此，aa.calculateTime() 调用的是 AA 类中的 job() 方法，而 bb.calculateTime() 调用的是 BB 类中的 job() 方法。
这是多态性的一个关键点：方法调用在运行时根据对象的实际类型绑定。
简而言之，这是因为 Java 的动态绑定机制确保在运行时调用的是子类的实现，而不是父类的声明。</code></pre>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h3><pre><code class="hljs plaintext">interface UsbInterface &#123; //接口
    //规定接口的相关方法,老师规定的.即规范...
     public void start();
    public void stop();
&#125;

class Camera implements UsbInterface&#123;//实现接口,就是把接口方法实现
    @Override
    public void start() &#123;
        System.out.println(&quot;相机开始工作...&quot;);
    &#125;
    @Override
    public void stop() &#123;
        System.out.println(&quot;相机停止工作....&quot;);
    &#125;
&#125;
//Phone 类 实现 UsbInterface
//解读 1. 即 Phone 类需要实现 sbInterface 接口 规定/声明的方法
class Phone implements UsbInterface &#123;
    @Override
    public void start() &#123;
        System.out.println(&quot;手机开始工作...&quot;);
    &#125;
    @Override
    public void stop() &#123;
        System.out.println(&quot;手机停止工作.....&quot;);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725174711688.png" alt="image-20240725174711688"></p>
<p>不难，重点是<strong>何时使用</strong>接口。</p>
<p>注意事项和细节：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725192856145.png" alt="image-20240725192856145"></p>
<pre><code class="hljs plaintext">interface IA &#123;
    void say();//修饰符 public protected 默认 private
    void hi();
&#125;
class Cat implements IA&#123;
    @Override
    public void say() &#123;
    &#125;
    @Override
    public void hi() &#123;
    &#125;
&#125;
abstract class Tiger implements IA &#123;

&#125;</code></pre>

<p>一个普通类实现接口,就必须将该接口的所有方法都实现,可以使用 alt+enter （得先将光标放于该类上）来解决。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725194357733.png" alt="image-20240725194357733"></p>
<pre><code class="hljs plaintext">public class InterfaceDetail02 &#123;
    public static void main(String[] args) &#123;
//老韩证明 接口中的属性,是 public static final
        System.out.println(IB.n1);//说明 n1 就是 static
//IB.n1 = 30; 说明 n1 是 final
    &#125;
&#125;
interface IB &#123;
    //接口中的属性,只能是 final 的，而且是 public static final 修饰符
    int n1 = 10; //等价 public static final int n1 = 10;
    void hi();
&#125;
interface IC &#123;
    void say();
&#125;
//接口不能继承其它的类,但是可以继承多个别的接口
interface ID extends IB,IC &#123;
&#125;
//接口的修饰符 只能是 public 和默认，这点和类的修饰符是一样的
interface IE&#123;&#125;
//一个类同时可以实现多个接口
class Pig implements IB,IC &#123;
    @Override
    public void hi() &#123;
    &#125;
    @Override
    public void say() &#123;
    &#125;
&#125;</code></pre>

<h3 id="接口与继承"><a href="#接口与继承" class="headerlink" title="接口与继承"></a>接口与继承</h3><p><strong>接口的静态方法不能被子接口继承，也不被实现类继承。接口的默认方法 可以被子接口和子类继承。</strong></p>
<p>接口也可以继承另一个接口，上面就有例子。</p>
<pre><code class="hljs plaintext">public class ExtendsVsInterface &#123;
    public static void main(String[] args) &#123;
        LittleMonkey wuKong = new LittleMonkey(&quot;悟空&quot;);
        wuKong.climbing();
        wuKong.swimming();
        wuKong.flying();
    &#125;
&#125;
//猴子
class Monkey &#123;
    private String name;
    public Monkey(String name) &#123;
        this.name = name;
    &#125;
    public void climbing() &#123;
        System.out.println(name + &quot; 会爬树...&quot;);
    &#125;
    public String getName() &#123;
        return name;
    &#125;
&#125;
//接口
interface Fishable &#123;
    void swimming();
&#125;
interface Birdable &#123;
    void flying();
&#125;
//继承
//小结: 当子类继承了父类，就自动的拥有父类的功能
// 如果子类需要扩展功能，可以通过实现接口的方式扩展.
// 可以理解 实现接口 是 对 java 单继承机制的一种补充.
class LittleMonkey extends Monkey implements Fishable,Birdable &#123;
    public LittleMonkey(String name) &#123;
        super(name);
    &#125;
    @Override
    public void swimming() &#123;
        System.out.println(getName() + &quot; 通过学习，可以像鱼儿一样游泳...&quot;);
    &#125;
    @Override
    public void flying() &#123;
        System.out.println(getName() + &quot; 通过学习，可以像鸟儿一样飞翔...&quot;);
    &#125;
&#125;</code></pre>

<p>一个类可以同时继承和实现多个接口：<code>class LittleMonkey extends Monkey implements Fishable,Birdable</code> </p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725194954602.png" alt="image-20240725194954602"></p>
<h3 id="接口的多态特性"><a href="#接口的多态特性" class="headerlink" title="接口的多态特性"></a>接口的多态特性</h3><p>目前看到的，除了多态参数，其它多态可以的接口也可以，比如多态数组、向上、向下转型啥的。</p>
<p><strong>向上转型：</strong></p>
<pre><code class="hljs plaintext">public class InterfacePolyParameter &#123;
    public static void main(String[] args) &#123;
//接口的多态体现
//接口类型的变量 if01 可以指向 实现了 IF 接口类的对象实例
        IF if01 = new Monster();
        if01 = new Car();
//继承体现的多态
//父类类型的变量 a 可以指向 继承 AAA 的子类的对象实例
        AAA a = new BBB();
        a = new CCC();
    &#125;
&#125;
interface IF &#123;&#125;
class Monster implements IF&#123;&#125;
class Car implements IF&#123;&#125;
class AAA &#123;
&#125;
class BBB extends AAA &#123;&#125;
class CCC extends AAA &#123;&#125;</code></pre>

<p><strong>接口类型数组，向下转型：</strong></p>
<pre><code class="hljs plaintext">public class InterfacePolyArr &#123;
    public static void main(String[] args) &#123;
//多态数组 -&gt; 接口类型数组
        Usb[] usbs = new Usb[2];
        usbs[0] = new Phone_();
        usbs[1] = new Camera_();
/*
给 Usb 数组中，存放 Phone 和 相机对象，Phone 类还有一个特有的方法 call（），
请遍历 Usb 数组，如果是 Phone 对象，除了调用 Usb 接口定义的方法外，
还需要调用 Phone 特有方法 call
*/
        for(int i = 0; i &lt; usbs.length; i++) &#123;
            usbs[i].work();//动态绑定.. //和前面一样，我们仍然需要进行类型的向下转型
            if(usbs[i] instanceof Phone_) &#123;//判断他的运行类型是 Phone_
                ((Phone_) usbs[i]).call();
            &#125;
        &#125;
    &#125;
&#125;
interface Usb&#123;
    void work();
&#125;
class Phone_ implements Usb &#123;
    public void call() &#123;
        System.out.println(&quot;手机可以打电话...&quot;);
    &#125;
    @Override
    public void work() &#123;
        System.out.println(&quot;手机工作中...&quot;);
    &#125;
&#125;
class Camera_ implements Usb &#123;
    @Override
    public void work() &#123;
        System.out.println(&quot;相机工作中...&quot;);
    &#125;
&#125;</code></pre>

<p><strong>多态传递现象（接口之间的继承）：</strong></p>
<pre><code class="hljs plaintext">public class InterfacePolyPass &#123;
    public static void main(String[] args) &#123;
//接口类型的变量可以指向实现了该接口的类的对象实例
        IG ig = new Teacher();
//如果 IG 继承了 IH 接口，而 Teacher 类实现了 IG 接口
//那么，实际上就相当于 Teacher 类也实现了 IH 接口. //这就是所谓的 接口多态传递现象. 
        IH ih = new Teacher();
    &#125;
&#125;
interface IH &#123;
    void hi();
&#125;
interface IG extends IH&#123; &#125;
class Teacher implements IG &#123;
    @Override
    public void hi() &#123;
    &#125;
&#125;</code></pre>

<p>一道题：</p>
<pre><code class="hljs plaintext">public class InterfaceExercise02 &#123;
    public static void main(String[] args) &#123;
    &#125;
&#125;
interface A &#123; // 1min 看看
    int x = 0;
&#125; //想到 等价 public static final int x = 0;
class B &#123;
    int x = 1;
&#125; //普通属性
class C extends B implements A &#123;
    public void pX() &#123;
//System.out.println(x); //错误，原因不明确 x
//可以明确的指定 x
//访问接口的 x 就使用 A.x
//访问父类的 x 就使用 super.x
        System.out.println(A.x + &quot; &quot; + super.x);
    &#125;
    public static void main(String[] args) &#123;
        new C().pX();
    &#125;
&#125;</code></pre>

<p><code>class C extends B implements A</code>这句是对的，没有语法错误。</p>
<p>如何区分X:</p>
<pre><code class="hljs plaintext">//访问接口的 x 就使用 A.x
//访问父类的 x 就使用 super.x</code></pre>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果定义类在局部位置(方法中&#x2F;代码块) :(1) 局部内部类 (2) 匿名内部类 。</p>
<p>定义在成员位置 (1) 成员内部类 (2) 静态内部类。</p>
<p><strong>基本介绍：</strong><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725213723566.png" alt="image-20240725213723566"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725213754328.png" alt="image-20240725213754328"></p>
<p><strong>分类：</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725213940513.png" alt="image-20240725213940513"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>可以参考局部变量</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725214604330.png" alt="image-20240725214604330"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725214609681.png" alt="image-20240725214609681"></p>
<pre><code class="hljs plaintext">public class c&#123;//
    public static void main(String[] args) &#123;
//演示一遍
        Outer02 outer02 = new Outer02();
        outer02.m1();
        System.out.println(&quot;outer02 的 hashcode=&quot; + outer02);
    &#125;
&#125;
class Outer02 &#123;//外部类
    private int n1 = 100;
    private void m2() &#123;
        System.out.println(&quot;Outer02 m2()&quot;);
    &#125;//私有方法
    public void m1() &#123;//方法
//1.局部内部类是定义在外部类的局部位置,通常在方法
//3.不能添加访问修饰符,但是可以使用 final 修饰
//4.作用域 : 仅仅在定义它的方法或代码块中
        final class Inner02 &#123;//局部内部类(本质仍然是一个类)
//2.可以直接访问外部类的所有成员，包含私有的
            private int n1 = 800;
            public void f1() &#123;
//5. 局部内部类可以直接访问外部类的成员，比如下面 外部类 n1 和 m2()
//7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，
// 使用 外部类名.this.成员）去访问
// 老韩解读 Outer02.this 本质就是外部类的对象, 即哪个对象调用了 m1, Outer02.this 就是哪个对象
                System.out.println(&quot;n1=&quot; + n1 + &quot; 外部类的 n1=&quot; + Outer02.this.n1);
                System.out.println(&quot;Outer02.this hashcode=&quot; + Outer02.this);
                m2();
            &#125;
        &#125;
//6. 外部类在方法中，可以创建 Inner02 对象，然后调用方法即可
        Inner02 inner02 = new Inner02();
        inner02.f1();
    &#125;
&#125;</code></pre>

<p><code>System.out.println(&quot;outer02 的 hashcode=&quot; + outer02);</code>这个输出的是  全类名+@+哈希码的十六进制（调用了toString），<code>System.out.println(&quot;Outer02.this hashcode=&quot; + Outer02.this);</code>这个也是。</p>
<h4 id="匿名内部类（重要）"><a href="#匿名内部类（重要）" class="headerlink" title="匿名内部类（重要）"></a>匿名内部类（重要）</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240725220102012.png" alt="image-20240725220102012"></p>
<p><strong>记住最后有一个分号。</strong></p>
<p>new后面加接口的相当于是实现接口，接类的相当于是继承。</p>
<p>接口： IA tiger &#x3D; new IA(){}；类：Animal animal &#x3D; new Animal()，可以调用构造器。</p>
<pre><code class="hljs plaintext">public class AnonymousInnerClass &#123;
    public static void main(String[] args) &#123;
        Outer04 outer04 = new Outer04();
        outer04.method();
    &#125;
&#125;
class Outer04 &#123; //外部类
    private int n1 = 10;//属性
    public void method() &#123;//方法
//基于接口的匿名内部类
//老韩解读
//1.需求： 想使用 IA 接口,并创建对象
//2.传统方式，是写一个类，实现该接口，并创建对象
//3.老韩需求是 Tiger/Dog 类只是使用一次，后面再不使用
//4. 可以使用匿名内部类来简化开发
//5. tiger 的编译类型 ? IA
//6. tiger 的运行类型 ? 就是匿名内部类 Outer04$1
/*
我们看底层 会分配 类名 Outer04$1
class Outer04$1 implements IA &#123;
    @Override
    public void cry() &#123;
        System.out.println(&quot;老虎叫唤...&quot;);
    &#125;
&#125;
*/
//7. jdk 底层在创建匿名内部类 Outer04$1,立即马上就创建了 Outer04$1 实例，并且把地址
// 返回给 tiger
//8. 匿名内部类使用一次，就不能再使用
        IA tiger = new IA() &#123;
            @Override
            public void cry() &#123;
                System.out.println(&quot;老虎叫唤...&quot;);
            &#125;
        &#125;;
        System.out.println(&quot;tiger 的运行类型=&quot; + tiger.getClass());
        tiger.cry();
        tiger.cry();
        tiger.cry();
        //演示基于类的匿名内部类
        //分析
        //1. father 编译类型 Father
        //2. father 运行类型 Outer04$2
        //3. 底层会创建匿名内部类
        /*
        class Outer04$2 extends Father&#123;
        @Override
        public void test() &#123;
        System.out.println(&quot;匿名内部类重写了 test 方法&quot;);
        &#125;
        &#125;
        */
        //4. 同时也直接返回了 匿名内部类 Outer04$2 的对象
        //5. 注意(&quot;jack&quot;) 参数列表会传递给 构造器
            Father father = new Father(&quot;jack&quot;)&#123;
                @Override
                public void test() &#123;
                    System.out.println(&quot;匿名内部类重写了 test 方法&quot;);
                &#125;
            &#125;;
            System.out.println(&quot;father 对象的运行类型=&quot; + father.getClass());//Outer04$2
            father.test();
    //基于抽象类的匿名内部类
            Animal animal = new Animal()&#123;
                @Override
                void eat() &#123;
                    System.out.println(&quot;小狗吃骨头...&quot;);
                &#125;
            &#125;;
            animal.eat();
        &#125;
    &#125;
    interface IA &#123;//接口
        public void cry();
    &#125;
    class Father &#123;//类
        public Father(String name) &#123;//构造器
            System.out.println(&quot;接收到 name=&quot; + name);
        &#125;
        public void test() &#123;//方法
        &#125;
    &#125;
abstract class Animal &#123; //抽象类
    abstract void eat();
&#125;</code></pre>

<p>getClass()  返回的是此时的运行类型，哪一个类的。</p>
<p>这里所说的匿名内部类只能使用一次，注意是说匿名内部<strong>类</strong>，而不是说对象，指向匿名内部类的<strong>对象</strong>可以使用多次。</p>
<p>tiger可以使用多次，但是匿名内部类——下面部分——只能使用一次。</p>
<pre><code class="hljs plaintext">new IA() &#123;
            @Override
            public void cry() &#123;
                System.out.println(&quot;老虎叫唤...&quot;);
            &#125;
        &#125;;</code></pre>

<p>由于普通的类有类名，如：public class Amimal{…}，使用时Animal al &#x3D; new Animal()；可根据这个Animal类名多次new使用，创建实例，Animal类的代码在new时是固定的。<br>而匿名内部类没有类名，每次使用时，都要new 类名（）{…};这里的代码不是固定的，每次都可以变化，故只能用一次。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240726194749047.png" alt="image-20240726194749047"></p>
<p>类似于创造对象的语法：Father father &#x3D; new Father(“jack”){}，不过后面要加上内容。</p>
<p>体现对象特征：<strong>可以当作实参</strong>。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240726195140571.png" alt="image-20240726195140571"></p>
<p>第三点和前面的局部内部类一样。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240726195227118.png" alt="image-20240726195227118"></p>
<pre><code class="hljs plaintext">public class InnerClassExercise01 &#123;
    public static void main(String[] args) &#123;
//当做实参直接传递，简洁高效
        f1(new IL() &#123;
            @Override
            public void show() &#123;
                System.out.println(&quot;这是一副名画~~...&quot;);
            &#125;
        &#125;);
//传统方法
        f1(new Picture());
    &#125;
    //静态方法,形参是接口类型
    public static void f1(IL il) &#123;
        il.show();
    &#125;
&#125;
//接口
interface IL &#123;
    void show();
&#125;
//类-&gt;实现 IL =&gt; 编程领域 (硬编码)
class Picture implements IL &#123;
    @Override
    public void show() &#123;
        System.out.println(&quot;这是一副名画 XX...&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">public interface Printable &#123; 
 void print(String message); 
&#125;
public static void method(Printable p)&#123; 
 String message = &quot;匿名内部类&quot;; 
 p.print(message); 
&#125; 
 public static void main(String[]args)&#123; 
    method(new Printable()&#123; 
        public void print(String message)&#123; 
         	System.out.println(message); 
         &#125; 
     &#125;); 
 &#125;</code></pre>

<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240726214516539.png" alt="image-20240726214516539"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240726214606711.png" alt="image-20240726214606711"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240726214615158.png" alt="image-20240726214615158"></p>
<pre><code class="hljs plaintext">public class MemberInnerClass01 &#123;
    public static void main(String[] args) &#123;
        Outer08 outer08 = new Outer08();
        outer08.t1();
//外部其他类，使用成员内部类的三种方式
//老韩解读
// 第一种方式
// outer08.new Inner08(); 相当于把 new Inner08()当做是 outer08 成员
// 这就是一个语法，不要特别的纠结. 
		Outer08.Inner08 inner08 = outer08.new Inner08();
        inner08.say();
// 第二方式 在外部类中，编写一个方法，可以返回 Inner08 对象
        Outer08.Inner08 inner08Instance = outer08.getInner08Instance();
        inner08Instance.say();
    &#125;
&#125;
class Outer08 &#123; //外部类
    private int n1 = 10;
    public String name = &quot;张三&quot;;
    private void hi() &#123;
        System.out.println(&quot;hi()方法...&quot;);
    &#125;
    //1.注意: 成员内部类，是定义在外部内的成员位置上
//2.可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员
    public class Inner08 &#123;//成员内部类
        private double sal = 99.8;
        private int n1 = 66;
        public void say() &#123;
//可以直接访问外部类的所有成员，包含私有的
//如果成员内部类的成员和外部类的成员重名，会遵守就近原则. //，可以通过 外部类名.this.属性 来访问外部类的成员
            System.out.println(&quot;n1 = &quot; + n1 + &quot; name = &quot; + name + &quot; 外部类的 n1=&quot; + Outer08.this.n1);
            hi();
        &#125;
    &#125;
    //方法，返回一个 Inner08 实例
    public Inner08 getInner08Instance()&#123;
        return new Inner08();
    &#125;
    //写方法
    public void t1() &#123;
//使用成员内部类
//创建成员内部类的对象，然后使用相关的方法
        Inner08 inner08 = new Inner08();
        inner08.say();
        System.out.println(inner08.sal);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">System.out.println(inner08.sal);</code></pre>

<p>仍可以直接输出sal，虽然它是成员内部类，但是仍处于同一个类中，所以即使是private，也可以直接用。</p>
<p>外部其它类使用成员内部类的三种方式：</p>
<p>1、 <code>outer08.new Inner08()</code>  相当于把 new Inner08()当做是 outer08 成员</p>
<pre><code class="hljs plaintext">outer08.new Inner08().say();</code></pre>

<p>2、创建一个成员内部类的对象，通过对象去访问他里面的方法：</p>
<pre><code class="hljs plaintext">Outer08.Inner08 inner08 = outer08.new Inner08();
inner08.say();</code></pre>

<p>3、在外部类中，编写一个方法，可以返回成员内部类对象：</p>
<pre><code class="hljs plaintext">Outer08 outer08 = new Outer08();
Outer08.Inner08 inner08Instance = outer08.getInner08Instance();
inner08Instance.say();</code></pre>

<p>或者将这个方法定义为静态方法会更加简单。</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727102408708.png" alt="image-20240727102408708"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727102414626.png" alt="image-20240727102414626"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727102419556.png" alt="image-20240727102419556"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240727102424525.png" alt="image-20240727102424525"></p>
<p>这个不用加this。</p>
<p>外部其它类使用静态内部类的方式和上面一个的完全一样。</p>
<hr>
<p>一道题：</p>
<pre><code class="hljs plaintext">public class Test &#123;//外部类
    public Test() &#123;//构造器
        Inner s1 = new Inner();
        s1.a = 10;
        Inner s2 = new Inner();
        System.out.println(s2.a);
    &#125;
    class Inner &#123; //内部类，成员内部类
        public int a = 5;
    &#125;
    public static void main(String[] args) &#123;
        Test t = new Test();
        Inner r = t.new Inner();//5
        System.out.println(r.a);//5
    &#125;
&#125;</code></pre>

<p><code>Inner r = t.new Inner();</code>这句话前面不用再引入Test类的原因是这句代码原本就是再Test类里面进行的。</p>
<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h3><p>枚举类[枚: 一个一个，举： 例举 。 即把具体的对象一个一个例举出来的类就称为枚举类]</p>
<p>何时使用：（1）需要创建的类只有有限几个对象（2）只读，不需要修改。</p>
<p>1）枚举对应英文(enumeration, 简写 enum。</p>
<p>2）枚举是一组常量的集合。 </p>
<p>3） 可以这里理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象。</p>
<p>枚举的两种实现方式：1）自定义类实现枚举； 2) 使用 enum 关键字实现枚举。</p>
<h3 id="自定义类实现枚举"><a href="#自定义类实现枚举" class="headerlink" title="自定义类实现枚举"></a>自定义类实现枚举</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240730103701253.png" alt="image-20240730103701253"></p>
<pre><code class="hljs plaintext">public class Enumeration02 &#123;
    public static void main(String[] args) &#123;
        System.out.println(Season.AUTUMN);
        System.out.println(Season.SPRING);
    &#125;
&#125;
//演示字定义枚举实现
class Season &#123;//类
    private String name;
    private String desc;//描述
    //定义了四个对象, 固定. 
    public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);
    public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;寒冷&quot;);
    public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;凉爽&quot;);
    public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;炎热&quot;);
//1. 将构造器私有化,目的防止 直接 new
//2. 去掉 setXxx 方法, 防止属性被修改
//3. 在 Season 内部，直接创建固定的对象
//4. 优化，可以加入 final 修饰符
    private Season(String name, String desc) &#123;
        this.name = name;
        this.desc = desc;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public String getDesc() &#123;
        return desc;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Season&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, desc=&#x27;&quot; + desc + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p>小结：自定义类实现枚举特点：</p>
<ol>
<li>构造器私有化</li>
<li>本类内部创建一组对象[四个 春夏秋冬]</li>
<li>对外暴露对象（通过为对象添加 public final static 修饰符）</li>
<li>可以提供 get 方法，但是不要提供 set</li>
</ol>
<h3 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a>enum关键字实现枚举</h3><pre><code class="hljs plaintext">public class Enumeration03 &#123;
    public static void main(String[] args) &#123;
        System.out.println(Season2.AUTUMN);
        System.out.println(Season2.SUMMER);
    &#125;
&#125;
//演示使用 enum 关键字来实现枚举类
enum Season2 &#123;//类
    //如果使用了 enum 来实现枚举类
//1. 使用关键字 enum 替代 class
//2. public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;) 直接使用 SPRING(&quot;春天&quot;, &quot;温暖&quot;) 解读 常量名(实参列表)
//3. 如果有多个常量(对象)， 使用 ,号间隔即可
//4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面
//5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()
    SPRING(&quot;春天&quot;, &quot;温暖&quot;), WINTER(&quot;冬天&quot;, &quot;寒冷&quot;), AUTUMN(&quot;秋天&quot;, &quot;凉爽&quot;), SUMMER(&quot;夏天&quot;, &quot;炎热&quot;)/*, What()*/;
    private String name;
    private String desc;//描述
    private Season2() &#123;//无参构造器
    &#125;
    private Season2(String name, String desc) &#123;
        this.name = name;
        this.desc = desc;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public String getDesc() &#123;
        return desc;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Season&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, desc=&#x27;&quot; + desc + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p>不去重新定义toString的话，它输出的是枚举类里面每个对象的对象名。</p>
<p>注意事项：</p>
<ol>
<li>当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类</li>
<li>传统的 public static final Season2 SPRING &#x3D; new Season2(“春天”, “温暖”); 简化成 SPRING(“春天”, “温暖”)， 这里必<br>须知道，它调用的是哪个构造器. </li>
<li>如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</li>
<li>当有多个枚举对象时，使用’,’间隔，最后有一个分号结尾</li>
<li>枚举对象必须放在枚举类的行首.</li>
</ol>
<h3 id="enum常用方法-增强for"><a href="#enum常用方法-增强for" class="headerlink" title="enum常用方法+增强for"></a>enum常用方法+增强for</h3><p>说明：使用关键字 enum 时，会隐式继承 Enum 类, 这样我们就可以使用 Enum 类相关的方法。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731104137732.png" alt="image-20240731104137732"></p>
<p>使用 Season2 枚举类，来演示各种方法</p>
<pre><code class="hljs plaintext">//补充了一个增强 for
// int[] nums = &#123;1, 2, 9&#125;;
// //普通的 for 循环
// System.out.println(&quot;=====普通的 for=====&quot;);
// for (int i = 0; i &lt; nums.length; i++) &#123;
// System.out.println(nums[i]);
// &#125;
// System.out.println(&quot;=====增强的 for=====&quot;);
// //执行流程是 依次从 nums 数组中取出数据，赋给 i, 如果取出完毕，则退出 for
// for(int i : nums) &#123;
// System.out.println(&quot;i=&quot; + i);
// &#125;</code></pre>

<pre><code class="hljs plaintext">public class EnumMethod &#123;
    public static void main(String[] args) &#123;
//使用 Season2 枚举类，来演示各种方法
        Season2 autumn = Season2.AUTUMN;
//输出枚举对象的名字
        System.out.println(autumn.name());
//ordinal() 输出的是该枚举对象的次序/编号，从 0 开始编号
//AUTUMN 枚举对象是第三个，因此输出 2
        System.out.println(autumn.ordinal());
//从反编译可以看出 values 方法，返回 Season2[]
//含有定义的所有枚举对象
        Season2[] values = Season2.values();
        System.out.println(&quot;===遍历取出枚举对象(增强 for)====&quot;);
        for (Season2 season: values) &#123;//增强 for 循环
            System.out.println(season);
        &#125;
//valueOf：将字符串转换成枚举对象，要求字符串必须
        为已有的常量名，否则报异常
//执行流程
//1. 根据你输入的 &quot;AUTUMN&quot; 到 Season2 的枚举对象去查找
//2. 如果找到了，就返回，如果没有找到，就报错
        Season2 autumn1 = Season2.valueOf(&quot;AUTUMN&quot;);
        System.out.println(&quot;autumn1=&quot; + autumn1);
        System.out.println(autumn == autumn1);
//compareTo：比较两个枚举常量，比较的就是编号
//老韩解读
//1. 就是把 Season2.AUTUMN 枚举对象的编号 和 Season2.SUMMER 枚举对象的编号比较
//2. 看看结果
/*
public final int compareTo(E o) &#123;
return self.ordinal - other.ordinal;
&#125;
Season2.AUTUMN 的编号[2] - Season2.SUMMER 的编号[3]
*/
        System.out.println(Season2.AUTUMN.compareTo(Season2.SUMMER));
    &#125;
&#125;</code></pre>

<h3 id="enum实现接口"><a href="#enum实现接口" class="headerlink" title="enum实现接口"></a>enum实现接口</h3><ol>
<li>使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制。</li>
<li>枚举类和普通类一样，可以实现接口，如下形式。<br>enum 类名 implements 接口 1，接口 2{}</li>
</ol>
<pre><code class="hljs plaintext">interface IPlaying &#123;
    public void playing();
&#125;
enum Music implements IPlaying &#123;
    CLASSICMUSIC;
    @Override
    public void playing() &#123;
	    System.out.println(&quot;播放好听的音乐...&quot;);
    &#125;
&#125;</code></pre>

<p>调用：<code>Music.CLASSICMUSIC.playing();</code></p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="基础-4"><a href="#基础-4" class="headerlink" title="基础"></a>基础</h3><pre><code class="hljs plaintext">1) 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。
2) 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。
3) 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角
色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。</code></pre>

<pre><code class="hljs plaintext">三个基本的 Annotation:
1) @Override: 限定某个方法，是重写父类方法, 该注解只能用于方法
2) @Deprecated: 用于表示某个程序元素(类, 方法等)已过时
3) @SuppressWarnings: 抑制编译器警告</code></pre>

<h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731153546504.png" alt="image-20240731153546504"></p>
<p>如果你写了@Override 注解，编译器就会去检查该方法是否真的重写了父类的方法，如果的确重写了，则编译通过，如果没有构成重写，则编译错误。</p>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><pre><code class="hljs plaintext">@Deprecated
class A &#123;
    @Deprecated
    public int n1 = 10;
    @Deprecated
    public void hi()&#123;
    &#125;
&#125;
</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731153824416.png" alt="image-20240731153824416"></p>
<h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><ol>
<li>当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息</li>
<li>在{“”} 中，可以写入你希望抑制(不显示)警告信息</li>
<li>关于 SuppressWarnings 作用范围是和你放置的位置相关<br>&#x2F;&#x2F; 比如 @SuppressWarnings 放置在 main 方法，那么抑制警告的范围就是 main<br>&#x2F;&#x2F; 通常我们可以放置具体的语句, 方法, 类.</li>
</ol>
<pre><code class="hljs plaintext">@SuppressWarnings(&#123;&quot;rawtypes&quot;&#125;)</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731154135263.png" alt="image-20240731154135263"></p>
<h1 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常-Exception"></a>异常-Exception</h1><h2 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h2><p>例子：</p>
<pre><code class="hljs plaintext">public class Exception01 &#123;
    public static void main(String[] args) &#123;
        int num1 = 10;
        int num2 = 0;//Scanner();
//老韩解读
//1. num1 / num2 =&gt; 10 / 0
//2. 当执行到 num1 / num2 因为 num2 = 0, 程序就会出现(抛出)异常 ArithmeticException
//3. 当抛出异常后，程序就退出，崩溃了 , 下面的代码就不在执行
//4. 大家想想这样的程序好吗? 不好，不应该出现了一个不算致命的问题，就导致整个系统崩溃
//5. java 设计者，提供了一个叫 异常处理机制来解决该问题
// int res = num1 / num2;
//如果程序员，认为一段代码可能出现异常/问题，可以使用 try-catch 异常处理机制来解决
//从而保证程序的健壮性
//将该代码块-&gt;选中-&gt;快捷键 ctrl + alt + t -&gt; 选中 try-catch
//6. 如果进行异常处理，那么即使出现了异常，程序可以继续执行
        try &#123;
            int res = num1 / num2;
        &#125; catch (Exception e) &#123;
//e.printStackTrace();
            System.out.println(&quot;出现异常的原因=&quot; + e.getMessage());//输出异常信息
        &#125;
        System.out.println(&quot;程序继续运行....&quot;);
    &#125;
&#125;</code></pre>

<p>将该代码块-&gt;选中-&gt;快捷键 ctrl + alt + t -&gt; 选中 try-catch，不能使用系统给你的，需要做些修改，不然只会将问题再输出一遍，程序仍然会中断。</p>
<p>将catch后面的方法体变为<code>System.out.println(&quot;出现异常的原因=&quot; + e.getMessage());</code>，程序就不会中断了。</p>
<p>输出异常信息：</p>
<pre><code class="hljs plaintext">e.printStackTrace();
或者
System.out.println(&quot;出现异常的原因=&quot; + e.getMessage());</code></pre>

<p>下面是程序给的：如果将<code>throw new RuntimeException(e);</code>注释掉，程序也会继续往下运行。</p>
<pre><code class="hljs plaintext">try &#123;
    int res = num1 / num2;
&#125; catch (Exception e) &#123;
    throw new RuntimeException(e);
&#125;</code></pre>

<h2 id="基础-5"><a href="#基础-5" class="headerlink" title="基础"></a>基础</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731161904912.png" alt="image-20240731161904912"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731162157449.png" alt="image-20240731162157449"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731164151694.png" alt="image-20240731164151694"></p>
<h2 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h2><ol>
<li>NullPointerException 空指针异常</li>
<li>ArithmeticException 数学运算异常</li>
<li>ArrayIndexOutOfBoundsException 数组下标越界异常</li>
<li>ClassCastException 类型转换异常</li>
<li>NumberFormatException 数字格式不正确异常[]</li>
</ol>
<p>4、当试图将对象强制转换为不是实例的子类时，抛出该异常。</p>
<pre><code class="hljs plaintext">public class ClassCastException_ &#123;
    public static void main(String[] args) &#123;
        A b = new B(); //向上转型
        B b2 = (B)b;//向下转型，这里是 OK
        C c2 = (C)b;//这里抛出 ClassCastException
    &#125;
&#125;
class A &#123;&#125;
class B extends A &#123;&#125;
class C extends A &#123;&#125;</code></pre>

<p>5、当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常</p>
<pre><code class="hljs plaintext">public class NumberFormatException_ &#123;
    public static void main(String[] args) &#123;
        String name = &quot;韩顺平教育&quot;;
//将 String 转成 int
        int num = Integer.parseInt(name);//抛出 NumberFormatException
        System.out.println(num);//1234
    &#125;
&#125;</code></pre>

<h2 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731162633775.png" alt="image-20240731162633775"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731162648857.png" alt="image-20240731162648857"></p>
<p>例子没看懂</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731162833533.png" alt="image-20240731162833533"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731162906866.png" alt="image-20240731162906866"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731163027886.png" alt="image-20240731163027886"></p>
<h3 id="try-catch-异常处理"><a href="#try-catch-异常处理" class="headerlink" title="try-catch 异常处理"></a>try-catch 异常处理</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731163110864.png" alt="image-20240731163110864"></p>
<p>上面的引入例子</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731163332984.png" alt="image-20240731163332984"></p>
<pre><code class="hljs plaintext">public class TryCatchDetail &#123;
    public static void main(String[] args) &#123;
//ctrl + atl + t
//老韩解读
//1. 如果异常发生了，则异常发生后面的代码不会执行，直接进入到 catch 块
//2. 如果异常没有发生，则顺序执行 try 的代码块，不会进入到 catch
//3. 如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用如下代码- finally
        try &#123;
            String str = &quot;韩顺平&quot;;
            int a = Integer.parseInt(str);
            System.out.println(&quot;数字：&quot; + a);
        &#125; catch (NumberFormatException e) &#123;
            System.out.println(&quot;异常信息=&quot; + e.getMessage());
        &#125; finally &#123;
            System.out.println(&quot;finally 代码块被执行...&quot;);
        &#125;
        System.out.println(&quot;程序继续...&quot;);
    &#125;
&#125;</code></pre>

<p>如果异常发生了，则异常发生后面的代码不会执行，直接进入到 catch 块：这里讲的异常后面的代码的范围是在try里面的，try里面的某处代码发生问题后，这处后面的代码不执行，直接跳到catch。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731164241784.png" alt="image-20240731164241784"></p>
<pre><code class="hljs plaintext">public class c&#123;
    public static void main(String[] args) &#123;
//老韩解读
//1.如果 try 代码块有可能有多个异常
//2.可以使用多个 catch 分别捕获不同的异常，相应处理
//3.要求子类异常写在前面，父类异常写在后面
        try &#123;
            Person person = new Person();
//person = null;
            System.out.println(person.getName());//NullPointerException
            int n1 = 10;
            int n2 = 0;
            int res = n1 / n2;//ArithmeticException
        &#125; catch (NullPointerException e) &#123;
            System.out.println(&quot;空指针异常=&quot; + e.getMessage());
        &#125; catch (ArithmeticException e) &#123;
            System.out.println(&quot;算术异常=&quot; + e.getMessage());
        &#125; catch (Exception e) &#123;
            System.out.println(e.getMessage());
        &#125; finally &#123;
        &#125;
    &#125;
&#125;
class Person &#123;
    private String name = &quot;jack&quot;;
    public String getName() &#123;
        return name;
    &#125;
&#125;</code></pre>

<p>上面代码不存在空指针问题。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731164845230.png" alt="image-20240731164845230"></p>
<p>有异常才会崩掉。</p>
<h3 id="利用try-catch解决问题"><a href="#利用try-catch解决问题" class="headerlink" title="利用try-catch解决问题"></a>利用try-catch解决问题</h3><p>如果用户输入的不是一个整数，就提示他反复输入，直到输入一个整数为止</p>
<pre><code class="hljs plaintext">import java.util.Scanner;

public class TryCatchExercise04 &#123;
    public static void main(String[] args) &#123;
//如果用户输入的不是一个整数，就提示他反复输入，直到输入一个整数为止
//思路
//1. 创建 Scanner 对象
//2. 使用无限循环，去接收一个输入
//3. 然后将该输入的值，转成一个 int
//4. 如果在转换时，抛出异常，说明输入的内容不是一个可以转成 int 的内容
//5. 如果没有抛出异常，则 break 该循环
        Scanner scanner = new Scanner(System.in);
        int num = 0;
        String inputStr = &quot;&quot;;
        while (true) &#123;
            System.out.println(&quot;请输入一个整数:&quot;); //
            inputStr = scanner.next();
            try &#123;
                num = Integer.parseInt(inputStr); //这里是可能抛出异常
                break;
            &#125; catch (NumberFormatException e) &#123;
                System.out.println(&quot;你输入的不是一个整数:&quot;);
            &#125;
        &#125;
        System.out.println(&quot;你输入的值是=&quot; + num);
    &#125;
&#125;</code></pre>

<h3 id="throws-异常处理"><a href="#throws-异常处理" class="headerlink" title="throws 异常处理"></a>throws 异常处理</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731173758424.png" alt="image-20240731173758424"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240731174140998.png" alt="image-20240731174140998"></p>
<p>没有用try-catch去处理异常，啥都没写就是默认throws处理，不用去写，就是默认它处理的。</p>
<pre><code class="hljs plaintext">import java.io.FileInputStream;
import java.io.FileNotFoundException;
/**
 * @author 韩顺平
 * @version 1.0
 */
public class ThrowsDetail &#123;
    public static void main(String[] args) &#123;
        f2();
    &#125;
    public static void f2() /*throws ArithmeticException*/ &#123;
//1.对于编译异常，程序中必须处理，比如 try-catch 或者 throws
//2.对于运行时异常，程序中如果没有处理，默认就是 throws 的方式处理
        int n1 = 10;
        int n2 = 0;
        double res = n1 / n2;
    &#125;
    public static void f1() throws FileNotFoundException &#123;
//这里大家思考问题 调用 f3() 报错
//老韩解读
//1. 因为 f3() 方法抛出的是一个编译异常
//2. 即这时，就要 f1() 必须处理这个编译异常
//3. 在 f1() 中，要么 try-catch-finally ,或者继续 throws 这个编译异常
        f3(); // 抛出异常
    &#125;
    public static void f3() throws FileNotFoundException &#123;
        FileInputStream fis = new FileInputStream(&quot;d://aa.txt&quot;);
    &#125;
    public static void f4() &#123;
//老韩解读:
//1. 在 f4()中调用方法 f5() 是 OK
//2. 原因是 f5() 抛出的是运行异常
//3. 而 java 中，并不要求程序员显示处理,因为有默认处理机制
        f5();
    &#125;
    public static void f5() throws ArithmeticException &#123;
    &#125;
&#125;
class Father &#123; //父类
    public void method() throws RuntimeException &#123;
    &#125;
&#125;
class Son extends Father &#123;//子类
    //3. 子类重写父类的方法时，对抛出异常的规定:子类重写的方法，
// 所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常类型的子类型
//4. 在 throws 过程中，如果有方法 try-catch , 就相当于处理异常，就可以不必 throws
    @Override
    public void method() throws ArithmeticException &#123;
    &#125;
&#125;</code></pre>

<p>有点没看懂上面那个。</p>
<p><strong>编写方法</strong>抛出异常：</p>
<p>声明一个方法抛出异常要在括号后面加<code>throws 异常</code>。</p>
<p>编写程序，定义一个 static 方法 methodA()，令其声明抛出一个 IOException 异常，再定义 另一个 static 方法 methodB()，在该方法中调用 methodA()方法。在 main()方法中调用 methodB() 方法。试编译该类，看编译器会报告什么？对于这种情况应如何处理？</p>
<pre><code class="hljs plaintext">import java.io.IOException;
public class c&#123;
    public static void methodA() throws IOException&#123;
        System.out.println(&quot;In method A&quot;);
    &#125;
    public static void methodB()&#123;
        methodA(); // 编译错误，没有处理 methodA()方法抛出的非运行时异常
        System.out.println(&quot;In method B&quot;);
    &#125;
    public static void main(String args[])&#123;
        methodB();
    &#125;
&#125;</code></pre>

<p>编译器报告：</p>
<p>java: 未报告的异常错误java.io.IOException; 必须对其进行捕获或声明以便抛出</p>
<p>处理：</p>
<p>（1）声明 methodB()方法抛出 IOException 异常。 </p>
<p>（2）在 methodB()方法中使用 try-catch 结构对 methodA()方法调用进行异常处理。</p>
<pre><code class="hljs plaintext">try&#123; 

methodA(); 

&#125;catch(IOException e) &#123; &#125;</code></pre>

<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240801110702617.png" alt="image-20240801110702617"></p>
<p>步骤：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240801110714899.png" alt="image-20240801110714899"></p>
<pre><code class="hljs plaintext">public class CustomException &#123;
    public static void main(String[] args) /*throws AgeException*/ &#123;
        int age = 180;
//要求范围在 18 – 120 之间，否则抛出一个自定义异常
        if(!(age &gt;= 18 &amp;&amp; age &lt;= 120)) &#123;
//这里我们可以通过构造器，设置信息
            throw new AgeException(&quot;年龄需要在 18~120 之间&quot;);
        &#125;
        System.out.println(&quot;你的年龄范围正确.&quot;);
    &#125;
&#125;
//自定义一个异常
//老韩解读
//1. 一般情况下，我们自定义异常是继承 RuntimeException
//2. 即把自定义异常做成 运行时异常，好处时，我们可以使用默认的处理机制
//3. 即比较方便
class AgeException extends RuntimeException &#123;
    public AgeException(String message) &#123;//构造器
        super(message);
    &#125;
&#125;</code></pre>

<p>记住这个例子，以后的按这个例子来写。</p>
<p>写一个方法，令其打印出保存下来的 String 对象：</p>
<pre><code class="hljs plaintext">public void output1()&#123;
        System.out.println(getMessage());
    &#125;</code></pre>

<p>要调用这个方法的话，一定要记得把catch里面异常的类型改为这个方法所在的自定义异常类，然后才能调用这个方法。如果是原来的Exception的话，由于自定义的是它的子类，而它作为父类是不能调用子类的方法的，除非向下转型。</p>
<pre><code class="hljs plaintext">public class c&#123;
    public static void main(String[] args)&#123;
        try&#123;
            throw new MyException(&quot;My Exception.&quot;);
        &#125;catch(MyException e)&#123;
            e.output1();
            System.out.println(e.getMessage());
        &#125;
    &#125;
&#125;

class MyException extends Exception&#123;
    public MyException() &#123; &#125;
    public MyException(String message)&#123;
        super(message);
    &#125;
    public void output1()&#123;
        System.out.println(getMessage());
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240801111139204.png" alt="image-20240801111139204"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240801111510841.png" alt="image-20240801111510841"></p>
<p>finally里面的内容是try运行完后无论如何都会运行的。</p>
<p>为什么“制造异常”在后面：因为在A中的throw生成了一个RuntimeException异常，所以main方法中的try就发生了异常，然后catch捕捉RuntimeException异常，之后在它的方法体中输出RuntimeException异常的内容“制造异常”，所以“制造异常”在后面。</p>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>针对八种基本数据类型相应的引用类型—包装类。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802102316270.png" alt="image-20240802102316270"></p>
<p>有了类的特点，就可以调用类中的方法。</p>
<h3 id="包装类和基本数据类型的转换"><a href="#包装类和基本数据类型的转换" class="headerlink" title="包装类和基本数据类型的转换"></a>包装类和基本数据类型的转换</h3><p>装箱：基本数据类型-&gt;包装类型；拆箱相反。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802102713074.png" alt="image-20240802102713074"></p>
<pre><code class="hljs plaintext">//jdk5 前是手动装箱和拆箱
//手动装箱 int-&gt;Integer
int n1 = 100;
Integer integer = new Integer(n1);//现在会报错
Integer integer1 = Integer.valueOf(n1);
//手动拆箱
//Integer -&gt; int
int i = integer.intValue();</code></pre>

<pre><code class="hljs plaintext">//jdk5（包括jdk5）后，就可以自动装箱和自动拆箱
int n2 = 200;
//自动装箱 int-&gt;Integer
Integer integer2 = n2; //底层使用的是 Integer.valueOf(n2)
//自动拆箱 Integer-&gt;int
int n3 = integer2; //底层仍然使用的是 intValue()方法</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802104712915.png" alt="image-20240802104712915"></p>
<p>第一个输出1.0的原因：</p>
<p>在 Java 中，三元运算符的两种可能结果会被提升为一个共同的类型。在这个例子中，<code>new Integer(1)</code> 和 <code>new Double(2.0)</code> 将会被提升为 <code>Double</code> 类型，因为 <code>Double</code> 是 <code>Integer</code> 和 <code>Double</code> 的共同父类。然后 <code>obj1</code> 会被赋值为 <code>Double</code> 类型的 <code>1.0</code>。</p>
<pre><code class="hljs plaintext">//示例六
Integer i11=127;
int i12=127;
//只要有基本数据类型，判断的是值是否相同，会自动拆箱
System.out.println(i11==i12); //T
//示例七
Integer i13=128;
int i14=128;
System.out.println(i13==i14);//T</code></pre>

<h3 id="包装类型和-String-类型的相互转换"><a href="#包装类型和-String-类型的相互转换" class="headerlink" title="包装类型和 String 类型的相互转换"></a>包装类型和 String 类型的相互转换</h3><pre><code class="hljs plaintext">//包装类(Integer)-&gt;String
Integer i = 100;//自动装箱
//方式 1
String str1 = i + &quot;&quot;;
//方式 2
String str2 = i.toString();
//方式 3
String str3 = String.valueOf(i);</code></pre>

<pre><code class="hljs plaintext">//String -&gt; 包装类(Integer)
String str4 = &quot;12345&quot;;
Integer i2 = Integer.parseInt(str4);//使用到自动装箱
Integer i3 = new Integer(str4);//构造器</code></pre>

<p><code>Integer i2 = Integer.parseInt(str4);</code>先转化为int类型，再用到自动装箱变为包装类。</p>
<h3 id="Integer-类和-Character-类的常用方法"><a href="#Integer-类和-Character-类的常用方法" class="headerlink" title="Integer 类和 Character 类的常用方法"></a>Integer 类和 Character 类的常用方法</h3><pre><code class="hljs plaintext">System.out.println(Integer.MIN_VALUE); //返回最小值
System.out.println(Integer.MAX_VALUE);//返回最大值
System.out.println(Character.isDigit(&#x27;a&#x27;));//判断是不是数字
System.out.println(Character.isLetter(&#x27;a&#x27;));//判断是不是字母
System.out.println(Character.isUpperCase(&#x27;a&#x27;));//判断是不是大写
System.out.println(Character.isLowerCase(&#x27;a&#x27;));//判断是不是小写
System.out.println(Character.isWhitespace(&#x27;a&#x27;));//判断是不是空格
System.out.println(Character.toUpperCase(&#x27;a&#x27;));//转成大写
System.out.println(Character.toLowerCase(&#x27;A&#x27;));//转成小写</code></pre>

<p>其它的与Integer类相似。</p>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="基础-6"><a href="#基础-6" class="headerlink" title="基础"></a>基础</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802112155115.png" alt="image-20240802112155115"></p>
<p>1）字符串的字符使用 Unicode 字符编码，一个字符(不区分字母还是汉字)占两个字节；</p>
<p>2）String 是 final 类，不能被其他的类继承。</p>
<p>创建String对象的两种方式：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802112932591.png" alt="image-20240802112932591"></p>
<p>两种方式的区别：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802112946033.png" alt="image-20240802112946033"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802112952647.png" alt="image-20240802112952647"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802113113614.png" alt="image-20240802113113614"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802152635252.png" alt="image-20240802152635252"></p>
<h3 id="字符串的特性"><a href="#字符串的特性" class="headerlink" title="字符串的特性"></a>字符串的特性</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802152156272.png" alt="image-20240802152156272"></p>
<p>变量名储存的只是地址。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802152322585.png" alt="image-20240802152322585"></p>
<p>两个变量相加和两个字符串（两个常量）直接相加创造的对象个数不同。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802152329006.png" alt="image-20240802152329006"></p>
<h3 id="String类的常用方法-进制转化"><a href="#String类的常用方法-进制转化" class="headerlink" title="String类的常用方法+进制转化"></a>String类的常用方法+进制转化</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802153728020.png" alt="image-20240802153728020"></p>
<pre><code class="hljs plaintext">// 2.equalsIgnoreCase 忽略大小写的判断内容是否相等
String username = &quot;johN&quot;;
if (&quot;john&quot;.equalsIgnoreCase(username)) &#123;
System.out.println(&quot;Success!&quot;);
&#125; else &#123;
System.out.println(&quot;Failure!&quot;);
&#125;
// 3.length 获取字符的个数，字符串的长度
System.out.println(&quot;韩顺平&quot;.length());
// 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1
String s1 = &quot;wer@terwe@g&quot;;
int index = s1.indexOf(&#x27;@&#x27;);
System.out.println(index);// 3
System.out.println(&quot;weIndex=&quot; + s1.indexOf(&quot;we&quot;));//0
// 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1
s1 = &quot;wer@terwe@g@&quot;;
index = s1.lastIndexOf(&#x27;@&#x27;);
System.out.println(index);//11
System.out.println(&quot;ter 的位置=&quot; + s1.lastIndexOf(&quot;ter&quot;));//4
// 6.substring 截取指定范围的子串
String name = &quot;hello,张三&quot;;
//下面 name.substring(6) 从索引 6 开始截取后面所有的内容
System.out.println(name.substring(6));//截取后面的字符
//name.substring(0,5)表示从索引 0 开始截取，截取到索引 5-1=4 位置
System.out.println(name.substring(2,5));//llo</code></pre>

<pre><code class="hljs plaintext">String[] elem = sentence.split(&quot;[, .]&quot;);//这句代表sentence内以&quot;,&quot;  &quot; &quot;  &quot;.&quot;三个为分界点。</code></pre>

<pre><code class="hljs plaintext">index = result.indexOf(&quot;hello&quot;, index + &quot;&lt;censored&gt;&quot;.length());
result，&lt;censored&gt;都是字符串，这个方法还可以指定从哪个位置开始查找。前面是查找的内容，后面是索引。</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802154437791.png" alt="image-20240802154437791"></p>
<pre><code class="hljs plaintext">// 1.toUpperCase 转换成大写
String s = &quot;heLLo&quot;;
System.out.println(s.toUpperCase());//HELLO
// 2.toLowerCase</code></pre>

<p>concat可以连续使用，只要在括号后面继续加上就好了。</p>
<p>replace() 是全替换，方法执行后，返回的结果才是替换过的，对原字符串无影响。</p>
<p><code>String s11 = s1.replace(&quot;林黛玉&quot;, &quot;jack&quot;);</code>林黛玉全部被替换，这是没有指定范围的情况，如果指定了范围就只会替代那个范围的字符，如下(forbidden是违禁词，字符串)，还有一个例子在StringBuffer那边：</p>
<pre><code class="hljs plaintext">// 替换当前违禁词为&lt;censored&gt;
result.replace(index, index + forbidden.length(), &quot;&lt;censored&gt;&quot;);</code></pre>

<pre><code class="hljs plaintext">String poem = &quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;;
String[] split = poem.split(&quot;,&quot;);
poem = &quot;E:\\aaa\\bbb&quot;;
split = poem.split(&quot;\\\\&quot;);
for (int i = 0; i &lt; split.length; i++) &#123;
    System.out.println(split[i]);
    System.out.println(s.toLowerCase());//hello
// 3.concat 拼接字符串
String s1 = &quot;宝玉&quot;;
s1 = s1.concat(&quot;林黛玉&quot;).concat(&quot;薛宝钗&quot;).concat(&quot;together&quot;);
System.out.println(s1);//宝玉林黛玉薛宝钗 together
// 4.replace 替换字符串中的字符
s1 = &quot;宝玉 and 林黛玉 林黛玉 林黛玉&quot;;
//在 s1 中，将 所有的 林黛玉 替换成薛宝钗
// 老韩解读: s1.replace() 方法执行后，返回的结果才是替换过的. // 注意对 s1 没有任何影响
String s11 = s1.replace(&quot;宝玉&quot;, &quot;jack&quot;);
System.out.println(s1);//宝玉 and 林黛玉 林黛玉 林黛玉
System.out.println(s11);//jack and 林黛玉 林黛玉 林黛玉
// 5.split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \\等
String poem = &quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;;
//老韩解读：
// 1. 以 , 为标准对 poem 进行分割 , 返回一个数组
// 2. 在对字符串进行分割时，如果有特殊字符，需要加入 转义符 \
String[] split = poem.split(&quot;,&quot;);
poem = &quot;E:\\aaa\\bbb&quot;;
split = poem.split(&quot;\\\\&quot;);
System.out.println(&quot;==分割后内容===&quot;);
for (int i = 0; i &lt; split.length; i++) &#123;
	System.out.println(split[i]);
&#125;</code></pre>

<p>原本的split数组存储的是诗句，但是下面再使用它来存储新的分割字符串时，不是以覆盖的形式覆盖原先内容，应该是原本存储内容全部清空然后存储新的内容，或者不是清空而是split存储的地址变了。</p>
<pre><code class="hljs plaintext">// 6.toCharArray 转换成字符数组
s = &quot;happy&quot;;
char[] chs = s.toCharArray();
for (int i = 0; i &lt; chs.length; i++) &#123;
	System.out.println(chs[i]);
&#125;
// 7.compareTo 比较两个字符串的大小，如果前者大，
// 则返回正数，后者大，则返回负数，如果相等，返回 0
// 老韩解读
// (1) 如果长度相同，并且每个字符也相同，就返回 0
// (2) 如果长度相同或者不相同，但是在进行比较时，可以区分大小
// 就返回 if (c1 != c2) &#123;
// return c1 - c2;
// &#125;
// (3) 如果前面的部分都相同，就返回 str1.len - str2.len
String a = &quot;jcck&quot;;// len = 3
String b = &quot;jack&quot;;// len = 4
System.out.println(a.compareTo(b)); // 返回值是 &#x27;c&#x27; - &#x27;a&#x27; = 2 的值
// 8.format 格式字符串
/* 占位符有:
* %s 字符串 %c 字符 %d 整型 %.2f 浮点型
*
*/
String name = &quot;john&quot;;
int age = 10;
double score = 56.857;
char gender = &#x27;男&#x27;;
//将所有的信息都拼接在一个字符串. 
String info =&quot;我的姓名是&quot; + name + &quot;年龄是&quot; + age + &quot;,成绩是&quot; + score + &quot;性别是&quot; + gender + &quot;。希望大家喜欢我！&quot;;
System.out.println(info);
//老韩解读
//1. %s , %d , %.2f %c 称为占位符
//2. 这些占位符由后面变量来替换
//3. %s 表示后面由 字符串来替换
//4. %d 是整数来替换
//5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理
//6. %c 使用 char 类型来替换
String formatStr = &quot;我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！&quot;;
String info2 = String.format(formatStr, name, age, score, gender);
System.out.println(&quot;info2=&quot; + info2);</code></pre>

<h4 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240819211720021.png" alt="image-20240819211720021"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240819211739407.png" alt="image-20240819211739407"></p>
<p>方法三：递归</p>
<h2 id="StringBuffer-类"><a href="#StringBuffer-类" class="headerlink" title="StringBuffer 类"></a>StringBuffer 类</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802162302892.png" alt="image-20240802162302892"></p>
<pre><code class="hljs plaintext">//1. StringBuffer 的直接父类 是 AbstractStringBuilder
//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化
//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final
// 该 value 数组存放 字符串内容，引出存放在堆中的
//4. StringBuffer 是一个 final 类，不能被继承
//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)
// 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String
StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240802163521972.png" alt="image-20240802163521972"></p>
<h3 id="String和StringBuffer的相互转换"><a href="#String和StringBuffer的相互转换" class="headerlink" title="String和StringBuffer的相互转换"></a>String和StringBuffer的相互转换</h3><pre><code class="hljs plaintext">//看 String——&gt;StringBuffer
String str = &quot;hello tom&quot;;
//方式 1 使用构造器
//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响
StringBuffer stringBuffer = new StringBuffer(str);
//方式 2 使用的是 append 方法
StringBuffer stringBuffer1 = new StringBuffer();
stringBuffer1 = stringBuffer1.append(str);
//看看 StringBuffer -&gt;String
StringBuffer stringBuffer3 = new StringBuffer(&quot;韩顺平教育&quot;);
//方式 1 使用 StringBuffer 提供的 toString 方法
String s = stringBuffer3.toString();
//方式 2: 使用构造器来搞定
String s1 = new String(stringBuffer3);</code></pre>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>上承String类方法。</p>
<pre><code class="hljs plaintext">StringBuffer s = new StringBuffer(&quot;hello&quot;);
//增
s.append(&#x27;,&#x27;);// &quot;hello,&quot;
s.append(&quot;张三丰&quot;);//&quot;hello,张三丰&quot;
s.append(&quot;赵敏&quot;).append(100).append(true).append(10.5);//&quot;hello,张三丰赵敏100true10.5&quot; System.out.println(s);//&quot;hello,张三丰赵敏 100true10.5&quot;
//删
/*
* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符
* 解读: 删除 11~14 的字符 [11, 14)
*/
s.delete(11, 14);
System.out.println(s);//&quot;hello,张三丰赵敏true10.5&quot;
//改
//老韩解读，使用 周芷若 替换 索引 9-11 的字符 [9,11)
s.replace(9, 11, &quot;周芷若&quot;);
System.out.println(s);//&quot;hello,张三丰周芷若 true10.5&quot;
//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1
int indexOf = s.indexOf(&quot;张三丰&quot;);
System.out.println(indexOf);//6
//插
//老韩解读，在索引为 9 的位置插入 &quot;赵敏&quot;,原来索引为 9 的内容自动后移
s.insert(9, &quot;赵敏&quot;);
System.out.println(s);//&quot;hello,张三丰赵敏周芷若 true10.5&quot;
//长度
System.out.println(s.length());//22
System.out.println(s);</code></pre>

<p>对StringBuffer类对象进行修改，字数不需要对等，它会自动调整空间。</p>
<p>方法括号里的数字代表的都是索引数字。</p>
<p>insert，在索引为 9 的位置插入 “赵敏”,原来索引为 9 的内容<strong>自动后移</strong>。</p>
<p>**reverse()**，StringBuffer也可以用。</p>
<p> <code>StringBuilder</code> 的 <code>reverse()</code> 方法会直接修改 <code>str</code> 本身，而不是创建一个新的字符串。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240824154300761.png" alt="image-20240824154300761"></p>
<h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><pre><code class="hljs plaintext">String str = null;// ok
StringBuffer sb = new StringBuffer(); //ok
sb.append(str);//需要看源码 , 底层调用的是 AbstractStringBuilder 的 appendNull
System.out.println(sb.length());//4
System.out.println(sb);//null
//下面的构造器，会抛出 NullpointerException
StringBuffer sb1 = new StringBuffer(str);//看底层源码 super(str.length() + 16);
System.out.println(sb1);</code></pre>

<p>str为空，所以将str转换为StringBuffer时会产生空指针异常；但是<strong>str的字符串长度为4</strong>，因为存储了null。</p>
<h2 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h2><h3 id="介绍和比较"><a href="#介绍和比较" class="headerlink" title="介绍和比较"></a>介绍和比较</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803152208071-1722669728912-1.png" alt="image-20240803152208071"></p>
<pre><code class="hljs plaintext">StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);</code></pre>

<p>String类要先转化为StringBuffer才能转化为StringBuider。</p>
<p>&#x2F;&#x2F;1. StringBuffer 的直接父类 是 AbstractStringBuilder<br>&#x2F;&#x2F;2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化<br>&#x2F;&#x2F;3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final<br>&#x2F;&#x2F; 该 value 数组存放 字符串内容，引出存放在堆中的<br>&#x2F;&#x2F;4. StringBuffer 是一个 final 类，不能被继承<br>&#x2F;&#x2F;5. 因为 StringBuffer 字符内容是存在 char[] value, 所以再变化(增加&#x2F;删除)不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803153113712.png" alt="image-20240803153113712"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803153150977.png" alt="image-20240803153150977"></p>
<h3 id="StringBuilder-常用方法"><a href="#StringBuilder-常用方法" class="headerlink" title="StringBuilder 常用方法"></a>StringBuilder 常用方法</h3><p>和StringBuffer的方法一样。</p>
<h2 id="Math类-常用方法（均为静态方法）"><a href="#Math类-常用方法（均为静态方法）" class="headerlink" title="Math类-常用方法（均为静态方法）"></a>Math类-常用方法（均为静态方法）</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803154943978.png" alt="image-20240803154943978"></p>
<pre><code class="hljs plaintext">//1.abs 绝对值
int abs = Math.abs(-9);
System.out.println(abs);//9
//2.pow 求幂
double pow = Math.pow(2, 4);//2 的 4 次方
System.out.println(pow);//16
//3.ceil 向上取整,返回&gt;=该参数的最小整数(转成 double);
double ceil = Math.ceil(3.9);
System.out.println(ceil);//4.0
//4.floor 向下取整，返回&lt;=该参数的最大整数(转成 double)
double floor = Math.floor(4.001);
System.out.println(floor);//4.0
//5.round 四舍五入 Math.floor(该参数+0.5)
long round = Math.round(5.51);
System.out.println(round);//6
//6.sqrt 求开方
double sqrt = Math.sqrt(9.0);
System.out.println(sqrt);//3.0
//7.random 求随机数
// random 返回的是 0 &lt;= x &lt; 1 之间的一个随机小数
// 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7
// 即返回一个数 x 2 &lt;= x &lt;= 7
// 老韩解读 Math.random() * (b-a) 返回的就是 0 &lt;= 数 &lt; b-a
// (1) (int)(a) &lt;= x &lt;= (int)(a + Math.random() * (b-a +1) )
// (2) 使用具体的数给小伙伴介绍 a = 2 b = 7
// (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6)
// Math.random()*6 返回的是 0 &lt;= x &lt; 6 小数
// 2 + Math.random()*6 返回的就是 2&lt;= x &lt; 8 小数
// (int)(2 + Math.random()*6) = 2 &lt;= x &lt;= 7
// (3) 公式就是 (int)(a + Math.random() * (b-a +1) )
for(int i = 0; i &lt; 100; i++) &#123;
	System.out.println((int)(2 + Math.random() * (7 - 2 + 1)));
&#125;
//max , min 返回最大值和最小值
int min = Math.min(1, 9);
int max = Math.max(45, 90);
System.out.println(&quot;min=&quot; + min);
System.out.println(&quot;max=&quot; + max);</code></pre>

<p>Math.round()返回的是long类型的数。</p>
<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><h3 id="常用方法（静态）"><a href="#常用方法（静态）" class="headerlink" title="常用方法（静态）"></a>常用方法（静态）</h3><p>需要引入Arrays类</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803160114605.png" alt="image-20240803160114605"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803160118325.png" alt="image-20240803160118325"></p>
<p>toString就是返回数组内容；sort可以对字符数组进行排序。</p>
<p>fill方法是把原数组里的所有元素全部替换成填充的数字。</p>
<p>fill(arr,fromIndex,toIndex,value)，在范围内的替换为value。</p>
<p>基本数据类型和包装类都可以调用Arrays的方法。</p>
<pre><code class="hljs plaintext">import java.util.Arrays;
public class c&#123;
    public static void main(String[] args)&#123;
        int[] arr = &#123;1, 2, 90, 123, 567&#125;;
// binarySearch 通过二分搜索法进行查找，要求必须排好
// 老韩解读
//1. 使用 binarySearch 二叉查找
//2. 要求该数组是有序的. 如果该数组是无序的，不能使用 binarySearch
//3. 如果数组中不存在该元素，就返回 return -(low + 1); //low为该元素应该插入的位置，以维持数组的排序顺序。
        int index = Arrays.binarySearch(arr, 567);
        System.out.println(&quot;index=&quot; + index);
//copyOf 数组元素的复制
// 老韩解读
//1. 从 arr 数组中，拷贝 arr.length 个元素到 newArr 数组中
//2. 如果拷贝的长度 &gt; arr.length 就在新数组的后面 增加 null
//3. 如果拷贝长度 &lt; 0 就抛出异常 NegativeArraySizeException
//4. 该方法的底层使用的是 System.arraycopy()
        int[] newArr = Arrays.copyOf(arr, arr.length);
        System.out.println(&quot;==拷贝执行完毕后==&quot;);
        System.out.println(Arrays.toString(newArr));
//fill 数组元素的填充
        int[] num = new int[]&#123;9,3,2&#125;;
//老韩解读
//1. 使用 99 去填充 num 数组，可以理解成是替换原理的元素
        Arrays.fill(num, 99);
        System.out.println(&quot;==num 数组填充后==&quot;);
        System.out.println(Arrays.toString(num));
//equals 比较两个数组元素内容是否完全一致
        int[] arr2 = &#123;1, 2, 90, 123&#125;;
//老韩解读
//1. 如果 arr 和 arr2 数组的元素一样，则方法 true;
//2. 如果不是完全一样，就返回 false
        boolean equals = Arrays.equals(arr, arr2);
        System.out.println(&quot;equals=&quot; + equals);
    &#125;
&#125;</code></pre>

<h3 id="sort排序的定制排序"><a href="#sort排序的定制排序" class="headerlink" title="sort排序的定制排序"></a>sort排序的定制排序</h3><p>sort是可以重载的，也可以通过传入一个<strong>接口 Comparator</strong> 实现定制排序，调用 定制排序 时，传入两个参数 (1) 排序的数组 arr &#x2F;&#x2F; (2) 实现了 Comparator 接口的匿名内部类 , 要求实现 compare 方法。</p>
<p>下面的是自己编写的冒泡排序方法加上实现定制排序的Comparator匿名类，用sort实现这种定制排序的原理和这种形式是一样的。</p>
<p><code>Arrays.sort(arr, new Comparator()&#123;&#125;)</code></p>
<pre><code class="hljs plaintext">import java.util.Arrays;
import java.util.Comparator;
public class c&#123;
    public static void main(String[] args)&#123;
        int[] arr = &#123;1, -1, 8, 0, 20&#125;;
//bubble01(arr);
        bubble02(arr, new Comparator() &#123;
            @Override
            public int compare(Object o1, Object o2) &#123;
                int i1 = (Integer) o1;
                int i2 = (Integer) o2;
                return i2 - i1;// return i2 - i1;
            &#125;
        &#125;);
        System.out.println(&quot;==定制排序后的情况==&quot;);
        System.out.println(Arrays.toString(arr));
    &#125;
    //使用冒泡完成排序
    public static void bubble01(int[] arr) &#123;
        int temp = 0;
        for (int i = 0; i &lt; arr.length - 1; i++) &#123;
            for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;
//从小到大
                if (arr[j] &gt; arr[j + 1]) &#123;
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                &#125;
            &#125;
        &#125;
    &#125;
    //结合冒泡 + 定制
    public static void bubble02(int[] arr, Comparator c) &#123;
        int temp = 0;
        for (int i = 0; i &lt; arr.length - 1; i++) &#123;
            for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;
//数组排序由 c.compare(arr[j], arr[j + 1])返回的值决定
                if (c.compare(arr[j], arr[j + 1]) &gt; 0) &#123;
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240803164210193.png" alt="image-20240803164210193"></p>
<pre><code class="hljs plaintext">import java.util.Arrays;
import java.util.Comparator;</code></pre>

<pre><code class="hljs plaintext">//(1)price 从大到小
 Arrays.sort(books, new Comparator() &#123;
     //这里是对 Book 数组排序，因此 o1 和 o2 就是 Book 对象
     @Override
     public int compare(Object o1, Object o2) &#123;
         Book book1 = (Book) o1;
         Book book2 = (Book) o2;
         double priceVal = book2.getPrice() - book1.getPrice();
         //这里老师进行了一个转换
         //如果发现返回结果和我们输出的不一致，就修改一下返回的 1 和 -1
         if(priceVal &gt; 0) &#123;
         return 1;
         &#125; else if(priceVal &lt; 0) &#123;
         return -1;
         &#125; else &#123;
         return 0;
         &#125;
     &#125;
 &#125;);</code></pre>

<pre><code class="hljs plaintext">//(2)price 从小到大
 Arrays.sort(books, new Comparator() &#123;
     //这里是对 Book 数组排序，因此 o1 和 o2 就是 Book 对象
     @Override
     public int compare(Object o1, Object o2) &#123;
         Book book1 = (Book) o1;
         Book book2 = (Book) o2;
         double priceVal = book2.getPrice() - book1.getPrice();
         if(priceVal &gt; 0) &#123;
         return -1;
         &#125; else if(priceVal &lt; 0) &#123;
         return 1;
         &#125; else &#123;
         return 0;
         &#125;
     &#125;
 &#125;);</code></pre>

<pre><code class="hljs plaintext">//(3)按照书名长度从大到小
Arrays.sort(books, new Comparator() &#123;
//这里是对 Book 数组排序，因此 o1 和 o2 就是 Book 对象
    @Override
    public int compare(Object o1, Object o2) &#123;
        Book book1 = (Book) o1;
        Book book2 = (Book) o2;
//要求按照书名的长度来进行排序
        return book2.getName().length() - book1.getName().length();
    &#125;
&#125;);</code></pre>

<h2 id="System-类-常用方法"><a href="#System-类-常用方法" class="headerlink" title="System 类-常用方法"></a>System 类-常用方法</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804155633708.png" alt="image-20240804155633708"></p>
<pre><code class="hljs plaintext">//exit 退出当前程序
 System.out.println(&quot;ok1&quot;);
 //老韩解读
 //1. exit(0) 表示程序退出
 //2. 0 表示一个状态 , 正常的状态
 System.exit(0);//
 System.out.println(&quot;ok2&quot;);
 //currentTimeMillens:返回当前时间距离 1970-1-1 的毫秒数
// 老韩解读:
System.out.println(System.currentTimeMillis());
//实现方法，调用 job 方法
//得到开始的时间
        long start = System.currentTimeMillis();
        job();
//得的结束的时间
        long end = System.currentTimeMillis();
        System.out.println(&quot;任务执行时间 &quot; + (end - start));</code></pre>

<p>arraycopy的翻前面的去看。</p>
<h2 id="BigInteger-和-BigDecimal-类"><a href="#BigInteger-和-BigDecimal-类" class="headerlink" title="BigInteger 和 BigDecimal 类"></a>BigInteger 和 BigDecimal 类</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804161408893.png" alt="image-20240804161408893"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804161509764.png" alt="image-20240804161509764"></p>
<p>使用方法都需要引入相关类。</p>
<pre><code class="hljs plaintext">import java.math.BigInteger;

//当我们编程中，需要处理很大的整数，long 不够用
//可以使用 BigInteger 的类来搞定
        BigInteger bigInteger = new BigInteger(&quot;23788888899999999999999999999&quot;);
        BigInteger bigInteger2 = new BigInteger(&quot;10099999999999999999999999999999999999999999999999999999999999999999999999999999999&quot;);
        System.out.println(bigInteger);
//老韩解读
//1. 在对 BigInteger 进行加减乘除的时候，需要使用对应的方法，不能直接进行 + - * /
//2. 可以创建一个 要操作的 BigInteger 然后进行相应操作
        BigInteger add = bigInteger.add(bigInteger2);
        System.out.println(add);//
        BigInteger subtract = bigInteger.subtract(bigInteger2);
        System.out.println(subtract);//减
        BigInteger multiply = bigInteger.multiply(bigInteger2);
        System.out.println(multiply);//乘
        BigInteger divide = bigInteger.divide(bigInteger2);
        System.out.println(divide);//除</code></pre>

<p><code>BigInteger add = bigInteger.add(bigInteger2);</code>代表的是bigInteger和bigInteger2相加，其它的类似。</p>
<p>BigDecimal类的方法调用和赋值与BigInteger类似。</p>
<pre><code class="hljs plaintext">import java.math.BigDecimal;</code></pre>

<p>需要注意的是除法。</p>
<pre><code class="hljs plaintext">//System.out.println(bigDecimal.divide(bigDecimal2));//可能抛出异常 ArithmeticException
//在调用 divide 方法时，指定精度即可. BigDecimal.ROUND_CEILING
//如果有无限循环小数，就会保留 分子 的精度
System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING));</code></pre>

<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804162504069.png" alt="image-20240804162504069"></p>
<pre><code class="hljs plaintext">import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class c &#123;
    public static void main(String[] args) throws ParseException &#123;  // 添加 throws ParseException
        //1. 获取当前系统时间
        //2. 这里的 Date 类是在 java.util 包
        //3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换
        Date d1 = new Date(); // 获取当前系统时间
		d1.getTime(); //返回的是一个 long 类型的值，表示自1970年1月1日00:00:00 UTC以来的毫秒数。
        System.out.println(&quot;当前日期=&quot; + d1);
        Date d2 = new Date(9234567); // 通过指定毫秒数得到时间
        System.out.println(&quot;d2=&quot; + d2); // 获取某个时间对应的毫秒数

        // 老韩解读
        //1. 创建 SimpleDateFormat 对象，可以指定相应的格式
        //2. 这里的格式使用的字母是规定好，不能乱写
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy 年 MM 月 dd 日 HH:mm:ss E&quot;);
        String format = sdf.format(d1); // format:将日期转换成指定格式的字符串
        System.out.println(&quot;当前日期=&quot; + format);

        // 老韩解读
        //1. 可以把一个格式化的 String 转成对应的 Date
        //2. 得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换
        //3. 在把 String -&gt; Date ， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常
        String s = &quot;2024 年 08 月 04 日 04:32:53 周日&quot;;
        Date parse = sdf.parse(s);
        System.out.println(&quot;parse=&quot; + sdf.format(parse));
    &#125;
&#125;</code></pre>

<p>如果想要将String转成对应的Date的话，需要引入<code>import java.text.ParseException;</code>，并且在主方法还需要抛出ParseException， <code>public static void main(String[] args) throws ParseException</code>，因为即使格式正确，但是<code>Date parse = sdf.parse(s);</code>这句在编译时仍会产生该异常，在主方法添加完后，如果格式不正确就会在运行时产生该异常，导致不能运行下去。</p>
<p><strong><code>date.getTime()</code></strong>:</p>
<ul>
<li><code>date.getTime()</code> 返回的是一个 <code>long</code> 类型的值，表示自1970年1月1日00:00:00 UTC以来的毫秒数。</li>
</ul>
<pre><code class="hljs plaintext">//1. 创建 SimpleDateFormat 对象，可以指定相应的格式
        //2. 这里的格式使用的字母是规定好，不能乱写
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy 年 MM 月 dd 日 HH:mm:ss E&quot;);</code></pre>

<p>格式不是固定的，字母是固定的，格式是自己编写的。</p>
<p>h代表12小时制，H代表24小时制，但输入时都需按照24小时制输入。</p>
<h3 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804165247557.png" alt="image-20240804165247557"></p>
<pre><code class="hljs plaintext">import java.util.Calendar;

public class c &#123;
    public static void main(String[] args)&#123;
        //1. Calendar 是一个抽象类， 并且构造器是 private
//2. 可以通过 getInstance() 来获取实例
//3. 提供大量的方法和字段提供给程序员
        //4. Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)
//5. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=&gt; Calendar.HOUR_OF_DAY
        Calendar c = Calendar.getInstance(); //创建日历类对象//比较简单，自由
        System.out.println(&quot;c=&quot; + c);
//2.获取日历对象的某个日历字段
        System.out.println(&quot;年：&quot; + c.get(Calendar.YEAR));
// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号
        System.out.println(&quot;月：&quot; + (c.get(Calendar.MONTH) + 1));
        System.out.println(&quot;日：&quot; + c.get(Calendar.DAY_OF_MONTH));
        System.out.println(&quot;小时：&quot; + c.get(Calendar.HOUR));
        System.out.println(&quot;分钟：&quot; + c.get(Calendar.MINUTE));
        System.out.println(&quot;秒：&quot; + c.get(Calendar.SECOND));
//Calender 没有专门的格式化方法，所以需要程序员自己来组合显示
        System.out.println(c.get(Calendar.YEAR) + &quot;-&quot; + (c.get(Calendar.MONTH) + 1) + &quot;-&quot; +
                c.get(Calendar.DAY_OF_MONTH) +
                &quot; &quot; + c.get(Calendar.HOUR_OF_DAY) + &quot;:&quot; + c.get(Calendar.MINUTE) + &quot;:&quot; + c.get(Calendar.SECOND) );
    &#125;
&#125;</code></pre>

<h3 id="第三代日期类（感觉比较好用）"><a href="#第三代日期类（感觉比较好用）" class="headerlink" title="第三代日期类（感觉比较好用）"></a>第三代日期类（感觉比较好用）</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804175601112.png" alt="image-20240804175601112"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804175615009.png" alt="image-20240804175615009"></p>
<pre><code class="hljs plaintext">import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

public class c &#123;
    public static void main(String[] args)&#123;
        //1. 使用 now() 返回表示当前日期时间的 对象
        LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()
        System.out.println(ldt);
//2. 使用 DateTimeFormatter 对象来进行格式化
// 创建 DateTimeFormatter 对象
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String format = dateTimeFormatter.format(ldt);
        System.out.println(&quot;格式化的日期=&quot; + format);
        System.out.println(&quot;年=&quot; + ldt.getYear());
        System.out.println(&quot;月=&quot; + ldt.getMonth());
        System.out.println(&quot;月=&quot; + ldt.getMonthValue());
        System.out.println(&quot;日=&quot; + ldt.getDayOfMonth());
        System.out.println(&quot;时=&quot; + ldt.getHour());
        System.out.println(&quot;分=&quot; + ldt.getMinute());
        System.out.println(&quot;秒=&quot; + ldt.getSecond());
        LocalDate now = LocalDate.now(); //可以获取年月日
        LocalTime now2 = LocalTime.now();//获取到时分秒
//提供 plus 和 minus 方法可以对当前时间进行加或者减
//看看 890 天后，是什么时候 把 年月日-时分秒
        LocalDateTime localDateTime = ldt.plusDays(890);
        System.out.println(&quot;890 天后=&quot; + dateTimeFormatter.format(localDateTime));
//看看在 3456 分钟前是什么时候，把 年月日-时分秒输出
        LocalDateTime localDateTime2 = ldt.minusMinutes(3456);
        System.out.println(&quot;3456 分钟前 日期=&quot; + dateTimeFormatter.format(localDateTime2));
    &#125;
&#125;</code></pre>

<p>plusDays，minusMinutes应该就是plus和minus后面加时间表示后面括号里的数字代表什么。</p>
<h3 id="DateTimeFormatter-格式日期类"><a href="#DateTimeFormatter-格式日期类" class="headerlink" title="DateTimeFormatter 格式日期类"></a>DateTimeFormatter 格式日期类</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804180459515.png" alt="image-20240804180459515"></p>
<p>SimpleDateFormate用于第一代日期类。</p>
<h3 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240804200138404.png" alt="image-20240804200138404"></p>
<p>表示的是格林威治时间。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805113308968.png" alt="image-20240805113308968"></p>
<h2 id="集合的框架体系"><a href="#集合的框架体系" class="headerlink" title="集合的框架体系"></a>集合的框架体系</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805113551076.png" alt="image-20240805113551076"></p>
<p>迭代器（Iterable）：是所有集合的基础，定义了遍历集合元素的方法。</p>
<p>集合（Collection）：是Java集合框架的根接口，提供了基本的集合操作，如添加、删除和检查元素。</p>
<p>列表（List）：是Collection的子接口，支持元素的随机访问，并允许在列表中插入和删除元素。</p>
<p>向量（Vector）：是List的一个实现，提供了线程安全的操作，但性能上可能不如ArrayList。</p>
<p>数组列表（ArrayList）：是List的另一个实现，使用动态数组来存储元素，提供了快速访问和修改的功能。</p>
<p>链表（LinkedList）：也是List的一个实现，使用链表结构存储元素，适用于频繁的插入和删除操作。</p>
<p>树集（TreeSet）：是基于红黑树实现的Set接口，它确保集合元素处于排序状态，不允许重复元素。</p>
<p>哈希集（HashSet）：是Set接口的另一个实现，不保证集合的迭代顺序，且允许null元素的存在。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805113556309.png" alt="image-20240805113556309"></p>
<p>Map：是Java中最基础的数据结构之一，提供了键值对的存储方式。</p>
<p>HashMap：是Map接口的一个常用实现，通过哈希表来存储键值对，提供了较快的访问速度。</p>
<p>TreeMap：是Map接口的另一种实现，它使用红黑树来存储键值对，可以确保元素按照键的顺序进行排序。</p>
<p>Hashtable：是Java早期版本中提供的一个线程安全的哈希表实现，但因其性能较低，在现代Java开发中较少使用。</p>
<p>LinkedHashMap：保留了插入顺序的HashMap实现，它维护了一个双向链表来记录元素的插入顺序。</p>
<p>Properties：是Java标准库中的一个类，用于处理键值对，通常用于配置文件或作为字典使用。</p>
<pre><code class="hljs plaintext">1. 集合主要是两组(单列集合 , 双列集合)
2. Collection 接口有两个重要的子接口 List，Set , 他们的实现子类都是单列集合
3. Map 接口的实现子类 是双列集合，存放的 K-V</code></pre>

<pre><code class="hljs plaintext">import java.util.ArrayList;
import java.util.HashMap;

public class c &#123;
    public static void main(String[] args)&#123;
        ArrayList arrayList = new ArrayList();
        arrayList.add(&quot;jack&quot;);
        arrayList.add(&quot;tom&quot;);
        HashMap hashMap = new HashMap();
        hashMap.put(&quot;NO1&quot;, &quot;北京&quot;);
        hashMap.put(&quot;NO2&quot;, &quot;上海&quot;);
    &#125;
&#125;</code></pre>

<h2 id="Collection-接口和常用方法"><a href="#Collection-接口和常用方法" class="headerlink" title="Collection 接口和常用方法"></a>Collection 接口和常用方法</h2><h3 id="Collection-接口实现类的特点"><a href="#Collection-接口实现类的特点" class="headerlink" title="Collection 接口实现类的特点"></a>Collection 接口实现类的特点</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805153109897.png" alt="image-20240805153109897"></p>
<p>Collection 接口常用方法,以实现子类 ArrayList 来演示</p>
<pre><code class="hljs plaintext">import java.util.ArrayList;
import java.util.List;

public class c &#123;
    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)
    public static void main(String[] args)&#123;
        List list = new ArrayList();
// add:添加单个元素
        list.add(&quot;jack&quot;);
        list.add(10);//list.add(new Integer(10))
        list.add(true);
        System.out.println(&quot;list=&quot; + list);
// remove:删除指定元素，并返回该元素
//list.remove(0);//删除第一个元素
        list.remove(true);//指定删除某个元素
        System.out.println(&quot;list=&quot; + list);
// contains:查找元素是否存在
        System.out.println(list.contains(&quot;jack&quot;));//T
// size:获取元素个数
        System.out.println(list.size());//2
// isEmpty:判断是否为空
        System.out.println(list.isEmpty());//F
// clear:清空
        list.clear();
        System.out.println(&quot;list=&quot; + list);
// addAll:添加多个元素
        ArrayList list2 = new ArrayList();
        list2.add(&quot;红楼梦&quot;);
        list2.add(&quot;三国演义&quot;);
        list.addAll(list2);//list.addAll(&quot;红楼梦&quot;,&quot;三国演义&quot;)，这样是错的
        System.out.println(&quot;list=&quot; + list);
// containsAll:查找多个元素是否都存在
        System.out.println(list.containsAll(list2));//T
// removeAll：删除多个元素
        list.add(&quot;聊斋&quot;);
        list.removeAll(list2);
        System.out.println(&quot;list=&quot; + list);//[聊斋]
// 说明：以 ArrayList 实现类来演示.
    &#125;
&#125;</code></pre>

<p>remove:删除指定元素后数组列表里的元素会自动填补空缺。</p>
<p>remove括号里面加的是索引的话（索引&gt;内容，如果存储1的话，那么remove(1)删除的是序列为1的元素而不是1），会返回一个Object型的该索引对应的数据，但如果后面加的是对象的话就不会返回。</p>
<p>原文里面用<code>@SuppressWarnings(&#123;&quot;all&quot;&#125;)</code>抑制全部警告，我感觉这样不好，所以就一个个抑制没什么大问题的警报，<code>@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</code>，这两个是由List以及相关方法引起的（也适用于下面的内容，Set、Map），与语法对错无关。</p>
<h3 id="Collection-接口遍历元素方式"><a href="#Collection-接口遍历元素方式" class="headerlink" title="Collection 接口遍历元素方式"></a>Collection 接口遍历元素方式</h3><h4 id="使用-Iterator-迭代器"><a href="#使用-Iterator-迭代器" class="headerlink" title="使用 Iterator(迭代器)"></a>使用 Iterator(迭代器)</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805160915142.png" alt="image-20240805160915142"></p>
<p>Collection的子接口例如List等也都可以使用迭代器。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805160927232.png" alt="image-20240805160927232"></p>
<p>coll是Collection的一个对象。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805160957407.png" alt="image-20240805160957407"></p>
<pre><code class="hljs plaintext">import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        Collection col = new ArrayList();
        col.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1));
        col.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1));
        col.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6));
//System.out.println(&quot;col=&quot; + col);
//现在老师希望能够遍历 col 集合
//1. 先得到 col 对应的 迭代器
        Iterator iterator = col.iterator();
//2. 使用 while 循环遍历
// while (iterator.hasNext()) &#123;//判断是否还有数据
// //返回下一个元素，类型是 Object
// Object obj = iterator.next();
// System.out.println(&quot;obj=&quot; + obj);
// &#125;
//老师教大家一个快捷键，快速生成 while =&gt; itit
//显示所有的快捷键的的快捷键 ctrl + j
        while (iterator.hasNext()) &#123;
            Object obj = iterator.next();
            System.out.println(&quot;obj=&quot; + obj);
        &#125;
//3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素
// iterator.next();//NoSuchElementException
//4. 如果希望再次遍历，需要重置我们的迭代器
        iterator = col.iterator();
        System.out.println(&quot;===第二次遍历===&quot;);
        while (iterator.hasNext()) &#123;
            Object obj = iterator.next();
            System.out.println(&quot;obj=&quot; + obj);
        &#125;
    &#125;
&#125;
class Book &#123;
    private String name;
    private String author;
    private double price;
    public Book(String name, String author, double price) &#123;
        this.name = name;
        this.author = author;
        this.price = price;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Book&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, author=&#x27;&quot; + author + &#x27;\&#x27;&#x27; +
                &quot;, price=&quot; + price +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p><code>System.out.println(&quot;col=&quot; + col);</code>仍然可以一次性输出col的内容。</p>
<h4 id="for-循环增强"><a href="#for-循环增强" class="headerlink" title="for 循环增强"></a>for 循环增强</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805161907452.png" alt="image-20240805161907452"></p>
<pre><code class="hljs plaintext">List list = new ArrayList();
list.add(new Dog(&quot;小黑&quot;, 3));
list.add(new Dog(&quot;大黄&quot;, 100));
list.add(new Dog(&quot;大壮&quot;, 8));
//先使用 for 增强
for (Object dog : list) &#123;
	System.out.println(&quot;dog=&quot; + dog);
&#125;
//使用迭代器
System.out.println(&quot;===使用迭代器来遍历===&quot;);
Iterator iterator = list.iterator();</code></pre>

<p><code>for (Object dog : list)</code>这个for语句里的对象类型必须是Object。因为元素在存入list中的时候会转化为Object类型。</p>
<h2 id="List-接口和常用方法"><a href="#List-接口和常用方法" class="headerlink" title="List 接口和常用方法"></a>List 接口和常用方法</h2><h3 id="介绍和常用方法"><a href="#介绍和常用方法" class="headerlink" title="介绍和常用方法"></a>介绍和常用方法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805165417212.png" alt="image-20240805165417212"></p>
<p>索引是从 0 开始的。</p>
<pre><code class="hljs plaintext">import java.util.ArrayList;
import java.util.List;
public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        List list = new ArrayList();
        list.add(&quot;张三丰&quot;);
        list.add(&quot;贾宝玉&quot;);
        // void add(int index, Object ele):在 index 位置插入 ele 元素
//在 index = 1 的位置插入一个对象
        list.add(1, &quot;韩顺平&quot;);
        System.out.println(&quot;list=&quot; + list);
        // boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来
        List list2 = new ArrayList();
        list2.add(&quot;jack&quot;);
        list2.add(&quot;tom&quot;);
        list.addAll(1, list2);
        System.out.println(&quot;list=&quot; + list);
// Object get(int index):获取指定 index 位置的元素
//说过
// int indexOf(Object obj):返回 obj 在集合中首次出现的位置
        System.out.println(list.indexOf(&quot;tom&quot;));//2
// int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置
        list.add(&quot;韩顺平&quot;);
        System.out.println(&quot;list=&quot; + list);
        System.out.println(list.lastIndexOf(&quot;韩顺平&quot;));
// Object remove(int index):移除指定 index 位置的元素，并返回此元素
        list.remove(0);
        System.out.println(&quot;list=&quot; + list);
// Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换. list.set(1, &quot;玛丽&quot;);
        System.out.println(&quot;list=&quot; + list);
// List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合
// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex
        List returnlist = list.subList(0, 2);
        System.out.println(&quot;returnlist=&quot; + returnlist);
    &#125;
&#125;</code></pre>

<p><code>void add(int index, Object ele):在 index 位置插入 ele 元素</code>原索引位置的元素依次后移。</p>
<p><code>list.getLast()</code>：取最后一个元素。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240823223412800.png" alt="image-20240823223412800"></p>
<h3 id="List-的三种遍历方式"><a href="#List-的三种遍历方式" class="headerlink" title="List 的三种遍历方式"></a>List 的三种遍历方式</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805170327199.png" alt="image-20240805170327199"></p>
<pre><code class="hljs plaintext">使用普通 for
for (int i = 0; i &lt; list.size(); i++) &#123;	
	System.out.println(&quot;对象=&quot; + list.get(i));
&#125;</code></pre>

<h2 id="ArrayList-底层结构和源码分析"><a href="#ArrayList-底层结构和源码分析" class="headerlink" title="ArrayList 底层结构和源码分析"></a>ArrayList 底层结构和源码分析</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805171457469.png" alt="image-20240805171457469"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805171512437.png" alt="image-20240805171512437"></p>
<p>指定大小：List list &#x3D; new ArrayList(5);</p>
<p>想看源码去pdf里面看。</p>
<h2 id="Vector-底层结构和源码剖析"><a href="#Vector-底层结构和源码剖析" class="headerlink" title="Vector 底层结构和源码剖析"></a>Vector 底层结构和源码剖析</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805193045404.png" alt="image-20240805193045404"></p>
<p>想看源码自己去pdf里面看。</p>
<p>Vector 和 ArrayList 的比较</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805193215719.png" alt="image-20240805193215719"></p>
<h2 id="LinkedList-底层结构"><a href="#LinkedList-底层结构" class="headerlink" title="LinkedList 底层结构"></a>LinkedList 底层结构</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805193504840.png" alt="image-20240805193504840"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805193519644.png" alt="image-20240805193519644"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240805194122247.png" alt="image-20240805194122247"></p>
<h2 id="Set-接口和常用方法"><a href="#Set-接口和常用方法" class="headerlink" title="Set 接口和常用方法"></a>Set 接口和常用方法</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806103202514.png" alt="image-20240806103202514"></p>
<p>和 List 接口一样, Set 接口也是 Collection 的子接口，因此，常用方法和 Collection 接口一样。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806103231006.png" alt="image-20240806103231006"></p>
<h2 id="Set-接口实现类"><a href="#Set-接口实现类" class="headerlink" title="Set 接口实现类"></a>Set 接口实现类</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><h4 id="基础-7"><a href="#基础-7" class="headerlink" title="基础"></a>基础</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806103343391.png" alt="image-20240806103343391"></p>
<p>可以连续存放相同的值，程序不会报错，但最后只会存储第一个值，就是只存储一个。</p>
<h4 id="底层机制-存储自定义类时的注意事项"><a href="#底层机制-存储自定义类时的注意事项" class="headerlink" title="底层机制+存储自定义类时的注意事项"></a>底层机制+存储自定义类时的注意事项</h4><p>想看源码去pdf。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806112731405.png" alt="image-20240806112731405"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806112707254.png" alt="image-20240806112707254"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806112715287.png" alt="image-20240806112715287"></p>
<p>哈希值一样后根据equals方法判断内容是否相同，因此要注意存储的对象类型是否有覆盖equals方法，若没有则按Object类的equals方法来，即比较两个对象的引用（内存地址）是否相同。</p>
<pre><code class="hljs plaintext">import java.util.HashSet;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        HashSet set = new HashSet();
        //说明
//1. 在执行 add 方法后，会返回一个 boolean 值
//2. 如果添加成功，返回 true, 否则返回 false
//3. 可以通过 remove 指定删除哪个对象
        System.out.println(set.add(&quot;john&quot;));//T
        System.out.println(set.add(&quot;lucy&quot;));//T
        System.out.println(set.add(&quot;john&quot;));//F
        System.out.println(set.add(&quot;jack&quot;));//T
        System.out.println(set.add(&quot;Rose&quot;));//T
        set.remove(&quot;john&quot;);
        System.out.println(&quot;set=&quot; + set);//3 个
//
        set = new HashSet();
        System.out.println(&quot;set=&quot; + set);//0
//4 Hashset 不能添加相同的元素/数据?
        set.add(&quot;lucy&quot;);//添加成功
        set.add(&quot;lucy&quot;);//加入不了
        set.add(new Dog(&quot;tom&quot;));//OK
        set.add(new Dog(&quot;tom&quot;));//Ok
        System.out.println(&quot;set=&quot; + set);
//在加深一下. 非常经典的面试题.
        //看源码，做分析， 先给小伙伴留一个坑，以后讲完源码，你就了然
//去看他的源码，即 add 到底发生了什么?=&gt; 底层机制.
        set.add(new String(&quot;hsp&quot;));//ok
        set.add(new String(&quot;hsp&quot;));//加入不了.
        System.out.println(&quot;set=&quot; + set);
    &#125;
&#125;
class Dog &#123; //定义了 Dog 类
    private String name;
    public Dog(String name) &#123;
        this.name = name;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Dog&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p>在Java中，<code>HashSet</code>是基于哈希表实现的集合，它确保集合中的元素是唯一的，即不能添加相同的元素（根据元素的<code>equals()</code>和<code>hashCode()</code>方法判断）。</p>
<p>然而，在示例中，<code>Dog</code>类没有覆盖<code>equals()</code>和<code>hashCode()</code>方法。因此，默认情况下，<code>HashSet</code>会使用<code>Object</code>类中的<code>equals()</code>和<code>hashCode()</code>方法来比较对象的引用是否相等。<code>HashSet</code>使用默认的<code>Object</code>类的实现，这将比较对象的引用（内存地址）。在Java中，对象的引用不同即使其内容相同，也会被视为不同的对象。</p>
<p>具体到代码，当添加两个相同名称的<code>Dog</code>对象时，例如<code>new Dog(&quot;tom&quot;)</code>，由于每次使用<code>new</code>关键字创建一个新的对象实例，这两个对象的引用是不同的。即使它们的内容相同，它们在内存中的地址也不同。</p>
<p>因此，<code>HashSet</code>会将这两个对象视为不同的元素，并将它们都添加到集合中。</p>
<p>在Java中，<code>String</code>类覆盖了<code>equals()</code>和<code>hashCode()</code>方法，String类的hashCode方法是根据字符串的内容来计算哈希值的。这意味着两个内容相同的<code>String</code>对象会被认为是相等的，并且它们的哈希码也相同。因此，当你尝试将两个内容相同的<code>String</code>对象添加到<code>HashSet</code>中时，第二个<code>String</code>对象不会被添加，因为<code>HashSet</code>检测到集合中已经存在一个相同的元素。</p>
<p>如果希望<code>HashSet</code>根据对象的内容（比如<code>Dog</code>对象的名称）来判断是否相等，则需要在<code>Dog</code>类中覆盖<code>equals()</code>和<code>hashCode()</code>方法。例如，可以根据<code>name</code>属性来实现这两个方法，这样相同名称的<code>Dog</code>对象就会被视为相等，不能重复添加到<code>HashSet</code>中。</p>
<pre><code class="hljs plaintext">class Dog &#123;
    private String name;

    public Dog(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Dog dog = (Dog) o;
        return Objects.equals(name, dog.name);
    &#125;

    @Override
    public int hashCode() &#123;
        return Objects.hash(name);
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Dog&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p>为什么没有重写hashCode方法还是会存储两个相同的Dog对象。</p>
<p>在这种情况下，即使两个<code>Dog</code>对象的<code>name</code>属性相同，它们的哈希码仍然是基于<code>Object</code>类的<code>hashCode()</code>方法，该方法返回对象的内存地址。因此，两个相同<code>name</code>的<code>Dog</code>对象会有不同的哈希码，被存储在不同的哈希桶中。而HashSet的存储机制是当俩个哈希码相同的时候才会调用equals方法进行判断，若两个对象的哈希码都不同则存储在两个不同的地方，不会调用equals。</p>
<p><code>Objects.equals(Object a, Object b)</code>方法会执行以下操作：</p>
<ol>
<li><p>如果<code>a</code>和<code>b</code>都是<code>null</code>，返回<code>true</code>。</p>
</li>
<li><p>如果只有一个是<code>null</code>，返回<code>false</code>。</p>
</li>
<li><p>否则，返回<code>a.equals(b)</code>的结果。</p>
<p>使用equals还避免了<code>name</code>字段为<code>null</code>时的空指针异常。</p>
</li>
</ol>
<p>若自定义类有两个属性，两个属性都相同则为同一对象，如下覆盖，其余类似</p>
<pre><code class="hljs plaintext">@Override
public boolean equals(Object o) &#123;
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Employee employee = (Employee) o;
    return age == employee.age &amp;&amp;
    Objects.equals(name, employee.name);
&#125;
@Override
public int hashCode() &#123;
	return Objects.hash(name, age);
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806113412779.png" alt="image-20240806113412779"></p>
<h3 id="LinkedHashSet-double类的compare"><a href="#LinkedHashSet-double类的compare" class="headerlink" title="LinkedHashSet+double类的compare	"></a>LinkedHashSet+double类的compare	<img src="/../source/imgs/$%7Bfiilname%7D/image-20240806154342854.png" alt="image-20240806154342854"></h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806154547157.png" alt="image-20240806154547157"></p>
<p><code>Double</code>类中的<code>compare</code>方法用于比较两个<code>double</code>值。它返回一个整数，指示第一个<code>double</code>值是等于、少于还是大于第二个<code>double</code>值。这种方法可以避免浮点数直接比较时可能出现的误差问题。</p>
<pre><code class="hljs plaintext">Double.compare(double d1, double d2)</code></pre>

<p>返回值：</p>
<ul>
<li>如果<code>d1</code>等于<code>d2</code>，返回<code>0</code>。</li>
<li>如果<code>d1</code>小于<code>d2</code>，返回一个负数。</li>
<li>如果<code>d1</code>大于<code>d2</code>，返回一个正数。</li>
</ul>
<h2 id="Map-接口和常用方法"><a href="#Map-接口和常用方法" class="headerlink" title="Map 接口和常用方法"></a>Map 接口和常用方法</h2><h3 id="基础-8"><a href="#基础-8" class="headerlink" title="基础"></a>基础</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806201214488.png" alt="image-20240806201214488"></p>
<p>当有相同的 k , 就等价于替换。</p>
<pre><code class="hljs plaintext">import java.util.HashMap;
import java.util.Map;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        Map map = new HashMap();
        map.put(&quot;no1&quot;, &quot;韩顺平&quot;);//k-v
        map.put(&quot;no2&quot;, &quot;张无忌&quot;);//k-v
        map.put(&quot;no1&quot;, &quot;张三丰&quot;);//当有相同的 k , 就等价于替换. 
        map.put(&quot;no3&quot;, &quot;张三丰&quot;);//k-v
        map.put(null, null); //k-v
        map.put(null, &quot;abc&quot;); //等价替换
        map.put(&quot;no4&quot;, null); //k-v
        map.put(&quot;no5&quot;, null); //k-v
        map.put(1, &quot;赵敏&quot;);//k-v
        map.put(new Object(), &quot;金毛狮王&quot;);//k-v
// 通过 get 方法，传入 key ,会返回对应的 value
        System.out.println(map.get(&quot;no2&quot;));//张无忌
        System.out.println(&quot;map=&quot; + map);
    &#125;
&#125;</code></pre>

<h3 id="Map-接口常用方法"><a href="#Map-接口常用方法" class="headerlink" title="Map 接口常用方法"></a>Map 接口常用方法</h3><pre><code class="hljs plaintext">import java.util.HashMap;
import java.util.Map;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        Map map = new HashMap();
        map.put(&quot;邓超&quot;, new Book(&quot;&quot;, 100));//OK
        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);//替换-&gt; 一会分析源码
        map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);//OK
        map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);//OK
        map.put(&quot;刘令博&quot;, null);//OK
        map.put(null, &quot;刘亦菲&quot;);//OK
        map.put(&quot;鹿晗&quot;, &quot;关晓彤&quot;);//OK
        map.put(&quot;hsp&quot;, &quot;hsp 的老婆&quot;);
        System.out.println(&quot;map=&quot; + map);
// remove:根据键删除映射关系
        map.remove(null);
        System.out.println(&quot;map=&quot; + map);
// get：根据键获取值
        Object val = map.get(&quot;鹿晗&quot;);
        System.out.println(&quot;val=&quot; + val);
// size:获取元素个数
        System.out.println(&quot;k-v=&quot; + map.size());
// isEmpty:判断个数是否为 0
        System.out.println(map.isEmpty());//F
// clear:清除 k-v
//map.clear();
        System.out.println(&quot;map=&quot; + map);
// containsKey:查找键是否存在
        System.out.println(&quot;结果=&quot; + map.containsKey(&quot;hsp&quot;));//T
    &#125;
&#125;
class Book &#123;
    private String name;
    private int num;
    public Book(String name, int num) &#123;
        this.name = name;
        this.num = num;
    &#125;
&#125;</code></pre>

<p>遍历方法：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806204935015.png" alt="image-20240806204935015"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806204948094.png" alt="image-20240806204948094"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240806203631348.png" alt="image-20240806203631348"></p>
<pre><code class="hljs plaintext">import java.util.*;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        Map map = new HashMap();
        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);
        map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);
        map.put(&quot;刘令博&quot;, null);
        map.put(null, &quot;刘亦菲&quot;);
        map.put(&quot;鹿晗&quot;, &quot;关晓彤&quot;);
//第一组: 先取出 所有的 Key , 通过 Key 取出对应的 Value
        Set keyset = map.keySet();
//(1) 增强 for
        System.out.println(&quot;-----第一种方式-------&quot;);
        for (Object key : keyset) &#123;
            System.out.println(key + &quot;-&quot; + map.get(key));
        &#125;
//(2) 迭代器
        System.out.println(&quot;----第二种方式--------&quot;);
        Iterator iterator = keyset.iterator();
        while (iterator.hasNext()) &#123;
            Object key = iterator.next();
            System.out.println(key + &quot;-&quot; + map.get(key));
        &#125;
//第二组: 把所有的 values 取出
        Collection values = map.values();
//这里可以使用所有的 Collections 使用的遍历方法
//(1) 增强 for
        System.out.println(&quot;---取出所有的 value 增强 for----&quot;);
        for (Object value : values) &#123;
            System.out.println(value);
        &#125;
//(2) 迭代器
        System.out.println(&quot;---取出所有的 value 迭代器----&quot;);
        Iterator iterator2 = values.iterator();
        while (iterator2.hasNext()) &#123;
            Object value = iterator2.next();
            System.out.println(value);
        &#125;
//第三组: 通过 entrySet 来获取 k-v
        Set entrySet = map.entrySet();// entrySet&lt;Map.Entry&lt;K,V&gt;&gt;
//(1) 增强 for
        System.out.println(&quot;----使用 EntrySet 的 for 增强(第 3 种)----&quot;);
        for (Object entry : entrySet) &#123;
//将 entry 转成 Map.Entry
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + &quot;-&quot; + m.getValue());
        &#125;
//(2) 迭代器
        System.out.println(&quot;----使用 EntrySet 的 迭代器(第 4 种)----&quot;);
        Iterator iterator3 = entrySet.iterator();
        while (iterator3.hasNext()) &#123;
            Object entry = iterator3.next();
//System.out.println(next.getClass());//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)
//向下转型 Map.Entry
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + &quot;-&quot; + m.getValue());
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="Map-接口实现类"><a href="#Map-接口实现类" class="headerlink" title="Map 接口实现类"></a>Map 接口实现类</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808110338660.png" alt="image-20240808110338660"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808110429658.png" alt="image-20240808110429658"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808110554802.png" alt="image-20240808110554802"></p>
<p>源码看pdf</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808110724566.png" alt="image-20240808110724566"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808110754123.png" alt="image-20240808110754123"></p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808111227573.png" alt="image-20240808111227573"></p>
<p>key和value也不能为null。</p>
<p>没教第3、4点。</p>
<h2 id="开发中如何选择集合实现类"><a href="#开发中如何选择集合实现类" class="headerlink" title="开发中如何选择集合实现类"></a>开发中如何选择集合实现类</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808111527052.png" alt="image-20240808111527052"></p>
<p><strong>TreeSet</strong></p>
<pre><code class="hljs plaintext">import java.util.Comparator;
import java.util.TreeSet;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        //1. 当我们使用无参构造器，创建 TreeSet 时，仍然是无序的
        //2. 老师希望添加的元素，按照字符串大小来排序
        //3. 使用 TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)
        // 并指定排序规则
        //4. 简单看看源码
        //老韩解读
        /*
        1. 构造器把传入的比较器对象，赋给了 TreeSet 的底层的 TreeMap 的属性 this.comparator
        public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;
            this.comparator = comparator;
        &#125;
        2. 在 调用 treeSet.add(&quot;tom&quot;), 在底层会执行到
        if (cpr != null) &#123;//cpr 就是我们的匿名内部类(对象)
        do &#123;
             parent = t;
            //动态绑定到我们的匿名内部类(对象)compare
            cmp = cpr.compare(key, t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else //如果相等，即返回 0,这个 Key 就没有加入
                return t.setValue(value);
            &#125; while (t != null);    
        &#125;
        */
        // TreeSet treeSet = new TreeSet();
        TreeSet treeSet = new TreeSet(new Comparator() &#123;
            @Override
            public int compare(Object o1, Object o2) &#123;
//下面 调用 String 的 compareTo 方法进行字符串大小比较
//如果老韩要求加入的元素，按照长度大小排序
//return ((String) o2).compareTo((String) o1);
                return ((String) o1).length() - ((String) o2).length();
            &#125;
        &#125;);
//添加数据.
        treeSet.add(&quot;jack&quot;);
        treeSet.add(&quot;tom&quot;);//3
        treeSet.add(&quot;sp&quot;);
        treeSet.add(&quot;a&quot;);
        treeSet.add(&quot;abc&quot;);//3
        System.out.println(&quot;treeSet=&quot; + treeSet);
    &#125;
&#125;</code></pre>

<p>根据源码，当想加入的两个对象有compare判断返回0时就只会添加第一个。例子里的”tom”和”abc”就只添加了”tom”。</p>
<p>如果只是<code>TreeSet treeSet = new TreeSet();</code>就是没有添加Comparator的时候，是按自然顺序排列的。</p>
<p><strong>TreeMap</strong></p>
<p>道理和TreeSet一样。</p>
<h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808153830100.png" alt="image-20240808153830100"></p>
<h3 id="排序操作-Collections里的static方法"><a href="#排序操作-Collections里的static方法" class="headerlink" title="排序操作(Collections里的static方法)"></a>排序操作(Collections里的static方法)</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808154056938.png" alt="image-20240808154056938"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240808154617956.png" alt="image-20240808154617956"></p>
<pre><code class="hljs plaintext">import java.util.*;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        //创建 ArrayList 集合，用于测试.
        List list = new ArrayList();
        list.add(&quot;tom&quot;);
        list.add(&quot;smith&quot;);
        list.add(&quot;king&quot;);
        list.add(&quot;milan&quot;);
        list.add(&quot;tom&quot;);
// reverse(List)：反转 List 中元素的顺序
        Collections.reverse(list);
        System.out.println(&quot;list=&quot; + list);
// shuffle(List)：对 List 集合元素进行随机排序
// for (int i = 0; i &lt; 5; i++) &#123;
// Collections.shuffle(list);
// System.out.println(&quot;list=&quot; + list);
// &#125;
// sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序
        Collections.sort(list);
        System.out.println(&quot;自然排序后&quot;);
        System.out.println(&quot;list=&quot; + list);
// sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
//我们希望按照 字符串的长度大小排序
        Collections.sort(list, new Comparator() &#123;
            @Override
            public int compare(Object o1, Object o2) &#123;
//可以加入校验代码.
                return ((String) o2).length() - ((String) o1).length();//注意是o2-o1
            &#125;
        &#125;);
        System.out.println(&quot;字符串长度大小排序=&quot; + list);//从长到短排
// swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换
//比如
        Collections.swap(list, 0, 1);
        System.out.println(&quot;交换后的情况&quot;);
        System.out.println(&quot;list=&quot; + list);
//Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
        System.out.println(&quot;自然顺序最大元素=&quot; + Collections.max(list));
//Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素
//比如，我们要返回长度最大的元素
        Object maxObject = Collections.max(list, new Comparator() &#123;
            @Override
            public int compare(Object o1, Object o2) &#123;
                return ((String)o1).length() - ((String)o2).length();
            &#125;//看源码得知应该是如果compare(o1,o2)&gt;0,则等于o1
        &#125;);
        System.out.println(&quot;长度最大的元素=&quot; + maxObject);
//Object min(Collection)
//Object min(Collection，Comparator)
//上面的两个方法，参考 max 即可
//int frequency(Collection，Object)：返回指定集合中指定元素的出现次数
        System.out.println(&quot;tom 出现的次数=&quot; + Collections.frequency(list, &quot;tom&quot;));
//void copy(List dest,List src)：将 src 中的内容复制到 dest 中
        ArrayList dest = new ArrayList();
//为了完成一个完整拷贝，我们需要先给 dest 赋值，大小和 list.size()一样
        for(int i = 0; i &lt; list.size(); i++) &#123;
            dest.add(&quot;&quot;);
        &#125;
//拷贝
        Collections.copy(dest, list);
        System.out.println(&quot;dest=&quot; + dest);
//boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值
//如果 list 中，有 tom 就替换成 汤姆
        Collections.replaceAll(list, &quot;tom&quot;, &quot;汤姆&quot;);
        System.out.println(&quot;list 替换后=&quot; + list);
    &#125;
&#125;</code></pre>

<p>自然排序是一种默认的对象排序方式，它是根据对象的内在特征或属性来排序的，通常是按升序。例如，对于整数，自然排序是按照数字的大小进行排序；对于字符串，自然排序是按照字母的字典顺序进行排序。自然排序通常是最直观和常见的排序方式，它使得对象在集合中以一种有序的方式存储和检索。</p>
<p>在 Java 中，自然排序是通过 Comparable 接口来实现的。这个接口定义了一个 compareTo 方法，允许对象自己来决定如何与其他对象进行比较。对于自定义类型，需要确保该类实现了Comparable接口，并重写compareTo方法来定义自然顺序（例子在下面）。</p>
<pre><code class="hljs plaintext">import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
//从大到小排序
public class Main &#123;
    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        Customer customer1 = new Customer(&quot;小明&quot;,scanner.nextInt());
        Customer customer2 = new Customer(&quot;小军&quot;,scanner.nextInt());
        Customer customer3 = new Customer(&quot;小红&quot;,scanner.nextInt());
        List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();
        customers.add(customer1);
        customers.add(customer2);
        customers.add(customer3);
        Collections.sort(customers);
        System.out.println(customers);
    &#125;
&#125;

class Customer implements Comparable&lt;Customer&gt;&#123;
    private String name;
    private int consumption;
    public Customer(String name, int consumption) &#123;
        this.name = name;
        this.consumption = consumption;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Customer&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, consumption=&quot; + consumption +
                &#x27;&#125;&#x27;;
    &#125;
    public int compareTo(Customer customer) &#123;
        return customer.consumption - this.consumption;
    &#125;
&#125;</code></pre>

<p><strong>frequency:</strong></p>
<pre><code class="hljs plaintext">import java.util.*;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        String sentence = &quot;Asenal.North London Forever!We are champion.We want more.&quot;;
        String[] split = sentence.split(&quot;[ .!]&quot;);
        List list = Arrays.asList(split);
        Map map = new HashMap();
        for(Object object : list)&#123;
            map.put(object,Collections.frequency(list,object));
        &#125;
        System.out.println(map);
    &#125;
&#125;</code></pre>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="引入-3"><a href="#引入-3" class="headerlink" title="引入"></a>引入</h2><pre><code class="hljs plaintext">/*
请编写程序，在 ArrayList 中，添加 3 个 Dog 对象
Dog 对象含有 name 和 age, 并输出 name 和 age (要求使用 getXxx())
*/
//使用传统的方法来解决
ArrayList arrayList = new ArrayList();
arrayList.add(new Dog(&quot;旺财&quot;, 10));
arrayList.add(new Dog(&quot;发财&quot;, 1));
arrayList.add(new Dog(&quot;小黄&quot;, 5));
//假如我们的程序员，不小心，添加了一只猫
arrayList.add(new Cat(&quot;招财猫&quot;, 8));
//遍历
for (Object o : arrayList) &#123;
//向下转型 Object -&gt;Dog
Dog dog = (Dog) o;
System.out.println(dog.getName() + &quot;-&quot; + dog.getAge());
&#125;</code></pre>

<p>可以发现无论是猫还是狗都可以存入arrayList中，并且程序在编译阶段不会出错，但是在运行阶段会出错。</p>
<p>分析使用传统方法解决问题：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809110141506.png" alt="image-20240809110141506"></p>
<p>使用泛型来解决：<code>ArrayList&lt;Dog&gt; arrayList = new ArrayList&lt;Dog&gt;();</code></p>
<pre><code class="hljs plaintext">//1. 当我们 ArrayList&lt;Dog&gt; 表示存放到 ArrayList 集合中的元素是 Dog 类型 (细节后面说...)
//2. 如果编译器发现添加的类型，不满足要求，就会报错
//3. 在遍历的时候，可以直接取出 Dog 类型而不是 Object
//4. public class ArrayList&lt;E&gt; &#123;&#125; E 称为泛型,那么 Dog-&gt;E
        ArrayList&lt;Dog&gt; arrayList = new ArrayList&lt;Dog&gt;();
        arrayList.add(new Dog(&quot;旺财&quot;, 10));
        arrayList.add(new Dog(&quot;发财&quot;, 1));
        arrayList.add(new Dog(&quot;小黄&quot;, 5));
//假如我们的程序员，不小心，添加了一只猫
//        arrayList.add(new Cat(&quot;招财猫&quot;, 8));
        System.out.println(&quot;===使用泛型====&quot;);
        for (Dog dog : arrayList) &#123;
            System.out.println(dog.getName() + &quot;-&quot; + dog.getAge());
        &#125;</code></pre>

<p>使用泛型来解决问题时，当添加猫的时候系统就会发出警报了。</p>
<h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809111102632.png" alt="image-20240809111102632"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809111218256-1723173139016-1.png" alt="image-20240809111218256"></p>
<p>与第4点相关的代码：</p>
<pre><code class="hljs plaintext">public class c &#123;
    public static void main(String[] args)&#123;
        //注意，特别强调： E 具体的数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型
        Person&lt;String&gt; person = new Person&lt;String&gt;(&quot;韩顺平教育&quot;);
        person.show(); //String
/*
        你可以这样理解，上面的 Person 类
class Person &#123;
    String s ;//E 表示 s 的数据类型, 该数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E
    是什么类型
    public Person(String s) &#123;//E 也可以是参数类型
        this.s = s;
    &#125;
    public String f() &#123;//返回类型使用 E
        return s;
    &#125;
&#125;
*/
        Person&lt;Integer&gt; person2 = new Person&lt;Integer&gt;(100);
        person2.show();//Integer
/*
class Person &#123;
    Integer s ;//E 表示 s 的数据类型, 该数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E
    是什么类型
    public Person(Integer s) &#123;//E 也可以是参数类型
        this.s = s;
    &#125;
    public Integer f() &#123;//返回类型使用 E
        return s;
    &#125;
&#125;
*/
    &#125;
&#125;
//泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，
// 或者是某个方法的返回值的类型，或者是参数类型
class Person&lt;E&gt; &#123;
    E s;//E 表示 s 的数据类型, 该数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型

    public Person(E s) &#123;//E 也可以是参数类型
        this.s = s;
    &#125;

    public E f() &#123;//返回类型使用 E
        return s;
    &#125;

    public void show() &#123;
        System.out.println(s.getClass());//显示 s 的运行类型
    &#125;
&#125;</code></pre>

<h2 id="泛型的语法"><a href="#泛型的语法" class="headerlink" title="泛型的语法"></a>泛型的语法</h2><p>声明：<img src="/../source/imgs/$%7Bfiilname%7D/image-20240809112640233.png" alt="image-20240809112640233"></p>
<p>实例化：<img src="/../source/imgs/$%7Bfiilname%7D/image-20240809112658580.png" alt="image-20240809112658580"></p>
<img src="../source/imgs/${fiilname}/image-20240809112743876.png" alt="image-20240809112743876" style="zoom:50%;" />

<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">c</span> &#123;
    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;
        <span class="hljs-comment">//使用泛型方式给 HashSet 放入 3 个学生对象</span>
        HashSet&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Student&gt;();
        students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">18</span>));
        students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">28</span>));
        students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;mary&quot;</span>, <span class="hljs-number">19</span>));
<span class="hljs-comment">//遍历</span>
        <span class="hljs-keyword">for</span> (Student student : students) &#123;
            System.out.println(student);
        &#125;
<span class="hljs-comment">//使用泛型方式给 HashMap 放入 3 个学生对象</span>
<span class="hljs-comment">//K -&gt; String,V-&gt;Student</span>
        HashMap&lt;String, Student&gt; hm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Student&gt;();
<span class="hljs-comment">/*</span>
<span class="hljs-comment">public class HashMap&lt;K,V&gt; &#123;&#125;</span>
<span class="hljs-comment">*/</span>
        hm.put(<span class="hljs-string">&quot;milan&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;milan&quot;</span>, <span class="hljs-number">38</span>));
        hm.put(<span class="hljs-string">&quot;smith&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;smith&quot;</span>, <span class="hljs-number">48</span>));
        hm.put(<span class="hljs-string">&quot;hsp&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;hsp&quot;</span>, <span class="hljs-number">28</span>));
<span class="hljs-comment">//迭代器 EntrySet</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span>
<span class="hljs-comment">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span>
<span class="hljs-comment">    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;</span>
<span class="hljs-comment">&#125;</span>
<span class="hljs-comment">*/</span>
        Set&lt;Map.Entry&lt;String, Student&gt;&gt; entries = hm.entrySet();
<span class="hljs-comment">/*</span>
<span class="hljs-comment">public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span>
<span class="hljs-comment">	return new EntryIterator();</span>
<span class="hljs-comment">&#125;</span>
<span class="hljs-comment">*/</span>
        Iterator&lt;Map.Entry&lt;String, Student&gt;&gt; iterator = entries.iterator();
        System.out.println(<span class="hljs-string">&quot;==============================&quot;</span>);
        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
            Map.Entry&lt;String, Student&gt; next = iterator.next();
            System.out.println(next.getKey() + <span class="hljs-string">&quot;-&quot;</span> + next.getValue());
        &#125;
    &#125;
&#125;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    &#125;
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> name;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> age;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;
        <span class="hljs-built_in">this</span>.age = age;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +
                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, age=&quot;</span> + age +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">Iterator&lt;Map.Entry&lt;String, Student&gt;&gt; iterator = entries.iterator();</code></pre>

<h2 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809113352685.png" alt="image-20240809113352685"></p>
<pre><code class="hljs plaintext">import java.util.*;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        //2. 说明
//因为 E 指定了 A 类型, 构造器传入了 new A()
//在给泛型指定具体类型后，可以传入该类型或者其子类类型
        Pig&lt;A&gt; aPig = new Pig&lt;A&gt;(new A());
        aPig.f();
        Pig&lt;A&gt; aPig2 = new Pig&lt;A&gt;(new B());
        aPig2.f();
//3. 泛型的使用形式
        ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();
        List&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();
//在实际开发中，我们往往简写
//编译器会进行类型推断, 老师推荐使用下面写法
        ArrayList&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; list4 = new ArrayList&lt;&gt;();
        ArrayList&lt;Pig&gt; pigs = new ArrayList&lt;&gt;();
//4. 如果是这样写 泛型默认是 Object
        ArrayList arrayList = new ArrayList();//等价 ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;Object&gt;();
/*
public boolean add(Object e) &#123;
    ensureCapacityInternal(size + 1); // Increments modCount!!
    elementData[size++] = e;
    return true;
&#125;
*/
        Tiger tiger = new Tiger();
/*
class Tiger &#123;//类
    Object e;
    public Tiger() &#123;&#125;
    public Tiger(Object e) &#123;
        this.e = e;
    &#125;
&#125;
*/
    &#125;
&#125;
class Tiger&lt;E&gt; &#123;//类
    E e;
    public Tiger() &#123;&#125;
    public Tiger(E e) &#123;
        this.e = e;
    &#125;
&#125;
class A &#123;&#125;
class B extends A &#123;&#125;
class Pig&lt;E&gt; &#123;//
    E e;
    public Pig(E e) &#123;
        this.e = e;
    &#125;
    public void f() &#123;
        System.out.println(e.getClass()); //运行类型
    &#125;
&#125;</code></pre>

<h2 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h2><h3 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809165532655.png" alt="image-20240809165532655"></p>
<p>上面有出现过。</p>
<pre><code class="hljs plaintext">package com.Hnu.experiment;

import java.util.*;

public class test &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;&#125;)
    public static void main(String[] args)&#123;
        //T=Double, R=String, M=Integer
        Tiger&lt;Double,String,Integer&gt; g = new Tiger&lt;&gt;(&quot;john&quot;);
        g.setT(10.9); //OK
//g.setT(&quot;yy&quot;); //错误，类型不对
        System.out.println(g);
        Tiger g2 = new Tiger(&quot;john~~&quot;);//OK T=Object R=Object M=Object
        g2.setT(&quot;yy&quot;); //OK ,因为 T=Object &quot;yy&quot;=String 是 Object 子类
        System.out.println(&quot;g2=&quot; + g2);
    &#125;
&#125;
//老韩解读
//1. Tiger 后面泛型，所以我们把 Tiger 就称为自定义泛型类
//2, T, R, M 泛型的标识符, 一般是单个大写字母
//3. 泛型标识符可以有多个. //4. 普通成员可以使用泛型 (属性、方法)
//5. 使用泛型的数组，不能初始化
//6. 静态方法中不能使用类的泛型
class Tiger&lt;T, R, M&gt; &#123;
    String name;
    R r; //属性使用到泛型
    M m;
    T t;
    //因为数组在 new 不能确定 T 的类型，就无法在内存开空间
    T[] ts;
    public Tiger(String name) &#123;
        this.name = name;
    &#125;
    public Tiger(R r, M m, T t) &#123;//构造器使用泛型
        this.r = r;
        this.m = m;
        this.t = t;
    &#125;
    public Tiger(String name, R r, M m, T t) &#123;//构造器使用泛型
        this.name = name;
        this.r = r;
        this.m = m;
        this.t = t;
    &#125;
//因为静态是和类相关的，在类加载时，对象还没有创建
//所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化,所以不能使用类的泛型
// static R r2;
// public static void m1(M m) &#123;
//
// &#125;
//方法使用泛型
public String getName() &#123;
    return name;
&#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public R getR() &#123;
        return r;
    &#125;
    public void setR(R r) &#123;//方法使用到泛型
        this.r = r;
    &#125;
    public M getM() &#123;//返回类型可以使用泛型. 
         return m;
    &#125;
    public void setM(M m) &#123;
        this.m = m;
    &#125;
    public T getT() &#123;
        return t;
    &#125;
    public void setT(T t) &#123;
        this.t = t;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Tiger&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &quot;, r=&quot; + r +
                &quot;, m=&quot; + m +
                &quot;, t=&quot; + t +
                &quot;, ts=&quot; + Arrays.toString(ts) +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<h3 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809170146345.png" alt="image-20240809170146345"></p>
<p>接口中定义的属性都是静态属性，所以不能使用泛型来定义。</p>
<p>继承接口的时候也要确定泛型。</p>
<pre><code class="hljs plaintext">//实现接口时，直接指定泛型接口的类型
//给 U 指定 Integer 给 R 指定了 Float
//所以，当我们实现 IUsb 方法时，会使用 Integer 替换 U, 使用 Float 替换 R
class BB implements IUsb&lt;Integer, Float&gt; &#123;
    @Override
    public Float get(Integer integer) &#123;
        return null;
    &#125;
    @Override
    public void hi(Float aFloat) &#123;
    &#125;
    @Override
    public void run(Float r1, Float r2, Integer u1, Integer u2) &#123;
    &#125;
&#125;
//没有指定类型，默认为 Object
//建议直接写成 IUsb&lt;Object,Object&gt;
class CC implements IUsb &#123; //等价 class CC implements IUsb&lt;Object,Object&gt; &#123;
    @Override
    public Object get(Object o) &#123;
        return null;
    &#125;
    @Override
    public void hi(Object o) &#123;
    &#125;
    @Override
    public void run(Object r1, Object r2, Object u1, Object u2) &#123;
    &#125;
&#125;
interface IUsb&lt;U, R&gt; &#123;
    int n = 10;
    //U name; 不能这样使用
//普通方法中，可以使用接口泛型
    R get(U u);
    void hi(R r);
    void run(R r1, R r2, U u1, U u2);
    //在 jdk8 中，可以在接口中，使用默认方法, 也是可以使用泛型
    default R method(U u) &#123;
        return null;
    &#125;
&#125;</code></pre>

<h3 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240809171004302.png" alt="image-20240809171004302"></p>
<p>为什么在方法前要声明一个泛型呢，不声明会怎么样。</p>
<p>这个方法不声明且定义这个类的时候也没有声明的话那编译会出错，前面为什么可以只是使用了泛型而不在方法那边声明，因为这个方法使用的泛型在定义那个类的时候就已经声明过了。</p>
<p><code>public &lt;K&gt; void hello(R r, K k)</code>只声明一个的原因是R在定义这个类的时候就已经声明过了。</p>
<pre><code class="hljs plaintext">package com.Hnu.experiment;

import java.util.*;

public class test &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;&#125;)
    public static void main(String[] args)&#123;
        Car car = new Car();
        car.fly(&quot;宝马&quot;, 100);//当调用方法时，传入参数，编译器，就会确定类型
        System.out.println(&quot;=======&quot;);
        car.fly(300, 100.1);//当调用方法时，传入参数，编译器，就会确定类型
//测试
//T-&gt;String, R-&gt; ArrayList
        Fish&lt;String, ArrayList&gt; fish = new Fish&lt;&gt;();
        fish.hello(new ArrayList(), 11.3f);
    &#125;
&#125;
//泛型方法，可以定义在普通类中, 也可以定义在泛型类中
class Car &#123;//普通类
    public void run() &#123;//普通方法
    &#125;
    //说明 泛型方法
//1. &lt;T,R&gt; 就是泛型
//2. 是提供给 fly 使用的
    public &lt;T, R&gt; void fly(T t, R r) &#123;//泛型方法
        System.out.println(t.getClass());//String
        System.out.println(r.getClass());//Integer
    &#125;
&#125;
class Fish&lt;T, R&gt; &#123;//泛型类

    public void run() &#123;//普通方法
    &#125;

    public &lt;U, M&gt; void eat(U u, M m) &#123;//泛型方法
    &#125;

    //说明
//1. 下面 hi 方法不是泛型方法
//2. 是 hi 方法使用了类声明的 泛型
    public void hi(T t) &#123;
    &#125;

    //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型
    public &lt;K&gt; void hello(R r, K k) &#123;
        System.out.println(r.getClass());//ArrayList
        System.out.println(k.getClass());//Float
    &#125;
&#125;</code></pre>

<h2 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="headerlink" title="泛型的继承和通配符"></a>泛型的继承和通配符</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240810105516928.png" alt="image-20240810105516928"></p>
<p>在给泛型指定具体类型后，可以传入该类型或者其子类类型，意思是传入的变量可以是子类，但后面写的泛型不能是子类。</p>
<pre><code class="hljs plaintext">import java.util.*;

public class c &#123;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    public static void main(String[] args)&#123;
        Object o = new String(&quot;xx&quot;);
//泛型没有继承性
//List&lt;Object&gt; list = new ArrayList&lt;String&gt;();
//举例说明下面三个方法的使用
        List&lt;Object&gt; list1 = new ArrayList&lt;&gt;();
        List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
        List&lt;AA&gt; list3 = new ArrayList&lt;&gt;();
        List&lt;BB&gt; list4 = new ArrayList&lt;&gt;();
        List&lt;CC&gt; list5 = new ArrayList&lt;&gt;();
//如果是 List&lt;?&gt; c ，可以接受任意的泛型类型
        printCollection1(list1);
        printCollection1(list2);
        printCollection1(list3);
        printCollection1(list4);
        printCollection1(list5);
//List&lt;? extends AA&gt; c： 表示 上限，可以接受 AA 或者 AA 子类
// printCollection2(list1);//×
// printCollection2(list2);//×
        printCollection2(list3);//√
        printCollection2(list4);//√
        printCollection2(list5);//√
//List&lt;? super AA&gt; c: 支持 AA 类以及 AA 类的父类，不限于直接父类
        printCollection3(list1);//√
//printCollection3(list2);//×
        printCollection3(list3);//√
//printCollection3(list4);//×
//printCollection3(list5);//×
//冒泡排序
//插入排序
//....
    &#125;
    // ? extends AA 表示 上限，可以接受 AA 或者 AA 子类
    public static void printCollection2(List&lt;? extends AA&gt; c) &#123;
        for (Object object : c) &#123;
            System.out.println(object);
        &#125;
    &#125;
    //说明: List&lt;?&gt; 表示 任意的泛型类型都可以接受
    public static void printCollection1(List&lt;?&gt; c) &#123;
        for (Object object : c) &#123; // 通配符，取出时，就是 Object
            System.out.println(object);
        &#125;
    &#125;
    // ? super 子类类名 AA:支持 AA 类以及 AA 类的父类，不限于直接父类，
//规定了泛型的下限
    public static void printCollection3(List&lt;? super AA&gt; c) &#123;
        for (Object object : c) &#123;
            System.out.println(object);
        &#125;
    &#125;
&#125;
class AA &#123;
&#125;
class BB extends AA &#123;
&#125;
class CC extends BB &#123;
&#125;</code></pre>

<h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><pre><code class="hljs plaintext">import org.junit.jupiter.api.Test;

public class c &#123;
    public static void main(String[] args)&#123;
        //传统方式
//new JUnit_().m1();
//new JUnit_().m2();
    &#125;
    @Test
    public void m1() &#123;
        System.out.println(&quot;m1 方法被调用&quot;);
    &#125;
    @Test
    public void m2() &#123;
        System.out.println(&quot;m2 方法被调用&quot;);
    &#125;
    @Test
    public void m3() &#123;
        System.out.println(&quot;m3 方法被调用&quot;);
    &#125;
&#125;</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240810112032671.png" alt="image-20240810112032671"></p>
<p>方便，方法可以进行单独测试。</p>
<h1 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h1><h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240811165750263.png" alt="image-20240811165750263"></p>
<h2 id="常用的文件操作"><a href="#常用的文件操作" class="headerlink" title="常用的文件操作"></a>常用的文件操作</h2><h3 id="创建文件对象相关构造器和方法"><a href="#创建文件对象相关构造器和方法" class="headerlink" title="创建文件对象相关构造器和方法"></a>创建文件对象相关构造器和方法</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240811165842195.png" alt="image-20240811165842195"></p>
<pre><code class="hljs plaintext">import org.junit.jupiter.api.Test;
import java.io.*;</code></pre>

<pre><code class="hljs plaintext">//方式 1 new File(String pathname)
@Test
public void create01() &#123;
    String filePath = &quot;e:\\news1.txt&quot;;
    File file = new File(filePath);
    try &#123;
        file.createNewFile();
        System.out.println(&quot;文件创建成功&quot;);
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre>

<p>Java中的printStackTrace()方法是Throwable类的一个公共方法，它用于打印异常（Exception）或错误（Error）的栈追踪信息到标准错误流（System.err）。当程序抛出异常或错误，并被捕获后，可以使用printStackTrace()方法输出详细的调用栈信息，这在调试程序时非常有用，因为它可以帮助开发者确定异常发生的位置和原因。</p>
<p>e或者E都可以。</p>
<pre><code class="hljs plaintext">//方式 2 new File(File parent,String child) //根据父目录文件+子路径构建
//e:\news2.txt    
    @Test
    public void create02() &#123;
        File parentFile = new File(&quot;e:\\&quot;);
        String fileName = &quot;news2.txt&quot;;
//这里的 file 对象，在 java 程序中，只是一个对象
//只有执行了 createNewFile 方法，才会真正的，在磁盘创建该文件
        File file = new File(parentFile, fileName);
        try &#123;
            file.createNewFile();
            System.out.println(&quot;创建成功~&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;</code></pre>

<pre><code class="hljs plaintext">//方式 2 new File(File parent,String child) //根据父目录文件+子路径构建
//e:\work\work1.txt
    @Test
    public void create02() &#123;
        File parentFile = new File(&quot;e:\\work\\&quot;);//转义字符&#x27;\&#x27;
        String fileName = &quot;work1.txt&quot;;
//这里的 file 对象，在 java 程序中，只是一个对象
//只有执行了 createNewFile 方法，才会真正的，在磁盘创建该文件
        File file = new File(parentFile, fileName);
        try &#123;
            file.createNewFile();
            System.out.println(&quot;创建成功~&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;</code></pre>

<p>得先在E盘里有个work文件夹才可以。上面还可以写作：</p>
<pre><code class="hljs plaintext">File parentFile = new File(&quot;e:\\&quot;);
String fileName = &quot;work\\work1.txt&quot;;</code></pre>

<pre><code class="hljs plaintext"> //方式 3 new File(String parent,String child) //根据父目录+子路径构建
    @Test
    public void create03() &#123;
//String parentPath = &quot;e:\\&quot;;
        String parentPath = &quot;e:\\&quot;;
        String fileName = &quot;news4.txt&quot;;
        File file = new File(parentPath, fileName);
        try &#123;
            file.createNewFile();
            System.out.println(&quot;创建成功~&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;</code></pre>

<p>file.creatNewFile()必须用try-catch包围不然会编译异常。</p>
<h3 id="获取文件的相关信息"><a href="#获取文件的相关信息" class="headerlink" title="获取文件的相关信息"></a>获取文件的相关信息</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240812170556243.png" alt="image-20240812170556243"></p>
<pre><code class="hljs plaintext">package com.Hnu.experiment;

import org.junit.jupiter.api.Test;
import java.io.*;

public class test &#123;
    public static void  main(String[] args)&#123;
    &#125;
    //方式 1 new File(String pathname)
    @Test
    public void create01() &#123;
        String filePath = &quot;e:\\news1.txt&quot;;
        File file = new File(filePath);
        try &#123;
            file.createNewFile();
            System.out.println(&quot;文件创建成功&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        //调用相应的方法，得到对应信息
        System.out.println(&quot;文件名字=&quot; + file.getName());
//getName、getAbsolutePath、getParent、length、exists、isFile、isDirectory
        System.out.println(&quot;文件绝对路径=&quot; + file.getAbsolutePath());
        System.out.println(&quot;文件父级目录=&quot; + file.getParent());
        System.out.println(&quot;文件大小(字节)=&quot; + file.length());
        System.out.println(&quot;文件是否存在=&quot; + file.exists());//T
        System.out.println(&quot;是不是一个文件=&quot; + file.isFile());//T
        System.out.println(&quot;是不是一个目录=&quot; + file.isDirectory());//F
    &#125;
&#125;</code></pre>

<p>isFile()和isDirectory()括号里面都不能加对象。</p>
<h3 id="目录的操作和文件删除"><a href="#目录的操作和文件删除" class="headerlink" title="目录的操作和文件删除"></a>目录的操作和文件删除</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813110428523.png" alt="image-20240813110428523"></p>
<p>没例子</p>
<h2 id="IO-流原理及流的分类"><a href="#IO-流原理及流的分类" class="headerlink" title="IO 流原理及流的分类"></a>IO 流原理及流的分类</h2><p>原理：<img src="/../source/imgs/$%7Bfiilname%7D/image-20240813110530651.png" alt="image-20240813110530651"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813110536404.png" alt="image-20240813110536404"></p>
<p>分类：<img src="/../source/imgs/$%7Bfiilname%7D/image-20240813110635780.png" alt="image-20240813110635780"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813110653713.png" alt="image-20240813110653713"></p>
<h2 id="FileInputStream-文件–-程序"><a href="#FileInputStream-文件–-程序" class="headerlink" title="FileInputStream(文件–&gt; 程序)"></a>FileInputStream(文件–&gt; 程序)</h2><p>演示 FileInputStream 的使用(字节输入流 文件–&gt; 程序)：</p>
<p>读取的内容是文件里的内容。</p>
<pre><code class="hljs plaintext">import org.junit.jupiter.api.Test;

import java.io.*;

public class c &#123;
    public static void main(String[] args)&#123;
    &#125;
    /**
     * 演示读取文件... * 单个字节的读取，效率比较低
     * -&gt; 使用 read(byte[] b)
     */
    @Test
    public void readFile01() &#123;
        String filePath = &quot;e:\\hello.txt&quot;;
        int readData = 0;
        FileInputStream fileInputStream = null;
        try &#123;
//创建 FileInputStream 对象，用于读取 文件
            fileInputStream = new FileInputStream(filePath);
//从该输入流读取一个字节的数据。 如果没有输入可用，此方法将阻止。
//如果返回-1 , 表示读取完毕
            while ((readData = fileInputStream.read()) != -1) &#123;
                System.out.print((char)readData);//转成 char 显示
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
//关闭文件流，释放资源.
            try &#123;
                fileInputStream.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
    /**
     * 使用 read(byte[] b) 读取文件，提高效率
     */
    @Test
    public void readFile02() &#123;
        String filePath = &quot;e:\\hello.txt&quot;;
//字节数组
        byte[] buf = new byte[8]; //一次读取 8 个字节.
        int readLen = 0;
        FileInputStream fileInputStream = null;
        try &#123;
//创建 FileInputStream 对象，用于读取 文件
            fileInputStream = new FileInputStream(filePath);
//从该输入流读取最多 buf.length 字节的数据到字节数组。 此方法将阻塞，直到某些输入可用。
//如果返回-1 , 表示读取完毕
//如果读取正常, 返回实际读取的字节数
            while ((readLen = fileInputStream.read(buf)) != -1) &#123;
                System.out.print(new String(buf, 0, readLen));//显示
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //关闭文件流，释放资源.
            try &#123;
                fileInputStream.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p><code>fileInputStream.read()</code>括号是空的就默认是一个一个字节读取。</p>
<p><code>new String(buf, 0, readLen)</code>，该方法在下面的FileReader有介绍，为什么不直接是(buf)，因为文件里的内容可能不是8的倍数，而读取内容是在buf里面以覆盖的形式存储的，所以直接是buf的话会输出额外内容。</p>
<p>为什么System.out.print((char)readData)需要强制转化为char?</p>
<p><code>FileInputStream.read()</code> 方法每次读取一个字节的数据，并返回该字节的数据作为 <code>int</code> 类型。具体来说，返回的 <code>int</code> 范围是 0 到 255（因为一个字节是 8 位，最大值是 255）。如果读取到文件的末尾，<code>read()</code> 方法返回 -1，表示已经没有数据可以读取了。</p>
<p>由于返回类型是 <code>int</code>，而不是直接返回 <code>byte</code> 或 <code>char</code>，这是因为它需要处理可能的 EOF（End of File）情况，即 -1。</p>
<h2 id="FileOutputStream-程序-文本"><a href="#FileOutputStream-程序-文本" class="headerlink" title="FileOutputStream(程序-&gt;文本)"></a>FileOutputStream(程序-&gt;文本)</h2><p>直接写入文件，不是像BufferedOutputStream要等流关闭后才可以写入。</p>
<pre><code class="hljs plaintext">import org.junit.jupiter.api.Test;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class c &#123;
    public static void main(String[] args)&#123;
    &#125;
    /**
     * 演示使用 FileOutputStream 将数据写到文件中, * 如果该文件不存在，则创建该文件
     */
    @Test
    public void writeFile() &#123;
//创建 FileOutputStream 对象
        String filePath = &quot;e:\\a.txt&quot;;
        FileOutputStream fileOutputStream = null;
        try &#123;
//得到 FileOutputStream 对象 对象
//老师说明
//1. new FileOutputStream(filePath) 创建方式，当写入内容，会覆盖原来的内容
//2. new FileOutputStream(filePath, true) 创建方式，当写入内容，是追加到文件后面
            fileOutputStream = new FileOutputStream(filePath, true);
//写入一个字节
//fileOutputStream.write(&#x27;H&#x27;);//
//写入字符串
            String str = &quot;hsp,world!&quot;;
//str.getBytes() 可以把 字符串-&gt; 字节数组
//fileOutputStream.write(str.getBytes());
/*
write(byte[] b, int off, int len) 将 len 字节从位于偏移量 off 的指定字节数组写入此文件输出流
*/
            fileOutputStream.write(str.getBytes(), 0, 3);//写入htp
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
                fileOutputStream.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>要求: 编程完成图片&#x2F;音乐的拷贝：</p>
<pre><code class="hljs plaintext">import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.FileInputStream;

public class c &#123;
    public static void main(String[] args)&#123;
        //完成 文件拷贝，将 e:\\Koala.jpg 拷贝 c:\\
//思路分析
        //1. 创建文件的输入流 , 将文件读入到程序
//2. 创建文件的输出流， 将读取到的文件数据，写入到指定的文件.
        String srcFilePath = &quot;e:\\Koala.jpg&quot;;
        String destFilePath = &quot;e:\\Koala3.jpg&quot;;
        FileInputStream fileInputStream = null;
        FileOutputStream fileOutputStream = null;
        try &#123;
            fileInputStream = new FileInputStream(srcFilePath);
            fileOutputStream = new FileOutputStream(destFilePath);
//定义一个字节数组,提高读取效果
            byte[] buf = new byte[1024];
            int readLen = 0;
            while ((readLen = fileInputStream.read(buf)) != -1) &#123;
//读取到后，就写入到文件 通过 fileOutputStream
//即，是一边读，一边写
                fileOutputStream.write(buf, 0, readLen);//一定要使用这个方法
            &#125;
            System.out.println(&quot;拷贝 ok~&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
//关闭输入流和输出流，释放资源
                if (fileInputStream != null) &#123;
                    fileInputStream.close();
                &#125;
                if (fileOutputStream != null) &#123;
                    fileOutputStream.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>该程序中的fileOutputStream.write(buf, 0, readLen)buf是字节数组，存储的不是字母，那么写入文本的时候写入的是数字还是字母？</p>
<p><code>buf</code> 是一个字节数组，里面存储的是从源文件（即 <code>Koala.jpg</code>）中读取的原始二进制数据。写入的内容是图片的二进制数据，而不是数字或者字母。换句话说，写入的是文件的<strong>原始字节数据</strong>。二进制文件，比如图片、音频、视频等，都是以字节流的形式存储的，每个字节都可能代表一个像素的颜色值、一段声音的波形等。</p>
<ul>
<li><strong>对于图片文件</strong>：<code>fileOutputStream.write(buf, 0, readLen)</code> 写入的字节数据会被重新组装成图片文件，能够正确显示出原始图片内容。</li>
<li><strong>对于文本文件</strong>：如果你在处理文本文件，这些字节数据可能代表字符的编码值（如 ASCII、UTF-8 编码），写入后重新读取时会显示原来的文本。</li>
</ul>
<h2 id="FileReader-和-FileWriter-处理字符流"><a href="#FileReader-和-FileWriter-处理字符流" class="headerlink" title="FileReader 和 FileWriter(处理字符流)"></a>FileReader 和 FileWriter(处理字符流)</h2><p>这俩只能处理字符，但是上面两个stream可以处理二进制数据，也就是字节流。</p>
<p><strong><code>FileReader</code></strong>: 用于读取文本文件中的字符数据。它将字节数据自动转换为字符数据，使用系统默认的字符编码或指定的字符编码。</p>
<p><strong><code>FileWriter</code></strong>: 用于将字符数据写入文本文件。它会将字符数据转换为字节数据，并写入文件中。</p>
<p>reader想要从文本中读到内容首先要有这个文本文件才可以不然就会报错，writer就不需要先创建文本了，它会自动创建如果没有的话。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813173129946.png" alt="image-20240813173129946"></p>
<p>FileReader 相关方法：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813173513118.png" alt="image-20240813173513118"></p>
<p>new String（在上面的String类有讲到）括号里的也可以是byte数组<code>new String(byte[] bytes, int offset, int length)</code>。字符串在底层实际上也是以字节的形式存储的。字符串（<code>String</code>）在 Java 中是以字符（<code>char</code>）的形式表示的，而 <code>char</code> 在 Java 中是 16 位的 Unicode 字符。另一方面，<code>byte</code> 是 8 位的。因此，字节数组中的每个 <code>byte</code> 实际上可以表示一个 ASCII 字符（对于简单的英文字符）或者是一个 UTF-8 编码的字节（对于复杂的多字节字符，如汉字）。当调用时，Java 会将字节数组 <code>bytes</code> 中的数据按照指定的字符编码解码成字符串。默认情况下，Java 使用平台默认的字符集（通常是 UTF-8）来解释这些字节，并将它们转换为对应的字符。</p>
<p>FileWriter 常用方法：<img src="/../source/imgs/$%7Bfiilname%7D/image-20240813173546876.png" alt="image-20240813173546876"></p>
<pre><code class="hljs plaintext">import org.junit.jupiter.api.Test;

import java.io.*;

public class c &#123;
    public static void main(String[] args)&#123;
    &#125;
    /**
     * 单个字符读取文件
     */
    @Test
    public void readFile01() &#123;
        String filePath = &quot;e:\\story.txt&quot;;
        FileReader fileReader = null;
        int data = 0;
//1. 创建 FileReader 对象
        try &#123;
            fileReader = new FileReader(filePath);
//循环读取 使用 read, 单个字符读取
            while ((data = fileReader.read()) != -1) &#123;
                System.out.print((char) data);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
                if (fileReader != null) &#123;
                    fileReader.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
    /**
     * 字符数组读取文件
     */
    @Test
    public void readFile02() &#123;
        System.out.println(&quot;~~~readFile02 ~~~&quot;);
        String filePath = &quot;e:\\story.txt&quot;;
        FileReader fileReader = null;
        int readLen = 0;
        char[] buf = new char[8];
//1. 创建 FileReader 对象
        try &#123;
            fileReader = new FileReader(filePath);
//循环读取 使用 read(buf), 返回的是实际读取到的字符数
//如果返回-1, 说明到文件结束
            while ((readLen = fileReader.read(buf)) != -1) &#123;
                System.out.print(new String(buf, 0, readLen));
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
                if (fileReader != null) &#123;
                    fileReader.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>使用 FileWriter 将 “风雨之后，定见彩虹” 写入到 note.txt 文件中：</p>
<pre><code class="hljs plaintext">import java.io.FileWriter;
import java.io.IOException;

public class c &#123;
    public static void main(String[] args)&#123;
        String filePath = &quot;e:\\note.txt&quot;;
//创建 FileWriter 对象
        FileWriter fileWriter = null;
        char[] chars = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;
        try &#123;
            fileWriter = new FileWriter(filePath);//默认是覆盖写入
// 3) write(int):写入单个字符
            fileWriter.write(&#x27;H&#x27;);
// 4) write(char[]):写入指定数组
            fileWriter.write(chars);
// 5) write(char[],off,len):写入指定数组的指定部分
            fileWriter.write(&quot;韩顺平教育&quot;.toCharArray(), 0, 3);
// 6) write（string）：写入整个字符串
            fileWriter.write(&quot; 你好北京~&quot;);
            fileWriter.write(&quot;风雨之后，定见彩虹&quot;);
            // 7) write(string,off,len):写入字符串的指定部分
            fileWriter.write(&quot;上海天津&quot;, 0, 2);
//在数据量大的情况下，可以使用循环操作.
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
//对应 FileWriter , 一定要关闭流，或者 flush 才能真正的把数据写入到文件
            try &#123;
//fileWriter.flush();
//关闭文件流，等价 flush() + 关闭
                fileWriter.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        System.out.println(&quot;程序结束...&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">fileWriter = new FileWriter(filePath);//默认是覆盖写入</code></pre>

<p>覆盖写入没有错，那为什么按照上面的程序，最后note文本里的内容会是存进去的所有内容呢？因为它们全部都是在同一个try-catch里面存进去的，而<strong>对应 FileWriter , 要关闭流，或者 flush 才能真正的把数据写入到文件</strong>，关闭流是在finally里面，所以上面那些内容都是一起、一次被写入note的，只写了这一次，所以内容是全部。如果后面继续写入其它内容就会覆盖之前写的内容了。</p>
<p>怎么继续写入呢，如果直接在后面fileWriter.write的话会因为流关闭而出现异常，所以要重新要这样，再开一个：</p>
<pre><code class="hljs plaintext">fileWriter = new FileWriter(filePath);
fileWriter.write(&#x27;H&#x27;);
fileWriter.close();</code></pre>

<pre><code class="hljs plaintext">fileWriter = new FileWriter(filePath,true);//这个会追加到后面</code></pre>

<h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813223615180.png" alt="image-20240813223615180"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813223620304.png" alt="image-20240813223620304"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240813223704614.png" alt="image-20240813223704614"></p>
<h3 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h3><p>功能：<img src="/../source/imgs/$%7Bfiilname%7D/image-20240814111046367.png" alt="image-20240814111046367"></p>
<h4 id="BufferedReader-和-BufferedWriter-字符操作"><a href="#BufferedReader-和-BufferedWriter-字符操作" class="headerlink" title="BufferedReader 和 BufferedWriter(字符操作)"></a>BufferedReader 和 BufferedWriter(字符操作)</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814111410113-1723605250860-1.png" alt="image-20240814111410113"></p>
<p><strong>1、使用BufferedReader读取文本文件并显示在控制台</strong></p>
<pre><code class="hljs plaintext">import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class c &#123;
    public static void main(String[] args) throws IOException &#123;
        String filePath = &quot;e:\\a.java&quot;;
//创建 bufferedReader
        BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));
        //读取
        String line; //按行读取, 效率高
//说明
//1. bufferedReader.readLine() 是按行读取文件
//2. 当返回 null 时，表示文件读取完毕
        while ((line = bufferedReader.readLine()) != null) &#123;
            System.out.println(line);
        &#125;
//关闭流, 这里注意，只需要关闭 BufferedReader ，因为底层会自动的去关闭 节点流
        bufferedReader.close();
    &#125;
&#125;</code></pre>

<p>为什么这边没有try-catch呢，因为这次在主方法就抛出了异常。</p>
<p>为什么FileNotFoundException和java.io.IOException可以用同一个catch(IOException e)捕获？</p>
<p>在Java中，<code>FileNotFoundException</code>是<code>IOException</code>的一个子类。这意味着<code>FileNotFoundException</code>是<code>IOException</code>的一个更具体的类型。当你使用<code>catch(IOException e)</code>块时，它可以捕获类型为<code>IOException</code>的异常，以及它的任何子类（包括<code>FileNotFoundException</code>）。</p>
<p><strong>2、使用BufferedWriter输入</strong></p>
<pre><code class="hljs plaintext">import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class c &#123;
    public static void main(String[] args) throws IOException &#123;
        String filePath = &quot;e:\\ok.txt&quot;;
//创建 BufferedWriter
//说明:
//1. new FileWriter(filePath, true) 表示以追加的方式写入
//2. new FileWriter(filePath) , 表示以覆盖的方式写入
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(filePath));
        bufferedWriter.write(&quot;hello, 韩顺平教育!&quot;);
        bufferedWriter.newLine();//插入一个和系统相关的换行
        bufferedWriter.write(&quot;hello2, 韩顺平教育!&quot;);
        bufferedWriter.newLine();
        bufferedWriter.write(&quot;hello3, 韩顺平教育!&quot;);
        bufferedWriter.newLine();
//说明：关闭外层流即可 ， 传入的 new FileWriter(filePath) ,会在底层关闭
        bufferedWriter.close();
    &#125;
&#125;</code></pre>

<p>验证是覆盖写入，后面加上</p>
<pre><code class="hljs plaintext">bufferedWriter = new BufferedWriter(new FileWriter(filePath));
bufferedWriter.write(&quot;hello3, 韩顺平教育!&quot;);
bufferedWriter.close();</code></pre>

<p><strong>3、综合使用BufferedReader和BufferedWriter完成文件拷贝</strong></p>
<pre><code class="hljs plaintext">import java.io.*;

public class c &#123;
    public static void main(String[] args)&#123;
        //1. BufferedReader 和 BufferedWriter 是安装字符操作
//2. 不要去操作 二进制文件[声音，视频，doc, pdf ], 可能造成文件损坏
        String srcFilePath = &quot;e:\\a.java&quot;;
        String destFilePath = &quot;e:\\a2.java&quot;;
// String srcFilePath = &quot;e:\\0245_韩顺平零基础学 Java_引出 this.avi&quot;;
// String destFilePath = &quot;e:\\a2 韩顺平.avi&quot;;
        BufferedReader br = null;
        BufferedWriter bw = null;
        String line;
        try &#123;
            br = new BufferedReader(new FileReader(srcFilePath));
            bw = new BufferedWriter(new FileWriter(destFilePath));
//说明: readLine 读取一行内容，但是没有换行
            while ((line = br.readLine()) != null) &#123;
//每读取一行，就写入
                bw.write(line);
//插入一个换行
                bw.newLine();
            &#125;
            System.out.println(&quot;拷贝完毕...&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
//关闭流
            try &#123;
                if(br != null) &#123;
                    br.close();
                &#125;
                if(bw != null) &#123;
                    bw.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<ol>
<li>为什么拷贝的时候要换行？</li>
</ol>
<p>在你的代码中，<code>BufferedReader.readLine()</code> 方法被用来读取文件中的一行内容。<code>readLine()</code> 方法会读取一行文本，但它不会包含行尾的换行符（即不会包含 <code>\n</code> 或 <code>\r\n</code>）。</p>
<p>因此，如果你只是用 <code>bw.write(line);</code> 来写入文件，那么原文件中的换行符将不会被复制到目标文件中，结果就是所有的行都会被写入同一行中。为了保持原文件的格式不变，在每次写入一行内容后，需要手动添加一个换行符。<code>bw.newLine();</code> 方法就是用于这个目的的，它会根据操作系统的换行符标准（Windows 是 <code>\r\n</code>，Unix&#x2F;Linux 是 <code>\n</code>）插入适当的换行符，从而确保目标文件的内容和原文件一致。</p>
<ol start="2">
<li>关闭流的条件为什么是不为空？</li>
</ol>
<p>在使用文件流时，关闭流是非常重要的步骤。关闭流能够释放系统资源，避免内存泄漏以及锁定文件等问题。如果不关闭流，可能会导致文件无法被其他进程或操作所访问。</p>
<p>关闭流之前要检查流对象是否为 <code>null</code>，是因为如果某个流在创建过程中发生异常，那么该流对象可能依然是 <code>null</code>。如果你在 <code>null</code> 的情况下直接调用 <code>close()</code> 方法，就会引发 <code>NullPointerException</code>。</p>
<h4 id="BufferedInputStream-和-BufferedOutputStream-字节流"><a href="#BufferedInputStream-和-BufferedOutputStream-字节流" class="headerlink" title="BufferedInputStream 和 BufferedOutputStream(字节流)"></a>BufferedInputStream 和 BufferedOutputStream(字节流)</h4><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814171441700.png" alt="image-20240814171441700"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814171506503.png" alt="image-20240814171506503"></p>
<p><strong>使用Buffered……流完成文件的复制</strong></p>
<p>使用 BufferedOutputStream 和 BufferedInputStream，使用他们，<strong>可以完成二进制文件拷贝</strong>. </p>
<p>思考：字节流可以操作二进制文件，可以操作文本文件吗？当然可以</p>
<pre><code class="hljs plaintext">import java.io.*;

public class c &#123;
    public static void main(String[] args)&#123;
        // String srcFilePath = &quot;e:\\Koala.jpg&quot;;
// String destFilePath = &quot;e:\\hsp.jpg&quot;;
// String srcFilePath = &quot;e:\\0245_韩顺平零基础学 Java_引出 this.avi&quot;;
// String destFilePath = &quot;e:\\hsp.avi&quot;;
        String srcFilePath = &quot;e:\\a.java&quot;;
        String destFilePath = &quot;e:\\a3.java&quot;;
//创建 BufferedOutputStream 对象 BufferedInputStream 对象
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        try &#123;
//因为 FileInputStream 是 InputStream 子类
            bis = new BufferedInputStream(new FileInputStream(srcFilePath));
            bos = new BufferedOutputStream(new FileOutputStream(destFilePath));
//循环的读取文件，并写入到 destFilePath
            byte[] buff = new byte[1024];
            int readLen = 0;
//当返回 -1 时，就表示文件读取完毕
            while ((readLen = bis.read(buff)) != -1) &#123;
                bos.write(buff, 0, readLen);
            &#125;
            System.out.println(&quot;文件拷贝完毕~~~&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
//关闭流 , 关闭外层的处理流即可，底层会去关闭节点流
            try &#123;
                if (bis != null) &#123;
                    bis.close();
                &#125;
                if (bos != null) &#123;
                    bos.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="FileOutputStream和BufferedOutputStream的区别"><a href="#FileOutputStream和BufferedOutputStream的区别" class="headerlink" title="FileOutputStream和BufferedOutputStream的区别"></a>FileOutputStream和BufferedOutputStream的区别</h5><p><strong>FileOutputStream</strong><br>直接写入文件：FileOutputStream 是用于将数据写入文件（如二进制文件）的输出流。它是字节流的一种，直接连接到文件。<br>无缓冲：FileOutputStream 默认情况下不提供缓冲功能。这意味着每次调用 write 方法时，数据都会直接写入到文件中，这可能会导致频繁的磁盘I&#x2F;O操作，从而影响性能。<br>用途：适用于需要直接控制文件写入过程，或者对性能要求不是非常高的场景。<br><strong>BufferedOutputStream</strong><br>缓冲写入：BufferedOutputStream 为另一个输出流（如 FileOutputStream）添加缓冲功能。它内部维护了一个缓冲区，数据首先写入到这个缓冲区中，当缓冲区满或者显式调用 flush() 方法时，缓冲区中的数据才会被写入到目标输出流（如文件）中。<br>性能提升：由于减少了磁盘I&#x2F;O操作的次数（因为数据是批量写入的），BufferedOutputStream 相比 FileOutputStream 提供了更好的性能。<br>用途：适用于需要高效写入大量数据的场景，如文件复制、大文件写入等。<br><strong>总结</strong><br>如果你需要直接写入文件，且对性能要求不高，或者写入的数据量不大，可以直接使用 FileOutputStream。<br>如果你需要高效写入大量数据到文件，推荐使用 BufferedOutputStream，因为它通过缓冲机制减少了磁盘I&#x2F;O操作的次数，从而提高了性能。</p>
<h5 id="FileInputStream和BufferedInputStream的区别"><a href="#FileInputStream和BufferedInputStream的区别" class="headerlink" title="FileInputStream和BufferedInputStream的区别"></a>FileInputStream和BufferedInputStream的区别</h5><p><strong>FileInputStream</strong><br>直接读取文件：FileInputStream 是用于从文件中读取数据的输入流。它是字节流的一种，直接连接到文件，并以字节为单位读取数据。<br>无缓冲：FileInputStream 在读取文件时，默认情况下不提供缓冲功能。这意味着每次调用 read() 方法时，都会直接从文件中读取数据，这可能会导致频繁的磁盘I&#x2F;O操作，从而影响性能。<br>用途：适用于需要直接读取文件内容，且对性能要求不是非常高的场景。<br><strong>BufferedInputStream</strong><br>缓冲读取：BufferedInputStream 为另一个输入流（如 FileInputStream）添加缓冲功能。它内部维护了一个缓冲区，数据首先被读取到这个缓冲区中，当需要读取数据时，直接从缓冲区中获取，减少了磁盘I&#x2F;O操作的次数。<br>性能提升：由于使用了缓冲机制，BufferedInputStream 相比 FileInputStream 提供了更好的读取性能。特别是在处理大文件或需要频繁读取文件的场景下，性能优势更加明显。<br>内部实现：BufferedInputStream 的底层仍旧调用了 FileInputStream 的 read0() 方法来从文件中读取数据，但它会在读取之前将数据预先读取到缓冲区中。当缓冲区中的数据被读取完毕后，它会再次从文件中读取数据填充缓冲区。<br>用途：适用于需要高效读取大量数据的场景，如文件解析、数据处理等。</p>
<h3 id="对象流-ObjectInputStream-和-ObjectOutputStream"><a href="#对象流-ObjectInputStream-和-ObjectOutputStream" class="headerlink" title="对象流-ObjectInputStream 和 ObjectOutputStream"></a>对象流-ObjectInputStream 和 ObjectOutputStream</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814214504483.png" alt="image-20240814214504483"></p>
<p>对象流介绍：</p>
<p>功能：提供了对基本类型或对象类型的序列化和反序列化的方法<br>ObjectOutputStream 提供 序列化功能<br>ObjectInputStream 提供 反序列化功能</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814214703422.png" alt="image-20240814214703422"></p>
<pre><code class="hljs plaintext">import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class c &#123;
    public static void main(String[] args)throws Exception&#123;
        //序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存
        String filePath = &quot;e:\\data.dat&quot;;
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath));
//序列化数据到 e:\data.dat
        oos.writeInt(100);// int -&gt; Integer (实现了 Serializable)
        oos.writeBoolean(true);// boolean -&gt; Boolean (实现了 Serializable)
        oos.writeChar(&#x27;a&#x27;);// char -&gt; Character (实现了 Serializable)
        oos.writeDouble(9.5);// double -&gt; Double (实现了 Serializable)
        oos.writeUTF(&quot;韩顺平教育&quot;);//String
//保存一个 dog 对象
        oos.writeObject(new Dog(&quot;旺财&quot;, 10, &quot;日本&quot;, &quot;白色&quot;));
        oos.close();
        System.out.println(&quot;数据保存完毕(序列化形式)&quot;);
    &#125;
&#125;
class Dog implements Serializable&#123;
    private String name;
    private int year;
    private String country;
    private String color;

    public Dog() &#123;
    &#125;

    public Dog(String name, int year, String country, String color) &#123;
        this.color=color;
        this.name=name;
        this.year=year;
        this.country=country;
    &#125;
&#125;</code></pre>

<p>自定义类要实现接口才能被保存，所以<code>class Dog implements Serializable</code>。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814220715469.png" alt="image-20240814220715469"></p>
<pre><code class="hljs plaintext">import java.io.FileInputStream;
import java.io.ObjectInputStream;
import java.io.Serializable;

public class c &#123;
    public static void main(String[] args)throws Exception&#123;
        // 1.创建流对象
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;e:\\data.dat&quot;));
// 2.读取， 注意顺序
        System.out.println(ois.readInt());
        System.out.println(ois.readBoolean());
        System.out.println(ois.readChar());
        System.out.println(ois.readDouble());
        System.out.println(ois.readUTF());
        System.out.println(ois.readObject());
// 3.关闭
        ois.close();
        System.out.println(&quot;以反序列化的方式读取(恢复)ok~&quot;);
    &#125;
&#125;
class Dog implements Serializable&#123;
    private String name;
    private int year;
    private String country;
    private String color;

    public Dog() &#123;
    &#125;

    public Dog(String name, int year, String country, String color) &#123;
        this.color=color;
        this.name=name;
        this.year=year;
        this.country=country;
    &#125;
&#125;</code></pre>

<p>读取的数据里面有自定义类那该自定义类得在程序里面定义了才可以被读取。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240814221818587.png" alt="image-20240814221818587"></p>
<h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240815104404950.png" alt="image-20240815104404950"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240815104422172.png" alt="image-20240815104422172"></p>
<h3 id="转换流-InputStreamReader-和-OutputStreamWriter"><a href="#转换流-InputStreamReader-和-OutputStreamWriter" class="headerlink" title="转换流-InputStreamReader 和 OutputStreamWriter"></a>转换流-InputStreamReader 和 OutputStreamWriter</h3><p>使用 BufferedReader 对象读取txt文件，默认情况下，读取文件是按照 utf-8 编码，读取中文文件的时候可能会出现乱码问题，因为中文是多字节的，而utf-8是处理单字节的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240815105730149.png" alt="image-20240815105730149"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240815110054951.png" alt="image-20240815110054951"></p>
<pre><code class="hljs plaintext">import java.io.*;

public class c &#123;
    public static void main(String[] args) throws IOException &#123;
        String filePath = &quot;e:\\a.txt&quot;;
//解读
//1. 把 FileInputStream 转成 InputStreamReader
        //2. 指定编码 gbk
//InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath), &quot;gbk&quot;);
//3. 把 InputStreamReader 传入 BufferedReader
//BufferedReader br = new BufferedReader(isr);
//将 2 和 3 合在一起
        BufferedReader br = new BufferedReader(new InputStreamReader(
                new FileInputStream(filePath), &quot;gbk&quot;));
//4. 读取
        String s = br.readLine();
        System.out.println(&quot;读取内容=&quot; + s);
//5. 关闭外层流
        br.close();
    &#125;
&#125;</code></pre>

<p>但是为什么在txt文件里输入中文，使用BufferedReader读取的时候却可以正常输出呢？因为这个时候输入用的就是utf-8编码的，而BufferedReader默认是用utf-8编码的，所以可以正常输出，而转化流按gbk形式读取，所以会出现乱码情况。想用上面程序正常读取中文，那中文得是以gbk形式存储的才行。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240815112143826.png" alt="image-20240815112143826"></p>
<pre><code class="hljs plaintext">import java.io.*;

public class c &#123;
    public static void main(String[] args) throws IOException &#123;
        OutputStreamWriter osw =
                new OutputStreamWriter(new FileOutputStream(&quot;e:\\a.txt&quot;), &quot;gbk&quot;);
        // 2.写入
        osw.write(&quot;hello,韩顺平教育~&quot;);
// 3.关闭
        osw.close();
        System.out.println(&quot;保存成功~&quot;);
    &#125;
&#125;</code></pre>

<h2 id="打印流-PrintStream-和-PrintWriter"><a href="#打印流-PrintStream-和-PrintWriter" class="headerlink" title="打印流-PrintStream 和 PrintWriter"></a>打印流-PrintStream 和 PrintWriter</h2><p>只用输出流没有输入流。</p>
<p>PrintWriter：需要close才可以存入</p>
<pre><code class="hljs plaintext">import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class c &#123;
    public static void main(String[] args) throws IOException &#123;
        //PrintWriter printWriter = new PrintWriter(System.out);
        PrintWriter printWriter = new PrintWriter(new FileWriter(&quot;e:\\f2.txt&quot;));
        printWriter.print(&quot;hi, 北京你好~~~~&quot;);
        printWriter.close();//flush + 关闭流, 才会将数据写入到文件..
    &#125;
&#125;</code></pre>

<p>像下面的一样，这边也可以用write。</p>
<p>PrintStream：不用close就可以存入</p>
<pre><code class="hljs plaintext">import java.io.IOException;
import java.io.PrintStream;

public class c &#123;
    public static void main(String[] args) throws IOException &#123;
        PrintStream out = System.out;
//在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器
/*
public void print(String s) &#123;
if (s == null) &#123;
    s = &quot;null&quot;;
&#125;
write(s);
&#125;
*/
        out.print(&quot;john, hello&quot;);//也可以使用println自带换行。
//因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印/输出
        out.write(&quot;韩顺平,你好&quot;.getBytes());
        out.close();
//我们可以去修改打印流输出的位置/设备
//1. 输出修改成到 &quot;e:\\f1.txt&quot;
//2. &quot;hello, 韩顺平教育~&quot; 就会输出到 e:\f1.txt
//3. public static void setOut(PrintStream out) &#123;
// checkIO();
// setOut0(out); // native 方法，修改了 out
// &#125;
        System.setOut(new PrintStream(&quot;e:\\f1.txt&quot;));
        System.out.println(&quot;hello, 韩顺平教育~&quot;);
    &#125;
&#125;</code></pre>

<p>这个输入时覆盖写入，也不能使用追加写入，只能是覆盖。</p>
<h2 id="Properties-类"><a href="#Properties-类" class="headerlink" title="Properties 类"></a>Properties 类</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240816110944717.png" alt="image-20240816110944717"></p>
<p>传统方法：</p>
<pre><code class="hljs plaintext">import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
public class Properties01 &#123;
    public static void main(String[] args) throws IOException &#123;
//读取 mysql.properties 文件，并得到 ip, user 和 pwd
        BufferedReader br = new BufferedReader(new FileReader(&quot;src\\mysql.properties&quot;));
        String line = &quot;&quot;;
        while ((line = br.readLine()) != null) &#123; //循环读取
            String[] split = line.split(&quot;=&quot;);
//如果我们要求指定的 ip 值
            if (&quot;ip&quot;.equals(split[0])) &#123;
                System.out.println(split[0] + &quot;值是: &quot; + split[1]);
            &#125;
        &#125;
        br.close();
    &#125;
&#125;</code></pre>

<p>Properties介绍：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240816111311259.png" alt="image-20240816111311259"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240816111320424.png" alt="image-20240816111320424"></p>
<p>使用Properties类进行读取、创建：</p>
<pre><code class="hljs plaintext">//读取
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Properties;
public class Properties02 &#123;
    public static void main(String[] args) throws IOException &#123;
//使用 Properties 类来读取 mysql.properties 文件
//1. 创建 Properties 对象
        Properties properties = new Properties();
//2. 加载指定配置文件
        properties.load(new FileReader(&quot;src\\mysql.properties&quot;));
//3. 把 k-v 显示控制台
        properties.list(System.out);
//4. 根据 key 获取对应的值
        String user = properties.getProperty(&quot;user&quot;);
        String pwd = properties.getProperty(&quot;pwd&quot;);
        System.out.println(&quot;用户名=&quot; + user);
        System.out.println(&quot;密码是=&quot; + pwd);
    &#125;
&#125;</code></pre>

<pre><code class="hljs plaintext">//创建
//Properties 父类是 Hashtable ， 底层就是 Hashtable 核心方法
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;
public class Properties03 &#123;
    public static void main(String[] args) throws IOException &#123;
//使用 Properties 类来创建 配置文件, 修改配置文件内容
        Properties properties = new Properties();
//创建
//1.如果该文件没有 key 就是创建
//2.如果该文件有 key ,就是修改
        properties.setProperty(&quot;charset&quot;, &quot;utf8&quot;);
        properties.setProperty(&quot;user&quot;, &quot;汤姆&quot;);//注意保存时，是中文的 unicode 码值
        properties.setProperty(&quot;pwd&quot;, &quot;888888&quot;);
//将 k-v 存储文件中即可
        properties.store(new FileOutputStream(&quot;src\\mysql2.properties&quot;), null);
        System.out.println(&quot;保存配置文件成功~&quot;);
    &#125;
&#125;</code></pre>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%AD%E8%A8%80/" rel="tag">语言</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-python2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/05/python2/" class="article-date">
  	<time datetime="2024-10-05T09:38:13.000Z" itemprop="datePublished">2024-10-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/05/python2/">
        python2
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>同时输出字符和数字：将数字转化为字符处理。</p>
<pre><code class="hljs python">x,y,z = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;三个数的和为：&quot;</span> + <span class="hljs-built_in">str</span>(x + y + z))</code></pre>

<pre><code class="hljs plaintext">x,y,z = 1,2,3
print(&quot;三个数的和为：&quot;,x + y + z)</code></pre>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><pre><code class="hljs plaintext">文本类型： 
     str
数字类型： 
     int, 
     float, 
     complex(复数)
序列类型：
	list,
	tuple,
	range
映射类型：      
     dict
套装类型：      
     set,      
     frozenset
布尔类型：      
     bool
二进制类型：      
     bytes,      
     bytearray,      
     memoryview</code></pre>

<p>可使用以下<strong>type()函数</strong>获取<strong>任何</strong>对象的数据类型。</p>
<p>浮点数类型float：可以使用e(E)来表示科学计数法，x、y仍属于浮点数类型</p>
<pre><code class="hljs plaintext">x = 1e2
y = 2E3
print(x)#100.0
print(y)#2000.0</code></pre>

<p>complex：</p>
<p>复数写有“j”作为虚部。</p>
<pre><code class="hljs plaintext">x = 3 + 5j
y = 5j
print(x)#(3+5j)
print(y)#5j</code></pre>

<p>强制转化：</p>
<pre><code class="hljs plaintext">x = 1
y = complex(x)
print(x)#1
print(y)#(1+0j)</code></pre>

<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>Python 有一个内置模块 random可以用来生成随机数，需要引入。</p>
<pre><code class="hljs plaintext">import random</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240827170632781.png" alt="image-20240827170632781"></p>
<p>random.randrange(3,30,3)不是生成3到30之间的任何整数，因为width &#x3D; 3 ，所以生成的应该是3 + 3 * i 。</p>
<p>该方法生成的都是<strong>整数</strong>，包括负整数。</p>
<p>step步长的应用——生成n的随机整数范围(倍数)</p>
<p>让我们生成 5 到 100 之间的随机整数，即 5 的倍数，例如 5, 10, 25, 90, 95等。</p>
<pre><code class="hljs plaintext">import random
number = random.randrange(5, 101, 5)
print(&quot;Random number range (multiple) of 5 is &quot;, number)</code></pre>

<h1 id="python字符串"><a href="#python字符串" class="headerlink" title="python字符串"></a>python字符串</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>可以使用三个引号将多行字符串分配给变量。<code>&quot;&quot;&quot;   &quot;&quot;&quot;</code></p>
<pre><code class="hljs plaintext">x = &quot;&quot;&quot;gsgad asgsa
   ags ilnk &quot;&quot;&quot;
print(x)</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240902144043495.png" alt="image-20240902144043495"></p>
<p><strong>字符串是数组</strong>，Python <strong>没有字符</strong>数据类型，单个字符只是一个长度为 1 的字符串。方括号可用于访问字符串的元素。这里用到了切片，你可以不懂。<br>获取位置 1 处的字符（记住第一个字符的位置为 0）：</p>
<pre><code class="hljs plaintext">a = &quot;Hello, World!&quot;
print(a[1])</code></pre>

<p><code>len()</code>函数返回字符串的长度，注意标点符号和空格也算一个长度：len(a)</p>
<p>要检查字符串中是否存在某个短语或字符，我们可以使用关键字 in，返回值为布尔类型。</p>
<pre><code class="hljs plaintext">txt =&quot;The best things in life are free!&quot;
print(&quot;free&quot; in txt)</code></pre>

<p>如果是要检查不存在某个短语或字符的话，除了使用 in 外，还可以使用 not in ：</p>
<pre><code class="hljs plaintext">txt =&quot;The best things in life are free!&quot;
print(&quot;free&quot; not in txt)</code></pre>

<p>不存在就会输出true。</p>
<h2 id="切片字符串"><a href="#切片字符串" class="headerlink" title="切片字符串"></a>切片字符串</h2><p><strong>1）切片</strong></p>
<p>获取从位置 2 到位置 5 的字符（不包括在内）：</p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt[2:5])</code></pre>

<p>仍然是左闭右开的规律，且第一个字符索引为0。</p>
<p><strong>2）从头开始切片</strong></p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt[:5])</code></pre>

<p><strong>3)切到最后</strong></p>
<p>通过省略结束索引，范围将到最后。</p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt[2:])</code></pre>

<p><strong>4）负索引</strong></p>
<p>使用负索引从字符串末尾开始切片，就是从右往左看，不再是从左往右看。</p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt[-5:-2])</code></pre>

<p>这个时候字符串的最后一个元素索引为 -1，往前递减。</p>
<p>  f    r   e   e		这个时候要切片仍要按字符串顺序写入，不能写<code>[-1:-5]</code>，而使用负索引时由于是从后往前的，所以变成了<strong>左闭右开</strong>。</p>
<p>-4  -3  -2  -1</p>
<h2 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h2><p>1）upper()方法以大写形式返回字符串（不改变原字符串）：<code>txt.upper()</code>，txt内容直接全部转化为大写；也可以选择字符转大写，<code>txt[2].upper()</code>。</p>
<p>2）lower()方法以小写形式返回字符串。</p>
<p>3）strip()方法删除开头和结尾的任何空格（不改变原字符串）：</p>
<pre><code class="hljs plaintext">txt = &quot;   The best things in life are free!&quot;
print(txt.strip())
print(txt)</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240924164743183.png" alt="image-20240924164743183"></p>
<p>4）replace()方法用另一个字符串替换一个字符串(不改变原字符串)：</p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt.replace(&quot;e&quot;,&quot;E&quot;,4))
print(txt)</code></pre>

<p>replace(“要修改的”,”要修改成的”,要修改的数量)，没有规定数量则默认全部修改。</p>
<p>5）拆分字符串</p>
<p>split()方法返回一个列表，其中指定分隔符之间的文本成为列表项。split()如果找到分隔符的实例，该方法会将字符串拆分为子字符串。</p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt.split(&quot; &quot;))</code></pre>

<p>若要以多个字符作为分割符，那不像 java 中一样，python要用and</p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt.split(&quot; &quot; and &quot;e&quot;))</code></pre>

<pre><code class="hljs plaintext">my_list = txt.split(&quot; &quot;)</code></pre>

<p>my_list的类型为list。</p>
<h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p>要连接或组合两个字符串，可以使用 + 运算符。</p>
<h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><h3 id="对变量的格式化"><a href="#对变量的格式化" class="headerlink" title="对变量的格式化"></a>对变量的格式化</h3><h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><p>1）format<strong>单个</strong>传参</p>
<p>通过使用<strong>format()</strong> 方法来组合字符串和数字！format()方法接受传递的参数，格式化它们，并将它们放在占位符所在的字符串中{}。</p>
<pre><code class="hljs plaintext">age = 20
txt = &quot;Tom今年&#123;&#125;&quot;
print(txt.format(age))</code></pre>

<p>age的值会出现在“{}”里。</p>
<p>2）format<strong>多个</strong>传参</p>
<p>不规定顺序，默认按输入顺序取值：</p>
<pre><code class="hljs plaintext">quantity = 20
itemno = 3000
price = 49.95
myorder = &quot;川川今年 &#123;&#125;岁 买了个华为手机 &#123;&#125; 每个月花费 &#123;&#125; 元.&quot;
print(myorder.format(quantity, itemno, price))</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240829104210335.png" alt="image-20240829104210335"></p>
<p>规定顺序：按序列号取值</p>
<pre><code class="hljs plaintext">quantity = 20
itemno = 3000
price = 49.95
myorder = &quot;川川今年 &#123;2&#125;岁 买了个华为手机 &#123;0&#125; 每个月花费 &#123;1&#125; 元.&quot;
print(myorder.format(quantity, itemno, price))</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240829104100499.png" alt="image-20240829104100499"></p>
<h4 id=""><a href="#" class="headerlink" title="%"></a>%</h4><p><strong>3）%</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240902144652454.png" alt="image-20240902144652454"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240902144757723.png" alt="image-20240902144757723"></p>
<p>这个程序是将数字变为字符串后填入语句中的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240902145053559.png" alt="image-20240902145053559"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240902145436277.png" alt="image-20240902145436277"></p>
<h4 id="快速写法：f"><a href="#快速写法：f" class="headerlink" title="快速写法：f"></a>快速写法：f</h4><p>不限数据类型同时也不做精度控制，原来是什么样的就输出什么样的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240902145938978.png" alt="image-20240902145938978"></p>
<h3 id="对表达式的格式化"><a href="#对表达式的格式化" class="headerlink" title="对表达式的格式化"></a>对表达式的格式化</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240902150303533.png" alt="image-20240902150303533"></p>
<h2 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240829104305991.png" alt="image-20240829104305991"></p>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p><code>bool()</code>函数允许您评估任何值，并给您 True或False 作为返回。如果它具有某种内容，几乎任何值都会被评估。任何字符串都是True，空字符串除外。任何数字都是True，除了 0。任何列表、元组、集合和字典都是True，空的除外。</p>
<p>例如()、 []、{}、 “”、 数字 0和 False、None值，计算值为False。</p>
<p>Python 也有许多返回布尔值的内置函数，如 <code>isinstance()</code> 函数，可用于确定对象是否属于某种数据类型。</p>
<pre><code class="hljs plaintext">x = 20
print(isinstance(x,int))</code></pre>

<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="基础-元组定义"><a href="#基础-元组定义" class="headerlink" title="基础+元组定义"></a>基础+元组定义</h2><p>列表是使用方括号创建的，可以直接输出，和java中的一样。</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;]
print(mylist)</code></pre>

<p>创建新列表时也可以使用 <strong>list()</strong> 构造函数。</p>
<pre><code class="hljs plaintext">mylist = list((
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;))
print(mylist)</code></pre>

<p>为什么list需要有两个括号？因为传递给<code>list()</code>函数的参数是一个<strong>元组</strong>，而不是普通的单个字符串或其他类型的单个对象。</p>
<ol>
<li><strong>外层括号</strong>：<code>list()</code>函数的外层括号用于调用该函数。</li>
<li><strong>内层括号</strong>：<code>( ... )</code>内层括号用于定义一个元组。Python中的元组使用括号<code>()</code>定义。如果在调用<code>list()</code>时传递了一个元组（用括号括起来的多个元素），你就需要使用内层括号来创建这个元组。</li>
</ol>
<p>这个代码实际上是将一个元组传递给<code>list()</code>函数，并将这个元组转换成列表。</p>
<p>元组（Tuple）是Python中的一种数据类型，用于存储多个值。它与列表（List）非常相似，但有几个关键区别：</p>
<p>1）<strong>不可变性（Immutable）</strong>: 元组一旦创建，其元素不能修改（即不能增删改）。这与列表不同，列表是可变的（Mutable）。</p>
<p>2）<strong>使用小括号定义</strong>: 元组使用小括号 <code>()</code> 定义，而列表使用方括号 <code>[]</code>。</p>
<p>3）<strong>可以包含不同类型的数据</strong>: 元组可以包含不同类型的元素，例如整数、字符串、浮点数等：<code>mixed_tuple = (1, &quot;hello&quot;, 3.14)</code></p>
<p>4）<strong>访问方式与列表相同</strong>: 元组的元素通过索引访问，索引从0开始。</p>
<p>现在重新回到列表：</p>
<p>由于列表已编入索引，因此列表可以包含具有相同值的项目。</p>
<p>列表项可以是任何数据类型，同一列表中也可以包含不同类型的项。</p>
<p><strong>总结：</strong></p>
<ol>
<li>List列表是一个有序且可变的集合。允许重复成员。</li>
<li>turple元组是一个有序且不可更改的集合。允许重复成员。</li>
<li>Set集合是一个无序且无索引的集合。没有重复的成员。</li>
<li>dict字典是一个有序（从 Python 3.7 版开始）且可变的集合。没有重复的成员。</li>
</ol>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><strong>访问列表</strong></p>
<p>1）正常索引</p>
<p>2）负索引</p>
<p>3）索引范围</p>
<pre><code class="hljs plaintext">print(mylist[1:3])</code></pre>

<pre><code class="hljs plaintext">print(mylist[-3:-1])</code></pre>

<p>4）检查是否存在，和字符串一样</p>
<p><strong>更改列表</strong></p>
<p>更改一个范围内的元素：</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;,
    &quot;川川五号&quot;]
mylist[1:3] = [&quot;哈皮川川&quot;,&quot;憨批川川&quot;]
print(mylist)</code></pre>

<p><strong>插入列表</strong></p>
<p><code>insert()</code>方法在指定的索引处插入一个项目。</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;,
    &quot;川川五号&quot;]
mylist.insert(2,&quot;帅哥呀&quot;)
print(mylist)</code></pre>

<p><strong>添加列表</strong></p>
<p>1）末尾添加：要将值添加到列表的末尾，请使用append() 方法。</p>
<p>2）指定位置添加：insert()函数。</p>
<p>3）合并列表：要将另一个列表中的元素附加到当前列表，请使用extend()方法。</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;,
    &quot;川川五号&quot;]
mylist1 = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;]
mylist.extend(mylist1)
print(mylist)</code></pre>

<p>extend()方法不一定要 列表，您也可以添加任何可迭代对象（元组、集合、字典等）。</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;,
    &quot;川川五号&quot;]
mylist1 = (&quot;川川&quot;,&quot;菜鸟&quot;)
mylist.extend(mylist1)
print(mylist)</code></pre>

<p>使用 + 运算符</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;,
    &quot;川川五号&quot;]
mylist1 = [&quot;川川&quot;,&quot;菜鸟&quot;]
my = mylist1 + mylist
print(my)</code></pre>

<p><strong>删除列表</strong></p>
<p>remove()方法删除指定的项目。</p>
<pre><code class="hljs plaintext">mylist.remove(&#x27;川川二号&#x27;)</code></pre>

<p>pop()方法删除指定的索引，如果不指定索引，该pop()方法将删除最后一项。</p>
<pre><code class="hljs plaintext">mylist.pop(2)</code></pre>

<p>del删除指定的索引,也可以完全删除列表。</p>
<pre><code class="hljs plaintext">del mylist[0]</code></pre>

<pre><code class="hljs plaintext">del mylist</code></pre>

<p>clear()方法清空列表。该列表仍然存在，但没有内容。</p>
<pre><code class="hljs plaintext">mylist.clear()</code></pre>

<h2 id="循环列表"><a href="#循环列表" class="headerlink" title="循环列表"></a>循环列表</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>方法一：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240909151648171.png" alt="image-20240909151648171">循环遍历列表您可以使用循环遍历列表项for 。</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;]
for i in mylist:
    print(i)</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240909150647167.png" alt="image-20240909150647167"></p>
<p>方法二：遍历索引号</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240909152055723.png" alt="image-20240909152055723"></p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;]
for i in range(len(mylist)):
    print(mylist[i])</code></pre>

<p>相当于以前的：</p>
<pre><code class="hljs plaintext">for(int i = 0;i &lt; mylist.length;i ++)
	print(mylist.charAt(i)</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240909152204826.png" alt="image-20240909152204826"></p>
<p><strong>变量作用域</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240909152409235.png" alt="image-20240909152409235"></p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;]
i = 0
while i &lt; len(mylist):
    print(mylist[i])
    i += 1</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240828145231836.png" alt="image-20240828145231836"></p>
<p>那如果我while循环下面还要写不属于循环体的内容要怎么办呢？下面写的内容与while对齐就行，就代表不是循环的内容了。</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;]
i = 0
while i &lt; len(mylist):
    print(mylist[i])
    i += 1
i = 1
print(i)</code></pre>

<h3 id="continue和break"><a href="#continue和break" class="headerlink" title="continue和break"></a>continue和break</h3><p>和以前的一样</p>
<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240830101522063.png" alt="image-20240830101522063"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240830101751077.png" alt="image-20240830101751077"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240830101811824.png" alt="image-20240830101811824"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240830101824157.png" alt="image-20240830101824157"></p>
<p><strong>一个表达式，后面为一个 for 子句，然后，跟着 for 子句，if 语句</strong></p>
<pre><code class="hljs plaintext">OldList = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

TestList = [j for i in OldList for j in i if j % 2 == 0]

print(TestList)
# [2, 4, 6, 8]</code></pre>

<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240830102029883.png" alt="image-20240830102029883"></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>sort()方法区分大小写，导致所有大写字母都排在小写字母之前，按自然顺序排序。<code>thislist.sort()</code></p>
<p>不区分大小写的排序函数，则应使用<code>str.lower</code>作为键函数：<code>thislist.sort(key = str. lower)</code></p>
<p>reverse()方法反转元素的当前排序顺序。</p>
<h2 id="复制列表"><a href="#复制列表" class="headerlink" title="复制列表"></a>复制列表</h2><p>copy()方法制作列表的副本：</p>
<pre><code class="hljs plaintext">fruits = [
    &quot;apple&quot;,
    &quot;banana&quot;,
    &quot;cherry&quot;,
    &quot;kiwi&quot;,
    &quot;mango&quot;]
f = fruits.copy()
print(f)</code></pre>

<p>list()方法制作列表的副本：</p>
<pre><code class="hljs plaintext">fruits = [
    &quot;apple&quot;,
    &quot;banana&quot;,
    &quot;cherry&quot;,
    &quot;kiwi&quot;,
    &quot;mango&quot;]
f = list(fruits)
print(f)</code></pre>

<h2 id="操作合集"><a href="#操作合集" class="headerlink" title="操作合集"></a>操作合集</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240830103315208.png" alt="image-20240830103315208"></p>
<h1 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h1><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240902151833428.png" alt="image-20240902151833428"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240902152020658.png" alt="image-20240902152020658"></p>
<p>input默认<strong>接受</strong>的类型是<strong>字符串</strong>，所以你输入的数据是按照字符串去处理的，获取到的数据永远是字符串类型的。</p>
<h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240904145056331.png" alt="image-20240904145056331"></p>
<p><strong>注意：</strong>条件后面加<strong>冒号</strong>，结构体前面要<strong>留有空白</strong>（四个空格），就是要缩进；没有缩进代表和 if 是同级的，不受 if 控制。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240904145619929.png" alt="image-20240904145619929"></p>
<h2 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240904145840332.png" alt="image-20240904145840332"></p>
<h2 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if elif else语句"></a>if elif else语句</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240904150121743.png" alt="image-20240904150121743"></p>
<p>判断条件里可以是输入语句：</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240904150614390.png" alt="image-20240904150614390"></p>
<p>该代码在节省代码量的同时还做到了不用一次性输入三个变量，而是等前面一个不满足条件后在输入下一个变量值。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>和c语言大差不差的。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240920162622191.png" alt="image-20240920162622191"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240920162945376.png" alt="image-20240920162945376"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240920163335654.png" alt="image-20240920163335654"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240920163800172.png" alt="image-20240920163800172"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240920163903857.png" alt="image-20240920163903857"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240920164146996.png" alt="image-20240920164146996"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240920164831520.png" alt="image-20240920164831520"></p>
<p>调用函数时，鼠标停在函数上，会出现说明文档。</p>
<h1 id="数据容器"><a href="#数据容器" class="headerlink" title="数据容器"></a>数据容器</h1><h2 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240924161211649.png" alt="image-20240924161211649"></p>
<p>列表中可以存储不同的数据类型。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240924161704122.png" alt="image-20240924161704122"></p>
<h2 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple(元组)"></a>tuple(元组)</h2><p>元组一旦定义完成就不能被修改。但是如果元组中有元素list，可以修改list里的数据，list不变，变得是list里面的内容。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240924162913949.png" alt="image-20240924162913949"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240924163026626.png" alt="image-20240924163026626"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240924163430828.png" alt="image-20240924163430828"></p>
<h2 id="str-字符串"><a href="#str-字符串" class="headerlink" title="str(字符串)"></a>str(字符串)</h2><p>和元组一样，字符串时无法修改的，对它进行修改操作得到的是一个新的字符串，原字符串仍不变。</p>
<h2 id="数据容器-序列-的切片操作"><a href="#数据容器-序列-的切片操作" class="headerlink" title="数据容器(序列)的切片操作"></a>数据容器(序列)的切片操作</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240925164714610.png" alt="image-20240925164714610"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240925165222127.png" alt="image-20240925165222127"></p>
<p>切片操作不会影响到序列本身，而是会产生一个新的序列。</p>
<p>步长<strong>默认</strong>为1，所以可以不写。</p>
<p>起始和结束都不写的话，表示从头到尾。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240925165838825.png" alt="image-20240925165838825"></p>
<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set(集合)"></a>set(集合)</h2><p>不重复，无序，不支持下标索引。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240925170512617.png" alt="image-20240925170512617"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240925170945186.png" alt="image-20240925170945186"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240925171231409.png" alt="image-20240925171231409"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20240925171542869.png" alt="image-20240925171542869"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/e8de20e06fd56f6d2ceea032f44bc44.jpg" alt="e8de20e06fd56f6d2ceea032f44bc44"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/bd87986b8127cf5846dd255a229c1d1.jpg" alt="bd87986b8127cf5846dd255a229c1d1"></p>
<p>合并后的结果仍然不会包括重复元素，且是两个集合元素的随机排序。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/514528fca03cd17eb17868519899720.jpg" alt="514528fca03cd17eb17868519899720"></p>
<h2 id="dict-字典，映射"><a href="#dict-字典，映射" class="headerlink" title="dict(字典，映射)"></a>dict(字典，映射)</h2><p>类似于java中的map</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/79154cc663eb53d620c96fc64977de9.jpg" alt="79154cc663eb53d620c96fc64977de9"></p>
<p>不允许key重复，若定义时有多个相同的key，则后面的key会覆盖前面的key所对应的value。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/dec7bca820e4e130f9a5a6bd6652fbc.jpg" alt="dec7bca820e4e130f9a5a6bd6652fbc"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/059a07044f60f5e95d8d180fc236721.jpg" alt="059a07044f60f5e95d8d180fc236721"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/61c0aaaf135fad195606aa8e58e3ff7.jpg" alt="61c0aaaf135fad195606aa8e58e3ff7"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/717b6aff7adcb3b9f70da9c51d8f858.jpg" alt="717b6aff7adcb3b9f70da9c51d8f858"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/6b23551aa8c653399da60e74f342c68.jpg" alt="6b23551aa8c653399da60e74f342c68"></p>
<p>pop删除元素后，会返回key对应的value。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/5bd94c5a35aabcf48b9c73de7072206.jpg" alt="5bd94c5a35aabcf48b9c73de7072206"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/9251c3fd1779b131f239311c726dd6f.jpg" alt="9251c3fd1779b131f239311c726dd6f"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/a081ac4642bfff8f35659ac5c890848.jpg" alt="a081ac4642bfff8f35659ac5c890848"></p>
<h2 id="数据容器对比总结"><a href="#数据容器对比总结" class="headerlink" title="数据容器对比总结"></a>数据容器对比总结</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241006164035181.png" alt="image-20241006164035181"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241006164216252.png" alt="image-20241006164216252"></p>
<p>利用max和min筛选字典中的最大最小元素，只看key不看value。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241006165142739.png" alt="image-20241006165142739"></p>
<p>字符串转列表(元组，集合)会将字符串的每一个元素都提取出来单独变成列表(元组，集合)的元素，字典转列表(元组，集合)会将key提取出来变成元素，抛弃value。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241006165218795.png" alt="image-20241006165218795"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241006165308882.png" alt="image-20241006165308882"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241006165333622.png" alt="image-20241006165333622"></p>
<p>可以发现，排序的结果都变成了列表对象，且是升序排序，若想降序的话，那就加上reverse &#x3D; True。</p>
<h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="函数多返回值"><a href="#函数多返回值" class="headerlink" title="函数多返回值"></a>函数多返回值</h2><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241007203125481.png" alt="image-20241007203125481"></p>
<h2 id="函数的多种传参方式"><a href="#函数的多种传参方式" class="headerlink" title="函数的多种传参方式"></a>函数的多种传参方式</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>就是最普通的函数的参数名字。</p>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241007203810697.png" alt="image-20241007203810697"></p>
<h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241007204042022.png" alt="image-20241007204042022"></p>
<p>当没有给gender传递值的时候，gender的值就是”男”。</p>
<p>缺省参数必须写在最后，但不限制数量。</p>
<h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241007204349845.png" alt="image-20241007204349845"></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241007204445538.png" alt="image-20241007204445538"></p>
<p><strong>元组</strong></p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241007204530513.png" alt="image-20241007204530513"></p>
<p><strong>字典</strong></p>
<h2 id="匿名参数"><a href="#匿名参数" class="headerlink" title="匿名参数"></a>匿名参数</h2><h3 id="函数作为参数传入"><a href="#函数作为参数传入" class="headerlink" title="函数作为参数传入"></a>函数作为参数传入</h3><p>普通的传入数据的形式，计算逻辑时确定的，但是计算的数据不是确定的；传入函数的形式，计算的数据是确定的，但计算逻辑不确定。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241007213254747.png" alt="image-20241007213254747"></p>
<h3 id="lambda匿名函数"><a href="#lambda匿名函数" class="headerlink" title="lambda匿名函数"></a>lambda匿名函数</h3><p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241008154657216.png" alt="image-20241008154657216"></p>
<p>lambda函数<strong>直接将函数体的结果return</strong>，不用写return语句。</p>
<p><img src="/../source/imgs/$%7Bfiilname%7D/image-20241008154846531.png" alt="image-20241008154846531"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%AD%E8%A8%80/" rel="tag">语言</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-职业" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/05/%E8%81%8C%E4%B8%9A/" class="article-date">
  	<time datetime="2024-10-05T03:42:59.450Z" itemprop="datePublished">2024-10-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240212212756589.png" alt="image-20240212212756589"></p>
<h1 id="数据分析师"><a href="#数据分析师" class="headerlink" title="数据分析师"></a>数据分析师</h1><p>对代码能力要求不高，侧重的是对业务的理解，逻辑思维和对业务方向的精准判断。由于岗位要求不高，可以做的人多，可能是裁员的优先考虑对象，提升空间不高</p>
<p>越往高级，数据分析师其实就会逐渐<strong>轻技能而重分析</strong>。很多职位要求都需要具备良好的沟通表达能力。需要有较高的逻辑分析能力。最好需要有行业背景，像金融啥的。</p>
<p>数据分析相对来说还是一个比较看重经验的行业，<strong>从业时间越长，经验越是丰富</strong>，相对薪资水平也会越高，很多数据分析师的薪资也是逐年递增的。</p>
<p>要求：</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153551457.png" alt="image-20240211153551457"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153609295.png" alt="image-20240211153609295"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153657287.png" alt="image-20240211153657287"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153718324.png" alt="image-20240211153718324"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153802513.png" alt="image-20240211153802513"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153819410.png" alt="image-20240211153819410"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153906171.png" alt="image-20240211153906171"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153919623.png" alt="image-20240211153919623"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211154047528.png" alt="image-20240211154047528"></p>
<p>所以数据分析师工资高，真不一定意味着数据分析师紧缺，<strong>也可能是需要这个岗位的都是大公司，所以开出的工资高</strong>。</p>
<p>而且套用一个说职业前景的万能句式：<strong>数据分析师行业不缺人，缺的是精尖</strong>。你要想去一个公司做专业的数据分析师，就得证明自己比那些懂数据分析的运营、销售、市场强，也得证明自己比那些懂业务的程序员强，不然人家现有的员工组合拼凑就够用了，干嘛要你。</p>
<p>当然，专业的数据分析师也确实存在缺口，这个职业在国内火起来还不算久，国内缺乏真正的数据分析专业人才，很多人都是学了点软件应用就敢说自己是数据分析师，结果给个需求，既不知道怎么确定指标体系，又不知道如何找数据，好不容易可视化完，也分析不出个123，反正业务部门自己看去吧。</p>
<p>所以套用一句说职业的万能句式：<strong>数据分析师不缺普通人，缺的是牛人</strong>。你要是左手能数据挖掘ai建模，右手写分析报告建议策略，就可以被抢着要了。</p>
<p>当然一般人（比如我）做到这个级别还是有难度的（反正我在编程上一塌糊涂），<strong>所以我建议是技术和业务选一侧走到精通，另一侧做辅助。然后，如果编程和我一样废，或者是转行年纪稍大的，就选业务吧。</strong></p>
<p><strong>不过既然轻技能，那就势必会重思维和经验，在业务侧，你的数据分析思维很重要，比如老板要你分析一个产品应不应该上线，一个活动值不值得策划实施，这时候</strong>你要自行判断应该从什么角度进行分析，什么数据是关键指标，并通过分析数据给出业务上的意见，甚至出一个业务方案。</p>
<p>这需要你懂得统计学和概率论，以及基于这些数据基础而来的各种分析方法，什么AB测试，多维度拆分，AARRR分析法5w分析法，千变万化，不离其宗；还需要你对一个行业的业务发展上下游都有了解，能判断一个数据的变动是对应哪个环节。</p>
<p>这些东西，即使你是数据分析科班出身，都未必能在工作里直接用好，因为教材是套路的，但业务是多变而且超越教材的，所以比起啃书，我更建议你听听从业者的经验，看人家是如何把理论应用于实践<strong>，最好还能练一练，这样省去了自己在实际业务上摸爬滚打的试错成本，最好还能在求职前有一些个人项目经历，求职的时候就等于有了拿得出手的实习经历。</strong></p>
<p>可能对于一些科班出身的人来说，数据科学方向就是一直以来所预期的发展方向，但在实际的职场上，数据分析更多的是重在分析，<strong>毕竟不是所有的公司需要程序员，但只要是商业公司，总会有对业务进行分析的需求。</strong></p>
<p>就像前面说的，我更建议大家做业务侧，业务侧吃经验，重思维，真的要更适合普通人。尤其是大龄转行0基础想靠敲代码创出一片天的，真的要好好考虑一下，<strong>这把年纪想学通编程得付出多少时间和辛苦，你的家庭能等得起吗，你又真的能学得会吗？</strong></p>
<p>越往高级，数据分析师其实就会逐渐<strong>轻技能而重分析</strong>，真正数据获取阶段的工作做的很少，可能都会交给团队里的初级伙伴来完成。高级分析师则注重在分析阶段，需要的是在对业务的全局把控，对行业和经济的深刻理解。即使是技能，也要求模型优化等更高级别的能力。</p>
<p>而如果你成为创业者或者市场方面的高管，建模这样的工作也会被分派到下面，而你则要根据这些报告做出正确的决策。</p>
<h1 id="ETL工程师-数据工程师"><a href="#ETL工程师-数据工程师" class="headerlink" title="ETL工程师&#x2F;数据工程师"></a>ETL工程师&#x2F;数据工程师</h1><p>入门简单？</p>
<p>是从事系统编程、数据库编程与设计，要掌握各种常用的编程语言的专业技术人员。也叫<strong>数据库工程师</strong>。</p>
<p><strong>为什么之前叫ETL工程师，现在更多的是称数据工程师？</strong></p>
<p>我觉得从我个人而言，首先要从更宏观的角度来理解ETL工程师。一般传统公司称ETL工程师，因为以前经常是将业务系统的数据取出来，进行数据清洗，再按照星型或雪花型建模再放到<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%95%B0%E4%BB%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:630650110%7D">数仓</a>中为下游BI服务。</p>
<p>而现在为什么叫数据工程师？是因为大家意识到，随着数据量的增多，数据产生的价值和变现的维度也随之增多了，数据工程师需要掌握的技能发生了许多变化。</p>
<p><strong>其中最重要的是要肩负起这两点责任：运营数据（养数据）和达到公司的数据目的。</strong>这是ETL工程师或者说是数据工程师最终要达到的目标，</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211204720275.png" alt="image-20240211204720275"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211204740772.png" alt="image-20240211204740772"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211204812758.png" alt="image-20240211204812758"></p>
<p>利用ETL工具完成数据抽取、清洗、转换、装载，mysql，SQL，hadoop&#x2F;hive&#x2F;Spark，Linux，数据仓库原理，熟悉至少一门编程语言，例如Python、Java、Scala等</p>
<p>一味的解释数据仓库概念可能没意思，我们从不同角色出发吧！</p>
<p><strong>老板：</strong>我是一家手机公司的老板，今天要向去董事局汇报，我要准备一份介绍过去三年的用户增长、用户留存、用户活跃度、手机里面每个APP使用率等情况的报表，假如下面没有BI，那我肯定就蒙了……</p>
<p><strong>BI：</strong>我是一名非技术BI，我天天看竞品的分析报告，看双十一销量，看各种评论，<strong>知道自己的产品有哪些短板有哪些长处</strong>，我分析南北地域差异，国内外客户喜好，总之我在手机领域有着很强的<strong>行业解读能力和数据解读能力</strong>，我可以画出非常漂亮的图表和PPT。今天老板让我出一份报表，我还要去刷脸找ETL工程师帮我跑出这次报告的数据，基于这份数据我要给出一定的解读，为啥这个月手机卖得不如上个月，为啥用户流失越来越严重等等都是我要去做的。</p>
<p><strong>ETL工程师 :</strong> 我是食物链最底层的苦逼ETL工程师，我会写<strong>shell</strong>、我会搭<strong>hadoop&#x2F;hive&#x2F;hbase</strong>、会写<strong>超复杂逻辑的SQL</strong>，今天那个不会自己计算数据的BI又让我跑几个数据，我本想让她提需求流程的，但她说这是老板要的(运营惯用的杀手锏！！！)，要加急处理，我只能放下手头的活儿给她跑数据了，花了半个小时把数据跑好给她，希望能就这么交差吧。</p>
<p>大数据工程师，就是我们所知的大数据开发工程师，<strong>主要从事大数据平台的搭建，</strong>对个人技术要求偏高，需要从业者具备java基础，还得具备以下技术能力，<strong>hadoop、hive、hase、flume、storm、kafka、spark等</strong>，是一个非常庞大的技术集群。</p>
<p>如果你以为我每天就做这点事那你就错了，我平时的工作可不仅仅就是完成上面交给我的任务哦，我还负责<strong>数据ETL过程、数据建模、定时任务的分配、甚至有时Hadoop集群的维护</strong>等等都得我去做，每件事单独拿出来都可以拿出来写本书。</p>
<p>就拿ETL过程来说吧，你要把原始数据从各种数据库、各种服务器的不同业务日志归一化到同一类格式，要约定好分隔符，然后导入到分布式文件系统HDFS，甚至你还要和业务系统定义数据格式出规范，数据收集完，你还得出中间表，数据过滤，格式统一，ID统一，维度统一，通过不同的数据现象进行数据，完了，你就得出一些日报周报之类的数据了，这时候你要按照需求把数据组织成一定的格式然后导Mysql、或者HBASE等等。</p>
<p>总之你就是需要<strong>把数据各种收集、各种处理、然后各种导入导出</strong>，是不是很有意思？</p>
<p>不过这些数据仓库都非常初级，其中ETL工程师可发挥的空间太多了！</p>
<p>正常情况下，老板→BI→ETL出一份报告，这中间能否BI直接去计算数据？SQL太复杂，那么可不可以一切数据标签化，BI甚至老板要什么就选什么？</p>
<p><strong>ETL工程师可以把数据收集自动化、可以规范业务日志格式、可以将一切都配置化</strong>，但是这些都是基于N+1的，也就是说今天的发生了什么一定要到明天才能看到，那么有没有一个系统能把数据分析做到实时或者准实时？参考双十一大屏，马总要是到12号才能知道成交了多少笔不劈了那帮做数据的才怪。</p>
<p><strong>目前绝大部分分析系统都基于离线计算（HADOOP&#x2F;ODPS），</strong>那这里有个问题了，运营或BI想看个数据还得你离线慢腾腾跑完才能看到，那么有没有一个系统可以支持你再大的数据量，再复杂的逻辑，毫秒出数据？</p>
<p>我没有提到的还有<strong>算法工程师、大数据运维工程师</strong>等等。</p>
<h1 id="大数据开发"><a href="#大数据开发" class="headerlink" title="大数据开发"></a>大数据开发</h1><p>做大数据开发需要有强大的逻辑思维和代码编写能力，数学能力，以及对算法的敏感度。如果说数据分析更多的是和人打交道的话，那么大数据开发更像是机器打交道(阿宅们的福音）。大数据开发就不需要考虑和心理学相关问题，只是别人给你需求，按照他的需求编写好逻辑，提供给他他要的就行了。有一个绝对听话的编译软件陪着你，不需要过多的考虑他人的想法，</p>
<img src="C:\Users\BD\Documents\WeChat Files\wxid_eb3dot0ogrgw22\FileStorage\Temp\604bb97f7d335a95d6fa3310e357530.jpg" alt="604bb97f7d335a95d6fa3310e357530" style="zoom:67%;" />

<p>大数据开发主要是大数据组件的二次开发，或者大数据平台的搭建等方向，我目前干的就是大数据组件的二次开发。总而言之就是，参与大数据分布式应用系统服务器端或客户端软件开发工作（需求开发、故障解决和性能优化等）。主要偏向于Java方向，Java要求较高。</p>
<p>熟练掌握Java，有相关并发的编程经验，精通Java&#x2F;Python&#x2F;C++&#x2F;scala&#x2F;go语言中一种或多种，熟悉数据结构和算法，熟悉linux; 对Hadoop&#x2F;Flink&#x2F;Presto&#x2F;Druid&#x2F;Redis&#x2F;Kafka等开源技术有一定的了解， 读过源码的优先；                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211211422682.png" alt="image-20240211211422682"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211211516512.png" alt="image-20240211211516512"></p>
<h1 id="数据科学家"><a href="#数据科学家" class="headerlink" title="数据科学家"></a>数据科学家</h1><p><strong>难</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240212212543245.png" alt="image-20240212212543245"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240212212600055.png" alt="image-20240212212600055"></p>
<p>对数据的敏感程度直接决定了你将会如何使用手头的工具和知识，最终影响到conclusion的质量</p>
<p>data scientist的另外一个区别于其他类似职业的特性就是<strong>深入</strong>。且不管scientist这种叫法是否合适，但是被称作scientist的人必须永远是走在cutting-edge的人才，同时也必须是对问题、数据、方法、结论都有着深入理解的人，而不仅仅是停留在数据、现象、问题的表面，否则就变成了机械、简单、重复的统计分析。因此，data scientist作为<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BA%A4%E5%8F%89%E5%AD%A6%E7%A7%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:37410172%7D">交叉学科</a>人才，并不仅仅要求你拥有七十二般武艺，更需要你在关键的领域拥有对知识全面而深入的理解，看问题的角度需要独到犀利。除此之外，你还要像一名真正的scientist一样，拥有强烈的探索欲、好奇心、行动力。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/05/%E5%AD%A6%E4%B9%A0/" class="article-date">
  	<time datetime="2024-10-05T03:42:59.447Z" itemprop="datePublished">2024-10-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240212220055545.png" alt="image-20240212220055545"></p>
<p>牛客网刷题</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240212220157525.png" alt="image-20240212220157525"></p>
<p><strong>《<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA+MySQL&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2433597616%7D">深入浅出 MySQL</a>》</strong></p>
<p>前面的部分的“基础篇”可以快速略过，重点的就是后面的“开发篇和优化篇”。</p>
<p>尤其是后面的“优化篇”对我帮助很大，学习了一些常见的 MySQL 优化方式。</p>
<p>毕竟数据库性能优化是对我们来说很重要的一趴。</p>
<p><strong>《MySQL 技术内幕：InnoDB存储引擎》</strong></p>
<p>MySQL 中用的做多的就是 InnoDB 引擎，所以更进一步学习 InnoDB 存储引擎很有必要。</p>
<p>这本书反正就是 MySQL 中的经典书，解析了 InnoDB 的体系结构、实现原理、工作机制，里面呆了大量的实践内容。</p>
<p><strong>《高性能 MySQL》</strong></p>
<p>MySQL 不老的经典大部头，这个大家就放在最后看好了。</p>
<p>这本书好的方面是，每一章都是相对独立的主题，大家可以根据目录选择性的阅读。</p>
<p>我记得当时我主要就是看了创建高性能的索引、查询性能优化这几个章节，不得不说：Nice！</p>
<p>作为数据分析师，日常使用 SQL，<strong>主要就是把自己想要的数据或者指标需求转化成 SQL 的语言逻辑去数据库等地方查询数据。</strong></p>
<p>很多初学者会被网上的一些信息误导，以为 SQL 的学习要掌握到极精深的地步，恨不得深入内核嚼碎了来学。</p>
<p>怎么说呢，没必要，数据分析师使用 SQL 的重点就是在【<strong>查询</strong>】两个字上。</p>
<p>所以单纯对数据分析师来说，SQL 的掌握主要在基础语言的学习和性能优化上的学习上就好了。</p>
<p>没必要深入内核去学习。</p>
<p>其实大概分的话，由浅入深分成 3 个阶段吧：</p>
<p><strong>（1）入门阶段</strong></p>
<p><strong>入门阶段的话就是熟练的掌握增删改查语句、运算符以及函数。</strong></p>
<p>增删改查语句主要就是 select、insert、update、delete。</p>
<p>运算符主要就是算术运算符（+、-、*、&#x2F;、%）、赋值运算符（&#x3D;）、比较运算符（＞、≥、＜、≤）和逻辑运算符（AND、ANY、BETWEEN、IN）。</p>
<p>函数主要就是算法函数和时间函数等。</p>
<p><strong>（2）进阶阶段</strong></p>
<p><strong>这一个阶段是重中之重</strong></p>
<p><strong>进阶阶段主要是熟练掌握多表查询、分组查询、子查询、组合查询等。其中最重要的就是多表查询。</strong></p>
<p>工作里往往数据不是放在一个表里，而是不同的数据放在不同的表里，这就需要会从不同的表中根据业务需求来获取数据，这就需要 SQL 进行多表查询。</p>
<p><strong>（3）高级阶段</strong></p>
<p><strong>高级阶段要是为了提高 SQL 的效率。都是写 SQL，怎么可以让 SQL 执行效率更快。</strong></p>
<p>在这各阶段，主要要求你去学习约束、事务、锁、触发器、视图等内容。</p>
<p><strong>虽然我希望大家都能掌握到第 3 阶段，但是我也知道，这对刚入行的数据分析师是有点难度的，因为这些是需要你在大量工作中积累经验。</strong></p>
<p><strong>所以对于我希望你最好掌握到第二阶段【进阶】。</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-数据结构_复杂度" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%A4%8D%E6%9D%82%E5%BA%A6/" class="article-date">
  	<time datetime="2024-10-05T03:42:59.433Z" itemprop="datePublished">2024-10-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="算法的时间复杂度和空间复杂度"><a href="#算法的时间复杂度和空间复杂度" class="headerlink" title="算法的时间复杂度和空间复杂度"></a>算法的时间复杂度和空间复杂度</h1><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120110452980.png" alt="image-20240120110452980"></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>算法的时间复杂度是一个<strong>函数（数学里面带有未知数的函数表达式）</strong>，它定义了该算法的运行时间。一个算法所花费的时间于其中的语句的执行次数成正比例，<strong>算法中的基本操作的执行次数为算法的时间复杂度</strong>。</p>
<h3 id="计算："><a href="#计算：" class="headerlink" title="计算："></a>计算：</h3><p>计算时间复杂度的时，不一定要计算精确的执行次数，而只要大概之小红次数，那么这里我们使用大O的渐近表示法。</p>
<p>例子：<img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120113537752.png" alt="image-20240120113537752"></p>
<p>大O的渐近表示法：用于描述函数渐近行为的数学符号。</p>
<p>推导大O阶的方法：</p>
<p>1、用<strong>常数1</strong>取代运行时间中的所有加法<strong>常数</strong>。</p>
<p>2、在修改后的运行次数函数中，<strong>只保留最高阶项</strong>。</p>
<p>3、如果最高阶项存在且不是1，则<strong>去除于这个项目相乘的常数</strong>，得到的结果就是大O阶。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120114417835.png" alt="image-20240120114417835"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120114706253.png" alt="image-20240120114706253"><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120114903048.png" alt="image-20240120114903048"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120173940657.png" alt="image-20240120173940657"></p>
<p>该实例的时间复杂度是O(N)；平均情况一般等于（最好+最坏）&#x2F;2；一般不看平均。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120175817466.png" alt="image-20240120175817466"></p>
<p>排序的表本身就是有序的，比较次数，可以判断出是n-1次的比较，没有数据交换，此时时间复杂度为O(n)。当最坏的情况，即待排序是逆序的情况。当初始序列从大到小逆序时，需要进行n-1趟排序，进行n(n-1)&#x2F;2次比较和交换。</p>
<p>不要被题目的程序误导，实在想不出来就去看冒泡排序怎么写。</p>
<p><strong>算时间复杂度不能只去看是几层循环，而要去看他的思想。</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240122220744357.png" alt="image-20240122220744357"></p>
<p>设查找了X次</p>
<p>反推：最后剩下一个，那上一次的数量就是1的两倍，再上一次就又是两倍。</p>
<img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240122221014918.png" alt="image-20240122221014918" style="zoom:50%;" />

<p>正推：总数一半一半减少，最后剩下一个。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240122221134443.png" alt="image-20240122221134443"></p>
<p><strong>递归算法</strong>：递归次数*每次递归调用的次数</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240122224853317.png" alt="image-20240122224853317"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240122225924168.png" alt="image-20240122225924168"></p>
<p>虽然N&lt;3,但是右边那块空的相对于其他的来说很小，所以是O(2^N).</p>
<p>那也不对啊，这个程序应该到N&lt;3的时候就直接输出1了，而不是会递归到0和1.</p>
<p>下面这题是”真正的”O(2^N)。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124215911307.png" alt="image-20240124215911307"></p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>要注意计算的是额外的空间</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124220104955.png" alt="image-20240124220104955"></p>
<h3 id="计算：-1"><a href="#计算：-1" class="headerlink" title="计算："></a>计算：</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124220351847.png" alt="image-20240124220351847"></p>
<p>每一次循环结束后使用的空间都会被释放掉，所以从头到尾，i 所使用的应该都是同一个空间。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124222449970.png" alt="image-20240124222449970"></p>
<p>可直接看malloc</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124222818662.png" alt="image-20240124222818662"></p>
<p>递归的空间复杂度要看它递归的深度（次数），这题一共有N次，每次都额外建立了都是常数个额外空间。</p>
<p><strong>函数开辟的空间一次只能给一个用，不能同时开两个分别进行。</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124224437868.png" alt="image-20240124224437868"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124225028609.png" alt="image-20240124225028609"></p>
<p>当你要算F(N)的时候要先算N-1，要算N-1要先算N-2，依次类推不断往下一直到1，那一共要建立n+1个空间，算完2的时候算3时可以重复利用之前使用的空间（此时已经被释放掉了），所以数量不变，以此类推，一直向上，数量始终不变，所以是O(N)。</p>
<h1 id="顺序表和链表"><a href="#顺序表和链表" class="headerlink" title="顺序表和链表"></a>顺序表和链表</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240125163604905.png" alt="image-20240125163604905"></p>
<p>线性表在逻辑上是线性的关系，不是线性的关系的话比如，树形结构。</p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序表其实就是数组。</p>
<p>要从头连续存储。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240125163951122.png" alt="image-20240125163951122"></p>
<p>1、静态顺序表</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240125165658666.png" alt="image-20240125165658666"></p>
<p>特点：如果满了的话就不让插入；</p>
<p>缺点：不知道大小要定义多少，小了不够用，大了浪费。</p>
<p>2、动态顺序表</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240125172049350.png" alt="image-20240125172049350"></p>
<p>空间容量指的不是字节数而是个数</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Kaggle" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/05/Kaggle/" class="article-date">
  	<time datetime="2024-10-05T03:42:59.425Z" itemprop="datePublished">2024-10-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Kaggle"><a href="#Kaggle" class="headerlink" title="Kaggle"></a>Kaggle</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Kaggle成立于2010年，是一个进行数据发掘和预测竞赛的在线平台。从公司的角度来讲，可以提供一些数据，进而提出一个实际需要解决的问题；从参赛者的角度来讲，他们将组队参与项目，针对其中一个问题提出解决方案，最终由公司选出的最佳方案可以获得5K-10K美金的奖金。</p>
<p>除此之外，Kaggle官方每年还会举办一次大规模的竞赛，奖金高达一百万美金，吸引了广大的数据科学爱好者参与其中。从某种角度来讲，大家可以把它理解为一个众包平台，类似国内的猪八戒。但是不同于传统的低层次劳动力需求，Kaggle一直致力于解决业界难题，因此也创造了一种全新的劳动力市场——不再以学历和工作经验作为唯一的人才评判标准，而是着眼于个人技能，为顶尖人才和公司之间搭建了一座桥梁。</p>
<p>这里有一篇对Kaggle首席科学家Jeremy Howard的采访，介绍了Kaggle的创建初衷及运营模式，即任用最聪明的人解决世界上最棘手的问题；同时，任何公司和组织都可以受益于机器学习的发展进步，</p>
<h2 id="Kaggle参赛者的背景大多是什么样的？"><a href="#Kaggle参赛者的背景大多是什么样的？" class="headerlink" title="Kaggle参赛者的背景大多是什么样的？"></a><strong>Kaggle参赛者的背景大多是什么样的？</strong></h2><p>从比赛目标出发，参赛者主要分为两种，一种是以奖金和排名为目的，包括靠奖金为生的职业Kaggler；另外一种就是以提升相关skills和背景为目的业余爱好者甚至在校学生了。</p>
<p>从背景来看，前者的来源主要有丰富data science、data mining、machine learning工作经验的业内人士，或者是实力强劲的民间“技术宅”；而后者则往往是一些有一定技术能力，但经验欠缺，从中进行学习和锻炼的“长江后浪”。</p>
<h2 id="0基础的人如何上手Kaggle？"><a href="#0基础的人如何上手Kaggle？" class="headerlink" title="0基础的人如何上手Kaggle？"></a><strong>0基础的人如何上手Kaggle？</strong></h2><p>理论上来讲，Kaggle欢迎任何数据科学的爱好者，不过实际上，要想真的参与其中，还是有一定门槛的。一般来讲，参赛者最好具有统计、计算机或数学相关背景，有一定的coding技能，对机器学习和深度学习有基本的了解。Kaggle任务虽然不限制编程语言，但绝大多数队伍会选用Python和R，所以你应该至少熟悉其中一种。</p>
<p>此外，对于那些对成绩有追求的人，Feature Engineering也是必不可少的。</p>
<p>当然，如果你从未独立做过一个项目，还是要从<strong>练习赛开始熟悉</strong>。因为竞赛模式中的任务是公司悬赏发布的实际案例，并没有标准的答案；而练习赛不仅项目难度低，而且是有官方给出的参考方案的，大家可以用来对比改善自己的测试结果，从中进行提高。</p>
<p>所以呢，建议感兴趣的同学先去独立做一下101和playground的训练赛，至于做多少个案例才能上道，就要看个人素质啦。这里为大家推荐几篇非常好的文章，里面手把手的教了大家入门级的三个经典练习项目，供大家学习。</p>
<ol>
<li>Titanic（泰坦尼克之灾）</li>
</ol>
<p>中文教程： <a href="https://link.zhihu.com/?target=http://blog.csdn.net/han_xiaoyang/article/details/49797143">逻辑回归应用之Kaggle泰坦尼克之灾</a><br>英文教程：<a href="https://link.zhihu.com/?target=https://www.kaggle.com/helgejo/titanic/an-interactive-data-science-tutorial">An Interactive Data Science Tutorial</a></p>
<ol start="2">
<li>House Prices: Advanced Regression Techniques（房价预测）</li>
</ol>
<p>中文教程：<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/irenelin/p/7400388.html">Kaggle竞赛 — 2017年房价预测</a><br>英文教程：<a href="https://link.zhihu.com/?target=https://www.kaggle.com/neviadomski/house-prices-advanced-regression-techniques/how-to-get-to-top-25-with-simple-model-sklearn">How to get to TOP 25% with Simple Model using sklearn</a></p>
<ol start="3">
<li>Digital Recognition（数字识别）</li>
</ol>
<p>中文教程：<a href="https://link.zhihu.com/?target=http://blog.csdn.net/u012162613/article/details/41929171">大数据竞赛平台—Kaggle 入门</a><br>英文教程：<a href="https://link.zhihu.com/?target=https://www.kaggle.com/arthurtok/digit-recognizer/interactive-intro-to-dimensionality-reduction">Interactive Intro to Dimensionality Reduction</a></p>
<h2 id="Kaggle竞赛的认可度高么？"><a href="#Kaggle竞赛的认可度高么？" class="headerlink" title="Kaggle竞赛的认可度高么？"></a><strong>Kaggle竞赛的认可度高么？</strong></h2><p>Kaggle作为Data Science业内享有盛名的平台，在业界拥有极高的认可度。所以如果你是想寻找相关行业的工作，那一个漂亮的<strong>Kaggle profile将为你的简历增色不少</strong>。</p>
<p>对于刚刚进入这个行业的菜鸟而言，参加Kaggle的项目是非常“长见识”的，可能初期的尝试会非常吃力，毕竟都是非常前沿的问题，但是如果能坚持完整的把一个项目做下来，且不说coding能力会有一个很大的提高，在实际案例中解决问题的能力也会得到极大的锻炼，为自己的职业生涯打下一个良好的基础。如果能在Kaggle这种高手云集的比赛中获得一个还不错的成绩，写在简历上足以打动你今后的Boss，跳槽就翻倍的高薪工作指日可待！值得一提的是，虽然是汇集精英的社区，Kaggle的论坛氛围很好，对新人非常友好，大家一定要多看Script多请教！</p>
<p>首先，选择数据量小的项目，这样不管使用什么算法都不会耗时太久，对机器性能要求也不高，出结果也比较快；其次，选择难度低奖金少的项目，一方面竞争小，另一方面也适合新手；最后，选择参与人数多的项目，毕竟有那么多“僵尸号”撑着。这样下来，基本上认认真真做下来排名都不会太难看。</p>
<ul>
<li>选择恰当的工具：</li>
</ul>
<p>我们都知道循序渐进的道理，因此对于刚刚涉猎Kaggle，只是希望从中学习，而不追求高排名的同学，可以先从学习Machine Learning中常用的模型开始，比如Logistic Regression和Random Forest，这两个模型对于大部分问题就够了；基础好的还可以学习一下Gradient Boosting，虽然难度高一点，但是可视化效果会好很多。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/04/hello-world/" class="article-date">
  	<time datetime="2024-10-04T13:33:43.478Z" itemprop="datePublished">2024-10-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/04/hello-world/">
        Hello World
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2025 Odegaard
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>