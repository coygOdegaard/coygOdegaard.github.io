<!DOCTYPE html>
<html lang="zh-CN" >
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<meta name="description" content="">
	<meta name="keywords" content="">
	<title>归档 - coygOdegaard</title>
    <link rel="alternate" href="" type="application/atom+xml"/>
	<link rel="shortcut icon" href=""/>
	
<link rel="stylesheet" href="/css/style.css">

	
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
	<div class="main-con">

        <div class="nav cl">
    <ul class="cl nav-list">
        
            <li>
                
                    <a href="/" class="">
                        <i class="fa fa-home"></i> 
                        <span>主页</span>
                    </a>
                
            </li>
        
            <li>
                
                    <a href="/archives/" class="active">
                        <i class=" fa-"></i> 
                        <span>归档</span>
                    </a>
                
            </li>
        
            <li>
                
                    
                    <a href="javascript:void(0)" class="">
                    
                        <i class=" fa-"></i> 
                        <span>关于</span>
                        <span class="drop-flag fa fa-angle-down"></span>
                    </a>
                    <dl>
                        
                            <li>
                                <a href="/about" class="">
                                    <i class=" fa-"></i>
                                    <span>关于本站</span>
                                </a>
                            </li>
                        
                    </dl>
                
            </li>
        
    </ul>
    <ul class="cl nav-tool">
        
            <li>
                <a href="/github">
                    <i class="fa fa-github"></i>
                </a>
            </li>
        
            <li>
                <a href="/mail">
                    <i class="fa fa-envelope"></i>
                </a>
            </li>
        
            <li>
                <a href="/twitter">
                    <i class="fa fa-twitter"></i>
                </a>
            </li>
        
        
        <li>
            <a href="javascript:void(0)" class="nav-search-btn">
                <i class="fa fa-search"></i>
            </a>
        </li>
        
    </ul>
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="nav-search"><input type="search" name="q" class="nav-search-input" placeholder="search..."><input type="hidden" name="sitesearch" value="http://example.com"></form>
</div>

        <header class="top" id="fallEle" style="background-image: url(/imgs/head.jpg)">
    <i class="fa fa-bars" id="media-toggle" style="display: none"></i>
    <div class="top-info cl fadeToBottom">
        <h2 class="site-name"><a href="/">mokusei</a> <small id="type-data">This is a hexo theme</small></h2>
    </div>
</header>

        
<div class="con-wrap fadeToTop archive">
    
    <section class="article-area">
    
        
        
            
                <div class="archive-year"><span class="year-block">2024</span></div>

            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/10/05/职业/" title="空标题">
                    空标题
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-10-05
            </li>
            

            
                
            


        </ul>
        <div class="article-description">
            
            <p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240212212756589.png" alt="image-20240212212756589"></p>
<h1 id="数据分析师"><a href="#数据分析师" class="headerlink" title="数据分析师"></a>数据分析师</h1><p>对代码能力要求不高，侧重的是对业务的理解，逻辑思维和对业务方向的精准判断。由于岗位要求不高，可以做的人多，可能是裁员的优先考虑对象，提升空间不高</p>
<p>越往高级，数据分析师其实就会逐渐<strong>轻技能而重分析</strong>。很多职位要求都需要具备良好的沟通表达能力。需要有较高的逻辑分析能力。最好需要有行业背景，像金融啥的。</p>
<p>数据分析相对来说还是一个比较看重经验的行业，<strong>从业时间越长，经验越是丰富</strong>，相对薪资水平也会越高，很多数据分析师的薪资也是逐年递增的。</p>
<p>要求：</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153551457.png" alt="image-20240211153551457"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153609295.png" alt="image-20240211153609295"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153657287.png" alt="image-20240211153657287"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153718324.png" alt="image-20240211153718324"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153802513.png" alt="image-20240211153802513"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153819410.png" alt="image-20240211153819410"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153906171.png" alt="image-20240211153906171"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211153919623.png" alt="image-20240211153919623"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211154047528.png" alt="image-20240211154047528"></p>
<p>所以数据分析师工资高，真不一定意味着数据分析师紧缺，<strong>也可能是需要这个岗位的都是大公司，所以开出的工资高</strong>。</p>
<p>而且套用一个说职业前景的万能句式：<strong>数据分析师行业不缺人，缺的是精尖</strong>。你要想去一个公司做专业的数据分析师，就得证明自己比那些懂数据分析的运营、销售、市场强，也得证明自己比那些懂业务的程序员强，不然人家现有的员工组合拼凑就够用了，干嘛要你。</p>
<p>当然，专业的数据分析师也确实存在缺口，这个职业在国内火起来还不算久，国内缺乏真正的数据分析专业人才，很多人都是学了点软件应用就敢说自己是数据分析师，结果给个需求，既不知道怎么确定指标体系，又不知道如何找数据，好不容易可视化完，也分析不出个123，反正业务部门自己看去吧。</p>
<p>所以套用一句说职业的万能句式：<strong>数据分析师不缺普通人，缺的是牛人</strong>。你要是左手能数据挖掘ai建模，右手写分析报告建议策略，就可以被抢着要了。</p>
<p>当然一般人（比如我）做到这个级别还是有难度的（反正我在编程上一塌糊涂），<strong>所以我建议是技术和业务选一侧走到精通，另一侧做辅助。然后，如果编程和我一样废，或者是转行年纪稍大的，就选业务吧。</strong></p>
<p><strong>不过既然轻技能，那就势必会重思维和经验，在业务侧，你的数据分析思维很重要，比如老板要你分析一个产品应不应该上线，一个活动值不值得策划实施，这时候</strong>你要自行判断应该从什么角度进行分析，什么数据是关键指标，并通过分析数据给出业务上的意见，甚至出一个业务方案。</p>
<p>这需要你懂得统计学和概率论，以及基于这些数据基础而来的各种分析方法，什么AB测试，多维度拆分，AARRR分析法5w分析法，千变万化，不离其宗；还需要你对一个行业的业务发展上下游都有了解，能判断一个数据的变动是对应哪个环节。</p>
<p>这些东西，即使你是数据分析科班出身，都未必能在工作里直接用好，因为教材是套路的，但业务是多变而且超越教材的，所以比起啃书，我更建议你听听从业者的经验，看人家是如何把理论应用于实践<strong>，最好还能练一练，这样省去了自己在实际业务上摸爬滚打的试错成本，最好还能在求职前有一些个人项目经历，求职的时候就等于有了拿得出手的实习经历。</strong></p>
<p>可能对于一些科班出身的人来说，数据科学方向就是一直以来所预期的发展方向，但在实际的职场上，数据分析更多的是重在分析，<strong>毕竟不是所有的公司需要程序员，但只要是商业公司，总会有对业务进行分析的需求。</strong></p>
<p>就像前面说的，我更建议大家做业务侧，业务侧吃经验，重思维，真的要更适合普通人。尤其是大龄转行0基础想靠敲代码创出一片天的，真的要好好考虑一下，<strong>这把年纪想学通编程得付出多少时间和辛苦，你的家庭能等得起吗，你又真的能学得会吗？</strong></p>
<p>越往高级，数据分析师其实就会逐渐<strong>轻技能而重分析</strong>，真正数据获取阶段的工作做的很少，可能都会交给团队里的初级伙伴来完成。高级分析师则注重在分析阶段，需要的是在对业务的全局把控，对行业和经济的深刻理解。即使是技能，也要求模型优化等更高级别的能力。</p>
<p>而如果你成为创业者或者市场方面的高管，建模这样的工作也会被分派到下面，而你则要根据这些报告做出正确的决策。</p>
<h1 id="ETL工程师-数据工程师"><a href="#ETL工程师-数据工程师" class="headerlink" title="ETL工程师&#x2F;数据工程师"></a>ETL工程师&#x2F;数据工程师</h1><p>入门简单？</p>
<p>是从事系统编程、数据库编程与设计，要掌握各种常用的编程语言的专业技术人员。也叫<strong>数据库工程师</strong>。</p>
<p><strong>为什么之前叫ETL工程师，现在更多的是称数据工程师？</strong></p>
<p>我觉得从我个人而言，首先要从更宏观的角度来理解ETL工程师。一般传统公司称ETL工程师，因为以前经常是将业务系统的数据取出来，进行数据清洗，再按照星型或雪花型建模再放到<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%95%B0%E4%BB%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:630650110%7D">数仓</a>中为下游BI服务。</p>
<p>而现在为什么叫数据工程师？是因为大家意识到，随着数据量的增多，数据产生的价值和变现的维度也随之增多了，数据工程师需要掌握的技能发生了许多变化。</p>
<p><strong>其中最重要的是要肩负起这两点责任：运营数据（养数据）和达到公司的数据目的。</strong>这是ETL工程师或者说是数据工程师最终要达到的目标，</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211204720275.png" alt="image-20240211204720275"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211204740772.png" alt="image-20240211204740772"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211204812758.png" alt="image-20240211204812758"></p>
<p>利用ETL工具完成数据抽取、清洗、转换、装载，mysql，SQL，hadoop&#x2F;hive&#x2F;Spark，Linux，数据仓库原理，熟悉至少一门编程语言，例如Python、Java、Scala等</p>
<p>一味的解释数据仓库概念可能没意思，我们从不同角色出发吧！</p>
<p><strong>老板：</strong>我是一家手机公司的老板，今天要向去董事局汇报，我要准备一份介绍过去三年的用户增长、用户留存、用户活跃度、手机里面每个APP使用率等情况的报表，假如下面没有BI，那我肯定就蒙了……</p>
<p><strong>BI：</strong>我是一名非技术BI，我天天看竞品的分析报告，看双十一销量，看各种评论，<strong>知道自己的产品有哪些短板有哪些长处</strong>，我分析南北地域差异，国内外客户喜好，总之我在手机领域有着很强的<strong>行业解读能力和数据解读能力</strong>，我可以画出非常漂亮的图表和PPT。今天老板让我出一份报表，我还要去刷脸找ETL工程师帮我跑出这次报告的数据，基于这份数据我要给出一定的解读，为啥这个月手机卖得不如上个月，为啥用户流失越来越严重等等都是我要去做的。</p>
<p><strong>ETL工程师 :</strong> 我是食物链最底层的苦逼ETL工程师，我会写<strong>shell</strong>、我会搭<strong>hadoop&#x2F;hive&#x2F;hbase</strong>、会写<strong>超复杂逻辑的SQL</strong>，今天那个不会自己计算数据的BI又让我跑几个数据，我本想让她提需求流程的，但她说这是老板要的(运营惯用的杀手锏！！！)，要加急处理，我只能放下手头的活儿给她跑数据了，花了半个小时把数据跑好给她，希望能就这么交差吧。</p>
<p>大数据工程师，就是我们所知的大数据开发工程师，<strong>主要从事大数据平台的搭建，</strong>对个人技术要求偏高，需要从业者具备java基础，还得具备以下技术能力，<strong>hadoop、hive、hase、flume、storm、kafka、spark等</strong>，是一个非常庞大的技术集群。</p>
<p>如果你以为我每天就做这点事那你就错了，我平时的工作可不仅仅就是完成上面交给我的任务哦，我还负责<strong>数据ETL过程、数据建模、定时任务的分配、甚至有时Hadoop集群的维护</strong>等等都得我去做，每件事单独拿出来都可以拿出来写本书。</p>
<p>就拿ETL过程来说吧，你要把原始数据从各种数据库、各种服务器的不同业务日志归一化到同一类格式，要约定好分隔符，然后导入到分布式文件系统HDFS，甚至你还要和业务系统定义数据格式出规范，数据收集完，你还得出中间表，数据过滤，格式统一，ID统一，维度统一，通过不同的数据现象进行数据，完了，你就得出一些日报周报之类的数据了，这时候你要按照需求把数据组织成一定的格式然后导Mysql、或者HBASE等等。</p>
<p>总之你就是需要<strong>把数据各种收集、各种处理、然后各种导入导出</strong>，是不是很有意思？</p>
<p>不过这些数据仓库都非常初级，其中ETL工程师可发挥的空间太多了！</p>
<p>正常情况下，老板→BI→ETL出一份报告，这中间能否BI直接去计算数据？SQL太复杂，那么可不可以一切数据标签化，BI甚至老板要什么就选什么？</p>
<p><strong>ETL工程师可以把数据收集自动化、可以规范业务日志格式、可以将一切都配置化</strong>，但是这些都是基于N+1的，也就是说今天的发生了什么一定要到明天才能看到，那么有没有一个系统能把数据分析做到实时或者准实时？参考双十一大屏，马总要是到12号才能知道成交了多少笔不劈了那帮做数据的才怪。</p>
<p><strong>目前绝大部分分析系统都基于离线计算（HADOOP&#x2F;ODPS），</strong>那这里有个问题了，运营或BI想看个数据还得你离线慢腾腾跑完才能看到，那么有没有一个系统可以支持你再大的数据量，再复杂的逻辑，毫秒出数据？</p>
<p>我没有提到的还有<strong>算法工程师、大数据运维工程师</strong>等等。</p>
<h1 id="大数据开发"><a href="#大数据开发" class="headerlink" title="大数据开发"></a>大数据开发</h1><p>做大数据开发需要有强大的逻辑思维和代码编写能力，数学能力，以及对算法的敏感度。如果说数据分析更多的是和人打交道的话，那么大数据开发更像是机器打交道(阿宅们的福音）。大数据开发就不需要考虑和心理学相关问题，只是别人给你需求，按照他的需求编写好逻辑，提供给他他要的就行了。有一个绝对听话的编译软件陪着你，不需要过多的考虑他人的想法，</p>
<img src="C:\Users\BD\Documents\WeChat Files\wxid_eb3dot0ogrgw22\FileStorage\Temp\604bb97f7d335a95d6fa3310e357530.jpg" alt="604bb97f7d335a95d6fa3310e357530" style="zoom:67%;" />

<p>大数据开发主要是大数据组件的二次开发，或者大数据平台的搭建等方向，我目前干的就是大数据组件的二次开发。总而言之就是，参与大数据分布式应用系统服务器端或客户端软件开发工作（需求开发、故障解决和性能优化等）。主要偏向于Java方向，Java要求较高。</p>
<p>熟练掌握Java，有相关并发的编程经验，精通Java&#x2F;Python&#x2F;C++&#x2F;scala&#x2F;go语言中一种或多种，熟悉数据结构和算法，熟悉linux; 对Hadoop&#x2F;Flink&#x2F;Presto&#x2F;Druid&#x2F;Redis&#x2F;Kafka等开源技术有一定的了解， 读过源码的优先；                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211211422682.png" alt="image-20240211211422682"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240211211516512.png" alt="image-20240211211516512"></p>
<h1 id="数据科学家"><a href="#数据科学家" class="headerlink" title="数据科学家"></a>数据科学家</h1><p><strong>难</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240212212543245.png" alt="image-20240212212543245"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240212212600055.png" alt="image-20240212212600055"></p>
<p>对数据的敏感程度直接决定了你将会如何使用手头的工具和知识，最终影响到conclusion的质量</p>
<p>data scientist的另外一个区别于其他类似职业的特性就是<strong>深入</strong>。且不管scientist这种叫法是否合适，但是被称作scientist的人必须永远是走在cutting-edge的人才，同时也必须是对问题、数据、方法、结论都有着深入理解的人，而不仅仅是停留在数据、现象、问题的表面，否则就变成了机械、简单、重复的统计分析。因此，data scientist作为<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BA%A4%E5%8F%89%E5%AD%A6%E7%A7%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:37410172%7D">交叉学科</a>人才，并不仅仅要求你拥有七十二般武艺，更需要你在关键的领域拥有对知识全面而深入的理解，看问题的角度需要独到犀利。除此之外，你还要像一名真正的scientist一样，拥有强烈的探索欲、好奇心、行动力。</p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/10/05/英语/" title="空标题">
                    空标题
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-10-05
            </li>
            

            
                
            


        </ul>
        <div class="article-description">
            
            <p>[TOC]</p>
<h1 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h1><h2 id="不会"><a href="#不会" class="headerlink" title="不会"></a>不会</h2><p>rigor 严厉，严格；component 零件，组成部分；endurance 忍耐力；depression 抑郁；fulfilling 充实的；prioritize 把…..区分优先次序，优先考虑；overall 整体的；fatigue 疲劳；yield 产生；bold 大胆的，果敢的；rust 使生锈，铁锈；blade 刀刃；strip 剥去，除去，脱去衣服；craft 工艺；outline 纲要；lease 租用，租约；loaner借用物；gamble 打赌，赌博；gambler 赌徒；rational 合理的，有理智的；harsh 严厉的，残酷的，恶劣的；prominent 重要的，知名的；substantial 大量的，物质的；inherent 本质的，基本的；administration 管理，行政；<del>部门；</del>部门；    speculation 预测；decent 体面的；essence 本质；dispute 争端；collapse 倒塌，昏倒，崩溃；</p>
<h2 id="不怎么熟"><a href="#不怎么熟" class="headerlink" title="不怎么熟"></a>不怎么熟</h2><p>adopt 采用；enhance 加强；exhausted 精疲力尽的；pledge v.发誓；enthusiasm 热爱，热情；virtually 实际上，几乎，虚拟地；barrel 桶；accessible 易得到的；易使用的；indispensable 不可缺少的；regulate 控制，管理，调整；meantime 与此同时；attribute(attribute sth.to sb.&#x2F;sth.)把…..归因于；contribute 有助于，贡献，捐赠；sustain 保持，维持；inherit 继承，继任，接受遗产；underline 强调，在什么下划线；outcome 结果；</p>
<h2 id="替代词"><a href="#替代词" class="headerlink" title="替代词"></a>替代词</h2><p>重要的：essential,vital,crucial</p>
<h1 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h1><p>in turn 依次，轮流，相应地，反过来；self-discipline 自律;coupled with+Ving&#x2F;n.  和；                        in conclusion 总之；inside and outside the classroom 课堂内外；prioritize…over… 把什么置于什么之上；lack of 缺少；over time 逐渐地，慢慢地；take delight&#x2F;pleasure in doing sth.  乐于做某事；give rise to sth. 引起；noting but 仅仅，不过；implementation of family planning 计划生育；</p>
<h1 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h1><p>By prioritizing regular exercise, healthy eating, and sufficient sleep, we can improve our physical and mental health, enabling us to perform better in our academic pursuits.<br>通过优先考虑规律的运动、健康的饮食和充足的睡眠，我们可以改善身心健康，使我们在学业上表现更好。</p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/10/05/职规/" title="空标题">
                    空标题
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-10-05
            </li>
            

            
                
            


        </ul>
        <div class="article-description">
            
            <h1 id="个性化信息"><a href="#个性化信息" class="headerlink" title="个性化信息"></a><strong>个性化信息</strong></h1><h2 id="以一天为时间单位，反映访谈对象在一整天中的典型工作行为，200-300-字"><a href="#以一天为时间单位，反映访谈对象在一整天中的典型工作行为，200-300-字" class="headerlink" title="以一天为时间单位，反映访谈对象在一整天中的典型工作行为，200-300 字"></a><strong>以一天为时间单位，反映访谈对象在一整天中的典型工作行为，200-300 字</strong></h2><p>早上六点种起床，我洗漱完去学生宿舍催促、提醒学生们起床，若上午早些时候没有课就在早上监督，巡视完早读后回去吃早饭和买菜。在上完一二节课后监督学生大课间的跑操、做操情况。在此之后有课就上课，没有上课就批改学生作业。同时还要备课,以及与其它老师交流同学们的学习情况。傍晚有时间就和同事打打 网球，或者运动一下。晚上就是巡查和监督晚读和晚自修。</p>
<h2 id="访谈对象对所从事职业的主观评价和工作体会，100-200字"><a href="#访谈对象对所从事职业的主观评价和工作体会，100-200字" class="headerlink" title="访谈对象对所从事职业的主观评价和工作体会，100-200字"></a><strong>访谈对象对所从事职业的主观评价和工作体会，100-200字</strong></h2><p>尽管工作上的事物业比较繁琐，工作也比较辛苦,但出于对孩子们的喜爱以及看到孩子们进步的成就感，使得其成为了我不断坚持从事这一行业的源源动力。这项工作出于为各种各样学生服务的性质，使得教师们还需调整自身的教学方法，使其适合大部分学生的需求。</p>
<h2 id="访谈对象给大学生的建议"><a href="#访谈对象给大学生的建议" class="headerlink" title="访谈对象给大学生的建议"></a>访谈对象给大学生的建议</h2><p>大学只是起点起点需立大志，而不应把大学当做放松消遣之地。</p>
<h2 id="访谈员访谈感受"><a href="#访谈员访谈感受" class="headerlink" title="访谈员访谈感受"></a>访谈员访谈感受</h2><p>深刻体悟到了教师行业的辛苦以及对学生的关心之切。即使在课余时间仍想着如何帮助学生取得进步，以及不仅要了解学生学业上的事情，同时也要了解学生生活上的事情。也理解了作为老师有着不能告诉学生的苦衷，这使得学生与老师产生了隔阂。就如老师因为某些学生生活上或心理上的问题，来对其有所偏担，这就造成了学生与学生或学生与老师之间的矛盾。</p>
<h1 id="职业技能"><a href="#职业技能" class="headerlink" title="职业技能"></a>职业技能</h1><p>1、沟通能力:教师需要与学生家长和同事进行有效的沟通。包括清晰表达思想、倾听他人意见和解释复杂概念等，并且其沟通能力要能适应不同的教学环境和学生需求，并灵活运用不同的教学技术、利用教学资源和评估学生学习成果。</p>
<p>2、教学方法:教师需要具备有效的教学方法和策略,包括灵活运用不同的教学方法，利用教学资源和评传学生学习成果等。</p>
<p>3、学科知识：教师需要深入了解所教授学科的知识和理论，以便能够准确教授学生，并回答他们的问题。</p>
<p>4、评估与反馈:教师需要具备评估学生学习成果的能力，并能够及时给予学生有针对性的反馈，帮助他们改变和进步。</p>
<h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><p>视频会议工具:钉钉、腾讯会议等，以远程教学或线上会议形式与学生、同事或家长进行互动和沟通。</p>
<p>办公软件:教师需熟练运用办公软件和Microsoft Office 套件用于制定课程计划、创建教学材料、记录学生成绩等.</p>
<h1 id="薪酬待遇"><a href="#薪酬待遇" class="headerlink" title="薪酬待遇"></a>薪酬待遇</h1><p>1、薪酬结构：基本工资+教龄津贴+职务津贴+其它补贴</p>
<p>2、福利：医疗保险、养老金和退休福利，假期和休假、住房津贴及子女教育福利、社会保障和福利</p>
<p>3、本人薪酬满意度：3   (薪酬满意度评分: 1-5,分别代表“非常不满意”~“非常满意”)</p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/10/05/学习/" title="空标题">
                    空标题
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-10-05
            </li>
            

            
                
            


        </ul>
        <div class="article-description">
            
            <p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240212220055545.png" alt="image-20240212220055545"></p>
<p>牛客网刷题</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240212220157525.png" alt="image-20240212220157525"></p>
<p><strong>《<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA+MySQL&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2433597616%7D">深入浅出 MySQL</a>》</strong></p>
<p>前面的部分的“基础篇”可以快速略过，重点的就是后面的“开发篇和优化篇”。</p>
<p>尤其是后面的“优化篇”对我帮助很大，学习了一些常见的 MySQL 优化方式。</p>
<p>毕竟数据库性能优化是对我们来说很重要的一趴。</p>
<p><strong>《MySQL 技术内幕：InnoDB存储引擎》</strong></p>
<p>MySQL 中用的做多的就是 InnoDB 引擎，所以更进一步学习 InnoDB 存储引擎很有必要。</p>
<p>这本书反正就是 MySQL 中的经典书，解析了 InnoDB 的体系结构、实现原理、工作机制，里面呆了大量的实践内容。</p>
<p><strong>《高性能 MySQL》</strong></p>
<p>MySQL 不老的经典大部头，这个大家就放在最后看好了。</p>
<p>这本书好的方面是，每一章都是相对独立的主题，大家可以根据目录选择性的阅读。</p>
<p>我记得当时我主要就是看了创建高性能的索引、查询性能优化这几个章节，不得不说：Nice！</p>
<p>作为数据分析师，日常使用 SQL，<strong>主要就是把自己想要的数据或者指标需求转化成 SQL 的语言逻辑去数据库等地方查询数据。</strong></p>
<p>很多初学者会被网上的一些信息误导，以为 SQL 的学习要掌握到极精深的地步，恨不得深入内核嚼碎了来学。</p>
<p>怎么说呢，没必要，数据分析师使用 SQL 的重点就是在【<strong>查询</strong>】两个字上。</p>
<p>所以单纯对数据分析师来说，SQL 的掌握主要在基础语言的学习和性能优化上的学习上就好了。</p>
<p>没必要深入内核去学习。</p>
<p>其实大概分的话，由浅入深分成 3 个阶段吧：</p>
<p><strong>（1）入门阶段</strong></p>
<p><strong>入门阶段的话就是熟练的掌握增删改查语句、运算符以及函数。</strong></p>
<p>增删改查语句主要就是 select、insert、update、delete。</p>
<p>运算符主要就是算术运算符（+、-、*、&#x2F;、%）、赋值运算符（&#x3D;）、比较运算符（＞、≥、＜、≤）和逻辑运算符（AND、ANY、BETWEEN、IN）。</p>
<p>函数主要就是算法函数和时间函数等。</p>
<p><strong>（2）进阶阶段</strong></p>
<p><strong>这一个阶段是重中之重</strong></p>
<p><strong>进阶阶段主要是熟练掌握多表查询、分组查询、子查询、组合查询等。其中最重要的就是多表查询。</strong></p>
<p>工作里往往数据不是放在一个表里，而是不同的数据放在不同的表里，这就需要会从不同的表中根据业务需求来获取数据，这就需要 SQL 进行多表查询。</p>
<p><strong>（3）高级阶段</strong></p>
<p><strong>高级阶段要是为了提高 SQL 的效率。都是写 SQL，怎么可以让 SQL 执行效率更快。</strong></p>
<p>在这各阶段，主要要求你去学习约束、事务、锁、触发器、视图等内容。</p>
<p><strong>虽然我希望大家都能掌握到第 3 阶段，但是我也知道，这对刚入行的数据分析师是有点难度的，因为这些是需要你在大量工作中积累经验。</strong></p>
<p><strong>所以对于我希望你最好掌握到第二阶段【进阶】。</strong></p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/10/05/问题/" title="空标题">
                    空标题
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-10-05
            </li>
            

            
                
            


        </ul>
        <div class="article-description">
            
            <p>1、python里面的print会自动换行，要怎样才能使分两次输出的内容在同一行呢？</p>
<p>2、<img src="/typora-user-images/image-20240803152232367.png" alt="image-20240803152232367"></p>
<p>黄色的句子是什么意思。</p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/10/05/数据结构2/" title="空标题">
                    空标题
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-10-05
            </li>
            

            
                
            


        </ul>
        <div class="article-description">
            
            <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240127164721571.png" alt="image-20240127164721571"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240127164543672.png" alt="image-20240127164543672"></p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240127164928463.png" alt="image-20240127164928463"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240127165239561.png" alt="image-20240127165239561"></p>
<p>在存储当前元素的时候顺便存储了下个元素的地址</p>
<p>接下来两个了解就可以</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240127165445674.png" alt="image-20240127165445674"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240127165514183.png" alt="image-20240127165514183"></p>
<h2 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h2><p>数据类型是一组性质相同的值的集合以及定义于这个值集合上的一组操作的总称。数据类型&#x3D;值的集合+<strong>值集合上的一组操作</strong>。</p>
<p>在定义一个变量的数据类型的时候也规定了它值的范围以及能进行的操作。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240127170323095.png" alt="image-20240127170323095"></p>
<p>抽象数据类型就是一个概念</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240127170445860.png" alt="image-20240127170445860"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240127171025284.png" alt="image-20240127171025284"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240127171059544.png" alt="image-20240127171059544"></p>
<p><strong>例子：</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240127171335993.png" alt="image-20240127171335993"></p>
<p>因为要返回C本身，所以前面加上&amp;</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240127171658402.png" alt="image-20240127171658402"></p>
<p>assigh是构建虚数</p>
<p><strong>小结：</strong><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240127180218139.png" alt="image-20240127180218139"></p>
<h2 id="抽象数据类型的表示与实现"><a href="#抽象数据类型的表示与实现" class="headerlink" title="抽象数据类型的表示与实现"></a>抽象数据类型的表示与实现</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240128101926420.png" alt="image-20240128101926420"></p>
<p>抽象数据类型利用处理器里已存在的数据类型来说明新的结构，用已经实现的操作来组合形成新的操作。</p>
<p>例如：<img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240128102515684.png" alt="image-20240128102515684"></p>
<h2 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240128103051438.png" alt="image-20240128103051438"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240128103215990.png" alt="image-20240128103215990"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240128103459228.png" alt="image-20240128103459228"></p>
<p><strong>时间复杂度</strong>，求得时候只考虑算法中的基本操作执行的次数</p>
<p>若T(n)函数可以分解为T1(n)和T2(n)两个函数，则可以利用加法和乘法法则</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240128113828306.png" alt="image-20240128113828306"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240128114150366.png" alt="image-20240128114150366"></p>
<p><strong>空间复杂度</strong></p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="定义和特点"><a href="#定义和特点" class="headerlink" title="定义和特点"></a>定义和特点</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240128223218645.png" alt="image-20240128223218645"></p>
<p>这里面的数据a[i]只是一个抽象的符号，其具体含义在不同情况下可以不同。</p>
<p>同一线性表中的元素必定是具有相同特性，数据元素间的关系是线性关系，1-1的</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240128223601677.png" alt="image-20240128223601677"></p>
<p>线性表属于顺序存储结构，而顺序存储结构存在问题：存储空间分配不灵活，运算的空间复杂度高。</p>
<p>线性表有两种基本的存储结构：<strong>顺序</strong>存储结构和<strong>链式</strong>存储结构。</p>
<h2 id="类型（抽象数据类型）定义"><a href="#类型（抽象数据类型）定义" class="headerlink" title="类型（抽象数据类型）定义"></a>类型（抽象数据类型）定义</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240128225013212.png" alt="image-20240128225013212"></p>
<h2 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h2><p>顺序表示就是顺序存储结构</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240129103850300.png" alt="image-20240129103850300"></p>
<p>存储的时候不能改变它们的顺序，存储的空间也要是连续的，中间没有空出的存储单元。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240129104941349.png" alt="image-20240129104941349"></p>
<p>存储线性表的一个模板（上面那个）</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240129110700726.png" alt="image-20240129110700726"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240129111035519.png" alt="image-20240129111035519"></p>
<p>例子：存储多项式</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240129105807288.png" alt="image-20240129105807288"></p>
<p>c++中传地址的方式——引用类型作参数</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240129111750089.png" alt="image-20240129111750089"></p>
<p>从另一个角度说，i 和j 的地址是一样的，所以i 改变j 也会改变。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240129111931228.png" alt="image-20240129111931228"></p>
<p>m是对a的引用，n是对b的引用，所以对m和n的操作就是对a和b的操作。这种方式比传指针要简单。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240129112319812.png" alt="image-20240129112319812"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240129120204427.png" alt="image-20240129120204427"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240129160801123.png" alt="image-20240129160801123"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240129162211640.png" alt="image-20240129162211640"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240129162310655.png" alt="image-20240129162310655"></p>
<p>上面的那些红色字迹不用管，这题的期望值就是4。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240129161925291.png" alt="image-20240129161925291"></p>
<h2 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130105455805.png" alt="image-20240130105455805"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130105846253.png" alt="image-20240130105846253"></p>
<p>部分术语</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130110209994.png" alt="image-20240130110209994"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130110342838.png" alt="image-20240130110342838"></p>
<p>双链表一个存储前驱的指针，一个存储后继的指针</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130110531125.png" alt="image-20240130110531125"></p>
<p>头结点是额外附加的一个节点，有时会出现，所以链表的存储结构有两种形式：一种是有头结点的一种是没有的。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130111022583.png" alt="image-20240130111022583"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130111202565.png" alt="image-20240130111202565"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130111321613.png" alt="image-20240130111321613"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130111442191.png" alt="image-20240130111442191"></p>
<p><strong>顺序表是随机存储，链表是顺序存取。</strong></p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130174916038.png" alt="image-20240130174916038"></p>
<p>Lnode和*LinkList都是类型名，Lnode *a相当于LinkList a。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130175335921.png" alt="image-20240130175335921"></p>
<p>常用的是前两个	</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130175623007.png" alt="image-20240130175623007"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130210457939.png" alt="image-20240130210457939"></p>
<p>因为要直接改变L的值，所以用&amp;L。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130211216292.png" alt="image-20240130211216292"></p>
<p>销毁，c用free那前面就要用mallloc，c++用delete那前面就要用new</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130211646412.png" alt="image-20240130211646412"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130220655401.png" alt="image-20240130220655401"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130221827475.png" alt="image-20240130221827475"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240130223956212.png" alt="image-20240130223956212"></p>
<p>第2的那个算法，和上面计算个数的算法不一样，用这个算法计算表长（即没有j&lt;i-1这个条件）会多出一个。然后当j&#x3D;1时，它所记得这个1代表的是首元结点，此时指针指向第一个结点，所以从另一个角度看，可以认为这个算法就是寻找第j 个结点 。这个算法中p&#x3D;L而不是p&#x3D;L-&gt;next，是因为这样，当我们找到第j 个结点的时候，p 此时就指向这个结点，而不是这个下一个结点。并且这个算法同时也可以解决插入在最后面的情况，例如：表长为5，要插入在第六个结点，此时，j 值最多为6，所以，p 可以等于第5个结点，此时j 也等于5，p 也不为空，若p 为空，则说明要插入位置大于表长+1，是错的。     <strong>妙</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131112132556.png" alt="image-20240131112132556"></p>
<p>也叫前插法，都接在头结点后面。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131115331514.png" alt="image-20240131115331514"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131115725772.png" alt="image-20240131115725772"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131115951390.png" alt="image-20240131115951390"></p>
<p>因为尾插法是在最后一项后面插入的，所以要多设一个变量来存储最后一项的信息；二头插法是从头开始插入的，已经有一个L存储了，所以不需要额外的一个变量。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131122217346.png" alt="image-20240131122217346"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131133820939.png" alt="image-20240131133820939"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131134010461.png" alt="image-20240131134010461"></p>
<p>用尾指针表示循环链表更好。</p>
<p>两个链表合并：</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131134726965.png" alt="image-20240131134726965"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131134855492.png" alt="image-20240131134855492"></p>
<p>注意最后return的是Tb</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131135410991.png" alt="image-20240131135410991"></p>
<p>双向单链表的头结点的prior为空</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131135554700.png" alt="image-20240131135554700"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131135801318.png" alt="image-20240131135801318"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131140307801.png" alt="image-20240131140307801"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131153311150.png" alt="image-20240131153311150"></p>
<h3 id="三种表的时间效率比较"><a href="#三种表的时间效率比较" class="headerlink" title="三种表的时间效率比较"></a>三种表的时间效率比较</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131153843328.png" alt="image-20240131153843328"></p>
<p>双向循环链表牺牲空间换取时间</p>
<h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131154238465.png" alt="image-20240131154238465"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131154331470.png" alt="image-20240131154331470"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240131154538272.png" alt="image-20240131154538272"></p>
<h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203104017610.png" alt="image-20240203104017610"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203104029654.png" alt="image-20240203104029654"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203104351785.png" alt="image-20240203104351785"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203105015613.png" alt="image-20240203105015613"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203105037562.png" alt="image-20240203105037562"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203105711670.png" alt="image-20240203105711670"></p>
<p>出循环的条件是pa或者pb为空，最后一项都输完了。</p>
<p>本方法不需要额外的空间，只需修改指针就可以了，所以空间复杂度为O(1)。</p>
<p>稀疏多项式相加</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203115103134.png" alt="image-20240203115103134"></p>
<p>最后因为所有项都到Pa里了，Pb没有用 了，所以要释放Pb的头结点。</p>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p>栈和队列是限定插入和删除只能在表的“<strong>端点</strong>”进行的线性表。</p>
<p>栈，简称LIFO结构，插入新元素只能插入在表尾，删除元素也是从表尾开始。——后进先出</p>
<p>队列，插入新元素在表尾，删除元素从表头开始。——先进先出</p>
<p> <strong>栈是解决封闭对应问题的有效方法</strong>。 </p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203153935765.png" alt="image-20240203153935765"></p>
<h2 id="定义和特点-1"><a href="#定义和特点-1" class="headerlink" title="定义和特点"></a>定义和特点</h2><p><strong>栈：</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203155226995.png" alt="image-20240203155226995"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203155527112.png" alt="image-20240203155527112"></p>
<p>可以一边入栈一边出栈，只要入栈顺序没变就行。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203155840371.png" alt="image-20240203155840371"></p>
<p><strong>队列：</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203160124068.png" alt="image-20240203160124068"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203160227814.png" alt="image-20240203160227814"></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>一、进制转化（栈）</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203160822121.png" alt="image-20240203160822121"></p>
<p>二、括号匹配的检验（栈）</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203161016775.png" alt="image-20240203161016775"></p>
<p>在外面的括号要晚匹配，在里面的括号要先匹配，相当于栈的后进先出。</p>
<p>三、表达式求值（栈）</p>
<p>后面会详细讲</p>
<p>接下来介绍的算法是有运算符优先级确定运算顺序的对表达式求值算法——算符优先算法</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203161537156.png" alt="image-20240203161537156"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203162128387.png" alt="image-20240203162128387"></p>
<p>四、舞伴问题（队列）</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203163300835.png" alt="image-20240203163300835"></p>
<h2 id="栈的表示和实现"><a href="#栈的表示和实现" class="headerlink" title="栈的表示和实现"></a>栈的表示和实现</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203165113076.png" alt="image-20240203165113076"></p>
<p>n&#x3D;0的时候叫做空栈</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203165258956.png" alt="image-20240203165258956"></p>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203165619730.png" alt="image-20240203165619730"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203170552897.png" alt="image-20240203170552897"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240203170707763.png" alt="image-20240203170707763"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205205035844.png" alt="image-20240205205035844"></p>
<p>栈中的元素个数仍可以用top-base来算，其实top和base也可以是整型变量。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205205629896.png" alt="image-20240205205629896"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205210014859.png" alt="image-20240205210014859"></p>
<p>只要将top指针指向base指针，不管中间有哪些值，就是为空。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205210623930.png" alt="image-20240205210623930"></p>
<p>第一步delete是把数组回归内存了（base相当于是数组名），红色的几句是把结构体里的元素设置为空了。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205211111207.png" alt="image-20240205211111207"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205212506217.png" alt="image-20240205212506217"></p>
<p>top指针下移后，top所指的元素是否有值就无所谓了，不需要将其清除或者其他操作。</p>
<p>为什么要先减，因为top指针比存储的位置大1。</p>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205214127633.png" alt="image-20240205214127633"></p>
<p>an里面存储的是前驱元素，不是后继元素，它的方向是从n-&gt;1的，和单链表的相反。（感觉方向没啥区别）</p>
<p>如果多一个头结点的话，那操作更加麻烦。</p>
<p>指针方向由上往下的话，那插入元素就相当于是头插法，因为S指向的是首元结点。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205214722773.png" alt="image-20240205214722773"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205214733752.png" alt="image-20240205214733752"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205215152393.png" alt="image-20240205215152393"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205215317853.png" alt="image-20240205215317853"></p>
<h2 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205223805062.png" alt="image-20240205223805062"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205223909252.png" alt="image-20240205223909252"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205224120366.png" alt="image-20240205224120366"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205224419543.png" alt="image-20240205224419543"></p>
<p>后调用的先返回，符合栈的特点，所以多个函数的嵌套就可以用栈来实现。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205224721441.png" alt="image-20240205224721441"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205224829776.png" alt="image-20240205224829776"></p>
<p>fact是一个用来计算阶层的函数。</p>
<p>在递归的过程中，由高级语言的系统自动生成一个栈存储相关数据。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205225050279.png" alt="image-20240205225050279"></p>
<p>递归的时间效率不高</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240205225241787.png" alt="image-20240205225241787"></p>
<p>一般情况下还是用递归</p>
<h2 id="队列的表示和操作的实现"><a href="#队列的表示和操作的实现" class="headerlink" title="队列的表示和操作的实现"></a>队列的表示和操作的实现</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206102641822.png" alt="image-20240206102641822"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206102726594.png" alt="image-20240206102726594"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206102858096.png" alt="image-20240206102858096"></p>
<h3 id="循环顺序队"><a href="#循环顺序队" class="headerlink" title="循环顺序队"></a>循环顺序队</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206110146633.png" alt="image-20240206110146633"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206103557156.png" alt="image-20240206103557156"></p>
<p>不可以继续入队，会越界</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206103815929.png" alt="image-20240206103815929"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206105454690.png" alt="image-20240206105454690"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206105839090.png" alt="image-20240206105839090"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206105950312.png" alt="image-20240206105950312"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206110614016.png" alt="image-20240206110614016"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206111006830.png" alt="image-20240206111006830"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206111357035.png" alt="image-20240206111357035"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206111629679.png" alt="image-20240206111629679"></p>
<h3 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206114241566.png" alt="image-20240206114241566"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206114450054.png" alt="image-20240206114450054"></p>
<p>入队只能从队尾输入</p>
<p> <img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206115845986.png" alt="image-20240206115845986"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206120219204.png" alt="image-20240206120219204"></p>
<p>但Q.front为空的时候才会跳出循环。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206120649559.png" alt="image-20240206120649559"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206120756111.png" alt="image-20240206120756111"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240206120904197.png" alt="image-20240206120904197"></p>
<h1 id="串，数组和广义表"><a href="#串，数组和广义表" class="headerlink" title="串，数组和广义表"></a>串，数组和广义表</h1><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208160951735.png" alt="image-20240208160951735"></p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>感觉就是字符串</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208161109202.png" alt="image-20240208161109202"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208161209490.png" alt="image-20240208161209490"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208161509249.png" alt="image-20240208161509249"></p>
<p>应该是b 在d 中的位置是：5。</p>
<p>串相等：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。</p>
<p><strong>所有的空串都是相等的。</strong></p>
<h3 id="类型定义和存储结构"><a href="#类型定义和存储结构" class="headerlink" title="类型定义和存储结构"></a>类型定义和存储结构</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208165504432.png" alt="image-20240208165504432"></p>
<p>串中元素的逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构。</p>
<p>顺序存储结构——顺序串；链式存储结构——链串。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208173831481.png" alt="image-20240208173831481"></p>
<p>一般不用ch[0]，这样可以为后面的算法带来简便。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208174253068.png" alt="image-20240208174253068"></p>
<p>存储数值的那个部分叫做<strong>块</strong>，如图。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208174356815.png" alt="image-20240208174356815"></p>
<h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208174832458.png" alt="image-20240208174832458"></p>
<h4 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h4><p>BF，暴力破解法</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208175200905.png" alt="image-20240208175200905"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208204406810.png" alt="image-20240208204406810"></p>
<p>返回第一个字符的序号</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208204920246.png" alt="image-20240208204920246"></p>
<p>为什么i&#x3D;1，因为它存储时从1开始存的，0的位置没有存储。<strong>j应该是&gt;而不是&gt;&#x3D;</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208205321687.png" alt="image-20240208205321687"></p>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208210046857.png" alt="image-20240208210046857"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208210416309.png" alt="image-20240208210416309"></p>
<p>j 前面的字符，不包括j 本身。</p>
<p>其他情况就是j 前面的字符和从头开始的字符没有匹配的情况。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208212213731.png" alt="image-20240208212213731"></p>
<p>为什么j 会等于1呢，因为模式串存储也是从1 开始，0 并不存储。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216114641082.png" alt="image-20240216114641082"></p>
<p>为什么if 条件里面会有j&#x3D;&#x3D;0，因为当不匹配且当时j&#x3D;1的时候（也就是模式串第一位就不匹配），j 才会等于0，接下来主串和模式串都要往后移一位再继续比较，所以i++,j++。</p>
<p>下面是求next的</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240208212009223.png" alt="image-20240208212009223"></p>
<p>next值的改进-&gt;nextvalue</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216114505276.png" alt="image-20240216114505276"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216113034151.png" alt="image-20240216113034151"></p>
<p>next是一个一个慢慢比对过去，naxtvalue是一步到位。</p>
<p>例如：比对到第5位，原本第五位的next为2，那就将第五位的字符与第二位的字符比对，相同，则暂时为第二位字符的next值，然后第二位继续和第一位比，若相同就按照前面一部继续，不相同那 nextvalue 就等于第二位的next了。就是说因为第五位和第二位是相同的，所以第二位肯定不匹配，那就相当于j&#x3D;next[2]了，接着假如next[2]这个位置的字符和第五位的又一样，那肯定也不能匹配，那就继续从这位的next继续比对，知道和第五位不同的位置停下来，那接下来就是要从这个位置开始比较最划算，那nextvalue就等于这个位置。或者就是第五位字符和第二位比对，相同就为第二位的nextvalue，不相同则nextvalue 等于next。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216164550867.png" alt="image-20240216164550867"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216164728384.png" alt="image-20240216164728384"></p>
<p>L是一个存储元素的字节数，不乘L那求得就是这个元素前面有多少个元素，乘了那就是前面所占的空间。（不加a的话，a应该是首元素地址）</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216165216388.png" alt="image-20240216165216388"></p>
<h3 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216170650127.png" alt="image-20240216170650127"></p>
<p>节省空间</p>
<h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>对应存储到一维数组当中</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216201750728.png" alt="image-20240216201750728"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216202233791.png" alt="image-20240216202233791"></p>
<p>an1的存储位置：(1+2+3+…+n-1)+(1-1)&#x3D;n(n-1)&#x2F;2</p>
<h4 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h4><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216203447109.png" alt="image-20240216203447109"></p>
<p>存储方法和确认位置的方法和上面那个差不多，下三角矩阵i&gt;&#x3D;j是因为一行的除了常数c外的个数等于i 值，而要找三角里的元素，那j 肯定是&lt;&#x3D;i 的。上三角矩阵+1是因为对角线上的元素不是常数c。</p>
<h4 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h4><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216203941849.png" alt="image-20240216203941849"></p>
<p>图中有三条对角线，所以是三对角矩阵。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216204216591.png" alt="image-20240216204216591"></p>
<h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216204445441.png" alt="image-20240216204445441"></p>
<p>顺序存储结构</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216204641955.png" alt="image-20240216204641955"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216204804776.png" alt="image-20240216204804776"></p>
<p>链式存储结构</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216204950947.png" alt="image-20240216204950947"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240216211428461.png" alt="image-20240216211428461"></p>
<p>上面和旁边的那个head存的是头指针。</p>
<h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>就是扩展的线性表，线性表里的每个元素都是同一种类型的，但是广义表里的不一定是。</p>
<p>线性表是特殊的广义表。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240218111940757.png" alt="image-20240218111940757"></p>
<p>原子就是单一元素</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240218112148999.png" alt="image-20240218112148999"></p>
<p>表尾可以是空表。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240218112328837.png" alt="image-20240218112328837"></p>
<p>第六种叫做递归的广义表；第五种直接用广义表的名字C和D，拥有共同的定义，叫做共享广义表</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240218112850130.png" alt="image-20240218112850130"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240218113606538.png" alt="image-20240218113606538"></p>
<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240218165713461.png" alt="image-20240218165713461"></p>
<p>树是由根和子树组成的。</p>
<p>树是n个结点的有限集，树的定义是一个递归的定义。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240218170157197.png" alt="image-20240218170157197"></p>
<p>凹入越深代表层次越低</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240218175805131.png" alt="image-20240218175805131"></p>
<p><strong>结点的度</strong>既是它子树的个数又是它后继结点的个数又是它分支的个数。</p>
<p>这个树的度是3。</p>
<p>B,C,D为A的孩子，A就是B,C,D的双亲；双亲和孩子就是线性表里的前驱和后继。</p>
<p>拥有共同双亲的结点叫做兄弟。</p>
<p><strong>树的深度（高度）</strong>：树中结点的最大层次。</p>
<p>这棵树的深度是4。</p>
<p><strong>有序树</strong>：树中结点的各子树从左往右有次序（最左边的为第一个孩子）。（就是T1,T2,T3是一棵树，T1,T3,T2是另一棵树）</p>
<p><strong>无序树</strong>：树中结点的各子树无次序。（T1,T2,T3和T2,T1,T3是同一棵树）</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240218180429652.png" alt="image-20240218180429652"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240218180530668.png" alt="image-20240218180530668"></p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>普通树若不转化为二叉树，则运算很难实现。</p>
<p><strong>所有的树都可以和二叉树相互转化。</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240218180947488.png" alt="image-20240218180947488"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240218181104052.png" alt="image-20240218181104052"></p>
<p>二叉树不是有序树，两个概念</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240218181255104.png" alt="image-20240218181255104"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240222164704431.png" alt="image-20240222164704431"></p>
<h2 id="二叉树的性质和存储结构"><a href="#二叉树的性质和存储结构" class="headerlink" title="二叉树的性质和存储结构"></a>二叉树的性质和存储结构</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><strong>1、</strong>在二叉树的第i 层上至多有2^(i-1)个结点(i&gt;&#x3D;1)，至少有1个结点。</p>
<p><strong>2、</strong>深度为k的二叉树至多有2^k-1个结点(k&gt;&#x3D;1)，至少有k个结点。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240226123750695.png" alt="image-20240226123750695"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240226124842786.png" alt="image-20240226124842786"></p>
<p>n为结点数，边就是圈起来的那个，度为1的结点数是n1。</p>
<p>下面的两个式子相等即可以求出该结论。</p>
<p>重要的是分析过程，总边数那一行，左边的式子是从下往上分析，右边那个是从上往下分析，分析的都是边和结点之间的关系。</p>
<p>最后由最后两个式子可以推出性质3的结论。</p>
<h4 id="两种特殊形式的二叉树"><a href="#两种特殊形式的二叉树" class="headerlink" title="两种特殊形式的二叉树"></a>两种特殊形式的二叉树</h4><p><strong>满二叉树</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240310154828093.png" alt="image-20240310154828093"></p>
<p>满二叉树在同样深度的二叉树中结点个数和叶子结点个数最多。</p>
<p><strong>完全二叉树</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240310155201506.png" alt="image-20240310155201506"></p>
<p>为什么第三个图形是非完全二叉树，因为第三个图形中的第6个结点没有对应满二叉树中的第六个结点，并且非完全里的第六个结点占据的是满二叉树里的第7个结点的位置。</p>
<p>在满二叉树中，从最后一个结点开始，<strong>连续</strong>地去掉<strong>任意</strong>个结点，即是一棵完全二叉树。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240310155932043.png" alt="image-20240310155932043"></p>
<p>层次最大的两层就是最后一层和倒数第二层。</p>
<h5 id="性质（4，5，关于完全二叉树的）"><a href="#性质（4，5，关于完全二叉树的）" class="headerlink" title="性质（4，5，关于完全二叉树的）"></a>性质（4，5，关于完全二叉树的）</h5><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240310160550396.png" alt="image-20240310160550396"></p>
<p>那个特殊符号代表的是取整</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240310160825738.png" alt="image-20240310160825738"></p>
<h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240310161327482.png" alt="image-20240310161327482"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240310161410464.png" alt="image-20240310161410464"></p>
<p>TElemType 代表的是数组里面要存储的元素（最好去看一下typedef后加数组的情况的解释）。</p>
<p>此时定义完的bt 代表一个数组，可以存储MAXSTIZE 个元素。</p>
<p>存储不是满二叉树的情况</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240310162013542.png" alt="image-20240310162013542"></p>
<p>缺点和前面的都差不多。</p>
<p>适用与满二叉树和完全二叉树。</p>
<h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p><strong>二叉链表</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240310163152019.png" alt="image-20240310163152019"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240310163347189.png" alt="image-20240310163347189"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240310163645533.png" alt="image-20240310163645533"></p>
<p><strong>三叉链表</strong>（便于寻找双亲）</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240310163817979.png" alt="image-20240310163817979"></p>
<h2 id="遍历二叉树和线索二叉树"><a href="#遍历二叉树和线索二叉树" class="headerlink" title="遍历二叉树和线索二叉树"></a>遍历二叉树和线索二叉树</h2><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><h4 id="三种遍历方法"><a href="#三种遍历方法" class="headerlink" title="三种遍历方法"></a>三种遍历方法</h4><p>依次遍历二叉树的三个组成部分就是遍历了整个二叉树。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240317170154318.png" alt="image-20240317170154318"></p>
<p>D:根结点；L:左子树；R:右子树。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240317170428756.png" alt="image-20240317170428756"></p>
<p>采用递归的方法遍历。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240317170855246.png" alt="image-20240317170855246"></p>
<p>中序和后序遍历道理一样。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240317171308163.png" alt="image-20240317171308163"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240317171503262.png" alt="image-20240317171503262"></p>
<p>若题目要求将中缀表达式转化为后缀表达式，可以先将中缀表达式化作树的形式，然后再转化为后缀表达式。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240317171856530.png" alt="image-20240317171856530"></p>
<p>若只知道先序和后序则不可以确认一棵二叉树。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240317172248472.png" alt="image-20240317172248472"></p>
<p>判断完左右子树后，继续分析判断根和左右子树，直到左右子树中的一个   元素为空或为1，即可以判断元素位置。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240317172839511.png" alt="image-20240317172839511"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240317173135946.png" alt="image-20240317173135946"></p>
<p>后序遍历先左右后根，所以根位于最后，可以从后往前看。</p>
<p><strong>上面两种题型都要先确定根</strong></p>
<h4 id="二叉树的遍历算法"><a href="#二叉树的遍历算法" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h4><h5 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h5><p><strong>先序遍历</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240317174338628.png" alt="image-20240317174338628"></p>
<p>用二叉链表实现</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240317174735489.png" alt="image-20240317174735489"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324091243004.png" alt="image-20240324091243004"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240317175534497.png" alt="image-20240317175534497"></p>
<p>T是指针。</p>
<p>visit(T)可直接替换为对根节点进行的操作。</p>
<p><strong>中序遍历</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324091508322.png" alt="image-20240324091508322"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324091548013.png" alt="image-20240324091548013"></p>
<p><strong>后序遍历</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324091750803.png" alt="image-20240324091750803"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324091805832.png" alt="image-20240324091805832"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324091921852.png" alt="image-20240324091921852"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324092111487.png" alt="image-20240324092111487"></p>
<p>紫色线路为算法的访问路径</p>
<h5 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h5><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324092626487.png" alt="image-20240324092626487"></p>
<p>因为是中序遍历，所以在遍历过程中，碰到根结点要先存储起来，等到第二次遍历到的时候在输出，符合栈的思想，所以要建立一个栈来存储根结点。</p>
<p>重点是理清先后关系。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324093800755.png" alt="image-20240324093800755"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324094148253.png" alt="image-20240324094148253"></p>
<p>TRUE为1 ，FALSE 为0 。</p>
<p>指针变量q用来存储栈里面弹出的根结点的值。</p>
<h4 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h4><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324100832408.png" alt="image-20240324100832408"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324101045866.png" alt="image-20240324101045866"></p>
<p>入队						出队</p>
<p>a							  a</p>
<p>b f							b</p>
<p>f c d						 f</p>
<p>c d g						c</p>
<p>d g						   d</p>
<p>g e							g</p>
<p>e h							e</p>
<p>h							   h</p>
<p>从队列中出一个结点然后将它的左右子树结点入队。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324101558813.png" alt="image-20240324101558813"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324101704020.png" alt="image-20240324101704020"></p>
<p>和二叉树的非递归算法有点类似</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><strong>二叉树的建立</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324102735507.png" alt="image-20240324102735507"></p>
<p>若输入的二叉树的结点中没有包含空结点，那根据这些结点所建立的二叉树不唯一，若将空结点一起输入，那建立的二叉树就是唯一的。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240324103640807.png" alt="image-20240324103640807"></p>
<p><strong>复制二叉树</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331084057520.png" alt="image-20240331084057520"></p>
<p><strong>计算二叉树的深度</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331085109571.png" alt="image-20240331085109571"></p>
<p>计算某一子树的深度时，若m&#x3D;n则任意一个加一都会等于该子树的深度。</p>
<p><strong>计算二叉树的结点数量</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331110645552.png" alt="image-20240331110645552"></p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331112334427.png" alt="image-20240331112334427"></p>
<p>结点的前驱和后继结点不是看树里的结点来判断的，而是看它的遍历顺序来判断。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331112903617.png" alt="image-20240331112903617"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331112959121.png" alt="image-20240331112959121"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331113051434.png" alt="image-20240331113051434"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331113226206.png" alt="image-20240331113226206"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331113850192.png" alt="image-20240331113850192"></p>
<p>这是中序遍历的线索二叉树</p>
<h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331145729866.png" alt="image-20240331145729866"></p>
<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p><strong>双亲表示法</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331150242564.png" alt="image-20240331150242564"></p>
<p>r 代表根结点的位置，n 代表数量。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331150442735.png" alt="image-20240331150442735"></p>
<p><strong>孩子链表</strong></p>
<p>特点：找孩子容易，找双亲难。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331151329318.png" alt="image-20240331151329318"></p>
<p>链表里的数据部分存储的是孩子结点的下标。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331151625871.png" alt="image-20240331151625871"></p>
<p>如何克服缺点，将双亲表示法和孩子链表相结合，在双亲结点中再添加一个空间用来存储该结点的双亲所在位置的下标。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331152159409.png" alt="image-20240331152159409"></p>
<p><strong>孩子兄弟表示法（常用）</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331152452933.png" alt="image-20240331152452933"></p>
<p>找双亲困难，但可以根据需要再添加一个指针域用来指向它的双亲结点。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240331152835893.png" alt="image-20240331152835893"></p>
<h3 id="树和二叉树的转化"><a href="#树和二叉树的转化" class="headerlink" title="树和二叉树的转化"></a>树和二叉树的转化</h3><p>由于树和二叉树都可以用二叉链表作存储结构，则以二叉链表为媒介可以导出数和二叉树之间的对应关系。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405211228912.png" alt="image-20240405211228912"></p>
<p>一棵树的二叉链表是唯一的，而它对应的二叉树也是唯一的。</p>
<p>同一个二叉链表，左右指针域解释为孩子、兄弟则是树的存储方式，解释为左右子树，则是二叉树的存储形式。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405211647384.png" alt="image-20240405211647384"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405211821926.png" alt="image-20240405211821926"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405211928387.png" alt="image-20240405211928387"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405212044394.png" alt="image-20240405212044394"></p>
<h3 id="森林与二叉树的转化"><a href="#森林与二叉树的转化" class="headerlink" title="森林与二叉树的转化"></a>森林与二叉树的转化</h3><p>与树和二叉树的转化类似</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405212319844.png" alt="image-20240405212319844"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405212417458.png" alt="image-20240405212417458"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405212621831.png" alt="image-20240405212621831"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405212748167.png" alt="image-20240405212748167"></p>
<h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405213103578.png" alt="image-20240405213103578"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405213232528.png" alt="image-20240405213232528"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405213343843.png" alt="image-20240405213343843"></p>
<p>第一棵树遍历完之后，剩下的第三部分继续看成森林，然后再分成三部分，继续遍历。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405213413590.png" alt="image-20240405213413590"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405213802768.png" alt="image-20240405213802768"></p>
<h2 id="哈夫曼树及其应用"><a href="#哈夫曼树及其应用" class="headerlink" title="哈夫曼树及其应用"></a>哈夫曼树及其应用</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405215710407.png" alt="image-20240405215710407"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405215942369.png" alt="image-20240405215942369"></p>
<p>哈夫曼树的效率最高</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405220317088.png" alt="image-20240405220317088"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405220713754.png" alt="image-20240405220713754"></p>
<p>结点数目相同的二叉树中，路径最短的不一定是完全二叉树。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405221321967.png" alt="image-20240405221321967"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405221751933.png" alt="image-20240405221751933"></p>
<p>树的度是树中各结点的度中的最大值。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240405222054595.png" alt="image-20240405222054595"></p>
<p>权值较小的离根远，较大的离根近。</p>
<p>具有相同带权结点的哈夫曼树<strong>不唯一</strong>。</p>
<h3 id="构造算法"><a href="#构造算法" class="headerlink" title="构造算法"></a>构造算法</h3><p>贪心算法：先挑权值小的叶子结点构造哈夫曼树。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414095135336.png" alt="image-20240414095135336"></p>
<p>Ti是只有一个带权为wi的根结点。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414095508545.png" alt="image-20240414095508545"></p>
<p>根据刚开始的举例，哈夫曼树中的结点为空的应该是判断条件。</p>
<p>哈夫曼树的结点的度为0或2，没有为1的。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414095958424.png" alt="image-20240414095958424"></p>
<p>n-1各新结点都是度为2的结点。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414100331303.png" alt="image-20240414100331303"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414100718091.png" alt="image-20240414100718091"></p>
<p>使用数组进存储时因为在后面给结点赋双亲结点和左右子树时比较容易。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414101210199.png" alt="image-20240414101210199"></p>
<p>初始状态，构造n个子树。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414101331941.png" alt="image-20240414101331941"></p>
<p>完成第一次循环，删除两个结点就是给两个结点的双亲结点赋值。</p>
<p>所以判断剩余结点的条件就是双亲结点是否为0.</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414101631640.png" alt="image-20240414101631640"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414101943214.png" alt="image-20240414101943214"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414101958619.png" alt="image-20240414101958619"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414102120779.png" alt="image-20240414102120779"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414102604656.png" alt="image-20240414102604656"></p>
<h3 id="哈夫曼树的应用——哈夫曼编码"><a href="#哈夫曼树的应用——哈夫曼编码" class="headerlink" title="哈夫曼树的应用——哈夫曼编码"></a>哈夫曼树的应用——哈夫曼编码</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414102929965.png" alt="image-20240414102929965"></p>
<p>每个字母都用固定长度的空间来存储，比较浪费。</p>
<p>因此让出现次数较多的字母用较少的空间来存储，可以减少浪费。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414103254254.png" alt="image-20240414103254254"></p>
<p>任意一个字符的编码都不是另一个字符的前缀，而哈夫曼树只有叶子结点有值，所以利用哈夫曼树进行编码可以避免出现重码。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414103512970.png" alt="image-20240414103512970"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414104305770.png" alt="image-20240414104305770"></p>
<p>解码采用暴力破解法（我觉得），但其实不是。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414104746689.png" alt="image-20240414104746689"></p>
<p>每个叶子结点的编码不用经过其它需要翻译的字符的结点，所以不会出现一个字符的编码是另一个字符的前缀的情况。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414105526907.png" alt="image-20240414105526907"></p>
<p>cd数组是用来暂时存储寻找字符的编码过程中的编码，从倒数第二个也就是第5位开始存储。</p>
<p>HC数组是用来存储字符编码的。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414110048899.png" alt="image-20240414110048899"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414110440879.png" alt="image-20240414110440879"></p>
<p><strong>文件的编码和解码</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414111042964.png" alt="image-20240414111042964"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414111125810.png" alt="image-20240414111125810"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240414111427864.png" alt="image-20240414111427864"></p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/10/05/数据结构/" title="空标题">
                    空标题
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-10-05
            </li>
            

            
                
            


        </ul>
        <div class="article-description">
            
            <h1 id="算法的时间复杂度和空间复杂度"><a href="#算法的时间复杂度和空间复杂度" class="headerlink" title="算法的时间复杂度和空间复杂度"></a>算法的时间复杂度和空间复杂度</h1><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120110452980.png" alt="image-20240120110452980"></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>算法的时间复杂度是一个<strong>函数（数学里面带有未知数的函数表达式）</strong>，它定义了该算法的运行时间。一个算法所花费的时间于其中的语句的执行次数成正比例，<strong>算法中的基本操作的执行次数为算法的时间复杂度</strong>。</p>
<h3 id="计算："><a href="#计算：" class="headerlink" title="计算："></a>计算：</h3><p>计算时间复杂度的时，不一定要计算精确的执行次数，而只要大概之小红次数，那么这里我们使用大O的渐近表示法。</p>
<p>例子：<img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120113537752.png" alt="image-20240120113537752"></p>
<p>大O的渐近表示法：用于描述函数渐近行为的数学符号。</p>
<p>推导大O阶的方法：</p>
<p>1、用<strong>常数1</strong>取代运行时间中的所有加法<strong>常数</strong>。</p>
<p>2、在修改后的运行次数函数中，<strong>只保留最高阶项</strong>。</p>
<p>3、如果最高阶项存在且不是1，则<strong>去除于这个项目相乘的常数</strong>，得到的结果就是大O阶。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120114417835.png" alt="image-20240120114417835"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120114706253.png" alt="image-20240120114706253"><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120114903048.png" alt="image-20240120114903048"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120173940657.png" alt="image-20240120173940657"></p>
<p>该实例的时间复杂度是O(N)；平均情况一般等于（最好+最坏）&#x2F;2；一般不看平均。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240120175817466.png" alt="image-20240120175817466"></p>
<p>排序的表本身就是有序的，比较次数，可以判断出是n-1次的比较，没有数据交换，此时时间复杂度为O(n)。当最坏的情况，即待排序是逆序的情况。当初始序列从大到小逆序时，需要进行n-1趟排序，进行n(n-1)&#x2F;2次比较和交换。</p>
<p>不要被题目的程序误导，实在想不出来就去看冒泡排序怎么写。</p>
<p><strong>算时间复杂度不能只去看是几层循环，而要去看他的思想。</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240122220744357.png" alt="image-20240122220744357"></p>
<p>设查找了X次</p>
<p>反推：最后剩下一个，那上一次的数量就是1的两倍，再上一次就又是两倍。</p>
<img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240122221014918.png" alt="image-20240122221014918" style="zoom:50%;" />

<p>正推：总数一半一半减少，最后剩下一个。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240122221134443.png" alt="image-20240122221134443"></p>
<p><strong>递归算法</strong>：递归次数*每次递归调用的次数</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240122224853317.png" alt="image-20240122224853317"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240122225924168.png" alt="image-20240122225924168"></p>
<p>虽然N&lt;3,但是右边那块空的相对于其他的来说很小，所以是O(2^N).</p>
<p>那也不对啊，这个程序应该到N&lt;3的时候就直接输出1了，而不是会递归到0和1.</p>
<p>下面这题是”真正的”O(2^N)。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124215911307.png" alt="image-20240124215911307"></p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>要注意计算的是额外的空间</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124220104955.png" alt="image-20240124220104955"></p>
<h3 id="计算：-1"><a href="#计算：-1" class="headerlink" title="计算："></a>计算：</h3><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124220351847.png" alt="image-20240124220351847"></p>
<p>每一次循环结束后使用的空间都会被释放掉，所以从头到尾，i 所使用的应该都是同一个空间。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124222449970.png" alt="image-20240124222449970"></p>
<p>可直接看malloc</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124222818662.png" alt="image-20240124222818662"></p>
<p>递归的空间复杂度要看它递归的深度（次数），这题一共有N次，每次都额外建立了都是常数个额外空间。</p>
<p><strong>函数开辟的空间一次只能给一个用，不能同时开两个分别进行。</strong></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124224437868.png" alt="image-20240124224437868"></p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240124225028609.png" alt="image-20240124225028609"></p>
<p>当你要算F(N)的时候要先算N-1，要算N-1要先算N-2，依次类推不断往下一直到1，那一共要建立n+1个空间，算完2的时候算3时可以重复利用之前使用的空间（此时已经被释放掉了），所以数量不变，以此类推，一直向上，数量始终不变，所以是O(N)。</p>
<h1 id="顺序表和链表"><a href="#顺序表和链表" class="headerlink" title="顺序表和链表"></a>顺序表和链表</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240125163604905.png" alt="image-20240125163604905"></p>
<p>线性表在逻辑上是线性的关系，不是线性的关系的话比如，树形结构。</p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序表其实就是数组。</p>
<p>要从头连续存储。</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240125163951122.png" alt="image-20240125163951122"></p>
<p>1、静态顺序表</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240125165658666.png" alt="image-20240125165658666"></p>
<p>特点：如果满了的话就不让插入；</p>
<p>缺点：不知道大小要定义多少，小了不够用，大了浪费。</p>
<p>2、动态顺序表</p>
<p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240125172049350.png" alt="image-20240125172049350"></p>
<p>空间容量指的不是字节数而是个数</p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/10/05/临时/" title="空标题">
                    空标题
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-10-05
            </li>
            

            
                
            


        </ul>
        <div class="article-description">
            
            <p><img src="C:\Users\BD\AppData\Roaming\Typora\typora-user-images\image-20240226095905062.png" alt="image-20240226095905062"></p>
<p>到最后，b,c,c1,a都为常数，那就可以当作可分离变量来做。</p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/10/05/python/" title="空标题">
                    空标题
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-10-05
            </li>
            

            
                
            


        </ul>
        <div class="article-description">
            
            <h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>同时输出字符和数字：将数字转化为字符处理。</p>
<pre><code class="hljs python">x,y,z = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;三个数的和为：&quot;</span> + <span class="hljs-built_in">str</span>(x + y + z))</code></pre>

<pre><code class="hljs plaintext">x,y,z = 1,2,3
print(&quot;三个数的和为：&quot;,x + y + z)</code></pre>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><pre><code class="hljs plaintext">文本类型： 
     str
数字类型： 
     int, 
     float, 
     complex(复数)
序列类型：
	list,
	tuple,
	range
映射类型：      
     dict
套装类型：      
     set,      
     frozenset
布尔类型：      
     bool
二进制类型：      
     bytes,      
     bytearray,      
     memoryview</code></pre>

<p>可使用以下<strong>type()函数</strong>获取<strong>任何</strong>对象的数据类型。</p>
<p>浮点数类型float：可以使用e(E)来表示科学计数法，x、y仍属于浮点数类型</p>
<pre><code class="hljs plaintext">x = 1e2
y = 2E3
print(x)#100.0
print(y)#2000.0</code></pre>

<p>complex：</p>
<p>复数写有“j”作为虚部。</p>
<pre><code class="hljs plaintext">x = 3 + 5j
y = 5j
print(x)#(3+5j)
print(y)#5j</code></pre>

<p>强制转化：</p>
<pre><code class="hljs plaintext">x = 1
y = complex(x)
print(x)#1
print(y)#(1+0j)</code></pre>

<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>Python 有一个内置模块 random可以用来生成随机数，需要引入。</p>
<pre><code class="hljs plaintext">import random</code></pre>

<p><img src="E:\笔记备份\typora-user-images\image-20240827170632781.png" alt="image-20240827170632781"></p>
<p>random.randrange(3,30,3)不是生成3到30之间的任何整数，因为width &#x3D; 3 ，所以生成的应该是3 + 3 * i 。</p>
<p>该方法生成的都是<strong>整数</strong>，包括负整数。</p>
<p>step步长的应用——生成n的随机整数范围(倍数)</p>
<p>让我们生成 5 到 100 之间的随机整数，即 5 的倍数，例如 5, 10, 25, 90, 95等。</p>
<pre><code class="hljs plaintext">import random
number = random.randrange(5, 101, 5)
print(&quot;Random number range (multiple) of 5 is &quot;, number)</code></pre>

<h1 id="python字符串"><a href="#python字符串" class="headerlink" title="python字符串"></a>python字符串</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>可以使用三个引号将多行字符串分配给变量。<code>&quot;&quot;&quot;   &quot;&quot;&quot;</code></p>
<pre><code class="hljs plaintext">x = &quot;&quot;&quot;gsgad asgsa
   ags ilnk &quot;&quot;&quot;
print(x)</code></pre>

<p><img src="/typora-user-images/image-20240902144043495.png" alt="image-20240902144043495"></p>
<p><strong>字符串是数组</strong>，Python <strong>没有字符</strong>数据类型，单个字符只是一个长度为 1 的字符串。方括号可用于访问字符串的元素。这里用到了切片，你可以不懂。<br>获取位置 1 处的字符（记住第一个字符的位置为 0）：</p>
<pre><code class="hljs plaintext">a = &quot;Hello, World!&quot;
print(a[1])</code></pre>

<p><code>len()</code>函数返回字符串的长度，注意标点符号和空格也算一个长度：len(a)</p>
<p>要检查字符串中是否存在某个短语或字符，我们可以使用关键字 in，返回值为布尔类型。</p>
<pre><code class="hljs plaintext">txt =&quot;The best things in life are free!&quot;
print(&quot;free&quot; in txt)</code></pre>

<p>如果是要检查不存在某个短语或字符的话，除了使用 in 外，还可以使用 not in ：</p>
<pre><code class="hljs plaintext">txt =&quot;The best things in life are free!&quot;
print(&quot;free&quot; not in txt)</code></pre>

<p>不存在就会输出true。</p>
<h2 id="切片字符串"><a href="#切片字符串" class="headerlink" title="切片字符串"></a>切片字符串</h2><p><strong>1）切片</strong></p>
<p>获取从位置 2 到位置 5 的字符（不包括在内）：</p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt[2:5])</code></pre>

<p>仍然是左闭右开的规律，且第一个字符索引为0。</p>
<p><strong>2）从头开始切片</strong></p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt[:5])</code></pre>

<p><strong>3)切到最后</strong></p>
<p>通过省略结束索引，范围将到最后。</p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt[2:])</code></pre>

<p><strong>4）负索引</strong></p>
<p>使用负索引从字符串末尾开始切片，就是从右往左看，不再是从左往右看。</p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt[-5:-2])</code></pre>

<p>这个时候字符串的最后一个元素索引为 -1，往前递减。</p>
<p>  f    r   e   e		这个时候要切片仍要按字符串顺序写入，不能写<code>[-1:-5]</code>，而使用负索引时由于四从后往前的，所以变成了<strong>左开右闭</strong>。</p>
<p>-4  -3  -2  -1</p>
<h2 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h2><p>1）upper()方法以大写形式返回字符串（不改变原字符串）：<code>txt.upper()</code>，txt内容直接全部转化为大写；也可以选择字符转大写，<code>txt[2].upper()</code>。</p>
<p>2）lower()方法以小写形式返回字符串。</p>
<p>3）strip()方法删除开头和结尾的任何空格（不改变原字符串）：</p>
<pre><code class="hljs plaintext">txt = &quot;   The best things in life are free!&quot;
print(txt.strip())
print(txt)</code></pre>

<p><img src="/typora-user-images/image-20240924164743183.png" alt="image-20240924164743183"></p>
<p>4）replace()方法用另一个字符串替换一个字符串(不改变原字符串)：</p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt.replace(&quot;e&quot;,&quot;E&quot;,4))
print(txt)</code></pre>

<p>replace(“要修改的”,”要修改成的”,要修改的数量)，没有规定数量则默认全部修改。</p>
<p>5）拆分字符串</p>
<p>split()方法返回一个列表，其中指定分隔符之间的文本成为列表项。split()如果找到分隔符的实例，该方法会将字符串拆分为子字符串。</p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt.split(&quot; &quot;))</code></pre>

<p>若要以多个字符作为分割符，那不像 java 中一样，python要用and</p>
<pre><code class="hljs plaintext">txt = &quot;The best things in life are free!&quot;
print(txt.split(&quot; &quot; and &quot;e&quot;))</code></pre>

<pre><code class="hljs plaintext">my_list = txt.split(&quot; &quot;)</code></pre>

<p>my_list的类型为list。</p>
<h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p>要连接或组合两个字符串，可以使用 + 运算符。</p>
<h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><h3 id="对变量的格式化"><a href="#对变量的格式化" class="headerlink" title="对变量的格式化"></a>对变量的格式化</h3><h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><p>1）format<strong>单个</strong>传参</p>
<p>通过使用<strong>format()</strong> 方法来组合字符串和数字！format()方法接受传递的参数，格式化它们，并将它们放在占位符所在的字符串中{}。</p>
<pre><code class="hljs plaintext">age = 20
txt = &quot;Tom今年&#123;&#125;&quot;
print(txt.format(age))</code></pre>

<p>age的值会出现在“{}”里。</p>
<p>2）format<strong>多个</strong>传参</p>
<p>不规定顺序，默认按输入顺序取值：</p>
<pre><code class="hljs plaintext">quantity = 20
itemno = 3000
price = 49.95
myorder = &quot;川川今年 &#123;&#125;岁 买了个华为手机 &#123;&#125; 每个月花费 &#123;&#125; 元.&quot;
print(myorder.format(quantity, itemno, price))</code></pre>

<p><img src="/typora-user-images/image-20240829104210335.png" alt="image-20240829104210335"></p>
<p>规定顺序：按序列号取值</p>
<pre><code class="hljs plaintext">quantity = 20
itemno = 3000
price = 49.95
myorder = &quot;川川今年 &#123;2&#125;岁 买了个华为手机 &#123;0&#125; 每个月花费 &#123;1&#125; 元.&quot;
print(myorder.format(quantity, itemno, price))</code></pre>

<p><img src="/typora-user-images/image-20240829104100499.png" alt="image-20240829104100499"></p>
<h4 id=""><a href="#" class="headerlink" title="%"></a>%</h4><p><strong>3）%</strong></p>
<p><img src="/typora-user-images/image-20240902144652454.png" alt="image-20240902144652454"></p>
<p><img src="/typora-user-images/image-20240902144757723.png" alt="image-20240902144757723"></p>
<p>这个程序是将数字变为字符串后填入语句中的。</p>
<p><img src="/typora-user-images/image-20240902145053559.png" alt="image-20240902145053559"></p>
<p><img src="/typora-user-images/image-20240902145436277.png" alt="image-20240902145436277"></p>
<h4 id="快速写法：f"><a href="#快速写法：f" class="headerlink" title="快速写法：f"></a>快速写法：f</h4><p>不限数据类型同时也不做精度控制，原来是什么样的就输出什么样的。</p>
<p><img src="/typora-user-images/image-20240902145938978.png" alt="image-20240902145938978"></p>
<h3 id="对表达式的格式化"><a href="#对表达式的格式化" class="headerlink" title="对表达式的格式化"></a>对表达式的格式化</h3><p><img src="/typora-user-images/image-20240902150303533.png" alt="image-20240902150303533"></p>
<h2 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h2><p><img src="/typora-user-images/image-20240829104305991.png" alt="image-20240829104305991"></p>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p><code>bool()</code>函数允许您评估任何值，并给您 True或False 作为返回。如果它具有某种内容，几乎任何值都会被评估。任何字符串都是True，空字符串除外。任何数字都是True，除了 0。任何列表、元组、集合和字典都是True，空的除外。</p>
<p>例如()、 []、{}、 “”、 数字 0和 False、None值，计算值为False。</p>
<p>Python 也有许多返回布尔值的内置函数，如 <code>isinstance()</code> 函数，可用于确定对象是否属于某种数据类型。</p>
<pre><code class="hljs plaintext">x = 20
print(isinstance(x,int))</code></pre>

<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="基础-元组定义"><a href="#基础-元组定义" class="headerlink" title="基础+元组定义"></a>基础+元组定义</h2><p>列表是使用方括号创建的，可以直接输出，和java中的一样。</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;]
print(mylist)</code></pre>

<p>创建新列表时也可以使用 <strong>list()</strong> 构造函数。</p>
<pre><code class="hljs plaintext">mylist = list((
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;))
print(mylist)</code></pre>

<p>为什么list需要有两个括号？因为传递给<code>list()</code>函数的参数是一个<strong>元组</strong>，而不是普通的单个字符串或其他类型的单个对象。</p>
<ol>
<li><strong>外层括号</strong>：<code>list()</code>函数的外层括号用于调用该函数。</li>
<li><strong>内层括号</strong>：<code>( ... )</code>内层括号用于定义一个元组。Python中的元组使用括号<code>()</code>定义。如果在调用<code>list()</code>时传递了一个元组（用括号括起来的多个元素），你就需要使用内层括号来创建这个元组。</li>
</ol>
<p>这个代码实际上是将一个元组传递给<code>list()</code>函数，并将这个元组转换成列表。</p>
<p>元组（Tuple）是Python中的一种数据类型，用于存储多个值。它与列表（List）非常相似，但有几个关键区别：</p>
<p>1）<strong>不可变性（Immutable）</strong>: 元组一旦创建，其元素不能修改（即不能增删改）。这与列表不同，列表是可变的（Mutable）。</p>
<p>2）<strong>使用小括号定义</strong>: 元组使用小括号 <code>()</code> 定义，而列表使用方括号 <code>[]</code>。</p>
<p>3）<strong>可以包含不同类型的数据</strong>: 元组可以包含不同类型的元素，例如整数、字符串、浮点数等：<code>mixed_tuple = (1, &quot;hello&quot;, 3.14)</code></p>
<p>4）<strong>访问方式与列表相同</strong>: 元组的元素通过索引访问，索引从0开始。</p>
<p>现在重新回到列表：</p>
<p>由于列表已编入索引，因此列表可以包含具有相同值的项目。</p>
<p>列表项可以是任何数据类型，同一列表中也可以包含不同类型的项。</p>
<p><strong>总结：</strong></p>
<ol>
<li>List列表是一个有序且可变的集合。允许重复成员。</li>
<li>turple元组是一个有序且不可更改的集合。允许重复成员。</li>
<li>Set集合是一个无序且无索引的集合。没有重复的成员。</li>
<li>dict字典是一个有序（从 Python 3.7 版开始）且可变的集合。没有重复的成员。</li>
</ol>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><strong>访问列表</strong></p>
<p>1）正常索引</p>
<p>2）负索引</p>
<p>3）索引范围</p>
<pre><code class="hljs plaintext">print(mylist[1:3])</code></pre>

<pre><code class="hljs plaintext">print(mylist[-3:-1])</code></pre>

<p>4）检查是否存在，和字符串一样</p>
<p><strong>更改列表</strong></p>
<p>更改一个范围内的元素：</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;,
    &quot;川川五号&quot;]
mylist[1:3] = [&quot;哈皮川川&quot;,&quot;憨批川川&quot;]
print(mylist)</code></pre>

<p><strong>插入列表</strong></p>
<p><code>insert()</code>方法在指定的索引处插入一个项目。</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;,
    &quot;川川五号&quot;]
mylist.insert(2,&quot;帅哥呀&quot;)
print(mylist)</code></pre>

<p><strong>添加列表</strong></p>
<p>1）末尾添加：要将值添加到列表的末尾，请使用append() 方法。</p>
<p>2）指定位置添加：insert()函数。</p>
<p>3）合并列表：要将另一个列表中的元素附加到当前列表，请使用extend()方法。</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;,
    &quot;川川五号&quot;]
mylist1 = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;]
mylist.extend(mylist1)
print(mylist)</code></pre>

<p>extend()方法不一定要 列表，您也可以添加任何可迭代对象（元组、集合、字典等）。</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;,
    &quot;川川五号&quot;]
mylist1 = (&quot;川川&quot;,&quot;菜鸟&quot;)
mylist.extend(mylist1)
print(mylist)</code></pre>

<p>使用 + 运算符</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;,
    &quot;川川五号&quot;]
mylist1 = [&quot;川川&quot;,&quot;菜鸟&quot;]
my = mylist1 + mylist
print(my)</code></pre>

<p><strong>删除列表</strong></p>
<p>remove()方法删除指定的项目。</p>
<pre><code class="hljs plaintext">mylist.remove(&#x27;川川二号&#x27;)</code></pre>

<p>pop()方法删除指定的索引，如果不指定索引，该pop()方法将删除最后一项。</p>
<pre><code class="hljs plaintext">mylist.pop(2)</code></pre>

<p>del删除指定的索引,也可以完全删除列表。</p>
<pre><code class="hljs plaintext">del mylist[0]</code></pre>

<pre><code class="hljs plaintext">del mylist</code></pre>

<p>clear()方法清空列表。该列表仍然存在，但没有内容。</p>
<pre><code class="hljs plaintext">mylist.clear()</code></pre>

<h2 id="循环列表"><a href="#循环列表" class="headerlink" title="循环列表"></a>循环列表</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>方法一：</p>
<p><img src="/typora-user-images/image-20240909151648171.png" alt="image-20240909151648171">循环遍历列表您可以使用循环遍历列表项for 。</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;]
for i in mylist:
    print(i)</code></pre>

<p><img src="/typora-user-images/image-20240909150647167.png" alt="image-20240909150647167"></p>
<p>方法二：遍历索引号</p>
<p><img src="/typora-user-images/image-20240909152055723.png" alt="image-20240909152055723"></p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;]
for i in range(len(mylist)):
    print(mylist[i])</code></pre>

<p>相当于以前的：</p>
<pre><code class="hljs plaintext">for(int i = 0;i &lt; mylist.length;i ++)
	print(mylist.charAt(i)</code></pre>

<p><img src="/typora-user-images/image-20240909152204826.png" alt="image-20240909152204826"></p>
<p><strong>变量作用域</strong></p>
<p><img src="/typora-user-images/image-20240909152409235.png" alt="image-20240909152409235"></p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;]
i = 0
while i &lt; len(mylist):
    print(mylist[i])
    i += 1</code></pre>

<p><img src="/typora-user-images/image-20240828145231836.png" alt="image-20240828145231836"></p>
<p>那如果我while循环下面还要写不属于循环体的内容要怎么办呢？下面写的内容与while对齐就行，就代表不是循环的内容了。</p>
<pre><code class="hljs plaintext">mylist = [
    &quot;川川一号&quot;,
    &quot;川川二号&quot;,
    &quot;川川三号&quot;,
    &quot;川川四号&quot;]
i = 0
while i &lt; len(mylist):
    print(mylist[i])
    i += 1
i = 1
print(i)</code></pre>

<h3 id="continue和break"><a href="#continue和break" class="headerlink" title="continue和break"></a>continue和break</h3><p>和以前的一样</p>
<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p><img src="/typora-user-images/image-20240830101522063.png" alt="image-20240830101522063"></p>
<p><img src="/typora-user-images/image-20240830101751077.png" alt="image-20240830101751077"></p>
<p><img src="/typora-user-images/image-20240830101811824.png" alt="image-20240830101811824"></p>
<p><img src="/typora-user-images/image-20240830101824157.png" alt="image-20240830101824157"></p>
<p><strong>一个表达式，后面为一个 for 子句，然后，跟着 for 子句，if 语句</strong></p>
<pre><code class="hljs plaintext">OldList = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

TestList = [j for i in OldList for j in i if j % 2 == 0]

print(TestList)
# [2, 4, 6, 8]</code></pre>

<p><img src="/typora-user-images/image-20240830102029883.png" alt="image-20240830102029883"></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>sort()方法区分大小写，导致所有大写字母都排在小写字母之前，按自然顺序排序。<code>thislist.sort()</code></p>
<p>不区分大小写的排序函数，则应使用<code>str.lower</code>作为键函数：<code>thislist.sort(key = str. lower)</code></p>
<p>reverse()方法反转元素的当前排序顺序。</p>
<h2 id="复制列表"><a href="#复制列表" class="headerlink" title="复制列表"></a>复制列表</h2><p>copy()方法制作列表的副本：</p>
<pre><code class="hljs plaintext">fruits = [
    &quot;apple&quot;,
    &quot;banana&quot;,
    &quot;cherry&quot;,
    &quot;kiwi&quot;,
    &quot;mango&quot;]
f = fruits.copy()
print(f)</code></pre>

<p>list()方法制作列表的副本：</p>
<pre><code class="hljs plaintext">fruits = [
    &quot;apple&quot;,
    &quot;banana&quot;,
    &quot;cherry&quot;,
    &quot;kiwi&quot;,
    &quot;mango&quot;]
f = list(fruits)
print(f)</code></pre>

<h2 id="操作合集"><a href="#操作合集" class="headerlink" title="操作合集"></a>操作合集</h2><p><img src="/typora-user-images/image-20240830103315208.png" alt="image-20240830103315208"></p>
<h1 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h1><p><img src="/typora-user-images/image-20240902151833428.png" alt="image-20240902151833428"></p>
<p><img src="/typora-user-images/image-20240902152020658.png" alt="image-20240902152020658"></p>
<p>input默认<strong>接受</strong>的类型是<strong>字符串</strong>，所以你输入的数据是按照字符串去处理的，获取到的数据永远是字符串类型的。</p>
<h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p><img src="/typora-user-images/image-20240904145056331.png" alt="image-20240904145056331"></p>
<p><strong>注意：</strong>条件后面加<strong>冒号</strong>，结构体前面要<strong>留有空白</strong>（四个空格），就是要缩进；没有缩进代表和 if 是同级的，不受 if 控制。</p>
<p><img src="/typora-user-images/image-20240904145619929.png" alt="image-20240904145619929"></p>
<h2 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h2><p><img src="/typora-user-images/image-20240904145840332.png" alt="image-20240904145840332"></p>
<h2 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if elif else语句"></a>if elif else语句</h2><p><img src="/typora-user-images/image-20240904150121743.png" alt="image-20240904150121743"></p>
<p>判断条件里可以是输入语句：</p>
<p><img src="/typora-user-images/image-20240904150614390.png" alt="image-20240904150614390"></p>
<p>该代码在节省代码量的同时还做到了不用一次性输入三个变量，而是等前面一个不满足条件后在输入下一个变量值。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>和c语言大差不差的。</p>
<p><img src="/typora-user-images/image-20240920162622191.png" alt="image-20240920162622191"></p>
<p><img src="/typora-user-images/image-20240920162945376.png" alt="image-20240920162945376"></p>
<p><img src="/typora-user-images/image-20240920163335654.png" alt="image-20240920163335654"></p>
<p><img src="/typora-user-images/image-20240920163800172.png" alt="image-20240920163800172"></p>
<p><img src="/typora-user-images/image-20240920163903857.png" alt="image-20240920163903857"></p>
<p><img src="/typora-user-images/image-20240920164146996.png" alt="image-20240920164146996"></p>
<p><img src="/typora-user-images/image-20240920164831520.png" alt="image-20240920164831520"></p>
<p>调用函数时，鼠标停在函数上，会出现说明文档。</p>
<h1 id="数据容器"><a href="#数据容器" class="headerlink" title="数据容器"></a>数据容器</h1><h2 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h2><p><img src="/typora-user-images/image-20240924161211649.png" alt="image-20240924161211649"></p>
<p>列表中可以存储不同的数据类型。</p>
<p><img src="/typora-user-images/image-20240924161704122.png" alt="image-20240924161704122"></p>
<h2 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple(元组)"></a>tuple(元组)</h2><p>元组一旦定义完成就不能被修改。但是如果元组中有元素list，可以修改list里的数据，list不变，变得是list里面的内容。</p>
<p><img src="/typora-user-images/image-20240924162913949.png" alt="image-20240924162913949"></p>
<p><img src="/typora-user-images/image-20240924163026626.png" alt="image-20240924163026626"></p>
<p><img src="/typora-user-images/image-20240924163430828.png" alt="image-20240924163430828"></p>
<h2 id="str-字符串"><a href="#str-字符串" class="headerlink" title="str(字符串)"></a>str(字符串)</h2><p>和元组一样，字符串时无法修改的，对它进行修改操作得到的是一个新的字符串，原字符串仍不变。</p>
<h2 id="数据容器-序列-的切片操作"><a href="#数据容器-序列-的切片操作" class="headerlink" title="数据容器(序列)的切片操作"></a>数据容器(序列)的切片操作</h2><p><img src="/typora-user-images/image-20240925164714610.png" alt="image-20240925164714610"></p>
<p><img src="/typora-user-images/image-20240925165222127.png" alt="image-20240925165222127"></p>
<p>切片操作不会影响到序列本身，而是会产生一个新的序列。</p>
<p>步长<strong>默认</strong>为1，所以可以不写。</p>
<p>起始和结束都不写的话，表示从头到尾。</p>
<p><img src="/typora-user-images/image-20240925165838825.png" alt="image-20240925165838825"></p>
<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set(集合)"></a>set(集合)</h2><p>不重复，无序，不支持下标索引。</p>
<p><img src="/typora-user-images/image-20240925170512617.png" alt="image-20240925170512617"></p>
<p><img src="/typora-user-images/image-20240925170945186.png" alt="image-20240925170945186"></p>
<p><img src="/typora-user-images/image-20240925171231409.png" alt="image-20240925171231409"></p>
<p><img src="/typora-user-images/image-20240925171542869.png" alt="image-20240925171542869"></p>
<p>73</p>

        </div>
        
            
        
        
    </div>
</article>

        
            
            <article class="article">
    <div class="article-wrap">
        
            <h2 class="article-title cl">
                <a href="/2024/10/05/Kaggle/" title="空标题">
                    空标题
                </a>
            </h2>
        

        <ul class="article-extra" style="margin-bottom: 20px">
            
            <li class="article-time">
                2024-10-05
            </li>
            

            
                
            


        </ul>
        <div class="article-description">
            
            <h1 id="Kaggle"><a href="#Kaggle" class="headerlink" title="Kaggle"></a>Kaggle</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Kaggle成立于2010年，是一个进行数据发掘和预测竞赛的在线平台。从公司的角度来讲，可以提供一些数据，进而提出一个实际需要解决的问题；从参赛者的角度来讲，他们将组队参与项目，针对其中一个问题提出解决方案，最终由公司选出的最佳方案可以获得5K-10K美金的奖金。</p>
<p>除此之外，Kaggle官方每年还会举办一次大规模的竞赛，奖金高达一百万美金，吸引了广大的数据科学爱好者参与其中。从某种角度来讲，大家可以把它理解为一个众包平台，类似国内的猪八戒。但是不同于传统的低层次劳动力需求，Kaggle一直致力于解决业界难题，因此也创造了一种全新的劳动力市场——不再以学历和工作经验作为唯一的人才评判标准，而是着眼于个人技能，为顶尖人才和公司之间搭建了一座桥梁。</p>
<p>这里有一篇对Kaggle首席科学家Jeremy Howard的采访，介绍了Kaggle的创建初衷及运营模式，即任用最聪明的人解决世界上最棘手的问题；同时，任何公司和组织都可以受益于机器学习的发展进步，</p>
<h2 id="Kaggle参赛者的背景大多是什么样的？"><a href="#Kaggle参赛者的背景大多是什么样的？" class="headerlink" title="Kaggle参赛者的背景大多是什么样的？"></a><strong>Kaggle参赛者的背景大多是什么样的？</strong></h2><p>从比赛目标出发，参赛者主要分为两种，一种是以奖金和排名为目的，包括靠奖金为生的职业Kaggler；另外一种就是以提升相关skills和背景为目的业余爱好者甚至在校学生了。</p>
<p>从背景来看，前者的来源主要有丰富data science、data mining、machine learning工作经验的业内人士，或者是实力强劲的民间“技术宅”；而后者则往往是一些有一定技术能力，但经验欠缺，从中进行学习和锻炼的“长江后浪”。</p>
<h2 id="0基础的人如何上手Kaggle？"><a href="#0基础的人如何上手Kaggle？" class="headerlink" title="0基础的人如何上手Kaggle？"></a><strong>0基础的人如何上手Kaggle？</strong></h2><p>理论上来讲，Kaggle欢迎任何数据科学的爱好者，不过实际上，要想真的参与其中，还是有一定门槛的。一般来讲，参赛者最好具有统计、计算机或数学相关背景，有一定的coding技能，对机器学习和深度学习有基本的了解。Kaggle任务虽然不限制编程语言，但绝大多数队伍会选用Python和R，所以你应该至少熟悉其中一种。</p>
<p>此外，对于那些对成绩有追求的人，Feature Engineering也是必不可少的。</p>
<p>当然，如果你从未独立做过一个项目，还是要从<strong>练习赛开始熟悉</strong>。因为竞赛模式中的任务是公司悬赏发布的实际案例，并没有标准的答案；而练习赛不仅项目难度低，而且是有官方给出的参考方案的，大家可以用来对比改善自己的测试结果，从中进行提高。</p>
<p>所以呢，建议感兴趣的同学先去独立做一下101和playground的训练赛，至于做多少个案例才能上道，就要看个人素质啦。这里为大家推荐几篇非常好的文章，里面手把手的教了大家入门级的三个经典练习项目，供大家学习。</p>
<ol>
<li>Titanic（泰坦尼克之灾）</li>
</ol>
<p>中文教程： <a href="https://link.zhihu.com/?target=http://blog.csdn.net/han_xiaoyang/article/details/49797143">逻辑回归应用之Kaggle泰坦尼克之灾</a><br>英文教程：<a href="https://link.zhihu.com/?target=https://www.kaggle.com/helgejo/titanic/an-interactive-data-science-tutorial">An Interactive Data Science Tutorial</a></p>
<ol start="2">
<li>House Prices: Advanced Regression Techniques（房价预测）</li>
</ol>
<p>中文教程：<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/irenelin/p/7400388.html">Kaggle竞赛 — 2017年房价预测</a><br>英文教程：<a href="https://link.zhihu.com/?target=https://www.kaggle.com/neviadomski/house-prices-advanced-regression-techniques/how-to-get-to-top-25-with-simple-model-sklearn">How to get to TOP 25% with Simple Model using sklearn</a></p>
<ol start="3">
<li>Digital Recognition（数字识别）</li>
</ol>
<p>中文教程：<a href="https://link.zhihu.com/?target=http://blog.csdn.net/u012162613/article/details/41929171">大数据竞赛平台—Kaggle 入门</a><br>英文教程：<a href="https://link.zhihu.com/?target=https://www.kaggle.com/arthurtok/digit-recognizer/interactive-intro-to-dimensionality-reduction">Interactive Intro to Dimensionality Reduction</a></p>
<h2 id="Kaggle竞赛的认可度高么？"><a href="#Kaggle竞赛的认可度高么？" class="headerlink" title="Kaggle竞赛的认可度高么？"></a><strong>Kaggle竞赛的认可度高么？</strong></h2><p>Kaggle作为Data Science业内享有盛名的平台，在业界拥有极高的认可度。所以如果你是想寻找相关行业的工作，那一个漂亮的<strong>Kaggle profile将为你的简历增色不少</strong>。</p>
<p>对于刚刚进入这个行业的菜鸟而言，参加Kaggle的项目是非常“长见识”的，可能初期的尝试会非常吃力，毕竟都是非常前沿的问题，但是如果能坚持完整的把一个项目做下来，且不说coding能力会有一个很大的提高，在实际案例中解决问题的能力也会得到极大的锻炼，为自己的职业生涯打下一个良好的基础。如果能在Kaggle这种高手云集的比赛中获得一个还不错的成绩，写在简历上足以打动你今后的Boss，跳槽就翻倍的高薪工作指日可待！值得一提的是，虽然是汇集精英的社区，Kaggle的论坛氛围很好，对新人非常友好，大家一定要多看Script多请教！</p>
<p>首先，选择数据量小的项目，这样不管使用什么算法都不会耗时太久，对机器性能要求也不高，出结果也比较快；其次，选择难度低奖金少的项目，一方面竞争小，另一方面也适合新手；最后，选择参与人数多的项目，毕竟有那么多“僵尸号”撑着。这样下来，基本上认认真真做下来排名都不会太难看。</p>
<ul>
<li>选择恰当的工具：</li>
</ul>
<p>我们都知道循序渐进的道理，因此对于刚刚涉猎Kaggle，只是希望从中学习，而不追求高排名的同学，可以先从学习Machine Learning中常用的模型开始，比如Logistic Regression和Random Forest，这两个模型对于大部分问题就够了；基础好的还可以学习一下Gradient Boosting，虽然难度高一点，但是可视化效果会好很多。</p>

        </div>
        
            
        
        
    </div>
</article>

        
        <ul class="pagination clear">
    <span class="page-number current">1</span><a class="page-number" href="/archives/2024/page/2/">2</a><a class="extend next" rel="next" href="/archives/2024/page/2/">下一页</a>
</ul>
    </section>
    
<section class="tool-area">

    <div class="toolbar">
        

        
        <div class="widget-post widget" style="order: 1 ">
            <h2 class="widget-title"><i class="fa fa-file-text"></i> 近期文章</h2>
            <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/10/05/%E8%81%8C%E4%B8%9A/">职业</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/05/%E8%8B%B1%E8%AF%AD/">英语</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/05/%E8%81%8C%E8%A7%84/">职规</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/05/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/05/%E9%97%AE%E9%A2%98/">问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/">数据结构2</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/05/%E4%B8%B4%E6%97%B6/">临时</a></li></ul>
        </div>
        

        
        <div class="widget-tags widget" style="order: 2 ">
            <h2 class="widget-title"><i class="fa fa-tags"></i> 标签</h2>
            
        </div>
        

        
        <div class="widget-categories widget" style="order: 3 ">
            <h2 class="widget-title"><i class="fa fa-folder-open"></i> 分类</h2>
            
        </div>
        

    </div>
</section>
</div>

    
        <footer class="footer">
	<p class="footer-intro">
		
		@2024 coygOdegaard.
	</p>
	<p class="footer-intro">
			Powered By <a href="https://hexo.io/zh-cn/" target="_blank">hexo</a>
			theme <a href="https://github.com/iengu/hexo-theme-mokusei" target="_blank">mokusei</a> by <a href="https://www.iengu.com" target="blank">iengu</a>
	</p>
</footer>




        <div class="extend-tools" id="extend-tools" style="display: none;">
    <ul>
        <li class="tools-returnTop" title="返回顶部"><i class="fa fa-angle-double-up"></i></li>
    </ul>
</div>

	</div>

	
<script src="/js/org/jquery.min.js"></script>

    
<script src="/js/extend.js"></script>

</body>
</html>